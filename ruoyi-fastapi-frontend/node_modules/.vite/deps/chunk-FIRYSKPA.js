import {
  assign_default,
  cloneDeep_default,
  debounce_default,
  find_default,
  forEach_default,
  get_default,
  has_default,
  indexOf_default,
  isArray_default,
  isBoolean_default,
  isEmpty_default,
  isEqual_default,
  isNil_default,
  isObject_default,
  isUndefined_default,
  last_default,
  mapKeys_default,
  map_default,
  merge_default,
  noop_default,
  pick_default,
  reduce_default,
  set_default,
  throttle_default,
  toPairs_default
} from "./chunk-SERHAQMS.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames2() {
        var classes = "";
        for (var i4 = 0; i4 < arguments.length; i4++) {
          var arg = arguments[i4];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames2.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames2.default = classNames2;
        module.exports = classNames2;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames2;
        });
      } else {
        window.classNames = classNames2;
      }
    })();
  }
});

// node_modules/mousetrap/mousetrap.js
var require_mousetrap = __commonJS({
  "node_modules/mousetrap/mousetrap.js"(exports, module) {
    (function(window2, document2, undefined2) {
      if (!window2) {
        return;
      }
      var _MAP = {
        8: "backspace",
        9: "tab",
        13: "enter",
        16: "shift",
        17: "ctrl",
        18: "alt",
        20: "capslock",
        27: "esc",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
        45: "ins",
        46: "del",
        91: "meta",
        93: "meta",
        224: "meta"
      };
      var _KEYCODE_MAP = {
        106: "*",
        107: "+",
        109: "-",
        110: ".",
        111: "/",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'"
      };
      var _SHIFT_MAP = {
        "~": "`",
        "!": "1",
        "@": "2",
        "#": "3",
        "$": "4",
        "%": "5",
        "^": "6",
        "&": "7",
        "*": "8",
        "(": "9",
        ")": "0",
        "_": "-",
        "+": "=",
        ":": ";",
        '"': "'",
        "<": ",",
        ">": ".",
        "?": "/",
        "|": "\\"
      };
      var _SPECIAL_ALIASES = {
        "option": "alt",
        "command": "meta",
        "return": "enter",
        "escape": "esc",
        "plus": "+",
        "mod": /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? "meta" : "ctrl"
      };
      var _REVERSE_MAP;
      for (var i4 = 1; i4 < 20; ++i4) {
        _MAP[111 + i4] = "f" + i4;
      }
      for (i4 = 0; i4 <= 9; ++i4) {
        _MAP[i4 + 96] = i4.toString();
      }
      function _addEvent(object, type, callback) {
        if (object.addEventListener) {
          object.addEventListener(type, callback, false);
          return;
        }
        object.attachEvent("on" + type, callback);
      }
      function _characterFromEvent(e3) {
        if (e3.type == "keypress") {
          var character = String.fromCharCode(e3.which);
          if (!e3.shiftKey) {
            character = character.toLowerCase();
          }
          return character;
        }
        if (_MAP[e3.which]) {
          return _MAP[e3.which];
        }
        if (_KEYCODE_MAP[e3.which]) {
          return _KEYCODE_MAP[e3.which];
        }
        return String.fromCharCode(e3.which).toLowerCase();
      }
      function _modifiersMatch(modifiers1, modifiers2) {
        return modifiers1.sort().join(",") === modifiers2.sort().join(",");
      }
      function _eventModifiers(e3) {
        var modifiers = [];
        if (e3.shiftKey) {
          modifiers.push("shift");
        }
        if (e3.altKey) {
          modifiers.push("alt");
        }
        if (e3.ctrlKey) {
          modifiers.push("ctrl");
        }
        if (e3.metaKey) {
          modifiers.push("meta");
        }
        return modifiers;
      }
      function _preventDefault(e3) {
        if (e3.preventDefault) {
          e3.preventDefault();
          return;
        }
        e3.returnValue = false;
      }
      function _stopPropagation(e3) {
        if (e3.stopPropagation) {
          e3.stopPropagation();
          return;
        }
        e3.cancelBubble = true;
      }
      function _isModifier(key) {
        return key == "shift" || key == "ctrl" || key == "alt" || key == "meta";
      }
      function _getReverseMap() {
        if (!_REVERSE_MAP) {
          _REVERSE_MAP = {};
          for (var key in _MAP) {
            if (key > 95 && key < 112) {
              continue;
            }
            if (_MAP.hasOwnProperty(key)) {
              _REVERSE_MAP[_MAP[key]] = key;
            }
          }
        }
        return _REVERSE_MAP;
      }
      function _pickBestAction(key, modifiers, action3) {
        if (!action3) {
          action3 = _getReverseMap()[key] ? "keydown" : "keypress";
        }
        if (action3 == "keypress" && modifiers.length) {
          action3 = "keydown";
        }
        return action3;
      }
      function _keysFromString(combination) {
        if (combination === "+") {
          return ["+"];
        }
        combination = combination.replace(/\+{2}/g, "+plus");
        return combination.split("+");
      }
      function _getKeyInfo(combination, action3) {
        var keys2;
        var key;
        var i5;
        var modifiers = [];
        keys2 = _keysFromString(combination);
        for (i5 = 0; i5 < keys2.length; ++i5) {
          key = keys2[i5];
          if (_SPECIAL_ALIASES[key]) {
            key = _SPECIAL_ALIASES[key];
          }
          if (action3 && action3 != "keypress" && _SHIFT_MAP[key]) {
            key = _SHIFT_MAP[key];
            modifiers.push("shift");
          }
          if (_isModifier(key)) {
            modifiers.push(key);
          }
        }
        action3 = _pickBestAction(key, modifiers, action3);
        return {
          key,
          modifiers,
          action: action3
        };
      }
      function _belongsTo(element, ancestor) {
        if (element === null || element === document2) {
          return false;
        }
        if (element === ancestor) {
          return true;
        }
        return _belongsTo(element.parentNode, ancestor);
      }
      function Mousetrap2(targetElement) {
        var self2 = this;
        targetElement = targetElement || document2;
        if (!(self2 instanceof Mousetrap2)) {
          return new Mousetrap2(targetElement);
        }
        self2.target = targetElement;
        self2._callbacks = {};
        self2._directMap = {};
        var _sequenceLevels = {};
        var _resetTimer;
        var _ignoreNextKeyup = false;
        var _ignoreNextKeypress = false;
        var _nextExpectedAction = false;
        function _resetSequences(doNotReset) {
          doNotReset = doNotReset || {};
          var activeSequences = false, key;
          for (key in _sequenceLevels) {
            if (doNotReset[key]) {
              activeSequences = true;
              continue;
            }
            _sequenceLevels[key] = 0;
          }
          if (!activeSequences) {
            _nextExpectedAction = false;
          }
        }
        function _getMatches(character, modifiers, e3, sequenceName, combination, level) {
          var i5;
          var callback;
          var matches = [];
          var action3 = e3.type;
          if (!self2._callbacks[character]) {
            return [];
          }
          if (action3 == "keyup" && _isModifier(character)) {
            modifiers = [character];
          }
          for (i5 = 0; i5 < self2._callbacks[character].length; ++i5) {
            callback = self2._callbacks[character][i5];
            if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
              continue;
            }
            if (action3 != callback.action) {
              continue;
            }
            if (action3 == "keypress" && !e3.metaKey && !e3.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {
              var deleteCombo = !sequenceName && callback.combo == combination;
              var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
              if (deleteCombo || deleteSequence) {
                self2._callbacks[character].splice(i5, 1);
              }
              matches.push(callback);
            }
          }
          return matches;
        }
        function _fireCallback(callback, e3, combo, sequence) {
          if (self2.stopCallback(e3, e3.target || e3.srcElement, combo, sequence)) {
            return;
          }
          if (callback(e3, combo) === false) {
            _preventDefault(e3);
            _stopPropagation(e3);
          }
        }
        self2._handleKey = function(character, modifiers, e3) {
          var callbacks = _getMatches(character, modifiers, e3);
          var i5;
          var doNotReset = {};
          var maxLevel = 0;
          var processedSequenceCallback = false;
          for (i5 = 0; i5 < callbacks.length; ++i5) {
            if (callbacks[i5].seq) {
              maxLevel = Math.max(maxLevel, callbacks[i5].level);
            }
          }
          for (i5 = 0; i5 < callbacks.length; ++i5) {
            if (callbacks[i5].seq) {
              if (callbacks[i5].level != maxLevel) {
                continue;
              }
              processedSequenceCallback = true;
              doNotReset[callbacks[i5].seq] = 1;
              _fireCallback(callbacks[i5].callback, e3, callbacks[i5].combo, callbacks[i5].seq);
              continue;
            }
            if (!processedSequenceCallback) {
              _fireCallback(callbacks[i5].callback, e3, callbacks[i5].combo);
            }
          }
          var ignoreThisKeypress = e3.type == "keypress" && _ignoreNextKeypress;
          if (e3.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
            _resetSequences(doNotReset);
          }
          _ignoreNextKeypress = processedSequenceCallback && e3.type == "keydown";
        };
        function _handleKeyEvent(e3) {
          if (typeof e3.which !== "number") {
            e3.which = e3.keyCode;
          }
          var character = _characterFromEvent(e3);
          if (!character) {
            return;
          }
          if (e3.type == "keyup" && _ignoreNextKeyup === character) {
            _ignoreNextKeyup = false;
            return;
          }
          self2.handleKey(character, _eventModifiers(e3), e3);
        }
        function _resetSequenceTimer() {
          clearTimeout(_resetTimer);
          _resetTimer = setTimeout(_resetSequences, 1e3);
        }
        function _bindSequence(combo, keys2, callback, action3) {
          _sequenceLevels[combo] = 0;
          function _increaseSequence(nextAction) {
            return function() {
              _nextExpectedAction = nextAction;
              ++_sequenceLevels[combo];
              _resetSequenceTimer();
            };
          }
          function _callbackAndReset(e3) {
            _fireCallback(callback, e3, combo);
            if (action3 !== "keyup") {
              _ignoreNextKeyup = _characterFromEvent(e3);
            }
            setTimeout(_resetSequences, 10);
          }
          for (var i5 = 0; i5 < keys2.length; ++i5) {
            var isFinal = i5 + 1 === keys2.length;
            var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action3 || _getKeyInfo(keys2[i5 + 1]).action);
            _bindSingle(keys2[i5], wrappedCallback, action3, combo, i5);
          }
        }
        function _bindSingle(combination, callback, action3, sequenceName, level) {
          self2._directMap[combination + ":" + action3] = callback;
          combination = combination.replace(/\s+/g, " ");
          var sequence = combination.split(" ");
          var info;
          if (sequence.length > 1) {
            _bindSequence(combination, sequence, callback, action3);
            return;
          }
          info = _getKeyInfo(combination, action3);
          self2._callbacks[info.key] = self2._callbacks[info.key] || [];
          _getMatches(info.key, info.modifiers, { type: info.action }, sequenceName, combination, level);
          self2._callbacks[info.key][sequenceName ? "unshift" : "push"]({
            callback,
            modifiers: info.modifiers,
            action: info.action,
            seq: sequenceName,
            level,
            combo: combination
          });
        }
        self2._bindMultiple = function(combinations, callback, action3) {
          for (var i5 = 0; i5 < combinations.length; ++i5) {
            _bindSingle(combinations[i5], callback, action3);
          }
        };
        _addEvent(targetElement, "keypress", _handleKeyEvent);
        _addEvent(targetElement, "keydown", _handleKeyEvent);
        _addEvent(targetElement, "keyup", _handleKeyEvent);
      }
      Mousetrap2.prototype.bind = function(keys2, callback, action3) {
        var self2 = this;
        keys2 = keys2 instanceof Array ? keys2 : [keys2];
        self2._bindMultiple.call(self2, keys2, callback, action3);
        return self2;
      };
      Mousetrap2.prototype.unbind = function(keys2, action3) {
        var self2 = this;
        return self2.bind.call(self2, keys2, function() {
        }, action3);
      };
      Mousetrap2.prototype.trigger = function(keys2, action3) {
        var self2 = this;
        if (self2._directMap[keys2 + ":" + action3]) {
          self2._directMap[keys2 + ":" + action3]({}, keys2);
        }
        return self2;
      };
      Mousetrap2.prototype.reset = function() {
        var self2 = this;
        self2._callbacks = {};
        self2._directMap = {};
        return self2;
      };
      Mousetrap2.prototype.stopCallback = function(e3, element) {
        var self2 = this;
        if ((" " + element.className + " ").indexOf(" mousetrap ") > -1) {
          return false;
        }
        if (_belongsTo(element, self2.target)) {
          return false;
        }
        if ("composedPath" in e3 && typeof e3.composedPath === "function") {
          var initialEventTarget = e3.composedPath()[0];
          if (initialEventTarget !== e3.target) {
            element = initialEventTarget;
          }
        }
        return element.tagName == "INPUT" || element.tagName == "SELECT" || element.tagName == "TEXTAREA" || element.isContentEditable;
      };
      Mousetrap2.prototype.handleKey = function() {
        var self2 = this;
        return self2._handleKey.apply(self2, arguments);
      };
      Mousetrap2.addKeycodes = function(object) {
        for (var key in object) {
          if (object.hasOwnProperty(key)) {
            _MAP[key] = object[key];
          }
        }
        _REVERSE_MAP = null;
      };
      Mousetrap2.init = function() {
        var documentMousetrap = Mousetrap2(document2);
        for (var method in documentMousetrap) {
          if (method.charAt(0) !== "_") {
            Mousetrap2[method] = /* @__PURE__ */ function(method2) {
              return function() {
                return documentMousetrap[method2].apply(documentMousetrap, arguments);
              };
            }(method);
          }
        }
      };
      Mousetrap2.init();
      window2.Mousetrap = Mousetrap2;
      if (typeof module !== "undefined" && module.exports) {
        module.exports = Mousetrap2;
      }
      if (typeof define === "function" && define.amd) {
        define(function() {
          return Mousetrap2;
        });
      }
    })(typeof window !== "undefined" ? window : null, typeof window !== "undefined" ? document : null);
  }
});

// node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var t;
var i;
var r;
var o;
var e;
var f;
var c;
var s;
var a;
var h;
var p = {};
var v = [];
var y = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
var d = Array.isArray;
function w(n2, l3) {
  for (var u4 in l3) n2[u4] = l3[u4];
  return n2;
}
function _(n2) {
  n2 && n2.parentNode && n2.parentNode.removeChild(n2);
}
function g(l3, u4, t3) {
  var i4, r3, o2, e3 = {};
  for (o2 in u4) "key" == o2 ? i4 = u4[o2] : "ref" == o2 ? r3 = u4[o2] : e3[o2] = u4[o2];
  if (arguments.length > 2 && (e3.children = arguments.length > 3 ? n.call(arguments, 2) : t3), "function" == typeof l3 && null != l3.defaultProps) for (o2 in l3.defaultProps) void 0 === e3[o2] && (e3[o2] = l3.defaultProps[o2]);
  return m(l3, e3, i4, r3, null);
}
function m(n2, t3, i4, r3, o2) {
  var e3 = { type: n2, props: t3, key: i4, ref: r3, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: null == o2 ? ++u : o2, __i: -1, __u: 0 };
  return null == o2 && null != l.vnode && l.vnode(e3), e3;
}
function b() {
  return { current: null };
}
function k(n2) {
  return n2.children;
}
function x(n2, l3) {
  this.props = n2, this.context = l3;
}
function C(n2, l3) {
  if (null == l3) return n2.__ ? C(n2.__, n2.__i + 1) : null;
  for (var u4; l3 < n2.__k.length; l3++) if (null != (u4 = n2.__k[l3]) && null != u4.__e) return u4.__e;
  return "function" == typeof n2.type ? C(n2) : null;
}
function S(n2) {
  var l3, u4;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++) if (null != (u4 = n2.__k[l3]) && null != u4.__e) {
      n2.__e = n2.__c.base = u4.__e;
      break;
    }
    return S(n2);
  }
}
function M(n2) {
  (!n2.__d && (n2.__d = true) && i.push(n2) && !P.__r++ || r !== l.debounceRendering) && ((r = l.debounceRendering) || o)(P);
}
function P() {
  var n2, u4, t3, r3, o2, f5, c3, s3;
  for (i.sort(e); n2 = i.shift(); ) n2.__d && (u4 = i.length, r3 = void 0, f5 = (o2 = (t3 = n2).__v).__e, c3 = [], s3 = [], t3.__P && ((r3 = w({}, o2)).__v = o2.__v + 1, l.vnode && l.vnode(r3), j(t3.__P, r3, o2, t3.__n, t3.__P.namespaceURI, 32 & o2.__u ? [f5] : null, c3, null == f5 ? C(o2) : f5, !!(32 & o2.__u), s3), r3.__v = o2.__v, r3.__.__k[r3.__i] = r3, z(c3, r3, s3), r3.__e != f5 && S(r3)), i.length > u4 && i.sort(e));
  P.__r = 0;
}
function $(n2, l3, u4, t3, i4, r3, o2, e3, f5, c3, s3) {
  var a3, h3, y3, d2, w3, _3, g4 = t3 && t3.__k || v, m3 = l3.length;
  for (f5 = I(u4, l3, g4, f5, m3), a3 = 0; a3 < m3; a3++) null != (y3 = u4.__k[a3]) && (h3 = -1 === y3.__i ? p : g4[y3.__i] || p, y3.__i = a3, _3 = j(n2, y3, h3, i4, r3, o2, e3, f5, c3, s3), d2 = y3.__e, y3.ref && h3.ref != y3.ref && (h3.ref && V(h3.ref, null, y3), s3.push(y3.ref, y3.__c || d2, y3)), null == w3 && null != d2 && (w3 = d2), 4 & y3.__u || h3.__k === y3.__k ? f5 = A(y3, f5, n2) : "function" == typeof y3.type && void 0 !== _3 ? f5 = _3 : d2 && (f5 = d2.nextSibling), y3.__u &= -7);
  return u4.__e = w3, f5;
}
function I(n2, l3, u4, t3, i4) {
  var r3, o2, e3, f5, c3, s3 = u4.length, a3 = s3, h3 = 0;
  for (n2.__k = new Array(i4), r3 = 0; r3 < i4; r3++) null != (o2 = l3[r3]) && "boolean" != typeof o2 && "function" != typeof o2 ? (f5 = r3 + h3, (o2 = n2.__k[r3] = "string" == typeof o2 || "number" == typeof o2 || "bigint" == typeof o2 || o2.constructor == String ? m(null, o2, null, null, null) : d(o2) ? m(k, { children: o2 }, null, null, null) : void 0 === o2.constructor && o2.__b > 0 ? m(o2.type, o2.props, o2.key, o2.ref ? o2.ref : null, o2.__v) : o2).__ = n2, o2.__b = n2.__b + 1, e3 = null, -1 !== (c3 = o2.__i = L(o2, u4, f5, a3)) && (a3--, (e3 = u4[c3]) && (e3.__u |= 2)), null == e3 || null === e3.__v ? (-1 == c3 && h3--, "function" != typeof o2.type && (o2.__u |= 4)) : c3 != f5 && (c3 == f5 - 1 ? h3-- : c3 == f5 + 1 ? h3++ : (c3 > f5 ? h3-- : h3++, o2.__u |= 4))) : n2.__k[r3] = null;
  if (a3) for (r3 = 0; r3 < s3; r3++) null != (e3 = u4[r3]) && 0 == (2 & e3.__u) && (e3.__e == t3 && (t3 = C(e3)), q(e3, e3));
  return t3;
}
function A(n2, l3, u4) {
  var t3, i4;
  if ("function" == typeof n2.type) {
    for (t3 = n2.__k, i4 = 0; t3 && i4 < t3.length; i4++) t3[i4] && (t3[i4].__ = n2, l3 = A(t3[i4], l3, u4));
    return l3;
  }
  n2.__e != l3 && (l3 && n2.type && !u4.contains(l3) && (l3 = C(n2)), u4.insertBefore(n2.__e, l3 || null), l3 = n2.__e);
  do {
    l3 = l3 && l3.nextSibling;
  } while (null != l3 && 8 == l3.nodeType);
  return l3;
}
function H(n2, l3) {
  return l3 = l3 || [], null == n2 || "boolean" == typeof n2 || (d(n2) ? n2.some(function(n3) {
    H(n3, l3);
  }) : l3.push(n2)), l3;
}
function L(n2, l3, u4, t3) {
  var i4, r3, o2 = n2.key, e3 = n2.type, f5 = l3[u4];
  if (null === f5 || f5 && o2 == f5.key && e3 === f5.type && 0 == (2 & f5.__u)) return u4;
  if (t3 > (null != f5 && 0 == (2 & f5.__u) ? 1 : 0)) for (i4 = u4 - 1, r3 = u4 + 1; i4 >= 0 || r3 < l3.length; ) {
    if (i4 >= 0) {
      if ((f5 = l3[i4]) && 0 == (2 & f5.__u) && o2 == f5.key && e3 === f5.type) return i4;
      i4--;
    }
    if (r3 < l3.length) {
      if ((f5 = l3[r3]) && 0 == (2 & f5.__u) && o2 == f5.key && e3 === f5.type) return r3;
      r3++;
    }
  }
  return -1;
}
function T(n2, l3, u4) {
  "-" == l3[0] ? n2.setProperty(l3, null == u4 ? "" : u4) : n2[l3] = null == u4 ? "" : "number" != typeof u4 || y.test(l3) ? u4 : u4 + "px";
}
function F(n2, l3, u4, t3, i4) {
  var r3;
  n: if ("style" == l3) if ("string" == typeof u4) n2.style.cssText = u4;
  else {
    if ("string" == typeof t3 && (n2.style.cssText = t3 = ""), t3) for (l3 in t3) u4 && l3 in u4 || T(n2.style, l3, "");
    if (u4) for (l3 in u4) t3 && u4[l3] === t3[l3] || T(n2.style, l3, u4[l3]);
  }
  else if ("o" == l3[0] && "n" == l3[1]) r3 = l3 != (l3 = l3.replace(f, "$1")), l3 = l3.toLowerCase() in n2 || "onFocusOut" == l3 || "onFocusIn" == l3 ? l3.toLowerCase().slice(2) : l3.slice(2), n2.l || (n2.l = {}), n2.l[l3 + r3] = u4, u4 ? t3 ? u4.u = t3.u : (u4.u = c, n2.addEventListener(l3, r3 ? a : s, r3)) : n2.removeEventListener(l3, r3 ? a : s, r3);
  else {
    if ("http://www.w3.org/2000/svg" == i4) l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" != l3 && "height" != l3 && "href" != l3 && "list" != l3 && "form" != l3 && "tabIndex" != l3 && "download" != l3 && "rowSpan" != l3 && "colSpan" != l3 && "role" != l3 && "popover" != l3 && l3 in n2) try {
      n2[l3] = null == u4 ? "" : u4;
      break n;
    } catch (n3) {
    }
    "function" == typeof u4 || (null == u4 || false === u4 && "-" != l3[4] ? n2.removeAttribute(l3) : n2.setAttribute(l3, "popover" == l3 && 1 == u4 ? "" : u4));
  }
}
function O(n2) {
  return function(u4) {
    if (this.l) {
      var t3 = this.l[u4.type + n2];
      if (null == u4.t) u4.t = c++;
      else if (u4.t < t3.u) return;
      return t3(l.event ? l.event(u4) : u4);
    }
  };
}
function j(n2, u4, t3, i4, r3, o2, e3, f5, c3, s3) {
  var a3, h3, p3, v6, y3, g4, m3, b2, C2, S2, M2, P4, I2, A4, H3, L2, T4, F4 = u4.type;
  if (void 0 !== u4.constructor) return null;
  128 & t3.__u && (c3 = !!(32 & t3.__u), o2 = [f5 = u4.__e = t3.__e]), (a3 = l.__b) && a3(u4);
  n: if ("function" == typeof F4) try {
    if (b2 = u4.props, C2 = "prototype" in F4 && F4.prototype.render, S2 = (a3 = F4.contextType) && i4[a3.__c], M2 = a3 ? S2 ? S2.props.value : a3.__ : i4, t3.__c ? m3 = (h3 = u4.__c = t3.__c).__ = h3.__E : (C2 ? u4.__c = h3 = new F4(b2, M2) : (u4.__c = h3 = new x(b2, M2), h3.constructor = F4, h3.render = B), S2 && S2.sub(h3), h3.props = b2, h3.state || (h3.state = {}), h3.context = M2, h3.__n = i4, p3 = h3.__d = true, h3.__h = [], h3._sb = []), C2 && null == h3.__s && (h3.__s = h3.state), C2 && null != F4.getDerivedStateFromProps && (h3.__s == h3.state && (h3.__s = w({}, h3.__s)), w(h3.__s, F4.getDerivedStateFromProps(b2, h3.__s))), v6 = h3.props, y3 = h3.state, h3.__v = u4, p3) C2 && null == F4.getDerivedStateFromProps && null != h3.componentWillMount && h3.componentWillMount(), C2 && null != h3.componentDidMount && h3.__h.push(h3.componentDidMount);
    else {
      if (C2 && null == F4.getDerivedStateFromProps && b2 !== v6 && null != h3.componentWillReceiveProps && h3.componentWillReceiveProps(b2, M2), !h3.__e && (null != h3.shouldComponentUpdate && false === h3.shouldComponentUpdate(b2, h3.__s, M2) || u4.__v == t3.__v)) {
        for (u4.__v != t3.__v && (h3.props = b2, h3.state = h3.__s, h3.__d = false), u4.__e = t3.__e, u4.__k = t3.__k, u4.__k.some(function(n3) {
          n3 && (n3.__ = u4);
        }), P4 = 0; P4 < h3._sb.length; P4++) h3.__h.push(h3._sb[P4]);
        h3._sb = [], h3.__h.length && e3.push(h3);
        break n;
      }
      null != h3.componentWillUpdate && h3.componentWillUpdate(b2, h3.__s, M2), C2 && null != h3.componentDidUpdate && h3.__h.push(function() {
        h3.componentDidUpdate(v6, y3, g4);
      });
    }
    if (h3.context = M2, h3.props = b2, h3.__P = n2, h3.__e = false, I2 = l.__r, A4 = 0, C2) {
      for (h3.state = h3.__s, h3.__d = false, I2 && I2(u4), a3 = h3.render(h3.props, h3.state, h3.context), H3 = 0; H3 < h3._sb.length; H3++) h3.__h.push(h3._sb[H3]);
      h3._sb = [];
    } else do {
      h3.__d = false, I2 && I2(u4), a3 = h3.render(h3.props, h3.state, h3.context), h3.state = h3.__s;
    } while (h3.__d && ++A4 < 25);
    h3.state = h3.__s, null != h3.getChildContext && (i4 = w(w({}, i4), h3.getChildContext())), C2 && !p3 && null != h3.getSnapshotBeforeUpdate && (g4 = h3.getSnapshotBeforeUpdate(v6, y3)), f5 = $(n2, d(L2 = null != a3 && a3.type === k && null == a3.key ? a3.props.children : a3) ? L2 : [L2], u4, t3, i4, r3, o2, e3, f5, c3, s3), h3.base = u4.__e, u4.__u &= -161, h3.__h.length && e3.push(h3), m3 && (h3.__E = h3.__ = null);
  } catch (n3) {
    if (u4.__v = null, c3 || null != o2) if (n3.then) {
      for (u4.__u |= c3 ? 160 : 128; f5 && 8 == f5.nodeType && f5.nextSibling; ) f5 = f5.nextSibling;
      o2[o2.indexOf(f5)] = null, u4.__e = f5;
    } else for (T4 = o2.length; T4--; ) _(o2[T4]);
    else u4.__e = t3.__e, u4.__k = t3.__k;
    l.__e(n3, u4, t3);
  }
  else null == o2 && u4.__v == t3.__v ? (u4.__k = t3.__k, u4.__e = t3.__e) : f5 = u4.__e = N(t3.__e, u4, t3, i4, r3, o2, e3, c3, s3);
  return (a3 = l.diffed) && a3(u4), 128 & u4.__u ? void 0 : f5;
}
function z(n2, u4, t3) {
  for (var i4 = 0; i4 < t3.length; i4++) V(t3[i4], t3[++i4], t3[++i4]);
  l.__c && l.__c(u4, n2), n2.some(function(u5) {
    try {
      n2 = u5.__h, u5.__h = [], n2.some(function(n3) {
        n3.call(u5);
      });
    } catch (n3) {
      l.__e(n3, u5.__v);
    }
  });
}
function N(u4, t3, i4, r3, o2, e3, f5, c3, s3) {
  var a3, h3, v6, y3, w3, g4, m3, b2 = i4.props, k3 = t3.props, x3 = t3.type;
  if ("svg" == x3 ? o2 = "http://www.w3.org/2000/svg" : "math" == x3 ? o2 = "http://www.w3.org/1998/Math/MathML" : o2 || (o2 = "http://www.w3.org/1999/xhtml"), null != e3) {
    for (a3 = 0; a3 < e3.length; a3++) if ((w3 = e3[a3]) && "setAttribute" in w3 == !!x3 && (x3 ? w3.localName == x3 : 3 == w3.nodeType)) {
      u4 = w3, e3[a3] = null;
      break;
    }
  }
  if (null == u4) {
    if (null == x3) return document.createTextNode(k3);
    u4 = document.createElementNS(o2, x3, k3.is && k3), c3 && (l.__m && l.__m(t3, e3), c3 = false), e3 = null;
  }
  if (null === x3) b2 === k3 || c3 && u4.data === k3 || (u4.data = k3);
  else {
    if (e3 = e3 && n.call(u4.childNodes), b2 = i4.props || p, !c3 && null != e3) for (b2 = {}, a3 = 0; a3 < u4.attributes.length; a3++) b2[(w3 = u4.attributes[a3]).name] = w3.value;
    for (a3 in b2) if (w3 = b2[a3], "children" == a3) ;
    else if ("dangerouslySetInnerHTML" == a3) v6 = w3;
    else if (!(a3 in k3)) {
      if ("value" == a3 && "defaultValue" in k3 || "checked" == a3 && "defaultChecked" in k3) continue;
      F(u4, a3, null, w3, o2);
    }
    for (a3 in k3) w3 = k3[a3], "children" == a3 ? y3 = w3 : "dangerouslySetInnerHTML" == a3 ? h3 = w3 : "value" == a3 ? g4 = w3 : "checked" == a3 ? m3 = w3 : c3 && "function" != typeof w3 || b2[a3] === w3 || F(u4, a3, w3, b2[a3], o2);
    if (h3) c3 || v6 && (h3.__html === v6.__html || h3.__html === u4.innerHTML) || (u4.innerHTML = h3.__html), t3.__k = [];
    else if (v6 && (u4.innerHTML = ""), $(u4, d(y3) ? y3 : [y3], t3, i4, r3, "foreignObject" == x3 ? "http://www.w3.org/1999/xhtml" : o2, e3, f5, e3 ? e3[0] : i4.__k && C(i4, 0), c3, s3), null != e3) for (a3 = e3.length; a3--; ) _(e3[a3]);
    c3 || (a3 = "value", "progress" == x3 && null == g4 ? u4.removeAttribute("value") : void 0 !== g4 && (g4 !== u4[a3] || "progress" == x3 && !g4 || "option" == x3 && g4 !== b2[a3]) && F(u4, a3, g4, b2[a3], o2), a3 = "checked", void 0 !== m3 && m3 !== u4[a3] && F(u4, a3, m3, b2[a3], o2));
  }
  return u4;
}
function V(n2, u4, t3) {
  try {
    if ("function" == typeof n2) {
      var i4 = "function" == typeof n2.__u;
      i4 && n2.__u(), i4 && null == u4 || (n2.__u = n2(u4));
    } else n2.current = u4;
  } catch (n3) {
    l.__e(n3, t3);
  }
}
function q(n2, u4, t3) {
  var i4, r3;
  if (l.unmount && l.unmount(n2), (i4 = n2.ref) && (i4.current && i4.current !== n2.__e || V(i4, null, u4)), null != (i4 = n2.__c)) {
    if (i4.componentWillUnmount) try {
      i4.componentWillUnmount();
    } catch (n3) {
      l.__e(n3, u4);
    }
    i4.base = i4.__P = null;
  }
  if (i4 = n2.__k) for (r3 = 0; r3 < i4.length; r3++) i4[r3] && q(i4[r3], u4, t3 || "function" != typeof n2.type);
  t3 || _(n2.__e), n2.__c = n2.__ = n2.__e = void 0;
}
function B(n2, l3, u4) {
  return this.constructor(n2, u4);
}
function D(u4, t3, i4) {
  var r3, o2, e3, f5;
  t3 == document && (t3 = document.documentElement), l.__ && l.__(u4, t3), o2 = (r3 = "function" == typeof i4) ? null : i4 && i4.__k || t3.__k, e3 = [], f5 = [], j(t3, u4 = (!r3 && i4 || t3).__k = g(k, null, [u4]), o2 || p, p, t3.namespaceURI, !r3 && i4 ? [i4] : o2 ? null : t3.firstChild ? n.call(t3.childNodes) : null, e3, !r3 && i4 ? i4 : o2 ? o2.__e : t3.firstChild, r3, f5), z(e3, u4, f5);
}
n = v.slice, l = { __e: function(n2, l3, u4, t3) {
  for (var i4, r3, o2; l3 = l3.__; ) if ((i4 = l3.__c) && !i4.__) try {
    if ((r3 = i4.constructor) && null != r3.getDerivedStateFromError && (i4.setState(r3.getDerivedStateFromError(n2)), o2 = i4.__d), null != i4.componentDidCatch && (i4.componentDidCatch(n2, t3 || {}), o2 = i4.__d), o2) return i4.__E = i4;
  } catch (l4) {
    n2 = l4;
  }
  throw n2;
} }, u = 0, t = function(n2) {
  return null != n2 && null == n2.constructor;
}, x.prototype.setState = function(n2, l3) {
  var u4;
  u4 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = w({}, this.state), "function" == typeof n2 && (n2 = n2(w({}, u4), this.props)), n2 && w(u4, n2), null != n2 && this.__v && (l3 && this._sb.push(l3), M(this));
}, x.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), M(this));
}, x.prototype.render = k, i = [], o = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e = function(n2, l3) {
  return n2.__v.__b - l3.__v.__b;
}, P.__r = 0, f = /(PointerCapture)$|Capture$/i, c = 0, s = O(false), a = O(true), h = 0;

// node_modules/mobx/lib/mobx.module.js
var OBFUSCATED_ERROR = "An invariant failed, however the error is obfuscated because this is a production build.";
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
function getNextId() {
  return ++globalState.mobxGuid;
}
function fail2(message) {
  invariant(false, message);
  throw "X";
}
function invariant(check, message) {
  if (!check)
    throw new Error("[mobx] " + (message || OBFUSCATED_ERROR));
}
var deprecatedMessages = [];
function deprecated(msg, thing) {
  if (false)
    return false;
  if (thing) {
    return deprecated("'" + msg + "', use '" + thing + "' instead.");
  }
  if (deprecatedMessages.indexOf(msg) !== -1)
    return false;
  deprecatedMessages.push(msg);
  console.error("[mobx] Deprecated: " + msg);
  return true;
}
function once(func) {
  var invoked = false;
  return function() {
    if (invoked)
      return;
    invoked = true;
    return func.apply(this, arguments);
  };
}
var noop = function() {
};
function unique(list) {
  var res = [];
  list.forEach(function(item) {
    if (res.indexOf(item) === -1)
      res.push(item);
  });
  return res;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject(value) {
  if (value === null || typeof value !== "object")
    return false;
  var proto = Object.getPrototypeOf(value);
  return proto === Object.prototype || proto === null;
}
function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject(dataStructure)) {
    var map = /* @__PURE__ */ new Map();
    for (var key in dataStructure) {
      map.set(key, dataStructure[key]);
    }
    return map;
  } else {
    return fail2("Cannot convert to map from '" + dataStructure + "'");
  }
}
function addHiddenProp(object, propName, value) {
  Object.defineProperty(object, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value
  });
}
function addHiddenFinalProp(object, propName, value) {
  Object.defineProperty(object, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value
  });
}
function isPropertyConfigurable(object, prop) {
  var descriptor = Object.getOwnPropertyDescriptor(object, prop);
  return !descriptor || descriptor.configurable !== false && descriptor.writable !== false;
}
function assertPropertyConfigurable(object, prop) {
  if (!isPropertyConfigurable(object, prop))
    fail2("Cannot make property '" + prop.toString() + "' observable, it is not configurable and writable in the target object");
}
function createInstanceofPredicate(name, clazz) {
  var propName = "isMobX" + name;
  clazz.prototype[propName] = true;
  return function(x3) {
    return isObject(x3) && x3[propName] === true;
  };
}
function isES6Map(thing) {
  return thing instanceof Map;
}
function isES6Set(thing) {
  return thing instanceof Set;
}
function getPlainObjectKeys(object) {
  var enumerables = /* @__PURE__ */ new Set();
  for (var key in object)
    enumerables.add(key);
  Object.getOwnPropertySymbols(object).forEach(function(k3) {
    if (Object.getOwnPropertyDescriptor(object, k3).enumerable)
      enumerables.add(k3);
  });
  return Array.from(enumerables);
}
function stringifyKey(key) {
  if (key && key.toString)
    return key.toString();
  else
    return new String(key).toString();
}
function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols ? function(obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} : (
  /* istanbul ignore next */
  Object.getOwnPropertyNames
);
var $mobx = Symbol("mobx administration");
var Atom = (
  /** @class */
  function() {
    function Atom2(name) {
      if (name === void 0) {
        name = "Atom@" + getNextId();
      }
      this.name = name;
      this.isPendingUnobservation = false;
      this.isBeingObserved = false;
      this.observers = /* @__PURE__ */ new Set();
      this.diffValue = 0;
      this.lastAccessedBy = 0;
      this.lowestObserverState = IDerivationState.NOT_TRACKING;
    }
    Atom2.prototype.onBecomeObserved = function() {
      if (this.onBecomeObservedListeners) {
        this.onBecomeObservedListeners.forEach(function(listener) {
          return listener();
        });
      }
    };
    Atom2.prototype.onBecomeUnobserved = function() {
      if (this.onBecomeUnobservedListeners) {
        this.onBecomeUnobservedListeners.forEach(function(listener) {
          return listener();
        });
      }
    };
    Atom2.prototype.reportObserved = function() {
      return reportObserved(this);
    };
    Atom2.prototype.reportChanged = function() {
      startBatch();
      propagateChanged(this);
      endBatch();
    };
    Atom2.prototype.toString = function() {
      return this.name;
    };
    return Atom2;
  }()
);
var isAtom = createInstanceofPredicate("Atom", Atom);
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop;
  }
  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop;
  }
  var atom = new Atom(name);
  if (onBecomeObservedHandler !== noop) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }
  if (onBecomeUnobservedHandler !== noop) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }
  return atom;
}
function identityComparer(a3, b2) {
  return a3 === b2;
}
function structuralComparer(a3, b2) {
  return deepEqual(a3, b2);
}
function shallowComparer(a3, b2) {
  return deepEqual(a3, b2, 1);
}
function defaultComparer(a3, b2) {
  return Object.is(a3, b2);
}
var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  default: defaultComparer,
  shallow: shallowComparer
};
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p3 in b3) if (b3.hasOwnProperty(p3)) d3[p3] = b3[p3];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign54(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3)) t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __values(o2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator], i4 = 0;
  if (m3) return m3.call(o2);
  return {
    next: function() {
      if (o2 && i4 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i4++], done: !o2 };
    }
  };
}
function __read(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i4 = 0; i4 < arguments.length; i4++)
    ar = ar.concat(__read(arguments[i4]));
  return ar;
}
var mobxDidRunLazyInitializersSymbol = Symbol("mobx did run lazy initializers");
var mobxPendingDecorators = Symbol("mobx pending decorators");
var enumerableDescriptorCache = {};
var nonEnumerableDescriptorCache = {};
function createPropertyInitializerDescriptor(prop, enumerable) {
  var cache2 = enumerable ? enumerableDescriptorCache : nonEnumerableDescriptorCache;
  return cache2[prop] || (cache2[prop] = {
    configurable: true,
    enumerable,
    get: function() {
      initializeInstance(this);
      return this[prop];
    },
    set: function(value) {
      initializeInstance(this);
      this[prop] = value;
    }
  });
}
function initializeInstance(target) {
  var e_1, _a2;
  if (target[mobxDidRunLazyInitializersSymbol] === true)
    return;
  var decorators = target[mobxPendingDecorators];
  if (decorators) {
    addHiddenProp(target, mobxDidRunLazyInitializersSymbol, true);
    var keys2 = __spread(Object.getOwnPropertySymbols(decorators), Object.keys(decorators));
    try {
      for (var keys_1 = __values(keys2), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
        var key = keys_1_1.value;
        var d2 = decorators[key];
        d2.propertyCreator(target, d2.prop, d2.descriptor, d2.decoratorTarget, d2.decoratorArguments);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (keys_1_1 && !keys_1_1.done && (_a2 = keys_1.return)) _a2.call(keys_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  }
}
function createPropDecorator(propertyInitiallyEnumerable, propertyCreator) {
  return function decoratorFactory() {
    var decoratorArguments;
    var decorator = function decorate(target, prop, descriptor, applyImmediately) {
      if (applyImmediately === true) {
        propertyCreator(target, prop, descriptor, target, decoratorArguments);
        return null;
      }
      if (!quacksLikeADecorator(arguments))
        fail2("This function is a decorator, but it wasn't invoked like a decorator");
      if (!Object.prototype.hasOwnProperty.call(target, mobxPendingDecorators)) {
        var inheritedDecorators = target[mobxPendingDecorators];
        addHiddenProp(target, mobxPendingDecorators, __assign({}, inheritedDecorators));
      }
      target[mobxPendingDecorators][prop] = {
        prop,
        propertyCreator,
        descriptor,
        decoratorTarget: target,
        decoratorArguments
      };
      return createPropertyInitializerDescriptor(prop, propertyInitiallyEnumerable);
    };
    if (quacksLikeADecorator(arguments)) {
      decoratorArguments = EMPTY_ARRAY;
      return decorator.apply(null, arguments);
    } else {
      decoratorArguments = Array.prototype.slice.call(arguments);
      return decorator;
    }
  };
}
function quacksLikeADecorator(args) {
  return (args.length === 2 || args.length === 3) && (typeof args[1] === "string" || typeof args[1] === "symbol") || args.length === 4 && args[3] === true;
}
function deepEnhancer(v6, _3, name) {
  if (isObservable(v6))
    return v6;
  if (Array.isArray(v6))
    return observable.array(v6, { name });
  if (isPlainObject(v6))
    return observable.object(v6, void 0, { name });
  if (isES6Map(v6))
    return observable.map(v6, { name });
  if (isES6Set(v6))
    return observable.set(v6, { name });
  return v6;
}
function shallowEnhancer(v6, _3, name) {
  if (v6 === void 0 || v6 === null)
    return v6;
  if (isObservableObject(v6) || isObservableArray(v6) || isObservableMap(v6) || isObservableSet(v6))
    return v6;
  if (Array.isArray(v6))
    return observable.array(v6, { name, deep: false });
  if (isPlainObject(v6))
    return observable.object(v6, void 0, { name, deep: false });
  if (isES6Map(v6))
    return observable.map(v6, { name, deep: false });
  if (isES6Set(v6))
    return observable.set(v6, { name, deep: false });
  return fail2("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
}
function referenceEnhancer(newValue) {
  return newValue;
}
function refStructEnhancer(v6, oldValue, name) {
  if (isObservable(v6))
    throw "observable.struct should not be used with observable values";
  if (deepEqual(v6, oldValue))
    return oldValue;
  return v6;
}
function createDecoratorForEnhancer(enhancer) {
  invariant(enhancer);
  var decorator = createPropDecorator(true, function(target, propertyName, descriptor, _decoratorTarget, decoratorArgs) {
    if (true) {
      invariant(!descriptor || !descriptor.get, '@observable cannot be used on getter (property "' + stringifyKey(propertyName) + '"), use @computed instead.');
    }
    var initialValue = descriptor ? descriptor.initializer ? descriptor.initializer.call(target) : descriptor.value : void 0;
    asObservableObject(target).addObservableProp(propertyName, initialValue, enhancer);
  });
  var res = (
    // Extra process checks, as this happens during module initialization
    typeof process !== "undefined" && process.env && true ? function observableDecorator() {
      if (arguments.length < 2)
        return fail2("Incorrect decorator invocation. @observable decorator doesn't expect any arguments");
      return decorator.apply(null, arguments);
    } : decorator
  );
  res.enhancer = enhancer;
  return res;
}
var defaultCreateObservableOptions = {
  deep: true,
  name: void 0,
  defaultDecorator: void 0,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions);
function assertValidOption(key) {
  if (!/^(deep|name|equals|defaultDecorator|proxy)$/.test(key))
    fail2("invalid option for (extend)observable: " + key);
}
function asCreateObservableOptions(thing) {
  if (thing === null || thing === void 0)
    return defaultCreateObservableOptions;
  if (typeof thing === "string")
    return { name: thing, deep: true, proxy: true };
  if (true) {
    if (typeof thing !== "object")
      return fail2("expected options object");
    Object.keys(thing).forEach(assertValidOption);
  }
  return thing;
}
var deepDecorator = createDecoratorForEnhancer(deepEnhancer);
var shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);
var refDecorator = createDecoratorForEnhancer(referenceEnhancer);
var refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);
function getEnhancerFromOptions(options) {
  return options.defaultDecorator ? options.defaultDecorator.enhancer : options.deep === false ? referenceEnhancer : deepEnhancer;
}
function createObservable(v6, arg2, arg3) {
  if (typeof arguments[1] === "string" || typeof arguments[1] === "symbol") {
    return deepDecorator.apply(null, arguments);
  }
  if (isObservable(v6))
    return v6;
  var res = isPlainObject(v6) ? observable.object(v6, arg2, arg3) : Array.isArray(v6) ? observable.array(v6, arg2) : isES6Map(v6) ? observable.map(v6, arg2) : isES6Set(v6) ? observable.set(v6, arg2) : v6;
  if (res !== v6)
    return res;
  fail2("The provided value could not be converted into an observable. If you want just create an observable reference to the object use 'observable.box(value)'");
}
var observableFactories = {
  box: function(value, options) {
    if (arguments.length > 2)
      incorrectlyUsedAsDecorator("box");
    var o2 = asCreateObservableOptions(options);
    return new ObservableValue(value, getEnhancerFromOptions(o2), o2.name, true, o2.equals);
  },
  array: function(initialValues, options) {
    if (arguments.length > 2)
      incorrectlyUsedAsDecorator("array");
    var o2 = asCreateObservableOptions(options);
    return createObservableArray(initialValues, getEnhancerFromOptions(o2), o2.name);
  },
  map: function(initialValues, options) {
    if (arguments.length > 2)
      incorrectlyUsedAsDecorator("map");
    var o2 = asCreateObservableOptions(options);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o2), o2.name);
  },
  set: function(initialValues, options) {
    if (arguments.length > 2)
      incorrectlyUsedAsDecorator("set");
    var o2 = asCreateObservableOptions(options);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o2), o2.name);
  },
  object: function(props, decorators, options) {
    if (typeof arguments[1] === "string")
      incorrectlyUsedAsDecorator("object");
    var o2 = asCreateObservableOptions(options);
    if (o2.proxy === false) {
      return extendObservable({}, props, decorators, o2);
    } else {
      var defaultDecorator = getDefaultDecoratorFromObjectOptions(o2);
      var base = extendObservable({}, void 0, void 0, o2);
      var proxy = createDynamicObservableObject(base);
      extendObservableObjectWithProperties(proxy, props, decorators, defaultDecorator);
      return proxy;
    }
  },
  ref: refDecorator,
  shallow: shallowDecorator,
  deep: deepDecorator,
  struct: refStructDecorator
};
var observable = createObservable;
Object.keys(observableFactories).forEach(function(name) {
  return observable[name] = observableFactories[name];
});
function incorrectlyUsedAsDecorator(methodName) {
  fail2(
    // process.env.NODE_ENV !== "production" &&
    "Expected one or two arguments to observable." + methodName + ". Did you accidentally try to use observable." + methodName + " as decorator?"
  );
}
var computedDecorator = createPropDecorator(false, function(instance, propertyName, descriptor, decoratorTarget, decoratorArgs) {
  if (true) {
    invariant(descriptor && descriptor.get, "Trying to declare a computed value for unspecified getter '" + stringifyKey(propertyName) + "'");
  }
  var get = descriptor.get, set2 = descriptor.set;
  var options = decoratorArgs[0] || {};
  asObservableObject(instance).addComputedProp(instance, propertyName, __assign({
    get,
    set: set2,
    context: instance
  }, options));
});
var computedStructDecorator = computedDecorator({ equals: comparer.structural });
var computed = function computed2(arg1, arg2, arg3) {
  if (typeof arg2 === "string") {
    return computedDecorator.apply(null, arguments);
  }
  if (arg1 !== null && typeof arg1 === "object" && arguments.length === 1) {
    return computedDecorator.apply(null, arguments);
  }
  if (true) {
    invariant(typeof arg1 === "function", "First argument to `computed` should be an expression.");
    invariant(arguments.length < 3, "Computed takes one or two arguments if used as function");
  }
  var opts = typeof arg2 === "object" ? arg2 : {};
  opts.get = arg1;
  opts.set = typeof arg2 === "function" ? arg2 : opts.set;
  opts.name = opts.name || arg1.name || "";
  return new ComputedValue(opts);
};
computed.struct = computedStructDecorator;
var IDerivationState;
(function(IDerivationState2) {
  IDerivationState2[IDerivationState2["NOT_TRACKING"] = -1] = "NOT_TRACKING";
  IDerivationState2[IDerivationState2["UP_TO_DATE"] = 0] = "UP_TO_DATE";
  IDerivationState2[IDerivationState2["POSSIBLY_STALE"] = 1] = "POSSIBLY_STALE";
  IDerivationState2[IDerivationState2["STALE"] = 2] = "STALE";
})(IDerivationState || (IDerivationState = {}));
var TraceMode;
(function(TraceMode2) {
  TraceMode2[TraceMode2["NONE"] = 0] = "NONE";
  TraceMode2[TraceMode2["LOG"] = 1] = "LOG";
  TraceMode2[TraceMode2["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = (
  /** @class */
  /* @__PURE__ */ function() {
    function CaughtException2(cause) {
      this.cause = cause;
    }
    return CaughtException2;
  }()
);
function isCaughtException(e3) {
  return e3 instanceof CaughtException;
}
function shouldCompute(derivation) {
  switch (derivation.dependenciesState) {
    case IDerivationState.UP_TO_DATE:
      return false;
    case IDerivationState.NOT_TRACKING:
    case IDerivationState.STALE:
      return true;
    case IDerivationState.POSSIBLY_STALE: {
      var prevAllowStateReads = allowStateReadsStart(true);
      var prevUntracked = untrackedStart();
      var obs = derivation.observing, l3 = obs.length;
      for (var i4 = 0; i4 < l3; i4++) {
        var obj = obs[i4];
        if (isComputedValue(obj)) {
          if (globalState.disableErrorBoundaries) {
            obj.get();
          } else {
            try {
              obj.get();
            } catch (e3) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
          if (derivation.dependenciesState === IDerivationState.STALE) {
            untrackedEnd(prevUntracked);
            allowStateReadsEnd(prevAllowStateReads);
            return true;
          }
        }
      }
      changeDependenciesStateTo0(derivation);
      untrackedEnd(prevUntracked);
      allowStateReadsEnd(prevAllowStateReads);
      return false;
    }
  }
}
function checkIfStateModificationsAreAllowed(atom) {
  var hasObservers = atom.observers.size > 0;
  if (globalState.computationDepth > 0 && hasObservers)
    fail2("Computed values are not allowed to cause side effects by changing observables that are already being observed. Tried to modify: " + atom.name);
  if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === "strict"))
    fail2((globalState.enforceActions ? "Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: ") + atom.name);
}
function checkIfStateReadsAreAllowed(observable2) {
  if (!globalState.allowStateReads && globalState.observableRequiresReaction) {
    console.warn("[mobx] Observable " + observable2.name + " being read outside a reactive context");
  }
}
function trackDerivedFunction(derivation, f5, context) {
  var prevAllowStateReads = allowStateReadsStart(true);
  changeDependenciesStateTo0(derivation);
  derivation.newObserving = new Array(derivation.observing.length + 100);
  derivation.unboundDepsCount = 0;
  derivation.runId = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  var result;
  if (globalState.disableErrorBoundaries === true) {
    result = f5.call(context);
  } else {
    try {
      result = f5.call(context);
    } catch (e3) {
      result = new CaughtException(e3);
    }
  }
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  warnAboutDerivationWithoutDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}
function warnAboutDerivationWithoutDependencies(derivation) {
  if (false)
    return;
  if (derivation.observing.length !== 0)
    return;
  if (globalState.reactionRequiresObservable || derivation.requiresObservable) {
    console.warn("[mobx] Derivation " + derivation.name + " is created/updated without reading any observable value");
  }
}
function bindDependencies(derivation) {
  var prevObserving = derivation.observing;
  var observing = derivation.observing = derivation.newObserving;
  var lowestNewObservingDerivationState = IDerivationState.UP_TO_DATE;
  var i0 = 0, l3 = derivation.unboundDepsCount;
  for (var i4 = 0; i4 < l3; i4++) {
    var dep = observing[i4];
    if (dep.diffValue === 0) {
      dep.diffValue = 1;
      if (i0 !== i4)
        observing[i0] = dep;
      i0++;
    }
    if (dep.dependenciesState > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState;
    }
  }
  observing.length = i0;
  derivation.newObserving = null;
  l3 = prevObserving.length;
  while (l3--) {
    var dep = prevObserving[l3];
    if (dep.diffValue === 0) {
      removeObserver(dep, derivation);
    }
    dep.diffValue = 0;
  }
  while (i0--) {
    var dep = observing[i0];
    if (dep.diffValue === 1) {
      dep.diffValue = 0;
      addObserver(dep, derivation);
    }
  }
  if (lowestNewObservingDerivationState !== IDerivationState.UP_TO_DATE) {
    derivation.dependenciesState = lowestNewObservingDerivationState;
    derivation.onBecomeStale();
  }
}
function clearObserving(derivation) {
  var obs = derivation.observing;
  derivation.observing = [];
  var i4 = obs.length;
  while (i4--)
    removeObserver(obs[i4], derivation);
  derivation.dependenciesState = IDerivationState.NOT_TRACKING;
}
function untracked(action3) {
  var prev = untrackedStart();
  try {
    return action3();
  } finally {
    untrackedEnd(prev);
  }
}
function untrackedStart() {
  var prev = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev;
}
function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev;
}
function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState === IDerivationState.UP_TO_DATE)
    return;
  derivation.dependenciesState = IDerivationState.UP_TO_DATE;
  var obs = derivation.observing;
  var i4 = obs.length;
  while (i4--)
    obs[i4].lowestObserverState = IDerivationState.UP_TO_DATE;
}
var currentActionId = 0;
var nextActionId = 1;
var functionNameDescriptor = Object.getOwnPropertyDescriptor(function() {
}, "name");
var isFunctionNameConfigurable = functionNameDescriptor && functionNameDescriptor.configurable;
function createAction(actionName, fn2, ref) {
  if (true) {
    invariant(typeof fn2 === "function", "`action` can only be invoked on functions");
    if (typeof actionName !== "string" || !actionName)
      fail2("actions should have valid names, got: '" + actionName + "'");
  }
  var res = function() {
    return executeAction(actionName, fn2, ref || this, arguments);
  };
  res.isMobxAction = true;
  if (true) {
    if (isFunctionNameConfigurable) {
      Object.defineProperty(res, "name", { value: actionName });
    }
  }
  return res;
}
function executeAction(actionName, fn2, scope, args) {
  var runInfo = _startAction(actionName, scope, args);
  try {
    return fn2.apply(scope, args);
  } catch (err) {
    runInfo.error = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}
function _startAction(actionName, scope, args) {
  var notifySpy = isSpyEnabled() && !!actionName;
  var startTime = 0;
  if (notifySpy && true) {
    startTime = Date.now();
    var l3 = args && args.length || 0;
    var flattendArgs = new Array(l3);
    if (l3 > 0)
      for (var i4 = 0; i4 < l3; i4++)
        flattendArgs[i4] = args[i4];
    spyReportStart({
      type: "action",
      name: actionName,
      object: scope,
      arguments: flattendArgs
    });
  }
  var prevDerivation = untrackedStart();
  startBatch();
  var prevAllowStateChanges = allowStateChangesStart(true);
  var prevAllowStateReads = allowStateReadsStart(true);
  var runInfo = {
    prevDerivation,
    prevAllowStateChanges,
    prevAllowStateReads,
    notifySpy,
    startTime,
    actionId: nextActionId++,
    parentActionId: currentActionId
  };
  currentActionId = runInfo.actionId;
  return runInfo;
}
function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId) {
    fail2("invalid action stack. did you forget to finish an action?");
  }
  currentActionId = runInfo.parentActionId;
  if (runInfo.error !== void 0) {
    globalState.suppressReactionErrors = true;
  }
  allowStateChangesEnd(runInfo.prevAllowStateChanges);
  allowStateReadsEnd(runInfo.prevAllowStateReads);
  endBatch();
  untrackedEnd(runInfo.prevDerivation);
  if (runInfo.notifySpy && true) {
    spyReportEnd({ time: Date.now() - runInfo.startTime });
  }
  globalState.suppressReactionErrors = false;
}
function allowStateChangesStart(allowStateChanges3) {
  var prev = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges3;
  return prev;
}
function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}
var ObservableValue = (
  /** @class */
  function(_super) {
    __extends(ObservableValue2, _super);
    function ObservableValue2(value, enhancer, name, notifySpy, equals) {
      if (name === void 0) {
        name = "ObservableValue@" + getNextId();
      }
      if (notifySpy === void 0) {
        notifySpy = true;
      }
      if (equals === void 0) {
        equals = comparer.default;
      }
      var _this = _super.call(this, name) || this;
      _this.enhancer = enhancer;
      _this.name = name;
      _this.equals = equals;
      _this.hasUnreportedChange = false;
      _this.value = enhancer(value, void 0, name);
      if (notifySpy && isSpyEnabled() && true) {
        spyReport({ type: "create", name: _this.name, newValue: "" + _this.value });
      }
      return _this;
    }
    ObservableValue2.prototype.dehanceValue = function(value) {
      if (this.dehancer !== void 0)
        return this.dehancer(value);
      return value;
    };
    ObservableValue2.prototype.set = function(newValue) {
      var oldValue = this.value;
      newValue = this.prepareNewValue(newValue);
      if (newValue !== globalState.UNCHANGED) {
        var notifySpy = isSpyEnabled();
        if (notifySpy && true) {
          spyReportStart({
            type: "update",
            name: this.name,
            newValue,
            oldValue
          });
        }
        this.setNewValue(newValue);
        if (notifySpy && true)
          spyReportEnd();
      }
    };
    ObservableValue2.prototype.prepareNewValue = function(newValue) {
      checkIfStateModificationsAreAllowed(this);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this,
          type: "update",
          newValue
        });
        if (!change)
          return globalState.UNCHANGED;
        newValue = change.newValue;
      }
      newValue = this.enhancer(newValue, this.value, this.name);
      return this.equals(this.value, newValue) ? globalState.UNCHANGED : newValue;
    };
    ObservableValue2.prototype.setNewValue = function(newValue) {
      var oldValue = this.value;
      this.value = newValue;
      this.reportChanged();
      if (hasListeners(this)) {
        notifyListeners(this, {
          type: "update",
          object: this,
          newValue,
          oldValue
        });
      }
    };
    ObservableValue2.prototype.get = function() {
      this.reportObserved();
      return this.dehanceValue(this.value);
    };
    ObservableValue2.prototype.intercept = function(handler) {
      return registerInterceptor(this, handler);
    };
    ObservableValue2.prototype.observe = function(listener, fireImmediately) {
      if (fireImmediately)
        listener({
          object: this,
          type: "update",
          newValue: this.value,
          oldValue: void 0
        });
      return registerListener(this, listener);
    };
    ObservableValue2.prototype.toJSON = function() {
      return this.get();
    };
    ObservableValue2.prototype.toString = function() {
      return this.name + "[" + this.value + "]";
    };
    ObservableValue2.prototype.valueOf = function() {
      return toPrimitive(this.get());
    };
    ObservableValue2.prototype[Symbol.toPrimitive] = function() {
      return this.valueOf();
    };
    return ObservableValue2;
  }(Atom)
);
var isObservableValue = createInstanceofPredicate("ObservableValue", ObservableValue);
var ComputedValue = (
  /** @class */
  function() {
    function ComputedValue2(options) {
      this.dependenciesState = IDerivationState.NOT_TRACKING;
      this.observing = [];
      this.newObserving = null;
      this.isBeingObserved = false;
      this.isPendingUnobservation = false;
      this.observers = /* @__PURE__ */ new Set();
      this.diffValue = 0;
      this.runId = 0;
      this.lastAccessedBy = 0;
      this.lowestObserverState = IDerivationState.UP_TO_DATE;
      this.unboundDepsCount = 0;
      this.__mapid = "#" + getNextId();
      this.value = new CaughtException(null);
      this.isComputing = false;
      this.isRunningSetter = false;
      this.isTracing = TraceMode.NONE;
      invariant(options.get, "missing option for computed: get");
      this.derivation = options.get;
      this.name = options.name || "ComputedValue@" + getNextId();
      if (options.set)
        this.setter = createAction(this.name + "-setter", options.set);
      this.equals = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer.default);
      this.scope = options.context;
      this.requiresReaction = !!options.requiresReaction;
      this.keepAlive = !!options.keepAlive;
    }
    ComputedValue2.prototype.onBecomeStale = function() {
      propagateMaybeChanged(this);
    };
    ComputedValue2.prototype.onBecomeObserved = function() {
      if (this.onBecomeObservedListeners) {
        this.onBecomeObservedListeners.forEach(function(listener) {
          return listener();
        });
      }
    };
    ComputedValue2.prototype.onBecomeUnobserved = function() {
      if (this.onBecomeUnobservedListeners) {
        this.onBecomeUnobservedListeners.forEach(function(listener) {
          return listener();
        });
      }
    };
    ComputedValue2.prototype.get = function() {
      if (this.isComputing)
        fail2("Cycle detected in computation " + this.name + ": " + this.derivation);
      if (globalState.inBatch === 0 && this.observers.size === 0 && !this.keepAlive) {
        if (shouldCompute(this)) {
          this.warnAboutUntrackedRead();
          startBatch();
          this.value = this.computeValue(false);
          endBatch();
        }
      } else {
        reportObserved(this);
        if (shouldCompute(this)) {
          if (this.trackAndCompute())
            propagateChangeConfirmed(this);
        }
      }
      var result = this.value;
      if (isCaughtException(result))
        throw result.cause;
      return result;
    };
    ComputedValue2.prototype.peek = function() {
      var res = this.computeValue(false);
      if (isCaughtException(res))
        throw res.cause;
      return res;
    };
    ComputedValue2.prototype.set = function(value) {
      if (this.setter) {
        invariant(!this.isRunningSetter, "The setter of computed value '" + this.name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?");
        this.isRunningSetter = true;
        try {
          this.setter.call(this.scope, value);
        } finally {
          this.isRunningSetter = false;
        }
      } else
        invariant(false, "[ComputedValue '" + this.name + "'] It is not possible to assign a new value to a computed value.");
    };
    ComputedValue2.prototype.trackAndCompute = function() {
      if (isSpyEnabled() && true) {
        spyReport({
          object: this.scope,
          type: "compute",
          name: this.name
        });
      }
      var oldValue = this.value;
      var wasSuspended = (
        /* see #1208 */
        this.dependenciesState === IDerivationState.NOT_TRACKING
      );
      var newValue = this.computeValue(true);
      var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals(oldValue, newValue);
      if (changed) {
        this.value = newValue;
      }
      return changed;
    };
    ComputedValue2.prototype.computeValue = function(track) {
      this.isComputing = true;
      globalState.computationDepth++;
      var res;
      if (track) {
        res = trackDerivedFunction(this, this.derivation, this.scope);
      } else {
        if (globalState.disableErrorBoundaries === true) {
          res = this.derivation.call(this.scope);
        } else {
          try {
            res = this.derivation.call(this.scope);
          } catch (e3) {
            res = new CaughtException(e3);
          }
        }
      }
      globalState.computationDepth--;
      this.isComputing = false;
      return res;
    };
    ComputedValue2.prototype.suspend = function() {
      if (!this.keepAlive) {
        clearObserving(this);
        this.value = void 0;
      }
    };
    ComputedValue2.prototype.observe = function(listener, fireImmediately) {
      var _this = this;
      var firstTime = true;
      var prevValue = void 0;
      return autorun(function() {
        var newValue = _this.get();
        if (!firstTime || fireImmediately) {
          var prevU = untrackedStart();
          listener({
            type: "update",
            object: _this,
            newValue,
            oldValue: prevValue
          });
          untrackedEnd(prevU);
        }
        firstTime = false;
        prevValue = newValue;
      });
    };
    ComputedValue2.prototype.warnAboutUntrackedRead = function() {
      if (false)
        return;
      if (this.requiresReaction === true) {
        fail2("[mobx] Computed value " + this.name + " is read outside a reactive context");
      }
      if (this.isTracing !== TraceMode.NONE) {
        console.log("[mobx.trace] '" + this.name + "' is being read outside a reactive context. Doing a full recompute");
      }
      if (globalState.computedRequiresReaction) {
        console.warn("[mobx] Computed value " + this.name + " is being read outside a reactive context. Doing a full recompute");
      }
    };
    ComputedValue2.prototype.toJSON = function() {
      return this.get();
    };
    ComputedValue2.prototype.toString = function() {
      return this.name + "[" + this.derivation.toString() + "]";
    };
    ComputedValue2.prototype.valueOf = function() {
      return toPrimitive(this.get());
    };
    ComputedValue2.prototype[Symbol.toPrimitive] = function() {
      return this.valueOf();
    };
    return ComputedValue2;
  }()
);
var isComputedValue = createInstanceofPredicate("ComputedValue", ComputedValue);
var MobXGlobals = (
  /** @class */
  /* @__PURE__ */ function() {
    function MobXGlobals2() {
      this.version = 5;
      this.UNCHANGED = {};
      this.trackingDerivation = null;
      this.computationDepth = 0;
      this.runId = 0;
      this.mobxGuid = 0;
      this.inBatch = 0;
      this.pendingUnobservations = [];
      this.pendingReactions = [];
      this.isRunningReactions = false;
      this.allowStateChanges = true;
      this.allowStateReads = true;
      this.enforceActions = false;
      this.spyListeners = [];
      this.globalReactionErrorHandlers = [];
      this.computedRequiresReaction = false;
      this.reactionRequiresObservable = false;
      this.observableRequiresReaction = false;
      this.computedConfigurable = false;
      this.disableErrorBoundaries = false;
      this.suppressReactionErrors = false;
    }
    return MobXGlobals2;
  }()
);
var mockGlobal = {};
function getGlobal() {
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return mockGlobal;
}
var canMergeGlobalState = true;
var isolateCalled = false;
var globalState = function() {
  var global2 = getGlobal();
  if (global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals)
    canMergeGlobalState = false;
  if (global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals().version)
    canMergeGlobalState = false;
  if (!canMergeGlobalState) {
    setTimeout(function() {
      if (!isolateCalled) {
        fail2("There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`");
      }
    }, 1);
    return new MobXGlobals();
  } else if (global2.__mobxGlobals) {
    global2.__mobxInstanceCount += 1;
    if (!global2.__mobxGlobals.UNCHANGED)
      global2.__mobxGlobals.UNCHANGED = {};
    return global2.__mobxGlobals;
  } else {
    global2.__mobxInstanceCount = 1;
    return global2.__mobxGlobals = new MobXGlobals();
  }
}();
function isolateGlobalState() {
  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions)
    fail2("isolateGlobalState should be called before MobX is running any reactions");
  isolateCalled = true;
  if (canMergeGlobalState) {
    if (--getGlobal().__mobxInstanceCount === 0)
      getGlobal().__mobxGlobals = void 0;
    globalState = new MobXGlobals();
  }
}
function getGlobalState() {
  return globalState;
}
function addObserver(observable2, node) {
  observable2.observers.add(node);
  if (observable2.lowestObserverState > node.dependenciesState)
    observable2.lowestObserverState = node.dependenciesState;
}
function removeObserver(observable2, node) {
  observable2.observers.delete(node);
  if (observable2.observers.size === 0) {
    queueForUnobservation(observable2);
  }
}
function queueForUnobservation(observable2) {
  if (observable2.isPendingUnobservation === false) {
    observable2.isPendingUnobservation = true;
    globalState.pendingUnobservations.push(observable2);
  }
}
function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions();
    var list = globalState.pendingUnobservations;
    for (var i4 = 0; i4 < list.length; i4++) {
      var observable2 = list[i4];
      observable2.isPendingUnobservation = false;
      if (observable2.observers.size === 0) {
        if (observable2.isBeingObserved) {
          observable2.isBeingObserved = false;
          observable2.onBecomeUnobserved();
        }
        if (observable2 instanceof ComputedValue) {
          observable2.suspend();
        }
      }
    }
    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable2) {
  checkIfStateReadsAreAllowed(observable2);
  var derivation = globalState.trackingDerivation;
  if (derivation !== null) {
    if (derivation.runId !== observable2.lastAccessedBy) {
      observable2.lastAccessedBy = derivation.runId;
      derivation.newObserving[derivation.unboundDepsCount++] = observable2;
      if (!observable2.isBeingObserved) {
        observable2.isBeingObserved = true;
        observable2.onBecomeObserved();
      }
    }
    return true;
  } else if (observable2.observers.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable2);
  }
  return false;
}
function propagateChanged(observable2) {
  if (observable2.lowestObserverState === IDerivationState.STALE)
    return;
  observable2.lowestObserverState = IDerivationState.STALE;
  observable2.observers.forEach(function(d2) {
    if (d2.dependenciesState === IDerivationState.UP_TO_DATE) {
      if (d2.isTracing !== TraceMode.NONE) {
        logTraceInfo(d2, observable2);
      }
      d2.onBecomeStale();
    }
    d2.dependenciesState = IDerivationState.STALE;
  });
}
function propagateChangeConfirmed(observable2) {
  if (observable2.lowestObserverState === IDerivationState.STALE)
    return;
  observable2.lowestObserverState = IDerivationState.STALE;
  observable2.observers.forEach(function(d2) {
    if (d2.dependenciesState === IDerivationState.POSSIBLY_STALE)
      d2.dependenciesState = IDerivationState.STALE;
    else if (d2.dependenciesState === IDerivationState.UP_TO_DATE)
      observable2.lowestObserverState = IDerivationState.UP_TO_DATE;
  });
}
function propagateMaybeChanged(observable2) {
  if (observable2.lowestObserverState !== IDerivationState.UP_TO_DATE)
    return;
  observable2.lowestObserverState = IDerivationState.POSSIBLY_STALE;
  observable2.observers.forEach(function(d2) {
    if (d2.dependenciesState === IDerivationState.UP_TO_DATE) {
      d2.dependenciesState = IDerivationState.POSSIBLY_STALE;
      if (d2.isTracing !== TraceMode.NONE) {
        logTraceInfo(d2, observable2);
      }
      d2.onBecomeStale();
    }
  });
}
function logTraceInfo(derivation, observable2) {
  console.log("[mobx.trace] '" + derivation.name + "' is invalidated due to a change in: '" + observable2.name + "'");
  if (derivation.isTracing === TraceMode.BREAK) {
    var lines = [];
    printDepTree(getDependencyTree(derivation), lines, 1);
    new Function("debugger;\n/*\nTracing '" + derivation.name + "'\n\nYou are entering this break point because derivation '" + derivation.name + "' is being traced and '" + observable2.name + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
  }
}
function printDepTree(tree, lines, depth) {
  if (lines.length >= 1e3) {
    lines.push("(and many more)");
    return;
  }
  lines.push("" + new Array(depth).join("	") + tree.name);
  if (tree.dependencies)
    tree.dependencies.forEach(function(child) {
      return printDepTree(child, lines, depth + 1);
    });
}
var Reaction = (
  /** @class */
  function() {
    function Reaction2(name, onInvalidate, errorHandler, requiresObservable) {
      if (name === void 0) {
        name = "Reaction@" + getNextId();
      }
      if (requiresObservable === void 0) {
        requiresObservable = false;
      }
      this.name = name;
      this.onInvalidate = onInvalidate;
      this.errorHandler = errorHandler;
      this.requiresObservable = requiresObservable;
      this.observing = [];
      this.newObserving = [];
      this.dependenciesState = IDerivationState.NOT_TRACKING;
      this.diffValue = 0;
      this.runId = 0;
      this.unboundDepsCount = 0;
      this.__mapid = "#" + getNextId();
      this.isDisposed = false;
      this._isScheduled = false;
      this._isTrackPending = false;
      this._isRunning = false;
      this.isTracing = TraceMode.NONE;
    }
    Reaction2.prototype.onBecomeStale = function() {
      this.schedule();
    };
    Reaction2.prototype.schedule = function() {
      if (!this._isScheduled) {
        this._isScheduled = true;
        globalState.pendingReactions.push(this);
        runReactions();
      }
    };
    Reaction2.prototype.isScheduled = function() {
      return this._isScheduled;
    };
    Reaction2.prototype.runReaction = function() {
      if (!this.isDisposed) {
        startBatch();
        this._isScheduled = false;
        if (shouldCompute(this)) {
          this._isTrackPending = true;
          try {
            this.onInvalidate();
            if (this._isTrackPending && isSpyEnabled() && true) {
              spyReport({
                name: this.name,
                type: "scheduled-reaction"
              });
            }
          } catch (e3) {
            this.reportExceptionInDerivation(e3);
          }
        }
        endBatch();
      }
    };
    Reaction2.prototype.track = function(fn2) {
      if (this.isDisposed) {
        return;
      }
      startBatch();
      var notify = isSpyEnabled();
      var startTime;
      if (notify && true) {
        startTime = Date.now();
        spyReportStart({
          name: this.name,
          type: "reaction"
        });
      }
      this._isRunning = true;
      var result = trackDerivedFunction(this, fn2, void 0);
      this._isRunning = false;
      this._isTrackPending = false;
      if (this.isDisposed) {
        clearObserving(this);
      }
      if (isCaughtException(result))
        this.reportExceptionInDerivation(result.cause);
      if (notify && true) {
        spyReportEnd({
          time: Date.now() - startTime
        });
      }
      endBatch();
    };
    Reaction2.prototype.reportExceptionInDerivation = function(error) {
      var _this = this;
      if (this.errorHandler) {
        this.errorHandler(error, this);
        return;
      }
      if (globalState.disableErrorBoundaries)
        throw error;
      var message = "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'";
      if (globalState.suppressReactionErrors) {
        console.warn("[mobx] (error in reaction '" + this.name + "' suppressed, fix error of causing action below)");
      } else {
        console.error(message, error);
      }
      if (isSpyEnabled()) {
        spyReport({
          type: "error",
          name: this.name,
          message,
          error: "" + error
        });
      }
      globalState.globalReactionErrorHandlers.forEach(function(f5) {
        return f5(error, _this);
      });
    };
    Reaction2.prototype.dispose = function() {
      if (!this.isDisposed) {
        this.isDisposed = true;
        if (!this._isRunning) {
          startBatch();
          clearObserving(this);
          endBatch();
        }
      }
    };
    Reaction2.prototype.getDisposer = function() {
      var r3 = this.dispose.bind(this);
      r3[$mobx] = this;
      return r3;
    };
    Reaction2.prototype.toString = function() {
      return "Reaction[" + this.name + "]";
    };
    Reaction2.prototype.trace = function(enterBreakPoint) {
      if (enterBreakPoint === void 0) {
        enterBreakPoint = false;
      }
      trace(this, enterBreakPoint);
    };
    return Reaction2;
  }()
);
var MAX_REACTION_ITERATIONS = 100;
var reactionScheduler = function(f5) {
  return f5();
};
function runReactions() {
  if (globalState.inBatch > 0 || globalState.isRunningReactions)
    return;
  reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0;
  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error("Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]));
      allReactions.splice(0);
    }
    var remainingReactions = allReactions.splice(0);
    for (var i4 = 0, l3 = remainingReactions.length; i4 < l3; i4++)
      remainingReactions[i4].runReaction();
  }
  globalState.isRunningReactions = false;
}
var isReaction = createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn2) {
  var baseScheduler = reactionScheduler;
  reactionScheduler = function(f5) {
    return fn2(function() {
      return baseScheduler(f5);
    });
  };
}
function isSpyEnabled() {
  return !!globalState.spyListeners.length;
}
function spyReport(event) {
  if (false)
    return;
  if (!globalState.spyListeners.length)
    return;
  var listeners = globalState.spyListeners;
  for (var i4 = 0, l3 = listeners.length; i4 < l3; i4++)
    listeners[i4](event);
}
function spyReportStart(event) {
  if (false)
    return;
  var change = __assign(__assign({}, event), { spyReportStart: true });
  spyReport(change);
}
var END_EVENT = { spyReportEnd: true };
function spyReportEnd(change) {
  if (false)
    return;
  if (change)
    spyReport(__assign(__assign({}, change), { spyReportEnd: true }));
  else
    spyReport(END_EVENT);
}
function spy(listener) {
  if (false) {
    console.warn("[mobx.spy] Is a no-op in production builds");
    return function() {
    };
  } else {
    globalState.spyListeners.push(listener);
    return once(function() {
      globalState.spyListeners = globalState.spyListeners.filter(function(l3) {
        return l3 !== listener;
      });
    });
  }
}
function dontReassignFields() {
  fail2("@action fields are not reassignable");
}
function namedActionDecorator(name) {
  return function(target, prop, descriptor) {
    if (descriptor) {
      if (descriptor.get !== void 0) {
        return fail2("@action cannot be used with getters");
      }
      if (descriptor.value) {
        return {
          value: createAction(name, descriptor.value),
          enumerable: false,
          configurable: true,
          writable: true
          // for typescript, this must be writable, otherwise it cannot inherit :/ (see inheritable actions test)
        };
      }
      var initializer_1 = descriptor.initializer;
      return {
        enumerable: false,
        configurable: true,
        writable: true,
        initializer: function() {
          return createAction(name, initializer_1.call(this));
        }
      };
    }
    return actionFieldDecorator(name).apply(this, arguments);
  };
}
function actionFieldDecorator(name) {
  return function(target, prop, descriptor) {
    Object.defineProperty(target, prop, {
      configurable: true,
      enumerable: false,
      get: function() {
        return void 0;
      },
      set: function(value) {
        addHiddenProp(this, prop, action(name, value));
      }
    });
  };
}
function boundActionDecorator(target, propertyName, descriptor, applyToInstance) {
  if (applyToInstance === true) {
    defineBoundAction(target, propertyName, descriptor.value);
    return null;
  }
  if (descriptor) {
    return {
      configurable: true,
      enumerable: false,
      get: function() {
        defineBoundAction(this, propertyName, descriptor.value || descriptor.initializer.call(this));
        return this[propertyName];
      },
      set: dontReassignFields
    };
  }
  return {
    enumerable: false,
    configurable: true,
    set: function(v6) {
      defineBoundAction(this, propertyName, v6);
    },
    get: function() {
      return void 0;
    }
  };
}
var action = function action2(arg1, arg2, arg3, arg4) {
  if (arguments.length === 1 && typeof arg1 === "function")
    return createAction(arg1.name || "<unnamed action>", arg1);
  if (arguments.length === 2 && typeof arg2 === "function")
    return createAction(arg1, arg2);
  if (arguments.length === 1 && typeof arg1 === "string")
    return namedActionDecorator(arg1);
  if (arg4 === true) {
    addHiddenProp(arg1, arg2, createAction(arg1.name || arg2, arg3.value, this));
  } else {
    return namedActionDecorator(arg2).apply(null, arguments);
  }
};
action.bound = boundActionDecorator;
function runInAction(arg1, arg2) {
  var actionName = typeof arg1 === "string" ? arg1 : arg1.name || "<unnamed action>";
  var fn2 = typeof arg1 === "function" ? arg1 : arg2;
  if (true) {
    invariant(typeof fn2 === "function" && fn2.length === 0, "`runInAction` expects a function without arguments");
    if (typeof actionName !== "string" || !actionName)
      fail2("actions should have valid names, got: '" + actionName + "'");
  }
  return executeAction(actionName, fn2, this, void 0);
}
function isAction(thing) {
  return typeof thing === "function" && thing.isMobxAction === true;
}
function defineBoundAction(target, propertyName, fn2) {
  addHiddenProp(target, propertyName, createAction(propertyName, fn2.bind(target)));
}
function autorun(view, opts) {
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  if (true) {
    invariant(typeof view === "function", "Autorun expects a function as first argument");
    invariant(isAction(view) === false, "Autorun does not accept actions since actions are untrackable");
  }
  var name = opts && opts.name || view.name || "Autorun@" + getNextId();
  var runSync = !opts.scheduler && !opts.delay;
  var reaction2;
  if (runSync) {
    reaction2 = new Reaction(name, function() {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler_1 = createSchedulerFromOptions(opts);
    var isScheduled_1 = false;
    reaction2 = new Reaction(name, function() {
      if (!isScheduled_1) {
        isScheduled_1 = true;
        scheduler_1(function() {
          isScheduled_1 = false;
          if (!reaction2.isDisposed)
            reaction2.track(reactionRunner);
        });
      }
    }, opts.onError, opts.requiresObservable);
  }
  function reactionRunner() {
    view(reaction2);
  }
  reaction2.schedule();
  return reaction2.getDisposer();
}
var run = function(f5) {
  return f5();
};
function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function(f5) {
    return setTimeout(f5, opts.delay);
  } : run;
}
function reaction(expression, effect, opts) {
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  if (true) {
    invariant(typeof expression === "function", "First argument to reaction should be a function");
    invariant(typeof opts === "object", "Third argument of reactions should be an object");
  }
  var name = opts.name || "Reaction@" + getNextId();
  var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
  var runSync = !opts.scheduler && !opts.delay;
  var scheduler = createSchedulerFromOptions(opts);
  var firstTime = true;
  var isScheduled = false;
  var value;
  var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer.default;
  var r3 = new Reaction(name, function() {
    if (firstTime || runSync) {
      reactionRunner();
    } else if (!isScheduled) {
      isScheduled = true;
      scheduler(reactionRunner);
    }
  }, opts.onError, opts.requiresObservable);
  function reactionRunner() {
    isScheduled = false;
    if (r3.isDisposed)
      return;
    var changed = false;
    r3.track(function() {
      var nextValue = expression(r3);
      changed = firstTime || !equals(value, nextValue);
      value = nextValue;
    });
    if (firstTime && opts.fireImmediately)
      effectAction(value, r3);
    if (!firstTime && changed === true)
      effectAction(value, r3);
    if (firstTime)
      firstTime = false;
  }
  r3.schedule();
  return r3.getDisposer();
}
function wrapErrorHandler(errorHandler, baseFn) {
  return function() {
    try {
      return baseFn.apply(this, arguments);
    } catch (e3) {
      errorHandler.call(this, e3);
    }
  };
}
function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook("onBecomeObserved", thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook("onBecomeUnobserved", thing, arg2, arg3);
}
function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb = typeof arg3 === "function" ? arg3 : arg2;
  var listenersKey = hook + "Listeners";
  if (atom[listenersKey]) {
    atom[listenersKey].add(cb);
  } else {
    atom[listenersKey] = /* @__PURE__ */ new Set([cb]);
  }
  var orig = atom[hook];
  if (typeof orig !== "function")
    return fail2("Not an atom that can be (un)observed");
  return function() {
    var hookListeners = atom[listenersKey];
    if (hookListeners) {
      hookListeners.delete(cb);
      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}
function configure(options) {
  var enforceActions = options.enforceActions, computedRequiresReaction = options.computedRequiresReaction, computedConfigurable = options.computedConfigurable, disableErrorBoundaries = options.disableErrorBoundaries, reactionScheduler2 = options.reactionScheduler, reactionRequiresObservable = options.reactionRequiresObservable, observableRequiresReaction = options.observableRequiresReaction;
  if (options.isolateGlobalState === true) {
    isolateGlobalState();
  }
  if (enforceActions !== void 0) {
    if (typeof enforceActions === "boolean" || enforceActions === "strict")
      deprecated(`Deprecated value for 'enforceActions', use 'false' => '"never"', 'true' => '"observed"', '"strict"' => "'always'" instead`);
    var ea = void 0;
    switch (enforceActions) {
      case true:
      case "observed":
        ea = true;
        break;
      case false:
      case "never":
        ea = false;
        break;
      case "strict":
      case "always":
        ea = "strict";
        break;
      default:
        fail2("Invalid value for 'enforceActions': '" + enforceActions + "', expected 'never', 'always' or 'observed'");
    }
    globalState.enforceActions = ea;
    globalState.allowStateChanges = ea === true || ea === "strict" ? false : true;
  }
  if (computedRequiresReaction !== void 0) {
    globalState.computedRequiresReaction = !!computedRequiresReaction;
  }
  if (reactionRequiresObservable !== void 0) {
    globalState.reactionRequiresObservable = !!reactionRequiresObservable;
  }
  if (observableRequiresReaction !== void 0) {
    globalState.observableRequiresReaction = !!observableRequiresReaction;
    globalState.allowStateReads = !globalState.observableRequiresReaction;
  }
  if (computedConfigurable !== void 0) {
    globalState.computedConfigurable = !!computedConfigurable;
  }
  if (disableErrorBoundaries !== void 0) {
    if (disableErrorBoundaries === true)
      console.warn("WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.");
    globalState.disableErrorBoundaries = !!disableErrorBoundaries;
  }
  if (reactionScheduler2) {
    setReactionScheduler(reactionScheduler2);
  }
}
function extendObservable(target, properties, decorators, options) {
  if (true) {
    invariant(arguments.length >= 2 && arguments.length <= 4, "'extendObservable' expected 2-4 arguments");
    invariant(typeof target === "object", "'extendObservable' expects an object as first argument");
    invariant(!isObservableMap(target), "'extendObservable' should not be used on maps, use map.merge instead");
  }
  options = asCreateObservableOptions(options);
  var defaultDecorator = getDefaultDecoratorFromObjectOptions(options);
  initializeInstance(target);
  asObservableObject(target, options.name, defaultDecorator.enhancer);
  if (properties)
    extendObservableObjectWithProperties(target, properties, decorators, defaultDecorator);
  return target;
}
function getDefaultDecoratorFromObjectOptions(options) {
  return options.defaultDecorator || (options.deep === false ? refDecorator : deepDecorator);
}
function extendObservableObjectWithProperties(target, properties, decorators, defaultDecorator) {
  var e_1, _a2, e_2, _b;
  if (true) {
    invariant(!isObservable(properties), "Extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540");
    if (decorators) {
      var keys2 = getPlainObjectKeys(decorators);
      try {
        for (var keys_1 = __values(keys2), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
          var key = keys_1_1.value;
          if (!(key in properties))
            fail2("Trying to declare a decorator for unspecified property '" + stringifyKey(key) + "'");
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (keys_1_1 && !keys_1_1.done && (_a2 = keys_1.return)) _a2.call(keys_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }
  }
  startBatch();
  try {
    var keys2 = ownKeys(properties);
    try {
      for (var keys_2 = __values(keys2), keys_2_1 = keys_2.next(); !keys_2_1.done; keys_2_1 = keys_2.next()) {
        var key = keys_2_1.value;
        var descriptor = Object.getOwnPropertyDescriptor(properties, key);
        if (true) {
          if (!isPlainObject(properties))
            fail2("'extendObservable' only accepts plain objects as second argument");
          if (isComputed(descriptor.value))
            fail2("Passing a 'computed' as initial property value is no longer supported by extendObservable. Use a getter or decorator instead");
        }
        var decorator = decorators && key in decorators ? decorators[key] : descriptor.get ? computedDecorator : defaultDecorator;
        if (typeof decorator !== "function")
          fail2("Not a valid decorator for '" + stringifyKey(key) + "', got: " + decorator);
        var resultDescriptor = decorator(target, key, descriptor, true);
        if (resultDescriptor)
          Object.defineProperty(target, key, resultDescriptor);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (keys_2_1 && !keys_2_1.done && (_b = keys_2.return)) _b.call(keys_2);
      } finally {
        if (e_2) throw e_2.error;
      }
    }
  } finally {
    endBatch();
  }
}
function getDependencyTree(thing, property) {
  return nodeToDependencyTree(getAtom(thing, property));
}
function nodeToDependencyTree(node) {
  var result = {
    name: node.name
  };
  if (node.observing && node.observing.length > 0)
    result.dependencies = unique(node.observing).map(nodeToDependencyTree);
  return result;
}
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = Object.create(Error.prototype);
function _isComputed(value, property) {
  if (value === null || value === void 0)
    return false;
  if (property !== void 0) {
    if (isObservableObject(value) === false)
      return false;
    if (!value[$mobx].values.has(property))
      return false;
    var atom = getAtom(value, property);
    return isComputedValue(atom);
  }
  return isComputedValue(value);
}
function isComputed(value) {
  if (arguments.length > 1)
    return fail2("isComputed expects only 1 argument. Use isObservableProp to inspect the observability of a property");
  return _isComputed(value);
}
function isComputedProp(value, propName) {
  if (typeof propName !== "string")
    return fail2("isComputed expected a property name as second argument");
  return _isComputed(value, propName);
}
function _isObservable(value, property) {
  if (value === null || value === void 0)
    return false;
  if (property !== void 0) {
    if (isObservableMap(value) || isObservableArray(value))
      return fail2("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");
    if (isObservableObject(value)) {
      return value[$mobx].values.has(property);
    }
    return false;
  }
  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}
function isObservable(value) {
  if (arguments.length !== 1)
    fail2("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
  return _isObservable(value);
}
function keys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].getKeys();
  }
  if (isObservableMap(obj)) {
    return Array.from(obj.keys());
  }
  if (isObservableSet(obj)) {
    return Array.from(obj.keys());
  }
  if (isObservableArray(obj)) {
    return obj.map(function(_3, index) {
      return index;
    });
  }
  return fail2("'keys()' can only be used on observable objects, arrays, sets and maps");
}
function values(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function(key) {
      return obj[key];
    });
  }
  if (isObservableMap(obj)) {
    return keys(obj).map(function(key) {
      return obj.get(key);
    });
  }
  if (isObservableSet(obj)) {
    return Array.from(obj.values());
  }
  if (isObservableArray(obj)) {
    return obj.slice();
  }
  return fail2("'values()' can only be used on observable objects, arrays, sets and maps");
}
function entries(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function(key) {
      return [key, obj[key]];
    });
  }
  if (isObservableMap(obj)) {
    return keys(obj).map(function(key) {
      return [key, obj.get(key)];
    });
  }
  if (isObservableSet(obj)) {
    return Array.from(obj.entries());
  }
  if (isObservableArray(obj)) {
    return obj.map(function(key, index) {
      return [index, key];
    });
  }
  return fail2("'entries()' can only be used on observable objects, arrays and maps");
}
function set(obj, key, value) {
  if (arguments.length === 2 && !isObservableSet(obj)) {
    startBatch();
    var values_1 = key;
    try {
      for (var key_1 in values_1)
        set(obj, key_1, values_1[key_1]);
    } finally {
      endBatch();
    }
    return;
  }
  if (isObservableObject(obj)) {
    var adm = obj[$mobx];
    var existingObservable = adm.values.get(key);
    if (existingObservable) {
      adm.write(key, value);
    } else {
      adm.addObservableProp(key, value, adm.defaultEnhancer);
    }
  } else if (isObservableMap(obj)) {
    obj.set(key, value);
  } else if (isObservableSet(obj)) {
    obj.add(key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number")
      key = parseInt(key, 10);
    invariant(key >= 0, "Not a valid index: '" + key + "'");
    startBatch();
    if (key >= obj.length)
      obj.length = key + 1;
    obj[key] = value;
    endBatch();
  } else {
    return fail2("'set()' can only be used on observable objects, arrays and maps");
  }
}
function observe(thing, propOrCb, cbOrFire, fireImmediately) {
  if (typeof cbOrFire === "function")
    return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
  else
    return observeObservable(thing, propOrCb, cbOrFire);
}
function observeObservable(thing, listener, fireImmediately) {
  return getAdministration(thing).observe(listener, fireImmediately);
}
function observeObservableProperty(thing, property, listener, fireImmediately) {
  return getAdministration(thing, property).observe(listener, fireImmediately);
}
var defaultOptions = {
  detectCycles: true,
  exportMapsAsObjects: true,
  recurseEverything: false
};
function cache(map, key, value, options) {
  if (options.detectCycles)
    map.set(key, value);
  return value;
}
function toJSHelper(source, options, __alreadySeen) {
  if (!options.recurseEverything && !isObservable(source))
    return source;
  if (typeof source !== "object")
    return source;
  if (source === null)
    return null;
  if (source instanceof Date)
    return source;
  if (isObservableValue(source))
    return toJSHelper(source.get(), options, __alreadySeen);
  if (isObservable(source))
    keys(source);
  var detectCycles = options.detectCycles === true;
  if (detectCycles && source !== null && __alreadySeen.has(source)) {
    return __alreadySeen.get(source);
  }
  if (isObservableArray(source) || Array.isArray(source)) {
    var res_1 = cache(__alreadySeen, source, [], options);
    var toAdd = source.map(function(value) {
      return toJSHelper(value, options, __alreadySeen);
    });
    res_1.length = toAdd.length;
    for (var i4 = 0, l3 = toAdd.length; i4 < l3; i4++)
      res_1[i4] = toAdd[i4];
    return res_1;
  }
  if (isObservableSet(source) || Object.getPrototypeOf(source) === Set.prototype) {
    if (options.exportMapsAsObjects === false) {
      var res_2 = cache(__alreadySeen, source, /* @__PURE__ */ new Set(), options);
      source.forEach(function(value) {
        res_2.add(toJSHelper(value, options, __alreadySeen));
      });
      return res_2;
    } else {
      var res_3 = cache(__alreadySeen, source, [], options);
      source.forEach(function(value) {
        res_3.push(toJSHelper(value, options, __alreadySeen));
      });
      return res_3;
    }
  }
  if (isObservableMap(source) || Object.getPrototypeOf(source) === Map.prototype) {
    if (options.exportMapsAsObjects === false) {
      var res_4 = cache(__alreadySeen, source, /* @__PURE__ */ new Map(), options);
      source.forEach(function(value, key) {
        res_4.set(key, toJSHelper(value, options, __alreadySeen));
      });
      return res_4;
    } else {
      var res_5 = cache(__alreadySeen, source, {}, options);
      source.forEach(function(value, key) {
        res_5[key] = toJSHelper(value, options, __alreadySeen);
      });
      return res_5;
    }
  }
  var res = cache(__alreadySeen, source, {}, options);
  getPlainObjectKeys(source).forEach(function(key) {
    res[key] = toJSHelper(source[key], options, __alreadySeen);
  });
  return res;
}
function toJS(source, options) {
  if (typeof options === "boolean")
    options = { detectCycles: options };
  if (!options)
    options = defaultOptions;
  options.detectCycles = options.detectCycles === void 0 ? options.recurseEverything === true : options.detectCycles === true;
  var __alreadySeen;
  if (options.detectCycles)
    __alreadySeen = /* @__PURE__ */ new Map();
  return toJSHelper(source, options, __alreadySeen);
}
function trace() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var enterBreakPoint = false;
  if (typeof args[args.length - 1] === "boolean")
    enterBreakPoint = args.pop();
  var derivation = getAtomFromArgs(args);
  if (!derivation) {
    return fail2("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
  }
  if (derivation.isTracing === TraceMode.NONE) {
    console.log("[mobx.trace] '" + derivation.name + "' tracing enabled");
  }
  derivation.isTracing = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}
function getAtomFromArgs(args) {
  switch (args.length) {
    case 0:
      return globalState.trackingDerivation;
    case 1:
      return getAtom(args[0]);
    case 2:
      return getAtom(args[0], args[1]);
  }
}
function transaction(action3, thisArg) {
  if (thisArg === void 0) {
    thisArg = void 0;
  }
  startBatch();
  try {
    return action3.apply(thisArg);
  } finally {
    endBatch();
  }
}
function getAdm(target) {
  return target[$mobx];
}
function isPropertyKey(val) {
  return typeof val === "string" || typeof val === "number" || typeof val === "symbol";
}
var objectProxyTraps = {
  has: function(target, name) {
    if (name === $mobx || name === "constructor" || name === mobxDidRunLazyInitializersSymbol)
      return true;
    var adm = getAdm(target);
    if (isPropertyKey(name))
      return adm.has(name);
    return name in target;
  },
  get: function(target, name) {
    if (name === $mobx || name === "constructor" || name === mobxDidRunLazyInitializersSymbol)
      return target[name];
    var adm = getAdm(target);
    var observable2 = adm.values.get(name);
    if (observable2 instanceof Atom) {
      var result = observable2.get();
      if (result === void 0) {
        adm.has(name);
      }
      return result;
    }
    if (isPropertyKey(name))
      adm.has(name);
    return target[name];
  },
  set: function(target, name, value) {
    if (!isPropertyKey(name))
      return false;
    set(target, name, value);
    return true;
  },
  deleteProperty: function(target, name) {
    if (!isPropertyKey(name))
      return false;
    var adm = getAdm(target);
    adm.remove(name);
    return true;
  },
  ownKeys: function(target) {
    var adm = getAdm(target);
    adm.keysAtom.reportObserved();
    return Reflect.ownKeys(target);
  },
  preventExtensions: function(target) {
    fail2("Dynamic observable objects cannot be frozen");
    return false;
  }
};
function createDynamicObservableObject(base) {
  var proxy = new Proxy(base, objectProxyTraps);
  base[$mobx].proxy = proxy;
  return proxy;
}
function hasInterceptors(interceptable) {
  return interceptable.interceptors !== void 0 && interceptable.interceptors.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors || (interceptable.interceptors = []);
  interceptors.push(handler);
  return once(function() {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1)
      interceptors.splice(idx, 1);
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();
  try {
    var interceptors = __spread(interceptable.interceptors || []);
    for (var i4 = 0, l3 = interceptors.length; i4 < l3; i4++) {
      change = interceptors[i4](change);
      invariant(!change || change.type, "Intercept handlers should return nothing or a change object");
      if (!change)
        break;
    }
    return change;
  } finally {
    untrackedEnd(prevU);
  }
}
function hasListeners(listenable) {
  return listenable.changeListeners !== void 0 && listenable.changeListeners.length > 0;
}
function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners || (listenable.changeListeners = []);
  listeners.push(handler);
  return once(function() {
    var idx = listeners.indexOf(handler);
    if (idx !== -1)
      listeners.splice(idx, 1);
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners;
  if (!listeners)
    return;
  listeners = listeners.slice();
  for (var i4 = 0, l3 = listeners.length; i4 < l3; i4++) {
    listeners[i4](change);
  }
  untrackedEnd(prevU);
}
var MAX_SPLICE_SIZE = 1e4;
var arrayTraps = {
  get: function(target, name) {
    if (name === $mobx)
      return target[$mobx];
    if (name === "length")
      return target[$mobx].getArrayLength();
    if (typeof name === "number") {
      return arrayExtensions.get.call(target, name);
    }
    if (typeof name === "string" && !isNaN(name)) {
      return arrayExtensions.get.call(target, parseInt(name));
    }
    if (arrayExtensions.hasOwnProperty(name)) {
      return arrayExtensions[name];
    }
    return target[name];
  },
  set: function(target, name, value) {
    if (name === "length") {
      target[$mobx].setArrayLength(value);
    }
    if (typeof name === "number") {
      arrayExtensions.set.call(target, name, value);
    }
    if (typeof name === "symbol" || isNaN(name)) {
      target[name] = value;
    } else {
      arrayExtensions.set.call(target, parseInt(name), value);
    }
    return true;
  },
  preventExtensions: function(target) {
    fail2("Observable arrays cannot be frozen");
    return false;
  }
};
function createObservableArray(initialValues, enhancer, name, owned) {
  if (name === void 0) {
    name = "ObservableArray@" + getNextId();
  }
  if (owned === void 0) {
    owned = false;
  }
  var adm = new ObservableArrayAdministration(name, enhancer, owned);
  addHiddenFinalProp(adm.values, $mobx, adm);
  var proxy = new Proxy(adm.values, arrayTraps);
  adm.proxy = proxy;
  if (initialValues && initialValues.length) {
    var prev = allowStateChangesStart(true);
    adm.spliceWithArray(0, 0, initialValues);
    allowStateChangesEnd(prev);
  }
  return proxy;
}
var ObservableArrayAdministration = (
  /** @class */
  function() {
    function ObservableArrayAdministration2(name, enhancer, owned) {
      this.owned = owned;
      this.values = [];
      this.proxy = void 0;
      this.lastKnownLength = 0;
      this.atom = new Atom(name || "ObservableArray@" + getNextId());
      this.enhancer = function(newV, oldV) {
        return enhancer(newV, oldV, name + "[..]");
      };
    }
    ObservableArrayAdministration2.prototype.dehanceValue = function(value) {
      if (this.dehancer !== void 0)
        return this.dehancer(value);
      return value;
    };
    ObservableArrayAdministration2.prototype.dehanceValues = function(values2) {
      if (this.dehancer !== void 0 && values2.length > 0)
        return values2.map(this.dehancer);
      return values2;
    };
    ObservableArrayAdministration2.prototype.intercept = function(handler) {
      return registerInterceptor(this, handler);
    };
    ObservableArrayAdministration2.prototype.observe = function(listener, fireImmediately) {
      if (fireImmediately === void 0) {
        fireImmediately = false;
      }
      if (fireImmediately) {
        listener({
          object: this.proxy,
          type: "splice",
          index: 0,
          added: this.values.slice(),
          addedCount: this.values.length,
          removed: [],
          removedCount: 0
        });
      }
      return registerListener(this, listener);
    };
    ObservableArrayAdministration2.prototype.getArrayLength = function() {
      this.atom.reportObserved();
      return this.values.length;
    };
    ObservableArrayAdministration2.prototype.setArrayLength = function(newLength) {
      if (typeof newLength !== "number" || newLength < 0)
        throw new Error("[mobx.array] Out of range: " + newLength);
      var currentLength = this.values.length;
      if (newLength === currentLength)
        return;
      else if (newLength > currentLength) {
        var newItems = new Array(newLength - currentLength);
        for (var i4 = 0; i4 < newLength - currentLength; i4++)
          newItems[i4] = void 0;
        this.spliceWithArray(currentLength, 0, newItems);
      } else
        this.spliceWithArray(newLength, currentLength - newLength);
    };
    ObservableArrayAdministration2.prototype.updateArrayLength = function(oldLength, delta) {
      if (oldLength !== this.lastKnownLength)
        throw new Error("[mobx] Modification exception: the internal structure of an observable array was changed.");
      this.lastKnownLength += delta;
    };
    ObservableArrayAdministration2.prototype.spliceWithArray = function(index, deleteCount, newItems) {
      var _this = this;
      checkIfStateModificationsAreAllowed(this.atom);
      var length = this.values.length;
      if (index === void 0)
        index = 0;
      else if (index > length)
        index = length;
      else if (index < 0)
        index = Math.max(0, length + index);
      if (arguments.length === 1)
        deleteCount = length - index;
      else if (deleteCount === void 0 || deleteCount === null)
        deleteCount = 0;
      else
        deleteCount = Math.max(0, Math.min(deleteCount, length - index));
      if (newItems === void 0)
        newItems = EMPTY_ARRAY;
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy,
          type: "splice",
          index,
          removedCount: deleteCount,
          added: newItems
        });
        if (!change)
          return EMPTY_ARRAY;
        deleteCount = change.removedCount;
        newItems = change.added;
      }
      newItems = newItems.length === 0 ? newItems : newItems.map(function(v6) {
        return _this.enhancer(v6, void 0);
      });
      if (true) {
        var lengthDelta = newItems.length - deleteCount;
        this.updateArrayLength(length, lengthDelta);
      }
      var res = this.spliceItemsIntoValues(index, deleteCount, newItems);
      if (deleteCount !== 0 || newItems.length !== 0)
        this.notifyArraySplice(index, newItems, res);
      return this.dehanceValues(res);
    };
    ObservableArrayAdministration2.prototype.spliceItemsIntoValues = function(index, deleteCount, newItems) {
      var _a2;
      if (newItems.length < MAX_SPLICE_SIZE) {
        return (_a2 = this.values).splice.apply(_a2, __spread([index, deleteCount], newItems));
      } else {
        var res = this.values.slice(index, index + deleteCount);
        this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount));
        return res;
      }
    };
    ObservableArrayAdministration2.prototype.notifyArrayChildUpdate = function(index, newValue, oldValue) {
      var notifySpy = !this.owned && isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        object: this.proxy,
        type: "update",
        index,
        newValue,
        oldValue
      } : null;
      if (notifySpy && true)
        spyReportStart(__assign(__assign({}, change), { name: this.atom.name }));
      this.atom.reportChanged();
      if (notify)
        notifyListeners(this, change);
      if (notifySpy && true)
        spyReportEnd();
    };
    ObservableArrayAdministration2.prototype.notifyArraySplice = function(index, added, removed) {
      var notifySpy = !this.owned && isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        object: this.proxy,
        type: "splice",
        index,
        removed,
        added,
        removedCount: removed.length,
        addedCount: added.length
      } : null;
      if (notifySpy && true)
        spyReportStart(__assign(__assign({}, change), { name: this.atom.name }));
      this.atom.reportChanged();
      if (notify)
        notifyListeners(this, change);
      if (notifySpy && true)
        spyReportEnd();
    };
    return ObservableArrayAdministration2;
  }()
);
var arrayExtensions = {
  intercept: function(handler) {
    return this[$mobx].intercept(handler);
  },
  observe: function(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }
    var adm = this[$mobx];
    return adm.observe(listener, fireImmediately);
  },
  clear: function() {
    return this.splice(0);
  },
  replace: function(newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray(0, adm.values.length, newItems);
  },
  /**
   * Converts this array back to a (shallow) javascript structure.
   * For a deep clone use mobx.toJS
   */
  toJS: function() {
    return this.slice();
  },
  toJSON: function() {
    return this.toJS();
  },
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function(index, deleteCount) {
    var newItems = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      newItems[_i - 2] = arguments[_i];
    }
    var adm = this[$mobx];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return adm.spliceWithArray(index);
      case 2:
        return adm.spliceWithArray(index, deleteCount);
    }
    return adm.spliceWithArray(index, deleteCount, newItems);
  },
  spliceWithArray: function(index, deleteCount, newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray(index, deleteCount, newItems);
  },
  push: function() {
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }
    var adm = this[$mobx];
    adm.spliceWithArray(adm.values.length, 0, items);
    return adm.values.length;
  },
  pop: function() {
    return this.splice(Math.max(this[$mobx].values.length - 1, 0), 1)[0];
  },
  shift: function() {
    return this.splice(0, 1)[0];
  },
  unshift: function() {
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }
    var adm = this[$mobx];
    adm.spliceWithArray(0, 0, items);
    return adm.values.length;
  },
  reverse: function() {
    if (true) {
      console.warn("[mobx] `observableArray.reverse()` will not update the array in place. Use `observableArray.slice().reverse()` to suppress this warning and perform the operation on a copy, or `observableArray.replace(observableArray.slice().reverse())` to reverse & update in place");
    }
    var clone = this.slice();
    return clone.reverse.apply(clone, arguments);
  },
  sort: function(compareFn) {
    if (true) {
      console.warn("[mobx] `observableArray.sort()` will not update the array in place. Use `observableArray.slice().sort()` to suppress this warning and perform the operation on a copy, or `observableArray.replace(observableArray.slice().sort())` to sort & update in place");
    }
    var clone = this.slice();
    return clone.sort.apply(clone, arguments);
  },
  remove: function(value) {
    var adm = this[$mobx];
    var idx = adm.dehanceValues(adm.values).indexOf(value);
    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }
    return false;
  },
  get: function(index) {
    var adm = this[$mobx];
    if (adm) {
      if (index < adm.values.length) {
        adm.atom.reportObserved();
        return adm.dehanceValue(adm.values[index]);
      }
      console.warn("[mobx.array] Attempt to read an array index (" + index + ") that is out of bounds (" + adm.values.length + "). Please check length first. Out of bound indices will not be tracked by MobX");
    }
    return void 0;
  },
  set: function(index, newValue) {
    var adm = this[$mobx];
    var values2 = adm.values;
    if (index < values2.length) {
      checkIfStateModificationsAreAllowed(adm.atom);
      var oldValue = values2[index];
      if (hasInterceptors(adm)) {
        var change = interceptChange(adm, {
          type: "update",
          object: adm.proxy,
          index,
          newValue
        });
        if (!change)
          return;
        newValue = change.newValue;
      }
      newValue = adm.enhancer(newValue, oldValue);
      var changed = newValue !== oldValue;
      if (changed) {
        values2[index] = newValue;
        adm.notifyArrayChildUpdate(index, newValue, oldValue);
      }
    } else if (index === values2.length) {
      adm.spliceWithArray(index, 0, [newValue]);
    } else {
      throw new Error("[mobx.array] Index out of bounds, " + index + " is larger than " + values2.length);
    }
  }
};
[
  "concat",
  "flat",
  "includes",
  "indexOf",
  "join",
  "lastIndexOf",
  "slice",
  "toString",
  "toLocaleString"
].forEach(function(funcName) {
  if (typeof Array.prototype[funcName] !== "function") {
    return;
  }
  arrayExtensions[funcName] = function() {
    var adm = this[$mobx];
    adm.atom.reportObserved();
    var dehancedValues = adm.dehanceValues(adm.values);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
});
["every", "filter", "find", "findIndex", "flatMap", "forEach", "map", "some"].forEach(function(funcName) {
  if (typeof Array.prototype[funcName] !== "function") {
    return;
  }
  arrayExtensions[funcName] = function(callback, thisArg) {
    var _this = this;
    var adm = this[$mobx];
    adm.atom.reportObserved();
    var dehancedValues = adm.dehanceValues(adm.values);
    return dehancedValues[funcName](function(element, index) {
      return callback.call(thisArg, element, index, _this);
    }, thisArg);
  };
});
["reduce", "reduceRight"].forEach(function(funcName) {
  arrayExtensions[funcName] = function() {
    var _this = this;
    var adm = this[$mobx];
    adm.atom.reportObserved();
    var callback = arguments[0];
    arguments[0] = function(accumulator, currentValue, index) {
      currentValue = adm.dehanceValue(currentValue);
      return callback(accumulator, currentValue, index, _this);
    };
    return adm.values[funcName].apply(adm.values, arguments);
  };
});
var isObservableArrayAdministration = createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
  return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
}
var _a;
var ObservableMapMarker = {};
var ObservableMap = (
  /** @class */
  function() {
    function ObservableMap2(initialData, enhancer, name) {
      if (enhancer === void 0) {
        enhancer = deepEnhancer;
      }
      if (name === void 0) {
        name = "ObservableMap@" + getNextId();
      }
      this.enhancer = enhancer;
      this.name = name;
      this[_a] = ObservableMapMarker;
      this._keysAtom = createAtom(this.name + ".keys()");
      this[Symbol.toStringTag] = "Map";
      if (typeof Map !== "function") {
        throw new Error("mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js");
      }
      this._data = /* @__PURE__ */ new Map();
      this._hasMap = /* @__PURE__ */ new Map();
      this.merge(initialData);
    }
    ObservableMap2.prototype._has = function(key) {
      return this._data.has(key);
    };
    ObservableMap2.prototype.has = function(key) {
      var _this = this;
      if (!globalState.trackingDerivation)
        return this._has(key);
      var entry = this._hasMap.get(key);
      if (!entry) {
        var newEntry = entry = new ObservableValue(this._has(key), referenceEnhancer, this.name + "." + stringifyKey(key) + "?", false);
        this._hasMap.set(key, newEntry);
        onBecomeUnobserved(newEntry, function() {
          return _this._hasMap.delete(key);
        });
      }
      return entry.get();
    };
    ObservableMap2.prototype.set = function(key, value) {
      var hasKey = this._has(key);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: hasKey ? "update" : "add",
          object: this,
          newValue: value,
          name: key
        });
        if (!change)
          return this;
        value = change.newValue;
      }
      if (hasKey) {
        this._updateValue(key, value);
      } else {
        this._addValue(key, value);
      }
      return this;
    };
    ObservableMap2.prototype.delete = function(key) {
      var _this = this;
      checkIfStateModificationsAreAllowed(this._keysAtom);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: "delete",
          object: this,
          name: key
        });
        if (!change)
          return false;
      }
      if (this._has(key)) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy ? {
          type: "delete",
          object: this,
          oldValue: this._data.get(key).value,
          name: key
        } : null;
        if (notifySpy && true)
          spyReportStart(__assign(__assign({}, change), { name: this.name, key }));
        transaction(function() {
          _this._keysAtom.reportChanged();
          _this._updateHasMapEntry(key, false);
          var observable2 = _this._data.get(key);
          observable2.setNewValue(void 0);
          _this._data.delete(key);
        });
        if (notify)
          notifyListeners(this, change);
        if (notifySpy && true)
          spyReportEnd();
        return true;
      }
      return false;
    };
    ObservableMap2.prototype._updateHasMapEntry = function(key, value) {
      var entry = this._hasMap.get(key);
      if (entry) {
        entry.setNewValue(value);
      }
    };
    ObservableMap2.prototype._updateValue = function(key, newValue) {
      var observable2 = this._data.get(key);
      newValue = observable2.prepareNewValue(newValue);
      if (newValue !== globalState.UNCHANGED) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy ? {
          type: "update",
          object: this,
          oldValue: observable2.value,
          name: key,
          newValue
        } : null;
        if (notifySpy && true)
          spyReportStart(__assign(__assign({}, change), { name: this.name, key }));
        observable2.setNewValue(newValue);
        if (notify)
          notifyListeners(this, change);
        if (notifySpy && true)
          spyReportEnd();
      }
    };
    ObservableMap2.prototype._addValue = function(key, newValue) {
      var _this = this;
      checkIfStateModificationsAreAllowed(this._keysAtom);
      transaction(function() {
        var observable2 = new ObservableValue(newValue, _this.enhancer, _this.name + "." + stringifyKey(key), false);
        _this._data.set(key, observable2);
        newValue = observable2.value;
        _this._updateHasMapEntry(key, true);
        _this._keysAtom.reportChanged();
      });
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        type: "add",
        object: this,
        name: key,
        newValue
      } : null;
      if (notifySpy && true)
        spyReportStart(__assign(__assign({}, change), { name: this.name, key }));
      if (notify)
        notifyListeners(this, change);
      if (notifySpy && true)
        spyReportEnd();
    };
    ObservableMap2.prototype.get = function(key) {
      if (this.has(key))
        return this.dehanceValue(this._data.get(key).get());
      return this.dehanceValue(void 0);
    };
    ObservableMap2.prototype.dehanceValue = function(value) {
      if (this.dehancer !== void 0) {
        return this.dehancer(value);
      }
      return value;
    };
    ObservableMap2.prototype.keys = function() {
      this._keysAtom.reportObserved();
      return this._data.keys();
    };
    ObservableMap2.prototype.values = function() {
      var self2 = this;
      var keys2 = this.keys();
      return makeIterable({
        next: function() {
          var _b = keys2.next(), done = _b.done, value = _b.value;
          return {
            done,
            value: done ? void 0 : self2.get(value)
          };
        }
      });
    };
    ObservableMap2.prototype.entries = function() {
      var self2 = this;
      var keys2 = this.keys();
      return makeIterable({
        next: function() {
          var _b = keys2.next(), done = _b.done, value = _b.value;
          return {
            done,
            value: done ? void 0 : [value, self2.get(value)]
          };
        }
      });
    };
    ObservableMap2.prototype[_a = $mobx, Symbol.iterator] = function() {
      return this.entries();
    };
    ObservableMap2.prototype.forEach = function(callback, thisArg) {
      var e_1, _b;
      try {
        for (var _c = __values(this), _d = _c.next(); !_d.done; _d = _c.next()) {
          var _e = __read(_d.value, 2), key = _e[0], value = _e[1];
          callback.call(thisArg, value, key, this);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    };
    ObservableMap2.prototype.merge = function(other) {
      var _this = this;
      if (isObservableMap(other)) {
        other = other.toJS();
      }
      transaction(function() {
        var prev = allowStateChangesStart(true);
        try {
          if (isPlainObject(other))
            getPlainObjectKeys(other).forEach(function(key) {
              return _this.set(key, other[key]);
            });
          else if (Array.isArray(other))
            other.forEach(function(_b) {
              var _c = __read(_b, 2), key = _c[0], value = _c[1];
              return _this.set(key, value);
            });
          else if (isES6Map(other)) {
            if (other.constructor !== Map)
              fail2("Cannot initialize from classes that inherit from Map: " + other.constructor.name);
            other.forEach(function(value, key) {
              return _this.set(key, value);
            });
          } else if (other !== null && other !== void 0)
            fail2("Cannot initialize map from " + other);
        } finally {
          allowStateChangesEnd(prev);
        }
      });
      return this;
    };
    ObservableMap2.prototype.clear = function() {
      var _this = this;
      transaction(function() {
        untracked(function() {
          var e_2, _b;
          try {
            for (var _c = __values(_this.keys()), _d = _c.next(); !_d.done; _d = _c.next()) {
              var key = _d.value;
              _this.delete(key);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        });
      });
    };
    ObservableMap2.prototype.replace = function(values2) {
      var _this = this;
      transaction(function() {
        var e_3, _b, e_4, _c;
        var replacementMap = convertToMap(values2);
        var orderedData = /* @__PURE__ */ new Map();
        var keysReportChangedCalled = false;
        try {
          for (var _d = __values(_this._data.keys()), _e = _d.next(); !_e.done; _e = _d.next()) {
            var key = _e.value;
            if (!replacementMap.has(key)) {
              var deleted = _this.delete(key);
              if (deleted) {
                keysReportChangedCalled = true;
              } else {
                var value = _this._data.get(key);
                orderedData.set(key, value);
              }
            }
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
        try {
          for (var _f = __values(replacementMap.entries()), _g = _f.next(); !_g.done; _g = _f.next()) {
            var _h = __read(_g.value, 2), key = _h[0], value = _h[1];
            var keyExisted = _this._data.has(key);
            _this.set(key, value);
            if (_this._data.has(key)) {
              var value_1 = _this._data.get(key);
              orderedData.set(key, value_1);
              if (!keyExisted) {
                keysReportChangedCalled = true;
              }
            }
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
          } finally {
            if (e_4) throw e_4.error;
          }
        }
        if (!keysReportChangedCalled) {
          if (_this._data.size !== orderedData.size) {
            _this._keysAtom.reportChanged();
          } else {
            var iter1 = _this._data.keys();
            var iter2 = orderedData.keys();
            var next1 = iter1.next();
            var next2 = iter2.next();
            while (!next1.done) {
              if (next1.value !== next2.value) {
                _this._keysAtom.reportChanged();
                break;
              }
              next1 = iter1.next();
              next2 = iter2.next();
            }
          }
        }
        _this._data = orderedData;
      });
      return this;
    };
    Object.defineProperty(ObservableMap2.prototype, "size", {
      get: function() {
        this._keysAtom.reportObserved();
        return this._data.size;
      },
      enumerable: true,
      configurable: true
    });
    ObservableMap2.prototype.toPOJO = function() {
      var e_5, _b;
      var res = {};
      try {
        for (var _c = __values(this), _d = _c.next(); !_d.done; _d = _c.next()) {
          var _e = __read(_d.value, 2), key = _e[0], value = _e[1];
          res[typeof key === "symbol" ? key : stringifyKey(key)] = value;
        }
      } catch (e_5_1) {
        e_5 = { error: e_5_1 };
      } finally {
        try {
          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        } finally {
          if (e_5) throw e_5.error;
        }
      }
      return res;
    };
    ObservableMap2.prototype.toJS = function() {
      return new Map(this);
    };
    ObservableMap2.prototype.toJSON = function() {
      return this.toPOJO();
    };
    ObservableMap2.prototype.toString = function() {
      var _this = this;
      return this.name + "[{ " + Array.from(this.keys()).map(function(key) {
        return stringifyKey(key) + ": " + ("" + _this.get(key));
      }).join(", ") + " }]";
    };
    ObservableMap2.prototype.observe = function(listener, fireImmediately) {
      invariant(fireImmediately !== true, "`observe` doesn't support fireImmediately=true in combination with maps.");
      return registerListener(this, listener);
    };
    ObservableMap2.prototype.intercept = function(handler) {
      return registerInterceptor(this, handler);
    };
    return ObservableMap2;
  }()
);
var isObservableMap = createInstanceofPredicate("ObservableMap", ObservableMap);
var _a$1;
var ObservableSetMarker = {};
var ObservableSet = (
  /** @class */
  function() {
    function ObservableSet2(initialData, enhancer, name) {
      if (enhancer === void 0) {
        enhancer = deepEnhancer;
      }
      if (name === void 0) {
        name = "ObservableSet@" + getNextId();
      }
      this.name = name;
      this[_a$1] = ObservableSetMarker;
      this._data = /* @__PURE__ */ new Set();
      this._atom = createAtom(this.name);
      this[Symbol.toStringTag] = "Set";
      if (typeof Set !== "function") {
        throw new Error("mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js");
      }
      this.enhancer = function(newV, oldV) {
        return enhancer(newV, oldV, name);
      };
      if (initialData) {
        this.replace(initialData);
      }
    }
    ObservableSet2.prototype.dehanceValue = function(value) {
      if (this.dehancer !== void 0) {
        return this.dehancer(value);
      }
      return value;
    };
    ObservableSet2.prototype.clear = function() {
      var _this = this;
      transaction(function() {
        untracked(function() {
          var e_1, _b;
          try {
            for (var _c = __values(_this._data.values()), _d = _c.next(); !_d.done; _d = _c.next()) {
              var value = _d.value;
              _this.delete(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        });
      });
    };
    ObservableSet2.prototype.forEach = function(callbackFn, thisArg) {
      var e_2, _b;
      try {
        for (var _c = __values(this), _d = _c.next(); !_d.done; _d = _c.next()) {
          var value = _d.value;
          callbackFn.call(thisArg, value, value, this);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
    };
    Object.defineProperty(ObservableSet2.prototype, "size", {
      get: function() {
        this._atom.reportObserved();
        return this._data.size;
      },
      enumerable: true,
      configurable: true
    });
    ObservableSet2.prototype.add = function(value) {
      var _this = this;
      checkIfStateModificationsAreAllowed(this._atom);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: "add",
          object: this,
          newValue: value
        });
        if (!change)
          return this;
      }
      if (!this.has(value)) {
        transaction(function() {
          _this._data.add(_this.enhancer(value, void 0));
          _this._atom.reportChanged();
        });
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy ? {
          type: "add",
          object: this,
          newValue: value
        } : null;
        if (notifySpy && true)
          spyReportStart(change);
        if (notify)
          notifyListeners(this, change);
        if (notifySpy && true)
          spyReportEnd();
      }
      return this;
    };
    ObservableSet2.prototype.delete = function(value) {
      var _this = this;
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: "delete",
          object: this,
          oldValue: value
        });
        if (!change)
          return false;
      }
      if (this.has(value)) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy ? {
          type: "delete",
          object: this,
          oldValue: value
        } : null;
        if (notifySpy && true)
          spyReportStart(__assign(__assign({}, change), { name: this.name }));
        transaction(function() {
          _this._atom.reportChanged();
          _this._data.delete(value);
        });
        if (notify)
          notifyListeners(this, change);
        if (notifySpy && true)
          spyReportEnd();
        return true;
      }
      return false;
    };
    ObservableSet2.prototype.has = function(value) {
      this._atom.reportObserved();
      return this._data.has(this.dehanceValue(value));
    };
    ObservableSet2.prototype.entries = function() {
      var nextIndex = 0;
      var keys2 = Array.from(this.keys());
      var values2 = Array.from(this.values());
      return makeIterable({
        next: function() {
          var index = nextIndex;
          nextIndex += 1;
          return index < values2.length ? { value: [keys2[index], values2[index]], done: false } : { done: true };
        }
      });
    };
    ObservableSet2.prototype.keys = function() {
      return this.values();
    };
    ObservableSet2.prototype.values = function() {
      this._atom.reportObserved();
      var self2 = this;
      var nextIndex = 0;
      var observableValues = Array.from(this._data.values());
      return makeIterable({
        next: function() {
          return nextIndex < observableValues.length ? { value: self2.dehanceValue(observableValues[nextIndex++]), done: false } : { done: true };
        }
      });
    };
    ObservableSet2.prototype.replace = function(other) {
      var _this = this;
      if (isObservableSet(other)) {
        other = other.toJS();
      }
      transaction(function() {
        var prev = allowStateChangesStart(true);
        try {
          if (Array.isArray(other)) {
            _this.clear();
            other.forEach(function(value) {
              return _this.add(value);
            });
          } else if (isES6Set(other)) {
            _this.clear();
            other.forEach(function(value) {
              return _this.add(value);
            });
          } else if (other !== null && other !== void 0) {
            fail2("Cannot initialize set from " + other);
          }
        } finally {
          allowStateChangesEnd(prev);
        }
      });
      return this;
    };
    ObservableSet2.prototype.observe = function(listener, fireImmediately) {
      invariant(fireImmediately !== true, "`observe` doesn't support fireImmediately=true in combination with sets.");
      return registerListener(this, listener);
    };
    ObservableSet2.prototype.intercept = function(handler) {
      return registerInterceptor(this, handler);
    };
    ObservableSet2.prototype.toJS = function() {
      return new Set(this);
    };
    ObservableSet2.prototype.toString = function() {
      return this.name + "[ " + Array.from(this).join(", ") + " ]";
    };
    ObservableSet2.prototype[_a$1 = $mobx, Symbol.iterator] = function() {
      return this.values();
    };
    return ObservableSet2;
  }()
);
var isObservableSet = createInstanceofPredicate("ObservableSet", ObservableSet);
var ObservableObjectAdministration = (
  /** @class */
  function() {
    function ObservableObjectAdministration2(target, values2, name, defaultEnhancer) {
      if (values2 === void 0) {
        values2 = /* @__PURE__ */ new Map();
      }
      this.target = target;
      this.values = values2;
      this.name = name;
      this.defaultEnhancer = defaultEnhancer;
      this.keysAtom = new Atom(name + ".keys");
    }
    ObservableObjectAdministration2.prototype.read = function(key) {
      return this.values.get(key).get();
    };
    ObservableObjectAdministration2.prototype.write = function(key, newValue) {
      var instance = this.target;
      var observable2 = this.values.get(key);
      if (observable2 instanceof ComputedValue) {
        observable2.set(newValue);
        return;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: "update",
          object: this.proxy || instance,
          name: key,
          newValue
        });
        if (!change)
          return;
        newValue = change.newValue;
      }
      newValue = observable2.prepareNewValue(newValue);
      if (newValue !== globalState.UNCHANGED) {
        var notify = hasListeners(this);
        var notifySpy = isSpyEnabled();
        var change = notify || notifySpy ? {
          type: "update",
          object: this.proxy || instance,
          oldValue: observable2.value,
          name: key,
          newValue
        } : null;
        if (notifySpy && true)
          spyReportStart(__assign(__assign({}, change), { name: this.name, key }));
        observable2.setNewValue(newValue);
        if (notify)
          notifyListeners(this, change);
        if (notifySpy && true)
          spyReportEnd();
      }
    };
    ObservableObjectAdministration2.prototype.has = function(key) {
      var map = this.pendingKeys || (this.pendingKeys = /* @__PURE__ */ new Map());
      var entry = map.get(key);
      if (entry)
        return entry.get();
      else {
        var exists = !!this.values.get(key);
        entry = new ObservableValue(exists, referenceEnhancer, this.name + "." + stringifyKey(key) + "?", false);
        map.set(key, entry);
        return entry.get();
      }
    };
    ObservableObjectAdministration2.prototype.addObservableProp = function(propName, newValue, enhancer) {
      if (enhancer === void 0) {
        enhancer = this.defaultEnhancer;
      }
      var target = this.target;
      assertPropertyConfigurable(target, propName);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy || target,
          name: propName,
          type: "add",
          newValue
        });
        if (!change)
          return;
        newValue = change.newValue;
      }
      var observable2 = new ObservableValue(newValue, enhancer, this.name + "." + stringifyKey(propName), false);
      this.values.set(propName, observable2);
      newValue = observable2.value;
      Object.defineProperty(target, propName, generateObservablePropConfig(propName));
      this.notifyPropertyAddition(propName, newValue);
    };
    ObservableObjectAdministration2.prototype.addComputedProp = function(propertyOwner, propName, options) {
      var target = this.target;
      options.name = options.name || this.name + "." + stringifyKey(propName);
      this.values.set(propName, new ComputedValue(options));
      if (propertyOwner === target || isPropertyConfigurable(propertyOwner, propName))
        Object.defineProperty(propertyOwner, propName, generateComputedPropConfig(propName));
    };
    ObservableObjectAdministration2.prototype.remove = function(key) {
      if (!this.values.has(key))
        return;
      var target = this.target;
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy || target,
          name: key,
          type: "remove"
        });
        if (!change)
          return;
      }
      try {
        startBatch();
        var notify = hasListeners(this);
        var notifySpy = isSpyEnabled();
        var oldObservable = this.values.get(key);
        var oldValue = oldObservable && oldObservable.get();
        oldObservable && oldObservable.set(void 0);
        this.keysAtom.reportChanged();
        this.values.delete(key);
        if (this.pendingKeys) {
          var entry = this.pendingKeys.get(key);
          if (entry)
            entry.set(false);
        }
        delete this.target[key];
        var change = notify || notifySpy ? {
          type: "remove",
          object: this.proxy || target,
          oldValue,
          name: key
        } : null;
        if (notifySpy && true)
          spyReportStart(__assign(__assign({}, change), { name: this.name, key }));
        if (notify)
          notifyListeners(this, change);
        if (notifySpy && true)
          spyReportEnd();
      } finally {
        endBatch();
      }
    };
    ObservableObjectAdministration2.prototype.illegalAccess = function(owner, propName) {
      console.warn("Property '" + propName + "' of '" + owner + "' was accessed through the prototype chain. Use 'decorate' instead to declare the prop or access it statically through it's owner");
    };
    ObservableObjectAdministration2.prototype.observe = function(callback, fireImmediately) {
      invariant(fireImmediately !== true, "`observe` doesn't support the fire immediately property for observable objects.");
      return registerListener(this, callback);
    };
    ObservableObjectAdministration2.prototype.intercept = function(handler) {
      return registerInterceptor(this, handler);
    };
    ObservableObjectAdministration2.prototype.notifyPropertyAddition = function(key, newValue) {
      var notify = hasListeners(this);
      var notifySpy = isSpyEnabled();
      var change = notify || notifySpy ? {
        type: "add",
        object: this.proxy || this.target,
        name: key,
        newValue
      } : null;
      if (notifySpy && true)
        spyReportStart(__assign(__assign({}, change), { name: this.name, key }));
      if (notify)
        notifyListeners(this, change);
      if (notifySpy && true)
        spyReportEnd();
      if (this.pendingKeys) {
        var entry = this.pendingKeys.get(key);
        if (entry)
          entry.set(true);
      }
      this.keysAtom.reportChanged();
    };
    ObservableObjectAdministration2.prototype.getKeys = function() {
      var e_1, _a2;
      this.keysAtom.reportObserved();
      var res = [];
      try {
        for (var _b = __values(this.values), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
          if (value instanceof ObservableValue)
            res.push(key);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return res;
    };
    return ObservableObjectAdministration2;
  }()
);
function asObservableObject(target, name, defaultEnhancer) {
  if (name === void 0) {
    name = "";
  }
  if (defaultEnhancer === void 0) {
    defaultEnhancer = deepEnhancer;
  }
  if (Object.prototype.hasOwnProperty.call(target, $mobx))
    return target[$mobx];
  invariant(Object.isExtensible(target), "Cannot make the designated object observable; it is not extensible");
  if (!isPlainObject(target))
    name = (target.constructor.name || "ObservableObject") + "@" + getNextId();
  if (!name)
    name = "ObservableObject@" + getNextId();
  var adm = new ObservableObjectAdministration(target, /* @__PURE__ */ new Map(), stringifyKey(name), defaultEnhancer);
  addHiddenProp(target, $mobx, adm);
  return adm;
}
var observablePropertyConfigs = /* @__PURE__ */ Object.create(null);
var computedPropertyConfigs = /* @__PURE__ */ Object.create(null);
function generateObservablePropConfig(propName) {
  return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = {
    configurable: true,
    enumerable: true,
    get: function() {
      return this[$mobx].read(propName);
    },
    set: function(v6) {
      this[$mobx].write(propName, v6);
    }
  });
}
function getAdministrationForComputedPropOwner(owner) {
  var adm = owner[$mobx];
  if (!adm) {
    initializeInstance(owner);
    return owner[$mobx];
  }
  return adm;
}
function generateComputedPropConfig(propName) {
  return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = {
    configurable: globalState.computedConfigurable,
    enumerable: false,
    get: function() {
      return getAdministrationForComputedPropOwner(this).read(propName);
    },
    set: function(v6) {
      getAdministrationForComputedPropOwner(this).write(propName, v6);
    }
  });
}
var isObservableObjectAdministration = createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function isObservableObject(thing) {
  if (isObject(thing)) {
    initializeInstance(thing);
    return isObservableObjectAdministration(thing[$mobx]);
  }
  return false;
}
function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== void 0)
        fail2("It is not possible to get index atoms from arrays");
      return thing[$mobx].atom;
    }
    if (isObservableSet(thing)) {
      return thing[$mobx];
    }
    if (isObservableMap(thing)) {
      var anyThing = thing;
      if (property === void 0)
        return anyThing._keysAtom;
      var observable2 = anyThing._data.get(property) || anyThing._hasMap.get(property);
      if (!observable2)
        fail2("the entry '" + property + "' does not exist in the observable map '" + getDebugName(thing) + "'");
      return observable2;
    }
    initializeInstance(thing);
    if (property && !thing[$mobx])
      thing[property];
    if (isObservableObject(thing)) {
      if (!property)
        return fail2("please specify a property");
      var observable2 = thing[$mobx].values.get(property);
      if (!observable2)
        fail2("no observable property '" + property + "' found on the observable object '" + getDebugName(thing) + "'");
      return observable2;
    }
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (typeof thing === "function") {
    if (isReaction(thing[$mobx])) {
      return thing[$mobx];
    }
  }
  return fail2("Cannot obtain atom from " + thing);
}
function getAdministration(thing, property) {
  if (!thing)
    fail2("Expecting some object");
  if (property !== void 0)
    return getAdministration(getAtom(thing, property));
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing))
    return thing;
  if (isObservableMap(thing) || isObservableSet(thing))
    return thing;
  initializeInstance(thing);
  if (thing[$mobx])
    return thing[$mobx];
  fail2("Cannot obtain administration from " + thing);
}
function getDebugName(thing, property) {
  var named;
  if (property !== void 0)
    named = getAtom(thing, property);
  else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing))
    named = getAdministration(thing);
  else
    named = getAtom(thing);
  return named.name;
}
var toString = Object.prototype.toString;
function deepEqual(a3, b2, depth) {
  if (depth === void 0) {
    depth = -1;
  }
  return eq(a3, b2, depth);
}
function eq(a3, b2, depth, aStack, bStack) {
  if (a3 === b2)
    return a3 !== 0 || 1 / a3 === 1 / b2;
  if (a3 == null || b2 == null)
    return false;
  if (a3 !== a3)
    return b2 !== b2;
  var type = typeof a3;
  if (type !== "function" && type !== "object" && typeof b2 != "object")
    return false;
  var className = toString.call(a3);
  if (className !== toString.call(b2))
    return false;
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a3 === "" + b2;
    case "[object Number]":
      if (+a3 !== +a3)
        return +b2 !== +b2;
      return +a3 === 0 ? 1 / +a3 === 1 / b2 : +a3 === +b2;
    case "[object Date]":
    case "[object Boolean]":
      return +a3 === +b2;
    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a3) === Symbol.valueOf.call(b2);
    case "[object Map]":
    case "[object Set]":
      if (depth >= 0) {
        depth++;
      }
      break;
  }
  a3 = unwrap(a3);
  b2 = unwrap(b2);
  var areArrays = className === "[object Array]";
  if (!areArrays) {
    if (typeof a3 != "object" || typeof b2 != "object")
      return false;
    var aCtor = a3.constructor, bCtor = b2.constructor;
    if (aCtor !== bCtor && !(typeof aCtor === "function" && aCtor instanceof aCtor && typeof bCtor === "function" && bCtor instanceof bCtor) && ("constructor" in a3 && "constructor" in b2)) {
      return false;
    }
  }
  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a3)
      return bStack[length] === b2;
  }
  aStack.push(a3);
  bStack.push(b2);
  if (areArrays) {
    length = a3.length;
    if (length !== b2.length)
      return false;
    while (length--) {
      if (!eq(a3[length], b2[length], depth - 1, aStack, bStack))
        return false;
    }
  } else {
    var keys2 = Object.keys(a3);
    var key = void 0;
    length = keys2.length;
    if (Object.keys(b2).length !== length)
      return false;
    while (length--) {
      key = keys2[length];
      if (!(has$1(b2, key) && eq(a3[key], b2[key], depth - 1, aStack, bStack)))
        return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function unwrap(a3) {
  if (isObservableArray(a3))
    return a3.slice();
  if (isES6Map(a3) || isObservableMap(a3))
    return Array.from(a3.entries());
  if (isES6Set(a3) || isObservableSet(a3))
    return Array.from(a3.entries());
  return a3;
}
function has$1(a3, key) {
  return Object.prototype.hasOwnProperty.call(a3, key);
}
function makeIterable(iterator) {
  iterator[Symbol.iterator] = getSelf;
  return iterator;
}
function getSelf() {
  return this;
}
if (typeof Proxy === "undefined" || typeof Symbol === "undefined") {
  throw new Error("[mobx] MobX 5+ requires Proxy and Symbol objects. If your environment doesn't support Symbol or Proxy objects, please downgrade to MobX 4. For React Native Android, consider upgrading JSCore.");
}
(function() {
  function testCodeMinification() {
  }
  if (testCodeMinification.name !== "testCodeMinification" && true && typeof process !== "undefined" && process.env.IGNORE_MOBX_MINIFY_WARNING !== "true") {
    var varName = ["process", "env", "NODE_ENV"].join(".");
    console.warn("[mobx] you are running a minified build, but '" + varName + "' was not set to 'production' in your bundler. This results in an unnecessarily large and slow bundle");
  }
})();
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy,
    extras: {
      getDebugName
    },
    $mobx
  });
}

// node_modules/mobx-preact/lib/index.module.js
function isStateless(component) {
  return !(component.prototype && component.prototype.render) && !x.isPrototypeOf(component);
}
function makeDisplayName(component) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$prefix = _ref.prefix, prefix = _ref$prefix === void 0 ? "" : _ref$prefix, _ref$suffix = _ref.suffix, suffix = _ref$suffix === void 0 ? "" : _ref$suffix;
  var displayName = component.displayName || component.name || component.constructor && component.constructor.name || "<component>";
  return prefix + displayName + suffix;
}
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = /* @__PURE__ */ function() {
  function defineProperties(target, props) {
    for (var i4 = 0; i4 < props.length; i4++) {
      var descriptor = props[i4];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var inherits = function(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};
var possibleConstructorReturn = function(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
};
var isUsingStaticRendering = false;
var logger = console;
function allowStateChangesStart2(allowStateChanges3) {
  var prev = getGlobalState().allowStateChanges;
  getGlobalState().allowStateChanges = allowStateChanges3;
  return prev;
}
function allowStateChangesEnd2(prev) {
  getGlobalState().allowStateChanges = prev;
}
function allowStateChanges(allowStateChanges3, func, props, state, context) {
  var prev = allowStateChangesStart2(allowStateChanges3);
  var res = void 0;
  try {
    res = func(props, state, context);
  } finally {
    allowStateChangesEnd2(prev);
  }
  return res;
}
function patch(target, funcName) {
  var runMixinFirst = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var base = target[funcName];
  var mixinFunc = reactiveMixin[funcName];
  var f5 = !base ? mixinFunc : runMixinFirst === true ? function() {
    mixinFunc.apply(this, arguments);
    base.apply(this, arguments);
  } : function() {
    base.apply(this, arguments);
    mixinFunc.apply(this, arguments);
  };
  target[funcName] = f5;
}
function isObjectShallowModified(prev, next) {
  if (null == prev || null == next || (typeof prev === "undefined" ? "undefined" : _typeof(prev)) !== "object" || (typeof next === "undefined" ? "undefined" : _typeof(next)) !== "object") {
    return prev !== next;
  }
  var keys2 = Object.keys(prev);
  if (keys2.length !== Object.keys(next).length) {
    return true;
  }
  var key = void 0;
  for (var i4 = keys2.length - 1; key = keys2[i4]; i4--) {
    if (next[key] !== prev[key]) {
      return true;
    }
  }
  return false;
}
var reactiveMixin = {
  componentWillMount: function componentWillMount() {
    var _this = this;
    if (isUsingStaticRendering === true) {
      return;
    }
    var initialName = makeDisplayName(this);
    var skipRender = false;
    var isForcingUpdate = false;
    function makePropertyObservableReference(propName) {
      var valueHolder = this[propName];
      var atom = createAtom("reactive " + propName);
      Object.defineProperty(this, propName, {
        configurable: true,
        enumerable: true,
        get: function get$$1() {
          atom.reportObserved();
          return valueHolder;
        },
        set: function set$$1(v6) {
          if (!isForcingUpdate && isObjectShallowModified(valueHolder, v6)) {
            valueHolder = v6;
            skipRender = true;
            atom.reportChanged();
            skipRender = false;
          } else {
            valueHolder = v6;
          }
        }
      });
    }
    makePropertyObservableReference.call(this, "props");
    makePropertyObservableReference.call(this, "state");
    var baseRender = this.render.bind(this);
    var reaction2 = null;
    var isRenderingPending = false;
    var initialRender = function initialRender2() {
      reaction2 = new Reaction(initialName + ".render()", function() {
        if (!isRenderingPending) {
          isRenderingPending = true;
          if (typeof _this.componentWillReact === "function") {
            _this.componentWillReact();
          }
          if (_this.__$mobxIsUnmounted !== true) {
            var hasError = true;
            try {
              isForcingUpdate = true;
              if (!skipRender) {
                x.prototype.forceUpdate.call(_this);
              }
              hasError = false;
            } finally {
              isForcingUpdate = false;
              if (hasError) {
                reaction2.dispose();
              }
            }
          }
        }
      });
      reaction2.reactComponent = _this;
      reactiveRender.$mobx = reaction2;
      _this.render = reactiveRender;
      return reactiveRender(_this.props, _this.state, _this.context);
    };
    var reactiveRender = function reactiveRender2(props, state, context) {
      isRenderingPending = false;
      var exception = void 0;
      var rendering = void 0;
      reaction2.track(function() {
        try {
          rendering = allowStateChanges(false, baseRender, props, state, context);
        } catch (e3) {
          exception = e3;
        }
      });
      if (exception) {
        throw exception;
      }
      return rendering;
    };
    this.render = initialRender;
  },
  componentWillUnmount: function componentWillUnmount() {
    if (isUsingStaticRendering === true) {
      return;
    }
    this.render.$mobx && this.render.$mobx.dispose();
    this.__$mobxIsUnmounted = true;
  },
  componentDidMount: function componentDidMount() {
  },
  componentDidUpdate: function componentDidUpdate() {
  },
  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
    if (isUsingStaticRendering) {
      logger.warn("[mobx-preact] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.");
    }
    if (this.state !== nextState) {
      return true;
    }
    return isObjectShallowModified(this.props, nextProps);
  }
};
function observer(componentClass) {
  if (arguments.length > 1) {
    logger.warn('Mobx observer: Using observer to inject stores is not supported. Use `@connect(["store1", "store2"]) ComponentClass instead or preferably, use `@inject("store1", "store2") @observer ComponentClass` or `inject("store1", "store2")(observer(componentClass))``');
  }
  if (componentClass.isMobxInjector === true) {
    logger.warn("Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'");
  }
  if (isStateless(componentClass)) {
    var _class, _temp;
    return observer((_temp = _class = function(_Component) {
      inherits(_class2, _Component);
      function _class2() {
        classCallCheck(this, _class2);
        return possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).apply(this, arguments));
      }
      createClass(_class2, [{
        key: "render",
        value: function render() {
          return componentClass.call(this, this.props, this.context);
        }
      }]);
      return _class2;
    }(x), _class.displayName = makeDisplayName(componentClass), _temp));
  }
  if (!componentClass) {
    throw new Error("Please pass a valid component to 'observer'");
  }
  var target = componentClass.prototype || componentClass;
  mixinLifecycleEvents(target);
  componentClass.isMobXReactObserver = true;
  return componentClass;
}
function mixinLifecycleEvents(target) {
  patch(target, "componentWillMount", true);
  patch(target, "componentDidMount");
  if (!target.shouldComponentUpdate) {
    target.shouldComponentUpdate = reactiveMixin.shouldComponentUpdate;
  }
}
var Observer = observer(function(_ref) {
  var children = _ref.children;
  return children[0]();
});
Observer.displayName = "Observer";
var commonjsGlobal = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function createCommonjsModule(fn2, module) {
  return module = { exports: {} }, fn2(module, module.exports), module.exports;
}
var hoistNonReactStatics = createCommonjsModule(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    var REACT_STATICS = {
      childContextTypes: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = getPrototypeOf && getPrototypeOf(Object);
    return function hoistNonReactStatics2(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics2(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys2 = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
        }
        for (var i4 = 0; i4 < keys2.length; ++i4) {
          var key = keys2[i4];
          if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e3) {
            }
          }
        }
        return targetComponent;
      }
      return targetComponent;
    };
  });
});
var specialReactKeys = { children: true, key: true, ref: true };
var logger$1 = console;
var Provider = function(_Component) {
  inherits(Provider2, _Component);
  function Provider2() {
    classCallCheck(this, Provider2);
    return possibleConstructorReturn(this, (Provider2.__proto__ || Object.getPrototypeOf(Provider2)).apply(this, arguments));
  }
  createClass(Provider2, [{
    key: "render",
    value: function render(_ref) {
      var children = _ref.children;
      return children.length > 1 ? g(
        "div",
        null,
        " ",
        children,
        " "
      ) : children[0];
    }
  }, {
    key: "getChildContext",
    value: function getChildContext() {
      var stores = {};
      var baseStores = this.context.mobxStores;
      if (baseStores) {
        for (var key in baseStores) {
          stores[key] = baseStores[key];
        }
      }
      for (var _key in this.props) {
        if (!specialReactKeys[_key] && _key !== "suppressChangedStoreWarning") {
          stores[_key] = this.props[_key];
        }
      }
      return {
        mobxStores: stores
      };
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      if (Object.keys(nextProps).length !== Object.keys(this.props).length) {
        logger$1.warn("MobX Provider: The set of provided stores has changed. Please avoid changing stores as the change might not propagate to all children");
      }
      if (!nextProps.suppressChangedStoreWarning) {
        for (var key in nextProps) {
          if (!specialReactKeys[key] && this.props[key] !== nextProps[key]) {
            logger$1.warn("MobX Provider: Provided store '" + key + "' has changed. Please avoid replacing stores as the change might not propagate to all children");
          }
        }
      }
    }
  }]);
  return Provider2;
}(x);
if (!x) {
  throw new Error("mobx-preact requires Preact to be available");
}

// node_modules/preact/hooks/dist/hooks.module.js
var t2;
var r2;
var u2;
var i2;
var f2 = [];
var c2 = l;
var e2 = c2.__b;
var a2 = c2.__r;
var v2 = c2.diffed;
var l2 = c2.__c;
var m2 = c2.unmount;
var s2 = c2.__;
function j2() {
  for (var n2; n2 = f2.shift(); ) if (n2.__P && n2.__H) try {
    n2.__H.__h.forEach(z2), n2.__H.__h.forEach(B2), n2.__H.__h = [];
  } catch (t3) {
    n2.__H.__h = [], c2.__e(t3, n2.__v);
  }
}
c2.__b = function(n2) {
  r2 = null, e2 && e2(n2);
}, c2.__ = function(n2, t3) {
  n2 && t3.__k && t3.__k.__m && (n2.__m = t3.__k.__m), s2 && s2(n2, t3);
}, c2.__r = function(n2) {
  a2 && a2(n2), t2 = 0;
  var i4 = (r2 = n2.__c).__H;
  i4 && (u2 === r2 ? (i4.__h = [], r2.__h = [], i4.__.forEach(function(n3) {
    n3.__N && (n3.__ = n3.__N), n3.i = n3.__N = void 0;
  })) : (i4.__h.forEach(z2), i4.__h.forEach(B2), i4.__h = [], t2 = 0)), u2 = r2;
}, c2.diffed = function(n2) {
  v2 && v2(n2);
  var t3 = n2.__c;
  t3 && t3.__H && (t3.__H.__h.length && (1 !== f2.push(t3) && i2 === c2.requestAnimationFrame || ((i2 = c2.requestAnimationFrame) || w2)(j2)), t3.__H.__.forEach(function(n3) {
    n3.i && (n3.__H = n3.i), n3.i = void 0;
  })), u2 = r2 = null;
}, c2.__c = function(n2, t3) {
  t3.some(function(n3) {
    try {
      n3.__h.forEach(z2), n3.__h = n3.__h.filter(function(n4) {
        return !n4.__ || B2(n4);
      });
    } catch (r3) {
      t3.some(function(n4) {
        n4.__h && (n4.__h = []);
      }), t3 = [], c2.__e(r3, n3.__v);
    }
  }), l2 && l2(n2, t3);
}, c2.unmount = function(n2) {
  m2 && m2(n2);
  var t3, r3 = n2.__c;
  r3 && r3.__H && (r3.__H.__.forEach(function(n3) {
    try {
      z2(n3);
    } catch (n4) {
      t3 = n4;
    }
  }), r3.__H = void 0, t3 && c2.__e(t3, r3.__v));
};
var k2 = "function" == typeof requestAnimationFrame;
function w2(n2) {
  var t3, r3 = function() {
    clearTimeout(u4), k2 && cancelAnimationFrame(t3), setTimeout(n2);
  }, u4 = setTimeout(r3, 100);
  k2 && (t3 = requestAnimationFrame(r3));
}
function z2(n2) {
  var t3 = r2, u4 = n2.__c;
  "function" == typeof u4 && (n2.__c = void 0, u4()), r2 = t3;
}
function B2(n2) {
  var t3 = r2;
  n2.__c = n2.__(), r2 = t3;
}

// node_modules/preact/compat/dist/compat.module.js
function g3(n2, t3) {
  for (var e3 in t3) n2[e3] = t3[e3];
  return n2;
}
function E2(n2, t3) {
  for (var e3 in n2) if ("__source" !== e3 && !(e3 in t3)) return true;
  for (var r3 in t3) if ("__source" !== r3 && n2[r3] !== t3[r3]) return true;
  return false;
}
function N2(n2, t3) {
  this.props = n2, this.context = t3;
}
(N2.prototype = new x()).isPureReactComponent = true, N2.prototype.shouldComponentUpdate = function(n2, t3) {
  return E2(this.props, n2) || E2(this.state, t3);
};
var T3 = l.__b;
l.__b = function(n2) {
  n2.type && n2.type.__f && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), T3 && T3(n2);
};
var A3 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
var F3 = l.__e;
l.__e = function(n2, t3, e3, r3) {
  if (n2.then) {
    for (var u4, o2 = t3; o2 = o2.__; ) if ((u4 = o2.__c) && u4.__c) return null == t3.__e && (t3.__e = e3.__e, t3.__k = e3.__k), u4.__c(n2, t3);
  }
  F3(n2, t3, e3, r3);
};
var U = l.unmount;
function V2(n2, t3, e3) {
  return n2 && (n2.__c && n2.__c.__H && (n2.__c.__H.__.forEach(function(n3) {
    "function" == typeof n3.__c && n3.__c();
  }), n2.__c.__H = null), null != (n2 = g3({}, n2)).__c && (n2.__c.__P === e3 && (n2.__c.__P = t3), n2.__c = null), n2.__k = n2.__k && n2.__k.map(function(n3) {
    return V2(n3, t3, e3);
  })), n2;
}
function W(n2, t3, e3) {
  return n2 && e3 && (n2.__v = null, n2.__k = n2.__k && n2.__k.map(function(n3) {
    return W(n3, t3, e3);
  }), n2.__c && n2.__c.__P === t3 && (n2.__e && e3.appendChild(n2.__e), n2.__c.__e = true, n2.__c.__P = e3)), n2;
}
function P3() {
  this.__u = 0, this.o = null, this.__b = null;
}
function j3(n2) {
  var t3 = n2.__.__c;
  return t3 && t3.__a && t3.__a(n2);
}
function B3() {
  this.i = null, this.l = null;
}
l.unmount = function(n2) {
  var t3 = n2.__c;
  t3 && t3.__R && t3.__R(), t3 && 32 & n2.__u && (n2.type = null), U && U(n2);
}, (P3.prototype = new x()).__c = function(n2, t3) {
  var e3 = t3.__c, r3 = this;
  null == r3.o && (r3.o = []), r3.o.push(e3);
  var u4 = j3(r3.__v), o2 = false, i4 = function() {
    o2 || (o2 = true, e3.__R = null, u4 ? u4(c3) : c3());
  };
  e3.__R = i4;
  var c3 = function() {
    if (!--r3.__u) {
      if (r3.state.__a) {
        var n3 = r3.state.__a;
        r3.__v.__k[0] = W(n3, n3.__c.__P, n3.__c.__O);
      }
      var t4;
      for (r3.setState({ __a: r3.__b = null }); t4 = r3.o.pop(); ) t4.forceUpdate();
    }
  };
  r3.__u++ || 32 & t3.__u || r3.setState({ __a: r3.__b = r3.__v.__k[0] }), n2.then(i4, i4);
}, P3.prototype.componentWillUnmount = function() {
  this.o = [];
}, P3.prototype.render = function(n2, e3) {
  if (this.__b) {
    if (this.__v.__k) {
      var r3 = document.createElement("div"), o2 = this.__v.__k[0].__c;
      this.__v.__k[0] = V2(this.__b, r3, o2.__O = o2.__P);
    }
    this.__b = null;
  }
  var i4 = e3.__a && g(k, null, n2.fallback);
  return i4 && (i4.__u &= -33), [g(k, null, e3.__a ? null : n2.children), i4];
};
var H2 = function(n2, t3, e3) {
  if (++e3[1] === e3[0] && n2.l.delete(t3), n2.props.revealOrder && ("t" !== n2.props.revealOrder[0] || !n2.l.size)) for (e3 = n2.i; e3; ) {
    for (; e3.length > 3; ) e3.pop()();
    if (e3[1] < e3[0]) break;
    n2.i = e3 = e3[2];
  }
};
(B3.prototype = new x()).__a = function(n2) {
  var t3 = this, e3 = j3(t3.__v), r3 = t3.l.get(n2);
  return r3[0]++, function(u4) {
    var o2 = function() {
      t3.props.revealOrder ? (r3.push(u4), H2(t3, n2, r3)) : u4();
    };
    e3 ? e3(o2) : o2();
  };
}, B3.prototype.render = function(n2) {
  this.i = null, this.l = /* @__PURE__ */ new Map();
  var t3 = H(n2.children);
  n2.revealOrder && "b" === n2.revealOrder[0] && t3.reverse();
  for (var e3 = t3.length; e3--; ) this.l.set(t3[e3], this.i = [1, 0, this.i]);
  return n2.children;
}, B3.prototype.componentDidUpdate = B3.prototype.componentDidMount = function() {
  var n2 = this;
  this.l.forEach(function(t3, e3) {
    H2(n2, e3, t3);
  });
};
var q3 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
var G2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
var J2 = /^on(Ani|Tra|Tou|BeforeInp|Compo)/;
var K = /[A-Z0-9]/g;
var Q = "undefined" != typeof document;
var X = function(n2) {
  return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n2);
};
function nn(n2, t3, e3) {
  return null == t3.__k && (t3.textContent = ""), D(n2, t3), "function" == typeof e3 && e3(), n2 ? n2.__c : null;
}
x.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t3) {
  Object.defineProperty(x.prototype, t3, { configurable: true, get: function() {
    return this["UNSAFE_" + t3];
  }, set: function(n2) {
    Object.defineProperty(this, t3, { configurable: true, writable: true, value: n2 });
  } });
});
var en = l.event;
function rn() {
}
function un() {
  return this.cancelBubble;
}
function on() {
  return this.defaultPrevented;
}
l.event = function(n2) {
  return en && (n2 = en(n2)), n2.persist = rn, n2.isPropagationStopped = un, n2.isDefaultPrevented = on, n2.nativeEvent = n2;
};
var cn;
var ln = { enumerable: false, configurable: true, get: function() {
  return this.class;
} };
var fn = l.vnode;
l.vnode = function(n2) {
  "string" == typeof n2.type && function(n3) {
    var t3 = n3.props, e3 = n3.type, u4 = {}, o2 = -1 === e3.indexOf("-");
    for (var i4 in t3) {
      var c3 = t3[i4];
      if (!("value" === i4 && "defaultValue" in t3 && null == c3 || Q && "children" === i4 && "noscript" === e3 || "class" === i4 || "className" === i4)) {
        var l3 = i4.toLowerCase();
        "defaultValue" === i4 && "value" in t3 && null == t3.value ? i4 = "value" : "download" === i4 && true === c3 ? c3 = "" : "translate" === l3 && "no" === c3 ? c3 = false : "o" === l3[0] && "n" === l3[1] ? "ondoubleclick" === l3 ? i4 = "ondblclick" : "onchange" !== l3 || "input" !== e3 && "textarea" !== e3 || X(t3.type) ? "onfocus" === l3 ? i4 = "onfocusin" : "onblur" === l3 ? i4 = "onfocusout" : J2.test(i4) && (i4 = l3) : l3 = i4 = "oninput" : o2 && G2.test(i4) ? i4 = i4.replace(K, "-$&").toLowerCase() : null === c3 && (c3 = void 0), "oninput" === l3 && u4[i4 = l3] && (i4 = "oninputCapture"), u4[i4] = c3;
      }
    }
    "select" == e3 && u4.multiple && Array.isArray(u4.value) && (u4.value = H(t3.children).forEach(function(n4) {
      n4.props.selected = -1 != u4.value.indexOf(n4.props.value);
    })), "select" == e3 && null != u4.defaultValue && (u4.value = H(t3.children).forEach(function(n4) {
      n4.props.selected = u4.multiple ? -1 != u4.defaultValue.indexOf(n4.props.value) : u4.defaultValue == n4.props.value;
    })), t3.class && !t3.className ? (u4.class = t3.class, Object.defineProperty(u4, "className", ln)) : (t3.className && !t3.class || t3.class && t3.className) && (u4.class = u4.className = t3.className), n3.props = u4;
  }(n2), n2.$$typeof = q3, fn && fn(n2);
};
var an = l.__r;
l.__r = function(n2) {
  an && an(n2), cn = n2.__c;
};
var sn = l.diffed;
l.diffed = function(n2) {
  sn && sn(n2);
  var t3 = n2.props, e3 = n2.__e;
  null != e3 && "textarea" === n2.type && "value" in t3 && t3.value !== e3.value && (e3.value = null == t3.value ? "" : t3.value), cn = null;
};

// node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js
var f3 = 0;
var i3 = Array.isArray;
function u3(e3, t3, n2, o2, i4, u4) {
  t3 || (t3 = {});
  var a3, c3, p3 = t3;
  if ("ref" in p3) for (c3 in p3 = {}, t3) "ref" == c3 ? a3 = t3[c3] : p3[c3] = t3[c3];
  var l3 = { type: e3, props: p3, key: n2, ref: a3, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: --f3, __i: -1, __u: 0, __source: i4, __self: u4 };
  if ("function" == typeof e3 && (a3 = e3.defaultProps)) for (c3 in a3) void 0 === p3[c3] && (p3[c3] = a3[c3]);
  return l.vnode && l.vnode(l3), l3;
}

// node_modules/@logicflow/core/es/options.js
var __rest = function(s3, e3) {
  var t3 = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t3[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p3 = Object.getOwnPropertySymbols(s3); i4 < p3.length; i4++) {
      if (e3.indexOf(p3[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i4]))
        t3[p3[i4]] = s3[p3[i4]];
    }
  return t3;
};
var Options;
(function(Options2) {
  function get(options) {
    var others = __rest(options, []);
    var container = options.container;
    if (!container) {
      throw new Error("Ensure the container of LogicFlow is specified and valid.");
    }
    return assign_default({}, Options2.defaults, others);
  }
  Options2.get = get;
})(Options || (Options = {}));
(function(Options2) {
  Options2.defaults = {
    background: false,
    grid: false,
    textEdit: true,
    snapline: true,
    outline: false,
    disabledTools: []
  };
})(Options || (Options = {}));

// node_modules/@logicflow/core/es/util/index.js
var util_exports = {};
__export(util_exports, {
  Matrix: () => Matrix,
  Point: () => Point,
  RotateMatrix: () => RotateMatrix,
  ScaleMatrix: () => ScaleMatrix,
  StepDrag: () => StepDrag,
  TranslateMatrix: () => TranslateMatrix,
  Vector: () => Vector,
  action: () => action,
  calculateWidthAndHeight: () => calculateWidthAndHeight,
  cancelRaf: () => cancelRaf,
  computed: () => computed,
  configure: () => configure,
  costByPoints: () => costByPoints,
  createEdgeGenerator: () => createEdgeGenerator,
  createRaf: () => createRaf,
  createUuid: () => createUuid,
  defaultAnimationOffConfig: () => defaultAnimationOffConfig,
  defaultAnimationOnConfig: () => defaultAnimationOnConfig,
  defaultTheme: () => defaultTheme,
  degrees: () => degrees,
  distance: () => distance,
  estimateDistance: () => estimateDistance,
  filterRepeatPoints: () => filterRepeatPoints,
  formatAnchorConnectValidateData: () => formatAnchorConnectValidateData,
  formatData: () => formatData,
  getAnchors: () => getAnchors,
  getAppendAttributes: () => getAppendAttributes,
  getBBoxCrossPointsByPoint: () => getBBoxCrossPointsByPoint,
  getBBoxOfPoints: () => getBBoxOfPoints,
  getBBoxXCrossPoints: () => getBBoxXCrossPoints,
  getBBoxYCrossPoints: () => getBBoxYCrossPoints,
  getBezierControlPoints: () => getBezierControlPoints,
  getBezierPoints: () => getBezierPoints,
  getBoxByOriginNode: () => getBoxByOriginNode,
  getBytesLength: () => getBytesLength,
  getClosestAnchor: () => getClosestAnchor,
  getClosestPointOfPolyline: () => getClosestPointOfPolyline,
  getClosestRadiusCenter: () => getClosestRadiusCenter,
  getCrossPointInRect: () => getCrossPointInRect,
  getCrossPointWithCircle: () => getCrossPointWithCircle,
  getCrossPointWithEllipse: () => getCrossPointWithEllipse,
  getCrossPointWithPolygon: () => getCrossPointWithPolygon,
  getEndTangent: () => getEndTangent,
  getExpandedBBox: () => getExpandedBBox,
  getExpandedBBoxPoint: () => getExpandedBBoxPoint,
  getGridOffset: () => getGridOffset,
  getHtmlTextHeight: () => getHtmlTextHeight,
  getLongestEdge: () => getLongestEdge,
  getMinIndex: () => getMinIndex,
  getNextNeighborPoints: () => getNextNeighborPoints,
  getNodeAnchorPosition: () => getNodeAnchorPosition,
  getNodeBBox: () => getNodeBBox,
  getPointsFromBBox: () => getPointsFromBBox,
  getPolylinePoints: () => getPolylinePoints,
  getRectRadiusCircle: () => getRectRadiusCircle,
  getSimplePoints: () => getSimplePoints,
  getSimplePolyline: () => getSimplePolyline,
  getSvgTextSize: () => getSvgTextSize,
  getSvgTextWidthHeight: () => getSvgTextWidthHeight,
  getTextWidth: () => getTextWidth,
  getThetaOfVector: () => getThetaOfVector,
  getZIndex: () => getZIndex,
  handleResize: () => handleResize,
  heuristicCostEstimate: () => heuristicCostEstimate,
  inStraightLineOfRect: () => inStraightLineOfRect,
  isBboxOverLapping: () => isBboxOverLapping,
  isIe: () => isIe,
  isInNode: () => isInNode,
  isInNodeBbox: () => isInNodeBbox,
  isMultipleSelect: () => isMultipleSelect,
  isObservable: () => isObservable,
  isPointInArea: () => isPointInArea,
  isPointOutsideBBox: () => isPointOutsideBBox,
  isSegmentCrossingBBox: () => isSegmentCrossingBBox,
  isSegmentsCrossNode: () => isSegmentsCrossNode,
  isSegmentsInNode: () => isSegmentsInNode,
  isSegmentsIntersected: () => isSegmentsIntersected,
  mergeBBox: () => mergeBBox,
  normalizePolygon: () => normalizePolygon,
  observable: () => observable,
  pathFinder: () => pathFinder,
  pickEdgeConfig: () => pickEdgeConfig,
  pickNodeConfig: () => pickNodeConfig,
  pointDirection: () => pointDirection,
  pointEdgeDirection: () => pointEdgeDirection,
  pointFilter: () => pointFilter,
  points2PointsList: () => points2PointsList,
  reaction: () => reaction,
  rebuildPath: () => rebuildPath,
  recalcResizeInfo: () => recalcResizeInfo,
  refreshGraphId: () => refreshGraphId,
  removeClosePointFromOpenList: () => removeClosePointFromOpenList,
  sampleCubic: () => sampleCubic,
  segmentDirection: () => segmentDirection,
  setupAnimation: () => setupAnimation,
  setupEdgeModel: () => setupEdgeModel,
  setupTheme: () => setupTheme,
  snapToGrid: () => snapToGrid,
  targetNodeInfo: () => targetNodeInfo,
  toJS: () => toJS,
  triggerResizeEvent: () => triggerResizeEvent,
  twoPointDistance: () => twoPointDistance,
  updateAnimation: () => updateAnimation,
  updateEdgePointByAnchors: () => updateEdgePointByAnchors,
  updateTheme: () => updateTheme
});

// node_modules/@logicflow/core/es/util/animation.js
var defaultAnimationOffConfig = {
  node: false,
  edge: false
};
var defaultAnimationOnConfig = {
  node: true,
  edge: true
};
var setupAnimation = function(config) {
  if (!config || typeof config === "boolean") {
    return config === true ? cloneDeep_default(defaultAnimationOnConfig) : cloneDeep_default(defaultAnimationOffConfig);
  }
  return merge_default(cloneDeep_default(defaultAnimationOffConfig), config);
};
var updateAnimation = setupAnimation;

// node_modules/@logicflow/core/es/util/browser.js
var isIe = function() {
  return get_default(window, "navigator.userAgent", "").match(/MSIE|Trident/) !== null;
};

// node_modules/@logicflow/core/es/util/compatible.js
function formatData(data) {
  try {
    return JSON.parse(JSON.stringify(data));
  } catch (_a2) {
    return data;
  }
}

// node_modules/@logicflow/core/es/constant/index.js
var DEFAULT_VISIBLE_SPACE = 200;
var ELEMENT_MAX_Z_INDEX = 9999;
var DEFAULT_GRID_SIZE = 10;
var ElementState;
(function(ElementState2) {
  ElementState2[ElementState2["DEFAULT"] = 1] = "DEFAULT";
  ElementState2[ElementState2["TEXT_EDIT"] = 2] = "TEXT_EDIT";
  ElementState2[ElementState2["SHOW_MENU"] = 3] = "SHOW_MENU";
  ElementState2[ElementState2["ALLOW_CONNECT"] = 4] = "ALLOW_CONNECT";
  ElementState2[ElementState2["NOT_ALLOW_CONNECT"] = 5] = "NOT_ALLOW_CONNECT";
})(ElementState || (ElementState = {}));
var ElementType;
(function(ElementType2) {
  ElementType2["NODE"] = "node";
  ElementType2["EDGE"] = "edge";
  ElementType2["GRAPH"] = "graph";
})(ElementType || (ElementType = {}));
var ModelType;
(function(ModelType2) {
  ModelType2["NODE"] = "node";
  ModelType2["CIRCLE_NODE"] = "circle-node";
  ModelType2["POLYGON_NODE"] = "polygon-node";
  ModelType2["RECT_NODE"] = "rect-node";
  ModelType2["TEXT_NODE"] = "text-node";
  ModelType2["ELLIPSE_NODE"] = "ellipse-node";
  ModelType2["DIAMOND_NODE"] = "diamond-node";
  ModelType2["HTML_NODE"] = "html-node";
  ModelType2["CUSTOM_HTML_NODE"] = "custom-html-node";
  ModelType2["EDGE"] = "edge";
  ModelType2["LINE_EDGE"] = "line-edge";
  ModelType2["POLYLINE_EDGE"] = "polyline-edge";
  ModelType2["BEZIER_EDGE"] = "bezier-edge";
  ModelType2["GRAPH"] = "graph";
})(ModelType || (ModelType = {}));
var EventType;
(function(EventType2) {
  EventType2["ELEMENT_CLICK"] = "element:click";
  EventType2["NODE_ADD"] = "node:add";
  EventType2["NODE_DELETE"] = "node:delete";
  EventType2["NODE_CLICK"] = "node:click";
  EventType2["NODE_DBCLICK"] = "node:dbclick";
  EventType2["NODE_GROUP_COPY"] = "node:group-copy-add";
  EventType2["NODE_DND_ADD"] = "node:dnd-add";
  EventType2["NODE_DND_DRAG"] = "node:dnd-drag";
  EventType2["NODE_MOUSEDOWN"] = "node:mousedown";
  EventType2["NODE_DRAGSTART"] = "node:dragstart";
  EventType2["NODE_DRAG"] = "node:drag";
  EventType2["NODE_DROP"] = "node:drop";
  EventType2["NODE_MOUSEUP"] = "node:mouseup";
  EventType2["NODE_MOUSEMOVE"] = "node:mousemove";
  EventType2["NODE_MOUSEENTER"] = "node:mouseenter";
  EventType2["NODE_MOUSELEAVE"] = "node:mouseleave";
  EventType2["NODE_CONTEXTMENU"] = "node:contextmenu";
  EventType2["NODE_ROTATE"] = "node:rotate";
  EventType2["NODE_RESIZE"] = "node:resize";
  EventType2["NODE_FOCUS"] = "node:focus";
  EventType2["NODE_BLUR"] = "node:blur";
  EventType2["NODE_PROPERTIES_CHANGE"] = "node:properties-change";
  EventType2["NODE_PROPERTIES_DELETE"] = "node:properties-delete";
  EventType2["EDGE_ADD"] = "edge:add";
  EventType2["EDGE_DELETE"] = "edge:delete";
  EventType2["EDGE_CLICK"] = "edge:click";
  EventType2["EDGE_DBCLICK"] = "edge:dbclick";
  EventType2["EDGE_FOCUS"] = "edge:focus";
  EventType2["EDGE_BLUR"] = "edge:blur";
  EventType2["EDGE_MOUSEENTER"] = "edge:mouseenter";
  EventType2["EDGE_MOUSELEAVE"] = "edge:mouseleave";
  EventType2["EDGE_CONTEXTMENU"] = "edge:contextmenu";
  EventType2["EDGE_ADJUST"] = "edge:adjust";
  EventType2["EDGE_EXCHANGE_NODE"] = "edge:exchange-node";
  EventType2["ANCHOR_DRAGSTART"] = "anchor:dragstart";
  EventType2["ANCHOR_DRAG"] = "anchor:drag";
  EventType2["ANCHOR_DROP"] = "anchor:drop";
  EventType2["ANCHOR_DRAGEND"] = "anchor:dragend";
  EventType2["ADJUST_POINT_MOUSEDOWN"] = "adjustPoint:mousedown";
  EventType2["ADJUST_POINT_MOUSEUP"] = "adjustPoint:mouseup";
  EventType2["ADJUST_POINT_MOUSEMOVE"] = "adjustPoint:mousemove";
  EventType2["ADJUST_POINT_DRAGSTART"] = "adjustPoint:dragstart";
  EventType2["ADJUST_POINT_DRAG"] = "adjustPoint:drag";
  EventType2["ADJUST_POINT_DROP"] = "adjustPoint:drop";
  EventType2["ADJUST_POINT_DRAGEND"] = "adjustPoint:dragend";
  EventType2["BLANK_MOUSEDOWN"] = "blank:mousedown";
  EventType2["BLANK_DRAGSTART"] = "blank:dragstart";
  EventType2["BLANK_DRAG"] = "blank:drag";
  EventType2["BLANK_DROP"] = "blank:drop";
  EventType2["BLANK_MOUSEMOVE"] = "blank:mousemove";
  EventType2["BLANK_MOUSEUP"] = "blank:mouseup";
  EventType2["BLANK_CLICK"] = "blank:click";
  EventType2["BLANK_CONTEXTMENU"] = "blank:contextmenu";
  EventType2["SELECTION_MOUSEDOWN"] = "selection:mousedown";
  EventType2["SELECTION_DRAGSTART"] = "selection:dragstart";
  EventType2["SELECTION_DRAG"] = "selection:drag";
  EventType2["SELECTION_DROP"] = "selection:drop";
  EventType2["SELECTION_MOUSEMOVE"] = "selection:mousemove";
  EventType2["SELECTION_MOUSEUP"] = "selection:mouseup";
  EventType2["SELECTION_CONTEXTMENU"] = "selection:contextmenu";
  EventType2["CONNECTION_NOT_ALLOWED"] = "connection:not-allowed";
  EventType2["TEXT_MOUSEDOWN"] = "text:mousedown";
  EventType2["TEXT_DRAGSTART"] = "text:dragstart";
  EventType2["TEXT_DRAG"] = "text:drag";
  EventType2["TEXT_DROP"] = "text:drop";
  EventType2["TEXT_CLICK"] = "text:click";
  EventType2["TEXT_DBCLICK"] = "text:dbclick";
  EventType2["TEXT_BLUR"] = "text:blur";
  EventType2["TEXT_MOUSEMOVE"] = "text:mousemove";
  EventType2["TEXT_MOUSEUP"] = "text:mouseup";
  EventType2["TEXT_FOCUS"] = "text:focus";
  EventType2["TEXT_ADD"] = "text:add";
  EventType2["TEXT_UPDATE"] = "text:update";
  EventType2["TEXT_CLEAR"] = "text:clear";
  EventType2["LABEL_MOUSEDOWN"] = "label:mousedown";
  EventType2["LABEL_DRAGSTART"] = "label:dragstart";
  EventType2["LABEL_DRAG"] = "label:drag";
  EventType2["LABEL_DROP"] = "label:drop";
  EventType2["LABEL_CLICK"] = "label:click";
  EventType2["LABEL_DBCLICK"] = "label:dbclick";
  EventType2["LABEL_BLUR"] = "label:blur";
  EventType2["LABEL_MOUSEMOVE"] = "label:mousemove";
  EventType2["LABEL_MOUSEUP"] = "label:mouseup";
  EventType2["LABEL_FOCUS"] = "label:focus";
  EventType2["LABEL_ADD"] = "label:add";
  EventType2["LABEL_UPDATE"] = "label:update";
  EventType2["LABEL_CLEAR"] = "label:clear";
  EventType2["LABEL_DELETE"] = "label:delete";
  EventType2["LABEL_SHOULD_ADD"] = "label:should-add";
  EventType2["LABEL_BATCH_ADD"] = "label:batch-add";
  EventType2["LABEL_SHOULD_UPDATE"] = "label:should-update";
  EventType2["LABEL_SHOULD_DELETE"] = "label:should-delete";
  EventType2["LABEL_BATCH_DELETE"] = "label:batch-delete";
  EventType2["LABEL_NOT_ALLOWED_ADD"] = "label:not-allowed-add";
  EventType2["HISTORY_CHANGE"] = "history:change";
  EventType2["GRAPH_TRANSFORM"] = "graph:transform";
  EventType2["GRAPH_RENDERED"] = "graph:rendered";
  EventType2["GRAPH_UPDATED"] = "graph:updated";
})(EventType || (EventType = {}));
var OverlapMode;
(function(OverlapMode2) {
  OverlapMode2[OverlapMode2["DEFAULT"] = 0] = "DEFAULT";
  OverlapMode2[OverlapMode2["INCREASE"] = 1] = "INCREASE";
})(OverlapMode || (OverlapMode = {}));
var SegmentDirection;
(function(SegmentDirection2) {
  SegmentDirection2["HORIZONTAL"] = "horizontal";
  SegmentDirection2["VERTICAL"] = "vertical";
})(SegmentDirection || (SegmentDirection = {}));
var TextMode;
(function(TextMode2) {
  TextMode2["TEXT"] = "text";
  TextMode2["LABEL"] = "label";
})(TextMode || (TextMode = {}));

// node_modules/@logicflow/core/es/util/drag.js
var LEFT_MOUSE_BUTTON_CODE = 0;
var StepDrag = (
  /** @class */
  function() {
    function StepDrag2(_a2) {
      var _b = _a2.onDragStart, onDragStart = _b === void 0 ? noop_default : _b, _c = _a2.onDragging, onDragging = _c === void 0 ? noop_default : _c, _d = _a2.onDragEnd, onDragEnd = _d === void 0 ? noop_default : _d, _e = _a2.eventType, eventType = _e === void 0 ? "" : _e, eventCenter = _a2.eventCenter, _f = _a2.step, step = _f === void 0 ? 1 : _f, _g = _a2.isStopPropagation, isStopPropagation = _g === void 0 ? true : _g, model = _a2.model, data = _a2.data;
      var _this = this;
      this.isDragging = false;
      this.isStartDragging = false;
      this.startX = 0;
      this.startY = 0;
      this.sumDeltaX = 0;
      this.sumDeltaY = 0;
      this.handleMouseDown = function(e3) {
        var _a3, _b2;
        var DOC = window === null || window === void 0 ? void 0 : window.document;
        if (e3.button !== LEFT_MOUSE_BUTTON_CODE)
          return;
        if (_this.isStopPropagation)
          e3.stopPropagation();
        _this.isStartDragging = true;
        _this.startX = e3.clientX;
        _this.startY = e3.clientY;
        DOC.addEventListener("mousemove", _this.handleMouseMove, false);
        DOC.addEventListener("mouseup", _this.handleMouseUp, false);
        var elementData = (_a3 = _this.model) === null || _a3 === void 0 ? void 0 : _a3.getData();
        (_b2 = _this.eventCenter) === null || _b2 === void 0 ? void 0 : _b2.emit(EventType["".concat(_this.eventType, "_MOUSEDOWN")], {
          e: e3,
          data: _this.data || elementData
        });
        _this.startTime = (/* @__PURE__ */ new Date()).getTime();
      };
      this.handleMouseMove = function(e3) {
        var _a3, _b2;
        if (_this.isStopPropagation)
          e3.stopPropagation();
        if (!_this.isStartDragging)
          return;
        _this.sumDeltaX += e3.clientX - _this.startX;
        _this.sumDeltaY += e3.clientY - _this.startY;
        _this.startX = e3.clientX;
        _this.startY = e3.clientY;
        if (_this.step <= 1 || Math.abs(_this.sumDeltaX) > _this.step || Math.abs(_this.sumDeltaY) > _this.step) {
          var remainderX = _this.sumDeltaX % _this.step;
          var remainderY = _this.sumDeltaY % _this.step;
          var deltaX_1 = _this.sumDeltaX - remainderX;
          var deltaY_1 = _this.sumDeltaY - remainderY;
          _this.sumDeltaX = remainderX;
          _this.sumDeltaY = remainderY;
          var elementData_1 = (_a3 = _this.model) === null || _a3 === void 0 ? void 0 : _a3.getData();
          if (!_this.isDragging) {
            (_b2 = _this.eventCenter) === null || _b2 === void 0 ? void 0 : _b2.emit(EventType["".concat(_this.eventType, "_DRAGSTART")], {
              e: e3,
              data: _this.data || elementData_1
            });
            _this.onDragStart({ event: e3 });
          }
          _this.isDragging = true;
          Promise.resolve().then(function() {
            var _a4, _b3;
            _this.onDragging({
              deltaX: deltaX_1,
              deltaY: deltaY_1,
              event: e3
            });
            (_a4 = _this.eventCenter) === null || _a4 === void 0 ? void 0 : _a4.emit(EventType["".concat(_this.eventType, "_MOUSEMOVE")], {
              deltaX: deltaX_1,
              deltaY: deltaY_1,
              e: e3,
              data: _this.data || elementData_1
            });
            (_b3 = _this.eventCenter) === null || _b3 === void 0 ? void 0 : _b3.emit(EventType["".concat(_this.eventType, "_DRAG")], {
              e: e3,
              data: _this.data || elementData_1
            });
          });
        }
      };
      this.handleMouseUp = function(e3) {
        var DOC = window.document;
        _this.isStartDragging = false;
        if (_this.isStopPropagation)
          e3.stopPropagation();
        Promise.resolve().then(function() {
          var _a3, _b2, _c2;
          DOC.removeEventListener("mousemove", _this.handleMouseMove, false);
          DOC.removeEventListener("mouseup", _this.handleMouseUp, false);
          var elementData = (_a3 = _this.model) === null || _a3 === void 0 ? void 0 : _a3.getData();
          (_b2 = _this.eventCenter) === null || _b2 === void 0 ? void 0 : _b2.emit(EventType["".concat(_this.eventType, "_MOUSEUP")], {
            e: e3,
            data: _this.data || elementData
          });
          if (!_this.isDragging)
            return;
          _this.isDragging = false;
          _this.onDragEnd({ event: e3 });
          (_c2 = _this.eventCenter) === null || _c2 === void 0 ? void 0 : _c2.emit(EventType["".concat(_this.eventType, "_DROP")], {
            e: e3,
            data: _this.data || elementData
          });
        });
      };
      this.cancelDrag = function() {
        var DOC = window === null || window === void 0 ? void 0 : window.document;
        DOC.removeEventListener("mousemove", _this.handleMouseMove, false);
        DOC.removeEventListener("mouseup", _this.handleMouseUp, false);
        _this.onDragEnd({ event: void 0 });
        _this.isDragging = false;
      };
      this.destroy = function() {
        if (_this.isStartDragging) {
          _this.cancelDrag();
        }
      };
      this.onDragStart = onDragStart;
      this.onDragging = onDragging;
      this.onDragEnd = onDragEnd;
      this.step = step;
      this.isStopPropagation = isStopPropagation;
      this.eventType = eventType;
      this.eventCenter = eventCenter;
      this.model = model;
      this.data = data;
    }
    StepDrag2.prototype.setStep = function(step) {
      this.step = step;
    };
    StepDrag2.prototype.setModel = function(model) {
      this.model = model;
    };
    return StepDrag2;
  }()
);

// node_modules/@logicflow/core/es/algorithm/outline.js
var getNodeOutline = function(node) {
  var x3 = node.x, y3 = node.y, width = node.width, height = node.height;
  return {
    x: x3 - width / 2,
    y: y3 - height / 2,
    x1: x3 + width / 2,
    y1: y3 + height / 2
  };
};
var getLineOutline = function(edge) {
  var startPoint = edge.startPoint, endPoint = edge.endPoint;
  var x3 = (startPoint.x + endPoint.x) / 2;
  var y3 = (startPoint.y + endPoint.y) / 2;
  var width = Math.abs(startPoint.x - endPoint.x) + 10;
  var height = Math.abs(startPoint.y - endPoint.y) + 10;
  return {
    x: x3 - width / 2,
    y: y3 - height / 2,
    x1: x3 + width / 2,
    y1: y3 + height / 2
  };
};
var getPolylineOutline = function(edge) {
  var points = edge.points;
  var pointsList = points2PointsList(points);
  var bbox = getBBoxOfPoints(pointsList, 8);
  var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
  return {
    x: x3 - width / 2,
    y: y3 - height / 2,
    x1: x3 + width / 2,
    y1: y3 + height / 2
  };
};
var getBezierOutline = function(edge) {
  var path = edge.path;
  var pointsList = getBezierPoints(path);
  var bbox = getBBoxOfPoints(pointsList, 8);
  var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
  return {
    x: x3 - width / 2,
    y: y3 - height / 2,
    x1: x3 + width / 2,
    y1: y3 + height / 2
  };
};
var getEdgeOutline = function(edge) {
  if (edge.modelType === ModelType.LINE_EDGE) {
    return getLineOutline(edge);
  }
  if (edge.modelType === ModelType.POLYLINE_EDGE) {
    return getPolylineOutline(edge);
  }
  if (edge.modelType === ModelType.BEZIER_EDGE) {
    return getBezierOutline(edge);
  }
};

// node_modules/@logicflow/core/es/algorithm/edge.js
var getCrossPointOfLine = function(a3, b2, c3, d2) {
  var denominator = (b2.y - a3.y) * (d2.x - c3.x) - (a3.x - b2.x) * (c3.y - d2.y);
  if (denominator === 0) {
    return false;
  }
  var x3 = ((b2.x - a3.x) * (d2.x - c3.x) * (c3.y - a3.y) + (b2.y - a3.y) * (d2.x - c3.x) * a3.x - (d2.y - c3.y) * (b2.x - a3.x) * c3.x) / denominator;
  var y3 = -((b2.y - a3.y) * (d2.y - c3.y) * (c3.x - a3.x) + (b2.x - a3.x) * (d2.y - c3.y) * a3.y - (d2.x - c3.x) * (b2.y - a3.y) * c3.y) / denominator;
  if (
    // 1
    (x3 - a3.x) * (x3 - b2.x) <= 0 && (y3 - a3.y) * (y3 - b2.y) <= 0 && // 2
    (x3 - c3.x) * (x3 - d2.x) <= 0 && (y3 - c3.y) * (y3 - d2.y) <= 0
  ) {
    return {
      x: x3,
      y: y3
    };
  }
  return false;
};
var isInSegment = function(point, start, end) {
  var x3 = point.x, y3 = point.y;
  var startX = start.x, startY = start.y;
  var endX = end.x, endY = end.y;
  var k3 = (endY - startY) / (endX - startX);
  var b2 = startY - k3 * startX;
  return (x3 >= startX && x3 <= endX || x3 <= startX && x3 >= endX) && (y3 >= startY && y3 <= endY || y3 <= startY && y3 >= endY) && Math.abs(y3 - k3 * x3 - b2) < Number.EPSILON;
};

// node_modules/@logicflow/core/es/algorithm/index.js
var getVerticalPointOfLine = function(config) {
  var start = config.start, end = config.end, offset = config.offset, verticalLength = config.verticalLength, type = config.type;
  var pointPosition = {
    leftX: 0,
    leftY: 0,
    rightX: 0,
    rightY: 0
  };
  var angleOfHorizontal = Math.atan((end.y - start.y) / (end.x - start.x));
  var angleOfPoints = Math.atan(offset / verticalLength);
  var len = Math.sqrt(verticalLength * verticalLength + offset * offset);
  if (type === "start") {
    if (end.x >= start.x) {
      pointPosition.leftX = start.x + len * Math.sin(angleOfHorizontal + angleOfPoints);
      pointPosition.leftY = start.y - len * Math.cos(angleOfHorizontal + angleOfPoints);
      pointPosition.rightX = start.x - len * Math.sin(angleOfHorizontal - angleOfPoints);
      pointPosition.rightY = start.y + len * Math.cos(angleOfHorizontal - angleOfPoints);
    } else {
      pointPosition.leftX = start.x - len * Math.sin(angleOfHorizontal + angleOfPoints);
      pointPosition.leftY = start.y + len * Math.cos(angleOfHorizontal + angleOfPoints);
      pointPosition.rightX = start.x + len * Math.sin(angleOfHorizontal - angleOfPoints);
      pointPosition.rightY = start.y - len * Math.cos(angleOfHorizontal - angleOfPoints);
    }
  } else if (type === "end") {
    if (end.x >= start.x) {
      pointPosition.leftX = end.x + len * Math.sin(angleOfHorizontal - angleOfPoints);
      pointPosition.leftY = end.y - len * Math.cos(angleOfHorizontal - angleOfPoints);
      pointPosition.rightX = end.x - len * Math.sin(angleOfHorizontal + angleOfPoints);
      pointPosition.rightY = end.y + len * Math.cos(angleOfHorizontal + angleOfPoints);
    } else {
      pointPosition.leftX = end.x - len * Math.sin(angleOfHorizontal - angleOfPoints);
      pointPosition.leftY = end.y + len * Math.cos(angleOfHorizontal - angleOfPoints);
      pointPosition.rightX = end.x + len * Math.sin(angleOfHorizontal + angleOfPoints);
      pointPosition.rightY = end.y - len * Math.cos(angleOfHorizontal + angleOfPoints);
    }
  }
  return pointPosition;
};

// node_modules/@logicflow/core/es/util/edge.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign2.apply(this, arguments);
};
var __read2 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l3 = from.length, ar; i4 < l3; i4++) {
    if (ar || !(i4 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i4);
      ar[i4] = from[i4];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var setupEdgeModel = function(edge, graphModel) {
  var model;
  switch (edge.type) {
    case "line":
      model = new LineEdgeModel(edge, graphModel);
      break;
    case "polyline":
      model = new PolylineEdgeModel(edge, graphModel);
      break;
    default:
      model = new LineEdgeModel(edge, graphModel);
      break;
  }
  return model;
};
var isBboxOverLapping = function(b1, b2) {
  return Math.abs(b1.centerX - b2.centerX) * 2 < b1.width + b2.width && Math.abs(b1.centerY - b2.centerY) * 2 < b1.height + b2.height;
};
var filterRepeatPoints = function(points) {
  var result = [];
  var pointsMap = {};
  points.forEach(function(p3) {
    var id = "".concat(p3.x, "-").concat(p3.y);
    p3.id = id;
    pointsMap[id] = p3;
  });
  Object.keys(pointsMap).forEach(function(p3) {
    result.push(pointsMap[p3]);
  });
  return result;
};
var getSimplePolyline = function(sPoint, tPoint) {
  var points = [
    sPoint,
    {
      x: sPoint.x,
      y: tPoint.y
    },
    tPoint
  ];
  return filterRepeatPoints(points);
};
var getExpandedBBox = function(bbox, offset) {
  if (bbox.width === 0 && bbox.height === 0) {
    return bbox;
  }
  return {
    x: bbox.x,
    y: bbox.y,
    centerX: bbox.centerX,
    centerY: bbox.centerY,
    minX: bbox.minX - offset,
    minY: bbox.minY - offset,
    maxX: bbox.maxX + offset,
    maxY: bbox.maxY + offset,
    height: bbox.height + 2 * offset,
    width: bbox.width + 2 * offset
  };
};
var pointDirection = function(point, bbox) {
  var dx = Math.abs(point.x - bbox.centerX);
  var dy = Math.abs(point.y - bbox.centerY);
  return dx / bbox.width > dy / bbox.height ? SegmentDirection.HORIZONTAL : SegmentDirection.VERTICAL;
};
var getExpandedBBoxPoint = function(expendBBox, bbox, point) {
  var direction = pointDirection(point, bbox);
  if (direction === SegmentDirection.HORIZONTAL) {
    return {
      x: point.x > expendBBox.centerX ? expendBBox.maxX : expendBBox.minX,
      y: point.y
    };
  }
  return {
    x: point.x,
    y: point.y > expendBBox.centerY ? expendBBox.maxY : expendBBox.minY
  };
};
var mergeBBox = function(b1, b2) {
  var minX = Math.min(b1.minX, b2.minX);
  var minY = Math.min(b1.minY, b2.minY);
  var maxX = Math.max(b1.maxX, b2.maxX);
  var maxY = Math.max(b1.maxY, b2.maxY);
  return {
    x: (minX + maxX) / 2,
    y: (minY + maxY) / 2,
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY) / 2,
    minX,
    minY,
    maxX,
    maxY,
    height: maxY - minY,
    width: maxX - minX
  };
};
var getBBoxOfPoints = function(points, offset) {
  if (points === void 0) {
    points = [];
  }
  var xList = [];
  var yList = [];
  points.forEach(function(p3) {
    xList.push(p3.x);
    yList.push(p3.y);
  });
  var minX = Math.min.apply(Math, __spreadArray([], __read2(xList), false));
  var maxX = Math.max.apply(Math, __spreadArray([], __read2(xList), false));
  var minY = Math.min.apply(Math, __spreadArray([], __read2(yList), false));
  var maxY = Math.max.apply(Math, __spreadArray([], __read2(yList), false));
  var width = maxX - minX;
  var height = maxY - minY;
  if (offset) {
    width += offset;
    height += offset;
  }
  return {
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY) / 2,
    maxX,
    maxY,
    minX,
    minY,
    x: (minX + maxX) / 2,
    y: (minY + maxY) / 2,
    height,
    width
  };
};
var getPointsFromBBox = function(bbox) {
  var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
  return [
    {
      x: minX,
      y: minY
    },
    {
      x: maxX,
      y: minY
    },
    {
      x: maxX,
      y: maxY
    },
    {
      x: minX,
      y: maxY
    }
  ];
};
var isPointOutsideBBox = function(point, bbox) {
  var x3 = point.x, y3 = point.y;
  return x3 < bbox.minX || x3 > bbox.maxX || y3 < bbox.minY || y3 > bbox.maxY;
};
var getBBoxXCrossPoints = function(bbox, x3) {
  if (x3 < bbox.minX || x3 > bbox.maxX) {
    return [];
  }
  return [
    {
      x: x3,
      y: bbox.minY
    },
    {
      x: x3,
      y: bbox.maxY
    }
  ];
};
var getBBoxYCrossPoints = function(bbox, y3) {
  if (y3 < bbox.minY || y3 > bbox.maxY) {
    return [];
  }
  return [
    {
      x: bbox.minX,
      y: y3
    },
    {
      x: bbox.maxX,
      y: y3
    }
  ];
};
var getBBoxCrossPointsByPoint = function(bbox, point) {
  return __spreadArray(__spreadArray([], __read2(getBBoxXCrossPoints(bbox, point.x)), false), __read2(getBBoxYCrossPoints(bbox, point.y)), false);
};
var estimateDistance = function(p1, p22) {
  return Math.abs(p1.x - p22.x) + Math.abs(p1.y - p22.y);
};
var costByPoints = function(p3, points) {
  var offset = -2;
  var result = 0;
  points.forEach(function(point) {
    if (point) {
      if (p3.x === point.x) {
        result += offset;
      }
      if (p3.y === point.y) {
        result += offset;
      }
    }
  });
  return result;
};
var heuristicCostEstimate = function(p3, ps, pt, source, target) {
  return estimateDistance(p3, ps) + estimateDistance(p3, pt) + costByPoints(p3, [ps, pt, source, target]);
};
var rebuildPath = function(pathPoints, pointById, cameFrom, currentId, iterator) {
  if (!iterator) {
    iterator = 0;
  }
  pathPoints.unshift(pointById[currentId]);
  if (cameFrom[currentId] && cameFrom[currentId] !== currentId && iterator <= 100) {
    rebuildPath(pathPoints, pointById, cameFrom, cameFrom[currentId], iterator + 1);
  }
};
var removeClosePointFromOpenList = function(arr, item) {
  var index = arr.indexOf(item);
  if (index > -1) {
    arr.splice(index, 1);
  }
};
var isSegmentsIntersected = function(p0, p1, p22, p3) {
  var s1x = p1.x - p0.x;
  var s1y = p1.y - p0.y;
  var s2x = p3.x - p22.x;
  var s2y = p3.y - p22.y;
  var s3 = (-s1y * (p0.x - p22.x) + s1x * (p0.y - p22.y)) / (-s2x * s1y + s1x * s2y);
  var t3 = (s2x * (p0.y - p22.y) - s2y * (p0.x - p22.x)) / (-s2x * s1y + s1x * s2y);
  return s3 >= 0 && s3 <= 1 && t3 >= 0 && t3 <= 1;
};
var isSegmentCrossingBBox = function(p1, p22, bbox) {
  if (bbox.width === 0 && bbox.height === 0) {
    return false;
  }
  var _a2 = __read2(getPointsFromBBox(bbox), 4), pa = _a2[0], pb = _a2[1], pc = _a2[2], pd = _a2[3];
  return isSegmentsIntersected(p1, p22, pa, pb) || isSegmentsIntersected(p1, p22, pa, pd) || isSegmentsIntersected(p1, p22, pb, pc) || isSegmentsIntersected(p1, p22, pc, pd);
};
var getNextNeighborPoints = function(points, point, bbox1, bbox2) {
  var neighbors = [];
  points.forEach(function(p3) {
    if (p3 !== point) {
      if (p3.x === point.x || p3.y === point.y) {
        if (!isSegmentCrossingBBox(p3, point, bbox1) && !isSegmentCrossingBBox(p3, point, bbox2)) {
          neighbors.push(p3);
        }
      }
    }
  });
  return filterRepeatPoints(neighbors);
};
var pathFinder = function(points, start, goal, sBBox, tBBox, os, ot) {
  var closedSet = [];
  var openSet = [start];
  var cameFrom = {};
  var gScore = {};
  var fScore = {};
  if (start.id) {
    gScore[start.id] = 0;
    fScore[start.id] = heuristicCostEstimate(start, goal, start);
  }
  var pointById = {};
  points.forEach(function(p3) {
    if (p3.id) {
      pointById[p3.id] = p3;
    }
  });
  var _loop_1 = function() {
    var current;
    var lowestFScore = Infinity;
    openSet.forEach(function(p3) {
      if (p3.id && fScore[p3.id] < lowestFScore) {
        lowestFScore = fScore[p3.id];
        current = p3;
      }
    });
    if (current === goal && goal.id) {
      var pathPoints = [];
      rebuildPath(pathPoints, pointById, cameFrom, goal.id);
      return { value: pathPoints };
    }
    if (!current) {
      return { value: [start, goal] };
    }
    removeClosePointFromOpenList(openSet, current);
    closedSet.push(current);
    getNextNeighborPoints(points, current, sBBox, tBBox).forEach(function(neighbor) {
      if (closedSet.indexOf(neighbor) !== -1) {
        return;
      }
      if (openSet.indexOf(neighbor) === -1) {
        openSet.push(neighbor);
      }
      if ((current === null || current === void 0 ? void 0 : current.id) && (neighbor === null || neighbor === void 0 ? void 0 : neighbor.id)) {
        var tentativeGScore = fScore[current.id] + estimateDistance(current, neighbor);
        if (gScore[neighbor.id] && tentativeGScore >= gScore[neighbor.id]) {
          return;
        }
        cameFrom[neighbor.id] = current.id;
        gScore[neighbor.id] = tentativeGScore;
        fScore[neighbor.id] = gScore[neighbor.id] + heuristicCostEstimate(neighbor, goal, start, os, ot);
      }
    });
  };
  while (openSet.length) {
    var state_1 = _loop_1();
    if (typeof state_1 === "object")
      return state_1.value;
  }
  return [start, goal];
};
var getBoxByOriginNode = function(node) {
  return getNodeBBox(node);
};
var pointFilter = function(points) {
  var i4 = 1;
  while (i4 < points.length - 1) {
    var pre = points[i4 - 1];
    var current = points[i4];
    var next = points[i4 + 1];
    if (pre.x === current.x && current.x === next.x || pre.y === current.y && current.y === next.y) {
      points.splice(i4, 1);
    } else {
      i4++;
    }
  }
  return points;
};
var getPolylinePoints = function(start, end, sNode, tNode, offset) {
  var sBBox = getBoxByOriginNode(sNode);
  var tBBox = getBoxByOriginNode(tNode);
  var sxBBox = getExpandedBBox(sBBox, offset);
  var txBBox = getExpandedBBox(tBBox, offset);
  var sPoint = getExpandedBBoxPoint(sxBBox, sBBox, start);
  var tPoint = getExpandedBBoxPoint(txBBox, tBBox, end);
  if (isBboxOverLapping(sxBBox, txBBox)) {
    var points = getSimplePoints(start, end, sPoint, tPoint);
    return __spreadArray(__spreadArray([start, sPoint], __read2(points), false), [tPoint, end], false);
  }
  var lineBBox = getBBoxOfPoints([sPoint, tPoint]);
  var sMixBBox = mergeBBox(sxBBox, lineBBox);
  var tMixBBox = mergeBBox(txBBox, lineBBox);
  var connectPoints = [];
  connectPoints = connectPoints.concat(getPointsFromBBox(sMixBBox));
  connectPoints = connectPoints.concat(getPointsFromBBox(tMixBBox));
  var centerPoint = {
    x: (start.x + end.x) / 2,
    y: (start.y + end.y) / 2
  };
  [lineBBox, sMixBBox, tMixBBox].forEach(function(bbox) {
    connectPoints = connectPoints.concat(getBBoxCrossPointsByPoint(bbox, centerPoint).filter(function(p3) {
      return isPointOutsideBBox(p3, sxBBox) && isPointOutsideBBox(p3, txBBox);
    }));
  });
  [
    {
      x: sPoint.x,
      y: tPoint.y
    },
    {
      x: tPoint.x,
      y: sPoint.y
    }
  ].forEach(function(p3) {
    if (isPointOutsideBBox(p3, sxBBox) && isPointOutsideBBox(p3, txBBox)) {
      connectPoints.push(p3);
    }
  });
  connectPoints.unshift(sPoint);
  connectPoints.push(tPoint);
  connectPoints = filterRepeatPoints(connectPoints);
  var pathPoints = pathFinder(connectPoints, sPoint, tPoint, sBBox, tBBox, start, end);
  pathPoints.unshift(start);
  pathPoints.push(end);
  if (pathPoints.length > 2) {
    pathPoints = pointFilter(pathPoints);
  }
  return filterRepeatPoints(pathPoints);
};
var getLongestEdge = function(pointsList) {
  if (pointsList.length === 1) {
    var _a2 = __read2(pointsList, 1), point = _a2[0];
    return [point, point];
  } else {
    var point1 = pointsList[0];
    var point2 = pointsList[1];
    var edgeLength = distance(point1.x, point1.y, point2.x, point2.y);
    for (var i4 = 1; i4 < pointsList.length - 1; i4++) {
      var newPoint1 = pointsList[i4];
      var newPoint2 = pointsList[i4 + 1];
      var newEdgeLength = distance(newPoint1.x, newPoint1.y, newPoint2.x, newPoint2.y);
      if (newEdgeLength > edgeLength) {
        edgeLength = newEdgeLength;
        point1 = newPoint1;
        point2 = newPoint2;
      }
    }
    return [point1, point2];
  }
};
var isSegmentsInNode = function(start, end, node) {
  var startInNode = isInNode(start, node);
  var endInNode = isInNode(end, node);
  return startInNode && endInNode;
};
var isSegmentsCrossNode = function(start, end, node) {
  var startInNode = isInNode(start, node);
  var endInNode = isInNode(end, node);
  var bothInNode = startInNode && endInNode;
  var inNode = startInNode || endInNode;
  return !bothInNode && inNode;
};
var getCrossPointInRect = function(start, end, node) {
  var crossSegments = void 0;
  var nodeBox = getNodeBBox(node);
  var points = getPointsFromBBox(nodeBox);
  for (var i4 = 0; i4 < points.length; i4++) {
    var isCross = isSegmentsIntersected(start, end, points[i4], points[(i4 + 1) % points.length]);
    if (isCross) {
      crossSegments = [points[i4], points[(i4 + 1) % points.length]];
    }
  }
  if (crossSegments) {
    return getCrossPointOfLine(start, end, crossSegments[0], crossSegments[1]);
  }
};
var segmentDirection = function(start, end) {
  var direction = void 0;
  if (start.x === end.x) {
    direction = SegmentDirection.VERTICAL;
  } else if (start.y === end.y) {
    direction = SegmentDirection.HORIZONTAL;
  }
  return direction;
};
var points2PointsList = function(points) {
  var currentPositionList = points.split(" ");
  var pointsList = [];
  currentPositionList && currentPositionList.forEach(function(item) {
    var _a2 = __read2(item.split(","), 2), x3 = _a2[0], y3 = _a2[1];
    pointsList.push({
      x: Number(x3),
      y: Number(y3)
    });
  });
  return pointsList;
};
var getSimplePoints = function(start, end, sPoint, tPoint) {
  var points = [];
  var startDirection = segmentDirection(start, sPoint);
  var endDirection = segmentDirection(end, tPoint);
  if (startDirection === endDirection) {
    if (start.y === sPoint.y) {
      points.push({
        x: sPoint.x,
        y: (sPoint.y + tPoint.y) / 2
      });
      points.push({
        x: tPoint.x,
        y: (sPoint.y + tPoint.y) / 2
      });
    } else {
      points.push({
        x: (sPoint.x + tPoint.x) / 2,
        y: sPoint.y
      });
      points.push({
        x: (sPoint.x + tPoint.x) / 2,
        y: tPoint.y
      });
    }
  } else {
    var point = {
      x: sPoint.x,
      y: tPoint.y
    };
    var inStart = isInSegment(point, start, sPoint);
    var inEnd = isInSegment(point, end, tPoint);
    if (inStart || inEnd) {
      point = {
        x: tPoint.x,
        y: sPoint.y
      };
    } else {
      var onStart = isOnLine(point, start, sPoint);
      var onEnd = isOnLine(point, end, tPoint);
      if (onStart && onEnd) {
        point = {
          x: tPoint.x,
          y: sPoint.y
        };
      }
    }
    points.push(point);
  }
  return points;
};
var isOnLine = function(point, start, end) {
  return point.x === start.x && point.x === end.x || point.y === start.y && point.y === end.y;
};
var getBytesLength = function(word) {
  if (!word) {
    return 0;
  }
  var totalLength = 0;
  for (var i4 = 0; i4 < word.length; i4++) {
    var c3 = word.charCodeAt(i4);
    if (word.match(/[A-Z]/)) {
      totalLength += 1.5;
    } else if (c3 >= 1 && c3 <= 126 || c3 >= 65376 && c3 <= 65439) {
      totalLength += 1;
    } else {
      totalLength += 2;
    }
  }
  return totalLength;
};
var canvas = void 0;
var getTextWidth = function(text, font) {
  if (!canvas) {
    canvas = document.createElement("canvas");
  }
  var context = canvas.getContext("2d");
  context.font = font;
  var metrics = context.measureText(text);
  return metrics.width;
};
var getAppendAttributes = function(appendInfo) {
  var start = appendInfo.start, end = appendInfo.end;
  var d2;
  if (start.x === end.x && start.y === end.y) {
    d2 = "";
  } else {
    var config = {
      start,
      end,
      offset: 10,
      verticalLength: 5
    };
    var startPosition = getVerticalPointOfLine(__assign2(__assign2({}, config), { type: "start" }));
    var endPosition = getVerticalPointOfLine(__assign2(__assign2({}, config), { type: "end" }));
    d2 = "M".concat(startPosition.leftX, " ").concat(startPosition.leftY, "\n    L").concat(startPosition.rightX, " ").concat(startPosition.rightY, "\n    L").concat(endPosition.rightX, " ").concat(endPosition.rightY, "\n    L").concat(endPosition.leftX, " ").concat(endPosition.leftY, " z");
  }
  return {
    d: d2,
    fill: "transparent",
    stroke: "transparent",
    strokeWidth: 1,
    strokeDasharray: "4, 4"
  };
};
var getBezierControlPoints = function(_a2) {
  var start = _a2.start, end = _a2.end, sourceNode = _a2.sourceNode, targetNode = _a2.targetNode, offset = _a2.offset;
  var sBBox = getNodeBBox(sourceNode);
  var tBBox = getNodeBBox(targetNode);
  var sExpendBBox = getExpandedBBox(sBBox, offset);
  var tExpendBBox = getExpandedBBox(tBBox, offset);
  var sNext = getExpandedBBoxPoint(sExpendBBox, sBBox, start);
  var ePre = getExpandedBBoxPoint(tExpendBBox, tBBox, end);
  return {
    sNext,
    ePre
  };
};
var getBezierPoints = function(path) {
  var list = path.replace(/M/g, "").replace(/C/g, ",").split(",");
  var start = getBezierPoint(list[0]);
  var sNext = getBezierPoint(list[1]);
  var ePre = getBezierPoint(list[2]);
  var end = getBezierPoint(list[3]);
  return [start, sNext, ePre, end];
};
var getBezierPoint = function(positionStr) {
  var _a2 = __read2(positionStr.replace(/(^\s*)/g, "").split(" "), 2), x3 = _a2[0], y3 = _a2[1];
  return {
    x: +x3,
    y: +y3
  };
};
var getEndTangent = function(pointsList, offset) {
  var _a2 = __read2(pointsList, 4), p1 = _a2[0], cp1 = _a2[1], cp2 = _a2[2], p22 = _a2[3];
  var start = sampleCubic(p1, cp1, cp2, p22, offset);
  return [start, pointsList[3]];
};
var getClosestPointOfPolyline = function(point, points) {
  var x3 = point.x, y3 = point.y;
  var pointsPosition = points2PointsList(points);
  var minDistance = Number.MAX_SAFE_INTEGER;
  var crossPoint;
  var segments = [];
  for (var i4 = 0; i4 < pointsPosition.length; i4++) {
    segments.push({
      start: pointsPosition[i4],
      end: pointsPosition[(i4 + 1) % pointsPosition.length]
    });
  }
  segments.forEach(function(item) {
    var start2 = item.start, end2 = item.end;
    if (start2.x === end2.x) {
      var pointXY = {
        x: start2.x,
        y: y3
      };
      var inSegment = isInSegment(pointXY, start2, end2);
      if (inSegment) {
        var currentDistance = Math.abs(start2.x - x3);
        if (currentDistance < minDistance) {
          minDistance = currentDistance;
          crossPoint = pointXY;
        }
      }
    } else if (start2.y === end2.y) {
      var pointXY = {
        x: x3,
        y: start2.y
      };
      var inSegment = isInSegment(pointXY, start2, end2);
      if (inSegment) {
        var currentDistance = Math.abs(start2.y - y3);
        if (currentDistance < minDistance) {
          minDistance = currentDistance;
          crossPoint = pointXY;
        }
      }
    }
  });
  if (!crossPoint) {
    var _a2 = segments[0], start = _a2.start, end = _a2.end;
    crossPoint = {
      x: start.x + (end.x - start.x) / 2,
      y: start.y + (end.y - start.y) / 2
    };
  }
  return crossPoint;
};
var pickEdgeConfig = function(data) {
  return pick_default(data, [
    "id",
    "type",
    "sourceNodeId",
    "sourceAnchorId",
    "targetNodeId",
    "targetAnchorId",
    "pointsList",
    "startPoint",
    "endPoint",
    "properties"
  ]);
};
var twoPointDistance = function(source, target) {
  return Math.sqrt(Math.pow(source.x - target.x, 2) + Math.pow(source.y - target.y, 2));
};
function createEdgeGenerator(graphModel, generator) {
  if (typeof generator !== "function") {
    return function(_sourceNode, _targetNode, currentEdge) {
      return Object.assign({ type: graphModel.edgeType }, currentEdge);
    };
  }
  return function(sourceNode, targetNode, currentEdge) {
    var result = generator(sourceNode, targetNode, currentEdge);
    if (!result)
      return { type: graphModel.edgeType };
    if (typeof result === "string") {
      return Object.assign({}, currentEdge, { type: result });
    }
    return Object.assign({ type: result }, currentEdge);
  };
}
var getSvgTextSize = function(_a2) {
  var rows = _a2.rows, rowsLength = _a2.rowsLength, fontSize = _a2.fontSize;
  var longestBytes = 0;
  forEach_default(rows, function(row) {
    var rowBytesLength = getBytesLength(row);
    longestBytes = rowBytesLength > longestBytes ? rowBytesLength : longestBytes;
  });
  return {
    width: Math.ceil(longestBytes / 2) * fontSize + fontSize / 4,
    height: rowsLength * (fontSize + 2) + fontSize / 4
  };
};

// node_modules/@logicflow/core/es/util/geometry.js
var __read3 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l3 = from.length, ar; i4 < l3; i4++) {
    if (ar || !(i4 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i4);
      ar[i4] = from[i4];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function snapToGrid(point, gridSize, snapGrid) {
  if (!snapGrid)
    return point;
  return gridSize * Math.round(point / gridSize) || point;
}
function getGridOffset(distance2, gridSize) {
  return distance2 % gridSize;
}
function normalizePolygon(points, width, height) {
  if (!points)
    return [];
  var minX = Math.min.apply(Math, __spreadArray2([], __read3(points.map(function(p3) {
    return p3[0];
  })), false));
  var maxX = Math.max.apply(Math, __spreadArray2([], __read3(points.map(function(p3) {
    return p3[0];
  })), false));
  var minY = Math.min.apply(Math, __spreadArray2([], __read3(points.map(function(p3) {
    return p3[1];
  })), false));
  var maxY = Math.max.apply(Math, __spreadArray2([], __read3(points.map(function(p3) {
    return p3[1];
  })), false));
  var dx = -minX;
  var dy = -minY;
  var translatedPoints = points.map(function(_a2) {
    var _b = __read3(_a2, 2), x3 = _b[0], y3 = _b[1];
    return [
      x3 + dx,
      y3 + dy
    ];
  });
  var bboxWidth = maxX - minX;
  var bboxHeight = maxY - minY;
  var scaleX = width ? width / bboxWidth : 1;
  var scaleY = height ? height / bboxHeight : 1;
  var scaleFactor = Math.min(scaleX, scaleY);
  return translatedPoints.map(function(_a2) {
    var _b = __read3(_a2, 2), x3 = _b[0], y3 = _b[1];
    return [x3 * scaleFactor, y3 * scaleFactor];
  });
}

// node_modules/@logicflow/core/es/util/graph.js
var __read4 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var isPointInArea = function(_a2, _b, _c) {
  var _d = __read4(_a2, 2), x3 = _d[0], y3 = _d[1];
  var _e = __read4(_b, 2), leftTopX = _e[0], leftTopY = _e[1];
  var _f = __read4(_c, 2), rightBottomX = _f[0], rightBottomY = _f[1];
  return x3 > leftTopX && x3 < rightBottomX && y3 > leftTopY && y3 < rightBottomY;
};
var isMultipleSelect = function(e3, editConfigModel) {
  var multipleSelectKey = editConfigModel.multipleSelectKey;
  var isMultiple = false;
  switch (multipleSelectKey) {
    case "meta":
      isMultiple = e3.metaKey;
      break;
    case "alt":
      isMultiple = e3.altKey;
      break;
    case "shift":
      isMultiple = e3.shiftKey;
      break;
    case "ctrl":
      isMultiple = e3.ctrlKey;
      break;
    default:
      isMultiple = false;
      break;
  }
  return isMultiple;
};

// node_modules/@logicflow/core/es/util/vector.js
var __extends2 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
function isVector(a1, a22) {
  return !!(a1 instanceof Vector && a22 instanceof Vector);
}
var Base = (
  /** @class */
  function(_super) {
    __extends2(Base2, _super);
    function Base2(x3, y3, z3) {
      var _this = _super.call(this, 3) || this;
      _this[0] = x3;
      _this[1] = y3;
      _this[2] = z3;
      _this.x = x3;
      _this.y = y3;
      _this.z = z3;
      Object.setPrototypeOf(_this, Base2.prototype);
      return _this;
    }
    Base2.prototype.add = function(v1) {
      if (isVector(this, v1)) {
        return new Vector(this.x + v1.x, this.y + v1.y);
      }
      var z3 = this.z + v1.z;
      return new Point((this.x + v1.x) / z3, (this.y + v1.y) / z3);
    };
    Base2.prototype.subtract = function(v1) {
      if (isVector(this, v1)) {
        return new Vector(this.x - v1.x, this.y - v1.y);
      }
      var z3 = this.z - v1.z;
      return z3 === 0 ? new Vector(this.x - v1.x, this.y - v1.y) : new Point((this.x - v1.x) / z3, (this.y - v1.y) / z3);
    };
    return Base2;
  }(Array)
);
var Vector = (
  /** @class */
  function(_super) {
    __extends2(Vector2, _super);
    function Vector2(x3, y3, z3) {
      var _this = _super.call(this, x3, y3, z3 !== null && z3 !== void 0 ? z3 : 0) || this;
      Object.setPrototypeOf(_this, Vector2.prototype);
      return _this;
    }
    Vector2.prototype.toString = function() {
      return "Vector";
    };
    Vector2.prototype.dot = function(v1) {
      var _this = this;
      return v1.reduce(function(prev, cur, index) {
        return prev + cur * _this[index];
      });
    };
    Vector2.prototype.cross = function(v1) {
      return new Vector2(this.y * v1.z - this.z * v1.y, this.z * v1.x - this.x * v1.z, this.x * v1.y - this.y * v1.x);
    };
    Vector2.prototype.getLength = function() {
      return Math.hypot(this.x, this.y);
    };
    Vector2.prototype.normalize = function() {
      var len = this.getLength();
      return new Vector2(this.x / len, this.y / len);
    };
    Vector2.prototype.crossZ = function(v1) {
      return this.x * v1.y - this.y * v1.x;
    };
    Vector2.prototype.angle = function(v1) {
      var negative = this.crossZ(v1);
      var r3 = Math.acos(this.normalize().dot(v1.normalize()));
      return negative >= 0 ? r3 : -r3;
    };
    return Vector2;
  }(Base)
);
var Point = (
  /** @class */
  function(_super) {
    __extends2(Point2, _super);
    function Point2(x3, y3) {
      var _this = _super.call(this, x3, y3, 1) || this;
      Object.setPrototypeOf(_this, Point2.prototype);
      return _this;
    }
    Point2.prototype.toString = function() {
      return "Point";
    };
    return Point2;
  }(Base)
);

// node_modules/@logicflow/core/es/util/matrix.js
var __extends3 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __read5 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray3 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l3 = from.length, ar; i4 < l3; i4++) {
    if (ar || !(i4 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i4);
      ar[i4] = from[i4];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Matrix = (
  /** @class */
  function(_super) {
    __extends3(Matrix2, _super);
    function Matrix2() {
      var vectors = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        vectors[_i] = arguments[_i];
      }
      var _this = _super.call(this, vectors.length) || this;
      _this.fill(new Array(3));
      vectors.forEach(function(v6, index) {
        _this[index] = v6;
      });
      _this.columns = vectors[0].length;
      _this.rows = vectors.length;
      Object.setPrototypeOf(_this, Matrix2.prototype);
      return _this;
    }
    Matrix2.prototype.getRow = function(index) {
      return this[index];
    };
    Matrix2.prototype.getColumn = function(index) {
      return __spreadArray3([], __read5(this.map(function(row) {
        return row[index];
      })), false);
    };
    Matrix2.prototype.transpose = function() {
      var vectors = [];
      for (var i4 = 0; i4 < this.columns; i4++) {
        vectors.push(this.getColumn(i4));
      }
      return new (Matrix2.bind.apply(Matrix2, __spreadArray3([void 0], __read5(vectors), false)))();
    };
    Matrix2.prototype.cross = function(m1) {
      var arr = new Array(this.rows).fill("").map(function() {
        return [];
      });
      if (this.columns === m1.rows) {
        for (var i4 = 0; i4 < this.rows; i4++) {
          var row = this.getRow(i4);
          var _loop_1 = function(j5) {
            var column = m1.getColumn(j5);
            arr[i4][j5] = row.reduce(function(prev, r3, index) {
              return prev + r3 * column[index];
            }, 0);
          };
          for (var j4 = 0; j4 < m1.columns; j4++) {
            _loop_1(j4);
          }
        }
      }
      return new (Matrix2.bind.apply(Matrix2, __spreadArray3([void 0], __read5(arr), false)))();
    };
    Matrix2.prototype.to2D = function() {
      return this.map(function(item) {
        return [item[0], item[1]];
      });
    };
    Matrix2.prototype.toPoints = function() {
      return this.map(function(item) {
        return new Point(item[0], item[1]);
      });
    };
    Matrix2.prototype.toString = function() {
      var _a2 = __read5(this[0], 2), a3 = _a2[0], b2 = _a2[1];
      var _b = __read5(this[1], 2), c3 = _b[0], d2 = _b[1];
      var _c = __read5(this[2], 2), e3 = _c[0], f5 = _c[1];
      return "matrix(".concat(a3, " ").concat(b2, " ").concat(c3, " ").concat(d2, " ").concat(e3, " ").concat(f5, ")");
    };
    Matrix2.prototype.translate = function(tx, ty) {
      return this.cross(new TranslateMatrix(tx, ty));
    };
    Matrix2.prototype.rotate = function(angle2) {
      return this.cross(new RotateMatrix(angle2));
    };
    Matrix2.prototype.scale = function(sx, sy) {
      return this.cross(new ScaleMatrix(sx, sy));
    };
    return Matrix2;
  }(Array)
);
var RotateMatrix = (
  /** @class */
  function(_super) {
    __extends3(RotateMatrix2, _super);
    function RotateMatrix2(theta) {
      var _this = _super.call(this, new Vector(+Math.cos(theta).toFixed(2), +Math.sin(theta).toFixed(2), 0), new Vector(-Math.sin(theta).toFixed(2), +Math.cos(theta).toFixed(2), 0), new Vector(0, 0, 1)) || this;
      Object.setPrototypeOf(_this, RotateMatrix2.prototype);
      return _this;
    }
    RotateMatrix2.prototype.inverse = function() {
      return this.transpose();
    };
    return RotateMatrix2;
  }(Matrix)
);
var ScaleMatrix = (
  /** @class */
  function(_super) {
    __extends3(ScaleMatrix2, _super);
    function ScaleMatrix2(sx, sy) {
      var _this = _super.call(this, new Vector(sx, 0, 0), new Vector(0, sy, 0), new Vector(0, 0, 1)) || this;
      _this.sx = sx;
      _this.sy = sy;
      Object.setPrototypeOf(_this, ScaleMatrix2.prototype);
      return _this;
    }
    ScaleMatrix2.prototype.inverse = function() {
      return new ScaleMatrix2(1 / this.sx, 1 / this.sy);
    };
    return ScaleMatrix2;
  }(Matrix)
);
var TranslateMatrix = (
  /** @class */
  function(_super) {
    __extends3(TranslateMatrix2, _super);
    function TranslateMatrix2(tx, ty) {
      var _this = _super.call(this, new Vector(1, 0, 0), new Vector(0, 1, 0), new Vector(tx, ty, 1)) || this;
      _this.tx = tx;
      _this.ty = ty;
      Object.setPrototypeOf(_this, TranslateMatrix2.prototype);
      return _this;
    }
    TranslateMatrix2.prototype.inverse = function() {
      return new TranslateMatrix2(-this.tx, -this.ty);
    };
    return TranslateMatrix2;
  }(Matrix)
);

// node_modules/@logicflow/core/es/util/mobx.js
configure({ isolateGlobalState: true });

// node_modules/@logicflow/core/es/util/node.js
var __assign3 = function() {
  __assign3 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign3.apply(this, arguments);
};
var getAnchors = function(data) {
  var anchors = data.anchors;
  return anchors;
};
var targetNodeInfo = function(position, graphModel) {
  var nodes = graphModel.nodes;
  var nodeInfo;
  for (var i4 = nodes.length - 1; i4 >= 0; i4--) {
    var targetNode = nodes[i4];
    var inNode = isInNodeBbox(position, targetNode);
    if (inNode) {
      var anchorInfo = targetNode.getTargetAnchor(position);
      if (anchorInfo) {
        var currentNodeInfo = {
          node: targetNode,
          anchorIndex: anchorInfo.index,
          anchor: anchorInfo.anchor
        };
        if (!nodeInfo || isNodeHigher(targetNode, nodeInfo.node, graphModel)) {
          nodeInfo = currentNodeInfo;
        }
      }
    }
  }
  return nodeInfo;
};
var isNodeHigher = function(node1, node2, graphModel) {
  if (node1.zIndex > node2.zIndex) {
    return true;
  }
  return graphModel.nodesMap[node1.id].index > graphModel.nodesMap[node2.id].index;
};
var getClosestAnchor = function(position, node) {
  var anchors = getAnchors(node);
  var closest;
  var minDistance = Number.MAX_SAFE_INTEGER;
  for (var i4 = 0; i4 < anchors.length; i4++) {
    var len = distance(position.x, position.y, anchors[i4].x, anchors[i4].y);
    if (len < minDistance) {
      minDistance = len;
      closest = {
        index: i4,
        anchor: __assign3(__assign3({}, anchors[i4]), { x: anchors[i4].x, y: anchors[i4].y, id: anchors[i4].id })
      };
    }
  }
  return closest;
};
var distance = function(x1, y1, x22, y22) {
  return Math.hypot(x1 - x22, y1 - y22);
};
var isInNode = function(position, node) {
  var inNode = false;
  var offset = 0;
  var bBox = getNodeBBox(node);
  if (position.x >= bBox.minX - offset && position.x <= bBox.maxX + offset && position.y >= bBox.minY - offset && position.y <= bBox.maxY + offset) {
    inNode = true;
  }
  return inNode;
};
var isInNodeBbox = function(position, node) {
  var inNode = false;
  var offset = 5;
  var bBox = getNodeBBox(node);
  if (position.x >= bBox.minX - offset && position.x <= bBox.maxX + offset && position.y >= bBox.minY - offset && position.y <= bBox.maxY + offset) {
    inNode = true;
  }
  return inNode;
};
var getNodeBBox = function(node) {
  var x3 = node.x, y3 = node.y, width = node.width, height = node.height;
  return {
    minX: x3 - width / 2,
    minY: y3 - height / 2,
    maxX: x3 + width / 2,
    maxY: y3 + height / 2,
    x: x3,
    y: y3,
    width,
    height,
    centerX: x3,
    centerY: y3
  };
};
var getRectRadiusCircle = function(node) {
  var _a2 = node, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height, radius = _a2.radius;
  return [
    {
      x: x3 - width / 2 + radius,
      y: y3 - height / 2 + radius,
      r: radius
    },
    {
      x: x3 + width / 2 - radius,
      y: y3 - height / 2 + radius,
      r: radius
    },
    {
      x: x3 - width / 2 + radius,
      y: y3 + height / 2 - radius,
      r: radius
    },
    {
      x: x3 + width / 2 - radius,
      y: y3 + height / 2 - radius,
      r: radius
    }
  ];
};
var getClosestRadiusCenter = function(point, direction, node) {
  var radiusCenter = getRectRadiusCircle(node);
  var closestRadiusPoint;
  var minDistance = Number.MAX_SAFE_INTEGER;
  radiusCenter.forEach(function(item) {
    var radiusDistance = distance(point.x, point.y, item.x, item.y);
    if (radiusDistance < minDistance) {
      minDistance = radiusDistance;
      closestRadiusPoint = item;
    }
  });
  return getCrossPointWithCircle(point, direction, closestRadiusPoint);
};
var getCrossPointWithCircle = function(point, direction, node) {
  var crossPoint;
  var x3 = node.x, y3 = node.y, r3 = node.r;
  if (direction === SegmentDirection.HORIZONTAL) {
    var crossLeft = x3 - Math.sqrt(r3 * r3 - (point.y - y3) * (point.y - y3));
    var crossRight = x3 + Math.sqrt(r3 * r3 - (point.y - y3) * (point.y - y3));
    var crossX = Math.abs(crossLeft - point.x) < Math.abs(crossRight - point.x) ? crossLeft : crossRight;
    crossPoint = {
      x: crossX,
      y: point.y
    };
  } else if (direction === SegmentDirection.VERTICAL) {
    var crossTop = y3 - Math.sqrt(r3 * r3 - (point.x - x3) * (point.x - x3));
    var crossBottom = y3 + Math.sqrt(r3 * r3 - (point.x - x3) * (point.x - x3));
    var crossY = Math.abs(crossTop - point.y) < Math.abs(crossBottom - point.y) ? crossTop : crossBottom;
    crossPoint = {
      x: point.x,
      y: crossY
    };
  }
  return crossPoint;
};
var pointEdgeDirection = function(point, node) {
  var dx = Math.abs(point.x - node.x);
  var dy = Math.abs(point.y - node.y);
  return dx / node.width > dy / node.height ? SegmentDirection.VERTICAL : SegmentDirection.HORIZONTAL;
};
var inStraightLineOfRect = function(point, node) {
  var rect = node;
  var isInStraight = false;
  var x3 = rect.x, y3 = rect.y, width = rect.width, height = rect.height, radius = rect.radius;
  var rectBox = {
    minX: x3 - width / 2 + radius,
    maxX: x3 + width / 2 - radius,
    minY: y3 - height / 2 + radius,
    maxY: y3 + height / 2 - radius
  };
  if (point.y === y3 + height / 2 || point.y === y3 - height / 2) {
    isInStraight = point.x > rectBox.minX && point.x < rectBox.maxX;
  } else if (point.x === x3 + width / 2 || point.x === x3 - width / 2) {
    isInStraight = point.y > rectBox.minY && point.y < rectBox.maxY;
  }
  return isInStraight;
};
var getCrossPointWithEllipse = function(point, direction, node) {
  var crossPoint;
  var _a2 = node, x3 = _a2.x, y3 = _a2.y, rx = _a2.rx, ry = _a2.ry;
  if (direction === SegmentDirection.HORIZONTAL) {
    var crossLeft = x3 - Math.sqrt(rx * rx - (point.y - y3) * (point.y - y3) * rx * rx / (ry * ry));
    var crossRight = x3 + Math.sqrt(rx * rx - (point.y - y3) * (point.y - y3) * rx * rx / (ry * ry));
    var crossX = Math.abs(crossLeft - point.x) < Math.abs(crossRight - point.x) ? crossLeft : crossRight;
    crossPoint = {
      x: crossX,
      y: point.y
    };
  } else if (direction === SegmentDirection.VERTICAL) {
    var crossTop = y3 - Math.sqrt(ry * ry - (point.x - x3) * (point.x - x3) * ry * ry / (rx * rx));
    var crossBottom = y3 + Math.sqrt(ry * ry - (point.x - x3) * (point.x - x3) * ry * ry / (rx * rx));
    var crossY = Math.abs(crossTop - point.y) < Math.abs(crossBottom - point.y) ? crossTop : crossBottom;
    crossPoint = {
      x: point.x,
      y: crossY
    };
  }
  return crossPoint;
};
var getCrossPointWithPolygon = function(point, direction, node) {
  var pointsPosition = node.pointsPosition;
  var minDistance = Number.MAX_SAFE_INTEGER;
  var crossPoint;
  var segments = [];
  for (var i4 = 0; i4 < pointsPosition.length; i4++) {
    segments.push({
      start: pointsPosition[i4],
      end: pointsPosition[(i4 + 1) % pointsPosition.length]
    });
  }
  segments.forEach(function(item) {
    var start = item.start, end = item.end;
    var a3 = start;
    var b2 = end;
    if (start.x > end.x) {
      a3 = end;
      b2 = start;
    }
    var pointXY = {
      x: point.x,
      y: point.y
    };
    if (a3.x === b2.x && direction === SegmentDirection.HORIZONTAL) {
      pointXY = {
        x: a3.x,
        y: point.y
      };
    }
    if (a3.y === b2.y && direction === SegmentDirection.VERTICAL) {
      pointXY = {
        x: point.x,
        y: a3.y
      };
    }
    if (a3.x !== b2.x && a3.y !== b2.y) {
      var k3 = (b2.y - a3.y) / (b2.x - a3.x);
      var m3 = (a3.x * b2.y - b2.x * a3.y) / (a3.x - b2.x);
      if (direction === SegmentDirection.HORIZONTAL) {
        pointXY = {
          x: (point.y - m3) / k3,
          y: point.y
        };
      } else if (direction === SegmentDirection.VERTICAL) {
        pointXY = {
          x: point.x,
          y: k3 * point.x + m3
        };
      }
    }
    var inSegment = isInSegment(pointXY, start, end);
    if (inSegment) {
      var currentDistance = distance(pointXY.x, pointXY.y, point.x, point.y);
      if (currentDistance < minDistance) {
        minDistance = currentDistance;
        crossPoint = pointXY;
      }
    }
  });
  return crossPoint;
};
var pickNodeConfig = function(data) {
  var nodeData = pick_default(data, [
    "id",
    "type",
    "x",
    "y",
    "text",
    "label",
    "properties",
    "virtual",
    // dnd
    "rotate",
    // TODO: 
    "resizable",
    "rotatable"
  ]);
  return nodeData;
};
var getNodeAnchorPosition = function(center, point, width, height) {
  var x3 = center.x, y3 = center.y;
  if (point.x > center.x) {
    x3 = center.x + width / 2;
  } else if (point.x < center.x) {
    x3 = center.x - width / 2;
  }
  if (point.y > center.y) {
    y3 = center.y + height / 2;
  } else if (point.y < center.y) {
    y3 = center.y - height / 2;
  }
  return {
    x: x3,
    y: y3
  };
};
var getHtmlTextHeight = function(_a2) {
  var rows = _a2.rows, style = _a2.style, rowsLength = _a2.rowsLength, className = _a2.className;
  var dom = document.createElement("div");
  dom.className = className;
  dom.style.fontSize = "".concat(style.fontSize);
  dom.style.width = "".concat(style.width);
  dom.style.lineHeight = "".concat(style.lineHeight);
  dom.style.padding = "".concat(style.padding);
  if (style.fontFamily) {
    dom.style.fontFamily = "".concat(style.fontFamily);
  }
  if (rowsLength > 1) {
    rows.forEach(function(row) {
      var rowDom = document.createElement("div");
      rowDom.textContent = row;
      dom.appendChild(rowDom);
    });
  } else {
    dom.textContent = rows[0];
  }
  document.body.appendChild(dom);
  var height = dom.clientHeight;
  document.body.removeChild(dom);
  return height;
};
var getSvgTextWidthHeight = function(_a2) {
  var rows = _a2.rows, rowsLength = _a2.rowsLength, fontSize = _a2.fontSize;
  var longestBytes = 0;
  rows && rows.forEach(function(item) {
    var rowByteLength = getBytesLength(item);
    longestBytes = rowByteLength > longestBytes ? rowByteLength : longestBytes;
  });
  return {
    width: Math.ceil(longestBytes / 2) * fontSize + fontSize / 4,
    height: rowsLength * (fontSize + 2) + fontSize / 4
  };
};
var formatAnchorConnectValidateData = function(data) {
  if (typeof data !== "object") {
    return {
      isAllPass: !!data,
      msg: data ? "" : ""
    };
  }
  return data;
};

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i4 = 0; i4 < 256; ++i4) {
  byteToHex.push((i4 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v6;
  const arr = new Uint8Array(16);
  arr[0] = (v6 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v6 >>> 16 & 255;
  arr[2] = v6 >>> 8 & 255;
  arr[3] = v6 & 255;
  arr[4] = (v6 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v6 & 255;
  arr[6] = (v6 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v6 & 255;
  arr[8] = (v6 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v6 & 255;
  arr[10] = (v6 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v6 / 4294967296 & 255;
  arr[12] = v6 >>> 24 & 255;
  arr[13] = v6 >>> 16 & 255;
  arr[14] = v6 >>> 8 & 255;
  arr[15] = v6 & 255;
  return arr;
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i4 = 0; i4 < str.length; ++i4) {
    bytes.push(str.charCodeAt(i4));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i4 = 0; i4 < 16; ++i4) {
        buf[offset + i4] = bytes[i4];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i4 = 0; i4 < msg.length; ++i4) {
      bytes[i4] = msg.charCodeAt(i4);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i4 = 0; i4 < length32; i4 += 8) {
    const x3 = input[i4 >> 5] >>> i4 % 32 & 255;
    const hex = parseInt(hexTab.charAt(x3 >>> 4 & 15) + hexTab.charAt(x3 & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x3, len) {
  x3[len >> 5] |= 128 << len % 32;
  x3[getOutputLength(len) - 1] = len;
  let a3 = 1732584193;
  let b2 = -271733879;
  let c3 = -1732584194;
  let d2 = 271733878;
  for (let i4 = 0; i4 < x3.length; i4 += 16) {
    const olda = a3;
    const oldb = b2;
    const oldc = c3;
    const oldd = d2;
    a3 = md5ff(a3, b2, c3, d2, x3[i4], 7, -680876936);
    d2 = md5ff(d2, a3, b2, c3, x3[i4 + 1], 12, -389564586);
    c3 = md5ff(c3, d2, a3, b2, x3[i4 + 2], 17, 606105819);
    b2 = md5ff(b2, c3, d2, a3, x3[i4 + 3], 22, -1044525330);
    a3 = md5ff(a3, b2, c3, d2, x3[i4 + 4], 7, -176418897);
    d2 = md5ff(d2, a3, b2, c3, x3[i4 + 5], 12, 1200080426);
    c3 = md5ff(c3, d2, a3, b2, x3[i4 + 6], 17, -1473231341);
    b2 = md5ff(b2, c3, d2, a3, x3[i4 + 7], 22, -45705983);
    a3 = md5ff(a3, b2, c3, d2, x3[i4 + 8], 7, 1770035416);
    d2 = md5ff(d2, a3, b2, c3, x3[i4 + 9], 12, -1958414417);
    c3 = md5ff(c3, d2, a3, b2, x3[i4 + 10], 17, -42063);
    b2 = md5ff(b2, c3, d2, a3, x3[i4 + 11], 22, -1990404162);
    a3 = md5ff(a3, b2, c3, d2, x3[i4 + 12], 7, 1804603682);
    d2 = md5ff(d2, a3, b2, c3, x3[i4 + 13], 12, -40341101);
    c3 = md5ff(c3, d2, a3, b2, x3[i4 + 14], 17, -1502002290);
    b2 = md5ff(b2, c3, d2, a3, x3[i4 + 15], 22, 1236535329);
    a3 = md5gg(a3, b2, c3, d2, x3[i4 + 1], 5, -165796510);
    d2 = md5gg(d2, a3, b2, c3, x3[i4 + 6], 9, -1069501632);
    c3 = md5gg(c3, d2, a3, b2, x3[i4 + 11], 14, 643717713);
    b2 = md5gg(b2, c3, d2, a3, x3[i4], 20, -373897302);
    a3 = md5gg(a3, b2, c3, d2, x3[i4 + 5], 5, -701558691);
    d2 = md5gg(d2, a3, b2, c3, x3[i4 + 10], 9, 38016083);
    c3 = md5gg(c3, d2, a3, b2, x3[i4 + 15], 14, -660478335);
    b2 = md5gg(b2, c3, d2, a3, x3[i4 + 4], 20, -405537848);
    a3 = md5gg(a3, b2, c3, d2, x3[i4 + 9], 5, 568446438);
    d2 = md5gg(d2, a3, b2, c3, x3[i4 + 14], 9, -1019803690);
    c3 = md5gg(c3, d2, a3, b2, x3[i4 + 3], 14, -187363961);
    b2 = md5gg(b2, c3, d2, a3, x3[i4 + 8], 20, 1163531501);
    a3 = md5gg(a3, b2, c3, d2, x3[i4 + 13], 5, -1444681467);
    d2 = md5gg(d2, a3, b2, c3, x3[i4 + 2], 9, -51403784);
    c3 = md5gg(c3, d2, a3, b2, x3[i4 + 7], 14, 1735328473);
    b2 = md5gg(b2, c3, d2, a3, x3[i4 + 12], 20, -1926607734);
    a3 = md5hh(a3, b2, c3, d2, x3[i4 + 5], 4, -378558);
    d2 = md5hh(d2, a3, b2, c3, x3[i4 + 8], 11, -2022574463);
    c3 = md5hh(c3, d2, a3, b2, x3[i4 + 11], 16, 1839030562);
    b2 = md5hh(b2, c3, d2, a3, x3[i4 + 14], 23, -35309556);
    a3 = md5hh(a3, b2, c3, d2, x3[i4 + 1], 4, -1530992060);
    d2 = md5hh(d2, a3, b2, c3, x3[i4 + 4], 11, 1272893353);
    c3 = md5hh(c3, d2, a3, b2, x3[i4 + 7], 16, -155497632);
    b2 = md5hh(b2, c3, d2, a3, x3[i4 + 10], 23, -1094730640);
    a3 = md5hh(a3, b2, c3, d2, x3[i4 + 13], 4, 681279174);
    d2 = md5hh(d2, a3, b2, c3, x3[i4], 11, -358537222);
    c3 = md5hh(c3, d2, a3, b2, x3[i4 + 3], 16, -722521979);
    b2 = md5hh(b2, c3, d2, a3, x3[i4 + 6], 23, 76029189);
    a3 = md5hh(a3, b2, c3, d2, x3[i4 + 9], 4, -640364487);
    d2 = md5hh(d2, a3, b2, c3, x3[i4 + 12], 11, -421815835);
    c3 = md5hh(c3, d2, a3, b2, x3[i4 + 15], 16, 530742520);
    b2 = md5hh(b2, c3, d2, a3, x3[i4 + 2], 23, -995338651);
    a3 = md5ii(a3, b2, c3, d2, x3[i4], 6, -198630844);
    d2 = md5ii(d2, a3, b2, c3, x3[i4 + 7], 10, 1126891415);
    c3 = md5ii(c3, d2, a3, b2, x3[i4 + 14], 15, -1416354905);
    b2 = md5ii(b2, c3, d2, a3, x3[i4 + 5], 21, -57434055);
    a3 = md5ii(a3, b2, c3, d2, x3[i4 + 12], 6, 1700485571);
    d2 = md5ii(d2, a3, b2, c3, x3[i4 + 3], 10, -1894986606);
    c3 = md5ii(c3, d2, a3, b2, x3[i4 + 10], 15, -1051523);
    b2 = md5ii(b2, c3, d2, a3, x3[i4 + 1], 21, -2054922799);
    a3 = md5ii(a3, b2, c3, d2, x3[i4 + 8], 6, 1873313359);
    d2 = md5ii(d2, a3, b2, c3, x3[i4 + 15], 10, -30611744);
    c3 = md5ii(c3, d2, a3, b2, x3[i4 + 6], 15, -1560198380);
    b2 = md5ii(b2, c3, d2, a3, x3[i4 + 13], 21, 1309151649);
    a3 = md5ii(a3, b2, c3, d2, x3[i4 + 4], 6, -145523070);
    d2 = md5ii(d2, a3, b2, c3, x3[i4 + 11], 10, -1120210379);
    c3 = md5ii(c3, d2, a3, b2, x3[i4 + 2], 15, 718787259);
    b2 = md5ii(b2, c3, d2, a3, x3[i4 + 9], 21, -343485551);
    a3 = safeAdd(a3, olda);
    b2 = safeAdd(b2, oldb);
    c3 = safeAdd(c3, oldc);
    d2 = safeAdd(d2, oldd);
  }
  return [a3, b2, c3, d2];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i4 = 0; i4 < length8; i4 += 8) {
    output[i4 >> 5] |= (input[i4 / 8] & 255) << i4 % 32;
  }
  return output;
}
function safeAdd(x3, y3) {
  const lsw = (x3 & 65535) + (y3 & 65535);
  const msw = (x3 >> 16) + (y3 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q4, a3, b2, x3, s3, t3) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a3, q4), safeAdd(x3, t3)), s3), b2);
}
function md5ff(a3, b2, c3, d2, x3, s3, t3) {
  return md5cmn(b2 & c3 | ~b2 & d2, a3, b2, x3, s3, t3);
}
function md5gg(a3, b2, c3, d2, x3, s3, t3) {
  return md5cmn(b2 & d2 | c3 & ~d2, a3, b2, x3, s3, t3);
}
function md5hh(a3, b2, c3, d2, x3, s3, t3) {
  return md5cmn(b2 ^ c3 ^ d2, a3, b2, x3, s3, t3);
}
function md5ii(a3, b2, c3, d2, x3, s3, t3) {
  return md5cmn(c3 ^ (b2 | ~d2), a3, b2, x3, s3, t3);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i4 = 0; i4 < 16; ++i4) {
      buf[offset + i4] = rnds[i4];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f4(s3, x3, y3, z3) {
  switch (s3) {
    case 0:
      return x3 & y3 ^ ~x3 & z3;
    case 1:
      return x3 ^ y3 ^ z3;
    case 2:
      return x3 & y3 ^ x3 & z3 ^ y3 & z3;
    case 3:
      return x3 ^ y3 ^ z3;
  }
}
function ROTL(x3, n2) {
  return x3 << n2 | x3 >>> 32 - n2;
}
function sha1(bytes) {
  const K2 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H3 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i4 = 0; i4 < msg.length; ++i4) {
      bytes.push(msg.charCodeAt(i4));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l3 = bytes.length / 4 + 2;
  const N3 = Math.ceil(l3 / 16);
  const M2 = new Array(N3);
  for (let i4 = 0; i4 < N3; ++i4) {
    const arr = new Uint32Array(16);
    for (let j4 = 0; j4 < 16; ++j4) {
      arr[j4] = bytes[i4 * 64 + j4 * 4] << 24 | bytes[i4 * 64 + j4 * 4 + 1] << 16 | bytes[i4 * 64 + j4 * 4 + 2] << 8 | bytes[i4 * 64 + j4 * 4 + 3];
    }
    M2[i4] = arr;
  }
  M2[N3 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M2[N3 - 1][14] = Math.floor(M2[N3 - 1][14]);
  M2[N3 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i4 = 0; i4 < N3; ++i4) {
    const W2 = new Uint32Array(80);
    for (let t3 = 0; t3 < 16; ++t3) {
      W2[t3] = M2[i4][t3];
    }
    for (let t3 = 16; t3 < 80; ++t3) {
      W2[t3] = ROTL(W2[t3 - 3] ^ W2[t3 - 8] ^ W2[t3 - 14] ^ W2[t3 - 16], 1);
    }
    let a3 = H3[0];
    let b2 = H3[1];
    let c3 = H3[2];
    let d2 = H3[3];
    let e3 = H3[4];
    for (let t3 = 0; t3 < 80; ++t3) {
      const s3 = Math.floor(t3 / 20);
      const T4 = ROTL(a3, 5) + f4(s3, b2, c3, d2) + e3 + K2[s3] + W2[t3] >>> 0;
      e3 = d2;
      d2 = c3;
      c3 = ROTL(b2, 30) >>> 0;
      b2 = a3;
      a3 = T4;
    }
    H3[0] = H3[0] + a3 >>> 0;
    H3[1] = H3[1] + b2 >>> 0;
    H3[2] = H3[2] + c3 >>> 0;
    H3[3] = H3[3] + d2 >>> 0;
    H3[4] = H3[4] + e3 >>> 0;
  }
  return [H3[0] >> 24 & 255, H3[0] >> 16 & 255, H3[0] >> 8 & 255, H3[0] & 255, H3[1] >> 24 & 255, H3[1] >> 16 & 255, H3[1] >> 8 & 255, H3[1] & 255, H3[2] >> 24 & 255, H3[2] >> 16 & 255, H3[2] >> 8 & 255, H3[2] & 255, H3[3] >> 24 & 255, H3[3] >> 16 & 255, H3[3] >> 8 & 255, H3[3] & 255, H3[4] >> 24 & 255, H3[4] >> 16 & 255, H3[4] >> 8 & 255, H3[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/@logicflow/core/es/util/uuid.js
var createUuid = function() {
  return v4_default();
};
var refreshGraphId = function(graphData, prefix) {
  if (prefix === void 0) {
    prefix = "";
  }
  var nodeIdMap = graphData.nodes.reduce(function(nMap, node) {
    nMap[node.id] = prefix + v4_default();
    node.id = nMap[node.id];
    return nMap;
  }, {});
  graphData.edges.forEach(function(edge) {
    edge.id = prefix + v4_default();
    edge.sourceNodeId = nodeIdMap[edge.sourceNodeId];
    edge.targetNodeId = nodeIdMap[edge.targetNodeId];
  });
  return graphData;
};

// node_modules/@logicflow/core/es/util/raf.js
var rafIdMap = /* @__PURE__ */ new Map();
var createRaf = function(callback) {
  var rafId = createUuid();
  function run2() {
    callback();
    var eId = rafIdMap.get(rafId);
    if (eId) {
      var nId = window.requestAnimationFrame(run2);
      rafIdMap.set(rafId, nId);
    }
  }
  var id = window.requestAnimationFrame(run2);
  rafIdMap.set(rafId, id);
  return rafId;
};
var cancelRaf = function(rafId) {
  var eId = rafIdMap.get(rafId);
  if (eId) {
    window.cancelAnimationFrame(eId);
    rafIdMap.delete(rafId);
  }
};

// node_modules/@logicflow/core/es/view/shape/Text.js
var __assign4 = function() {
  __assign4 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign4.apply(this, arguments);
};
var __read6 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
function Text(props) {
  var _a2 = props.x, x3 = _a2 === void 0 ? 0 : _a2, _b = props.y, y3 = _b === void 0 ? 0 : _b, value = props.value, _c = props.fontSize, fontSize = _c === void 0 ? 12 : _c, _d = props.fill, fill = _d === void 0 ? "currentColor" : _d, _e = props.overflowMode, overflowMode = _e === void 0 ? "default" : _e, _f = props.textWidth, textWidth = _f === void 0 ? void 0 : _f, model = props.model;
  var attrs = {
    x: x3,
    y: y3,
    fill,
    fontSize,
    textAnchor: "middle",
    dominantBaseline: "central"
    // ...props,
  };
  forEach_default(toPairs_default(props), function(_a3) {
    var _b2 = __read6(_a3, 2), k3 = _b2[0], v6 = _b2[1];
    if (typeof v6 !== "object") {
      attrs[k3] = v6;
    }
  });
  if (value) {
    var rows = String(value).split(/[\r\n]/g);
    var rowsLength_1 = rows.length;
    if (overflowMode !== "default") {
      var BaseType = model.BaseType, modelType = model.modelType;
      if (BaseType === ElementType.NODE && modelType !== ModelType.TEXT_NODE || BaseType === ElementType.EDGE && textWidth) {
        return renderHtmlText(props);
      }
    }
    if (rowsLength_1 > 1) {
      var tSpans = rows.map(function(row, idx) {
        var tSpanLineHeight = fontSize + 2;
        var offsetY = (idx - (rowsLength_1 - 1) / 2) * tSpanLineHeight;
        return u3("tspan", { className: "lf-text-tspan", x: x3, y: y3 + offsetY, children: row });
      });
      return u3("text", __assign4({}, attrs, { children: tSpans }));
    }
    return u3("text", __assign4({}, attrs, { children: value }));
  }
  return null;
}
function renderHtmlText(props) {
  var x3 = props.x, y3 = props.y, value = props.value, model = props.model, textWidth = props.textWidth, _a2 = props.fontSize, fontSize = _a2 === void 0 ? 12 : _a2, lineHeight = props.lineHeight, _b = props.fontFamily, fontFamily = _b === void 0 ? "" : _b, _c = props.wrapPadding, wrapPadding = _c === void 0 ? "0, 0" : _c, overflowMode = props.overflowMode;
  var width = model.width, height = model.height, textHeight = model.textHeight;
  var textRealWidth = textWidth || width;
  var rows = String(value).split(/[\r\n]/g);
  var rowsLength = rows.length;
  var textRealHeight = getHtmlTextHeight({
    rows,
    style: {
      fontSize: "".concat(fontSize, "px"),
      width: "".concat(textRealWidth, "px"),
      fontFamily,
      lineHeight,
      padding: wrapPadding
    },
    rowsLength,
    className: "lf-get-text-height"
  });
  var foreignObjectHeight = height > textRealHeight ? height : textRealHeight;
  if (textHeight) {
    foreignObjectHeight = textHeight;
  }
  var isEllipsis = overflowMode === "ellipsis";
  if (isEllipsis) {
    foreignObjectHeight = fontSize + 2;
  }
  return u3("g", { children: u3("foreignObject", { width: textRealWidth, height: foreignObjectHeight, x: x3 - textRealWidth / 2, y: y3 - foreignObjectHeight / 2, style: { overflow: "visible", textAlign: "left" }, children: u3("div", { className: "lf-node-text-auto-wrap", style: {
    minHeight: foreignObjectHeight,
    width: textRealWidth,
    padding: wrapPadding
  }, children: u3("div", { className: isEllipsis ? "lf-node-text-ellipsis-content" : "lf-node-text-auto-wrap-content", title: isEllipsis ? rows.join("") : "", style: __assign4({}, props), children: rows.map(function(row) {
    return u3("div", { className: "lf-node-text--auto-wrap-inner", children: row });
  }) }) }) }) });
}

// node_modules/@logicflow/core/es/view/shape/Line.js
var __assign5 = function() {
  __assign5 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign5.apply(this, arguments);
};
var __read7 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
function Line(props) {
  var attrs = {
    // default
    x1: 10,
    y1: 10,
    x2: 20,
    y2: 20,
    stroke: "black"
    // ...props
  };
  forEach_default(toPairs_default(props), function(_a2) {
    var _b = __read7(_a2, 2), k3 = _b[0], v6 = _b[1];
    if (k3 === "style") {
      attrs[k3] = v6;
    } else if (typeof v6 !== "object") {
      attrs[k3] = v6;
    }
  });
  return u3("line", __assign5({}, attrs));
}
var Line_default = Line;

// node_modules/@logicflow/core/es/view/shape/Rect.js
var __assign6 = function() {
  __assign6 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign6.apply(this, arguments);
};
var __read8 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
function Rect(props) {
  var x3 = props.x, y3 = props.y, width = props.width, height = props.height, className = props.className, strokeWidth = props.strokeWidth, _a2 = props.radius, radius = _a2 === void 0 ? 0 : _a2;
  var leftTopX = x3 - width / 2;
  var leftTopY = y3 - height / 2;
  var attrs = {};
  attrs["stroke-width"] = strokeWidth;
  forEach_default(toPairs_default(props), function(_a3) {
    var _b = __read8(_a3, 2), k3 = _b[0], v6 = _b[1];
    if (typeof v6 !== "object") {
      attrs[k3] = v6;
    }
  });
  if (className) {
    attrs.className = "lf-basic-shape ".concat(className);
  } else {
    attrs.className = "lf-basic-shape";
  }
  if (radius) {
    attrs.rx = radius;
    attrs.ry = radius;
  }
  attrs.x = leftTopX;
  attrs.y = leftTopY;
  return u3("rect", __assign6({}, attrs));
}
var Rect_default = Rect;

// node_modules/@logicflow/core/es/view/shape/Path.js
var __assign7 = function() {
  __assign7 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign7.apply(this, arguments);
};
var __read9 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
function Path(props) {
  var attrs = {
    d: ""
  };
  forEach_default(toPairs_default(props), function(_a2) {
    var _b = __read9(_a2, 2), k3 = _b[0], v6 = _b[1];
    if (k3 === "style" || typeof v6 !== "object") {
      attrs[k3] = v6;
    }
  });
  return u3("path", __assign7({}, attrs));
}

// node_modules/@logicflow/core/es/view/shape/Circle.js
var __assign8 = function() {
  __assign8 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign8.apply(this, arguments);
};
var __read10 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
function Circle(props) {
  var _a2 = props.x, x3 = _a2 === void 0 ? 0 : _a2, _b = props.y, y3 = _b === void 0 ? 0 : _b, _c = props.r, r3 = _c === void 0 ? 4 : _c, className = props.className;
  var attrs = {
    cx: x3,
    cy: y3,
    r: r3,
    fill: "transparent",
    fillOpacity: 1,
    strokeWidth: 1,
    stroke: "#000",
    strokeOpacity: 1
  };
  forEach_default(toPairs_default(props), function(_a3) {
    var _b2 = __read10(_a3, 2), k3 = _b2[0], v6 = _b2[1];
    if (typeof v6 !== "object") {
      attrs[k3] = v6;
    }
  });
  if (className) {
    attrs.className = "lf-basic-shape ".concat(className);
  } else {
    attrs.className = "lf-basic-shape";
  }
  return u3("circle", __assign8({}, attrs));
}
var Circle_default = Circle;

// node_modules/@logicflow/core/es/view/shape/Ellipse.js
var __assign9 = function() {
  __assign9 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign9.apply(this, arguments);
};
var __read11 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
function Ellipse(props) {
  var _a2 = props.x, x3 = _a2 === void 0 ? 0 : _a2, _b = props.y, y3 = _b === void 0 ? 0 : _b, _c = props.rx, rx = _c === void 0 ? 4 : _c, _d = props.ry, ry = _d === void 0 ? 4 : _d, className = props.className;
  var attrs = {
    cx: x3,
    cy: y3,
    rx,
    ry,
    fill: "transparent",
    fillOpacity: 1,
    strokeWidth: 1,
    stroke: "#000",
    strokeOpacity: 1
  };
  forEach_default(toPairs_default(props), function(_a3) {
    var _b2 = __read11(_a3, 2), k3 = _b2[0], v6 = _b2[1];
    if (typeof v6 !== "object") {
      attrs[k3] = v6;
    }
  });
  if (className) {
    attrs.className = "lf-basic-shape ".concat(className);
  } else {
    attrs.className = "lf-basic-shape";
  }
  return u3("ellipse", __assign9({}, attrs));
}
var Ellipse_default = Ellipse;

// node_modules/@logicflow/core/es/view/shape/Polygon.js
var __assign10 = function() {
  __assign10 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign10.apply(this, arguments);
};
var __read12 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
function Polygon(props) {
  var _a2 = props.points, points = _a2 === void 0 ? [] : _a2, className = props.className;
  var attrs = {
    fill: "transparent",
    fillOpacity: 1,
    strokeWidth: 1,
    stroke: "#000",
    strokeOpacity: 1,
    points: ""
  };
  forEach_default(toPairs_default(props), function(_a3) {
    var _b = __read12(_a3, 2), k3 = _b[0], v6 = _b[1];
    if (typeof v6 !== "object") {
      attrs[k3] = v6;
    }
  });
  if (className) {
    attrs.classNmae = "lf-basic-shape ".concat(className);
  } else {
    attrs.className = "lf-basic-shape";
  }
  attrs.points = points.map(function(point) {
    return point.join(",");
  }).join(" ");
  return u3("polygon", __assign10({}, attrs));
}
var Polygon_default = Polygon;

// node_modules/@logicflow/core/es/view/shape/Polyline.js
var __assign11 = function() {
  __assign11 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign11.apply(this, arguments);
};
var __read13 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
function Polyline(props) {
  var className = props.className;
  var attrs = {
    points: "",
    fill: "none"
  };
  forEach_default(toPairs_default(props), function(_a2) {
    var _b = __read13(_a2, 2), k3 = _b[0], v6 = _b[1];
    if (k3 === "style") {
      attrs[k3] = v6;
    } else if (typeof v6 !== "object") {
      attrs[k3] = v6;
    }
  });
  if (className) {
    attrs.className = "".concat(className);
  }
  return u3("polyline", __assign11({}, attrs));
}

// node_modules/@logicflow/core/es/view/Control.js
var __extends4 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign12 = function() {
  __assign12 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign12.apply(this, arguments);
};
var __rest2 = function(s3, e3) {
  var t3 = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t3[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p3 = Object.getOwnPropertySymbols(s3); i4 < p3.length; i4++) {
      if (e3.indexOf(p3[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i4]))
        t3[p3[i4]] = s3[p3[i4]];
    }
  return t3;
};
var __read14 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var ResizeControlIndex;
(function(ResizeControlIndex2) {
  ResizeControlIndex2[ResizeControlIndex2["LEFT_TOP"] = 0] = "LEFT_TOP";
  ResizeControlIndex2[ResizeControlIndex2["RIGHT_TOP"] = 1] = "RIGHT_TOP";
  ResizeControlIndex2[ResizeControlIndex2["RIGHT_BOTTOM"] = 2] = "RIGHT_BOTTOM";
  ResizeControlIndex2[ResizeControlIndex2["LEFT_BOTTOM"] = 3] = "LEFT_BOTTOM";
})(ResizeControlIndex || (ResizeControlIndex = {}));
var ResizeControl = (
  /** @class */
  function(_super) {
    __extends4(ResizeControl2, _super);
    function ResizeControl2(props) {
      var _this = _super.call(this) || this;
      _this.updateEdgePointByAnchors = function() {
        var _a2 = _this.nodeModel, id = _a2.id, anchors = _a2.anchors;
        var edges = _this.graphModel.getNodeEdges(id);
        forEach_default(edges, function(edge) {
          if (edge.sourceNodeId === id) {
            var anchorItem = find_default(anchors, function(anchor) {
              return anchor.id === edge.sourceAnchorId;
            });
            if (anchorItem) {
              edge.updateStartPoint({
                x: anchorItem.x,
                y: anchorItem.y
              });
            }
          } else if (edge.targetNodeId === id) {
            var anchorItem = find_default(anchors, function(anchor) {
              return anchor.id === edge.targetAnchorId;
            });
            if (anchorItem) {
              edge.updateEndPoint({
                x: anchorItem.x,
                y: anchorItem.y
              });
            }
          }
        });
      };
      _this.triggerResizeEvent = function(preNodeData, curNodeData, deltaX, deltaY, index2, nodeModel) {
        _this.graphModel.eventCenter.emit(EventType.NODE_RESIZE, {
          preData: preNodeData,
          data: curNodeData,
          deltaX,
          deltaY,
          index: index2,
          model: nodeModel
        });
      };
      _this.recalcResizeInfo = function(index2, resizeInfo, pct, freezeWidth, freezeHeight) {
        if (pct === void 0) {
          pct = 1;
        }
        if (freezeWidth === void 0) {
          freezeWidth = false;
        }
        if (freezeHeight === void 0) {
          freezeHeight = false;
        }
        var nextResizeInfo = cloneDeep_default(resizeInfo);
        var deltaX = nextResizeInfo.deltaX, deltaY = nextResizeInfo.deltaY;
        var width = nextResizeInfo.width, height = nextResizeInfo.height, PCTResizeInfo = nextResizeInfo.PCTResizeInfo;
        if (PCTResizeInfo) {
          var sensitivity = 4;
          var deltaScale = 0;
          var combineDelta = 0;
          switch (index2) {
            case ResizeControlIndex.LEFT_TOP:
              combineDelta = (deltaX * -1 - deltaY) / sensitivity;
              break;
            case ResizeControlIndex.RIGHT_TOP:
              combineDelta = (deltaX - deltaY) / sensitivity;
              break;
            case ResizeControlIndex.RIGHT_BOTTOM:
              combineDelta = (deltaX + deltaY) / sensitivity;
              break;
            case ResizeControlIndex.LEFT_BOTTOM:
              combineDelta = (deltaX * -1 + deltaY) / sensitivity;
              break;
            default:
              break;
          }
          if (combineDelta !== 0) {
            deltaScale = Math.round(combineDelta / PCTResizeInfo.ResizeBasis.basisHeight * 1e5) / 1e3;
          }
          PCTResizeInfo.ResizePCT.widthPCT = Math.max(Math.min(PCTResizeInfo.ResizePCT.widthPCT + deltaScale, PCTResizeInfo.ScaleLimit.maxScaleLimit), PCTResizeInfo.ScaleLimit.minScaleLimit);
          PCTResizeInfo.ResizePCT.heightPCT = Math.max(Math.min(PCTResizeInfo.ResizePCT.heightPCT + deltaScale, PCTResizeInfo.ScaleLimit.maxScaleLimit), PCTResizeInfo.ScaleLimit.minScaleLimit);
          var spcWidth = Math.round(PCTResizeInfo.ResizePCT.widthPCT * PCTResizeInfo.ResizeBasis.basisWidth / 100);
          var spcHeight = Math.round(PCTResizeInfo.ResizePCT.heightPCT * PCTResizeInfo.ResizeBasis.basisHeight / 100);
          switch (index2) {
            case ResizeControlIndex.LEFT_TOP:
              deltaX = width - spcWidth;
              deltaY = height - spcHeight;
              break;
            case ResizeControlIndex.RIGHT_TOP:
              deltaX = spcWidth - width;
              deltaY = height - spcHeight;
              break;
            case ResizeControlIndex.RIGHT_BOTTOM:
              deltaX = spcWidth - width;
              deltaY = spcHeight - height;
              break;
            case ResizeControlIndex.LEFT_BOTTOM:
              deltaX = width - spcWidth;
              deltaY = spcHeight - height;
              break;
            default:
              break;
          }
          return nextResizeInfo;
        }
        switch (index2) {
          case ResizeControlIndex.LEFT_TOP:
            nextResizeInfo.width = freezeWidth ? width : width - deltaX * pct;
            nextResizeInfo.height = freezeHeight ? height : height - deltaY * pct;
            break;
          case ResizeControlIndex.RIGHT_TOP:
            nextResizeInfo.width = freezeWidth ? width : width + deltaX * pct;
            nextResizeInfo.height = freezeHeight ? height : height - deltaY * pct;
            break;
          case ResizeControlIndex.RIGHT_BOTTOM:
            nextResizeInfo.width = freezeWidth ? width : width + deltaX * pct;
            nextResizeInfo.height = freezeHeight ? height : height + deltaY * pct;
            break;
          case ResizeControlIndex.LEFT_BOTTOM:
            nextResizeInfo.width = freezeWidth ? width : width - deltaX * pct;
            nextResizeInfo.height = freezeHeight ? height : height + deltaY * pct;
            break;
          default:
            break;
        }
        return nextResizeInfo;
      };
      _this.resizeNode = function(_a2) {
        var deltaX = _a2.deltaX, deltaY = _a2.deltaY;
        var index2 = _this.index;
        var _b = _this.props, model2 = _b.model, graphModel2 = _b.graphModel, x3 = _b.x, y3 = _b.y;
        handleResize({
          x: x3,
          y: y3,
          deltaX,
          deltaY,
          index: index2,
          nodeModel: model2,
          graphModel: graphModel2,
          cancelCallback: function() {
            _this.dragHandler.cancelDrag();
          }
        });
      };
      _this.onDragging = function(_a2) {
        var deltaX = _a2.deltaX, deltaY = _a2.deltaY;
        var transformModel = _this.graphModel.transformModel;
        var _b = __read14(transformModel.fixDeltaXY(deltaX, deltaY), 2), dx = _b[0], dy = _b[1];
        _this.resizeNode({
          deltaX: dx,
          deltaY: dy
        });
      };
      _this.onDragEnd = function() {
        var x3 = _this.nodeModel.x;
        var y3 = _this.nodeModel.y;
        _this.nodeModel.moveTo(x3, y3);
        _this.updateEdgePointByAnchors();
      };
      var index = props.index, model = props.model, graphModel = props.graphModel;
      _this.index = index;
      _this.nodeModel = model;
      _this.graphModel = graphModel;
      _this.dragHandler = new StepDrag({
        onDragging: _this.onDragging,
        onDragEnd: _this.onDragEnd,
        step: graphModel.gridSize
      });
      return _this;
    }
    ResizeControl2.prototype.componentWillUnmount = function() {
      this.dragHandler.destroy();
    };
    ResizeControl2.prototype.render = function() {
      var _a2 = this.props, x3 = _a2.x, y3 = _a2.y, direction = _a2.direction, model = _a2.model;
      var _b = model.getResizeControlStyle(), width = _b.width, height = _b.height, restStyle = __rest2(_b, ["width", "height"]);
      return u3("g", { className: "lf-resize-control lf-resize-control-".concat(direction), children: [u3(Rect, __assign12({ className: "lf-resize-control-content", x: x3, y: y3, width: width !== null && width !== void 0 ? width : 7, height: height !== null && height !== void 0 ? height : 7 }, restStyle)), u3(Rect, { className: "lf-resize-control-content", x: x3, y: y3, width: 25, height: 25, fill: "transparent", stroke: "transparent", onMouseDown: this.dragHandler.handleMouseDown })] });
    };
    return ResizeControl2;
  }(x)
);
var ResizeControlGroup = (
  /** @class */
  function(_super) {
    __extends4(ResizeControlGroup2, _super);
    function ResizeControlGroup2() {
      return _super.call(this) || this;
    }
    ResizeControlGroup2.prototype.getResizeControl = function() {
      var _a2 = this.props, model = _a2.model, graphModel = _a2.graphModel;
      var _b = getNodeBBox(model), minX = _b.minX, minY = _b.minY, maxX = _b.maxX, maxY = _b.maxY;
      var controlList = [
        {
          index: ResizeControlIndex.LEFT_TOP,
          direction: "nw",
          x: minX,
          y: minY
        },
        // 
        {
          index: ResizeControlIndex.RIGHT_TOP,
          direction: "ne",
          x: maxX,
          y: minY
        },
        // 
        {
          index: ResizeControlIndex.RIGHT_BOTTOM,
          direction: "se",
          x: maxX,
          y: maxY
        },
        // 
        {
          index: ResizeControlIndex.LEFT_BOTTOM,
          direction: "sw",
          x: minX,
          y: maxY
        }
        // 
      ];
      return map_default(controlList, function(control) {
        return u3(ResizeControl, __assign12({}, control, { model, graphModel }));
      });
    };
    ResizeControlGroup2.prototype.getResizeOutline = function() {
      var model = this.props.model;
      var x3 = model.x, y3 = model.y, width = model.width, height = model.height;
      var style = model.getResizeOutlineStyle();
      return u3(Rect, __assign12({}, style, { x: x3, y: y3, width, height }));
    };
    ResizeControlGroup2.prototype.render = function() {
      return u3("g", { className: "lf-resize-control-group", children: [this.getResizeOutline(), this.getResizeControl()] });
    };
    return ResizeControlGroup2;
  }(x)
);
var Control_default = ResizeControlGroup;

// node_modules/@logicflow/core/es/algorithm/rotate.js
function getNewCenter(startPoint, endPoint) {
  var x1 = startPoint.x, y1 = startPoint.y;
  var x22 = endPoint.x, y22 = endPoint.y;
  var newCenter = {
    x: x1 + (x22 - x1) / 2,
    y: y1 + (y22 - y1) / 2
  };
  return newCenter;
}
function calculatePointAfterRotateAngle(p3, center, angle2) {
  var radian = angleToRadian(angle2);
  var dx = p3.x - center.x;
  var dy = p3.y - center.y;
  var x3 = dx * Math.cos(radian) - dy * Math.sin(radian) + center.x;
  var y3 = dx * Math.sin(radian) + dy * Math.cos(radian) + center.y;
  return {
    x: x3,
    y: y3
  };
}
function angleToRadian(angle2) {
  return angle2 * Math.PI / 180;
}
function radianToAngle(radian) {
  return radian / Math.PI * 180;
}

// node_modules/@logicflow/core/es/util/resize.js
function recalcRotatedResizeInfo(pct, resizeInfo, rotate, controlX, controlY, oldCenterX, oldCenterY, freezeWidth, freezeHeight) {
  if (freezeWidth === void 0) {
    freezeWidth = false;
  }
  if (freezeHeight === void 0) {
    freezeHeight = false;
  }
  var deltaX = resizeInfo.deltaX, deltaY = resizeInfo.deltaY, oldWidth = resizeInfo.width, oldHeight = resizeInfo.height;
  var angle2 = radianToAngle(rotate);
  var startZeroTouchControlPoint = {
    x: controlX,
    // controlx
    y: controlY
    // controly
  };
  var oldCenter = { x: oldCenterX, y: oldCenterY };
  var startRotatedTouchControlPoint = calculatePointAfterRotateAngle(startZeroTouchControlPoint, oldCenter, angle2);
  var endRotatedTouchControlPoint = {
    x: startRotatedTouchControlPoint.x + deltaX,
    y: startRotatedTouchControlPoint.y + deltaY
  };
  var _a2 = calculateWidthAndHeight(startRotatedTouchControlPoint, endRotatedTouchControlPoint, oldCenter, angle2, freezeWidth, freezeHeight, oldWidth, oldHeight), newWidth = _a2.width, newHeight = _a2.height, newCenter = _a2.center;
  resizeInfo.width = newWidth * pct;
  resizeInfo.height = newHeight * pct;
  resizeInfo.deltaX = (newCenter.x - oldCenter.x) * 2;
  resizeInfo.deltaY = (newCenter.y - oldCenter.y) * 2;
  return resizeInfo;
}
var recalcResizeInfo = function(index, resizeInfo, pct, freezeWidth, freezeHeight, rotate, controlX, controlY, oldCenterX, oldCenterY) {
  if (pct === void 0) {
    pct = 1;
  }
  if (freezeWidth === void 0) {
    freezeWidth = false;
  }
  if (freezeHeight === void 0) {
    freezeHeight = false;
  }
  if (rotate === void 0) {
    rotate = 0;
  }
  var nextResizeInfo = cloneDeep_default(resizeInfo);
  var deltaX = nextResizeInfo.deltaX, deltaY = nextResizeInfo.deltaY;
  var width = nextResizeInfo.width, height = nextResizeInfo.height, PCTResizeInfo = nextResizeInfo.PCTResizeInfo;
  if (PCTResizeInfo) {
    var sensitivity = 4;
    var deltaScale = 0;
    var combineDelta = 0;
    switch (index) {
      case ResizeControlIndex.LEFT_TOP:
        combineDelta = (deltaX * -1 - deltaY) / sensitivity;
        break;
      case ResizeControlIndex.RIGHT_TOP:
        combineDelta = (deltaX - deltaY) / sensitivity;
        break;
      case ResizeControlIndex.RIGHT_BOTTOM:
        combineDelta = (deltaX + deltaY) / sensitivity;
        break;
      case ResizeControlIndex.LEFT_BOTTOM:
        combineDelta = (deltaX * -1 + deltaY) / sensitivity;
        break;
      default:
        break;
    }
    if (combineDelta !== 0) {
      deltaScale = Math.round(combineDelta / PCTResizeInfo.ResizeBasis.basisHeight * 1e5) / 1e3;
    }
    PCTResizeInfo.ResizePCT.widthPCT = Math.max(Math.min(PCTResizeInfo.ResizePCT.widthPCT + deltaScale, PCTResizeInfo.ScaleLimit.maxScaleLimit), PCTResizeInfo.ScaleLimit.minScaleLimit);
    PCTResizeInfo.ResizePCT.heightPCT = Math.max(Math.min(PCTResizeInfo.ResizePCT.heightPCT + deltaScale, PCTResizeInfo.ScaleLimit.maxScaleLimit), PCTResizeInfo.ScaleLimit.minScaleLimit);
    var spcWidth = Math.round(PCTResizeInfo.ResizePCT.widthPCT * PCTResizeInfo.ResizeBasis.basisWidth / 100);
    var spcHeight = Math.round(PCTResizeInfo.ResizePCT.heightPCT * PCTResizeInfo.ResizeBasis.basisHeight / 100);
    switch (index) {
      case ResizeControlIndex.LEFT_TOP:
        deltaX = width - spcWidth;
        deltaY = height - spcHeight;
        break;
      case ResizeControlIndex.RIGHT_TOP:
        deltaX = spcWidth - width;
        deltaY = height - spcHeight;
        break;
      case ResizeControlIndex.RIGHT_BOTTOM:
        deltaX = spcWidth - width;
        deltaY = spcHeight - height;
        break;
      case ResizeControlIndex.LEFT_BOTTOM:
        deltaX = width - spcWidth;
        deltaY = spcHeight - height;
        break;
      default:
        break;
    }
    return nextResizeInfo;
  }
  if (rotate % (2 * Math.PI) !== 0 && controlX !== void 0 && controlY !== void 0) {
    return recalcRotatedResizeInfo(pct, nextResizeInfo, rotate, controlX, controlY, oldCenterX, oldCenterY, freezeWidth, freezeHeight);
  }
  switch (index) {
    case ResizeControlIndex.LEFT_TOP:
      nextResizeInfo.width = freezeWidth ? width : width - deltaX * pct;
      nextResizeInfo.height = freezeHeight ? height : height - deltaY * pct;
      break;
    case ResizeControlIndex.RIGHT_TOP:
      nextResizeInfo.width = freezeWidth ? width : width + deltaX * pct;
      nextResizeInfo.height = freezeHeight ? height : height - deltaY * pct;
      break;
    case ResizeControlIndex.RIGHT_BOTTOM:
      nextResizeInfo.width = freezeWidth ? width : width + deltaX * pct;
      nextResizeInfo.height = freezeHeight ? height : height + deltaY * pct;
      break;
    case ResizeControlIndex.LEFT_BOTTOM:
      nextResizeInfo.width = freezeWidth ? width : width - deltaX * pct;
      nextResizeInfo.height = freezeHeight ? height : height + deltaY * pct;
      break;
    default:
      break;
  }
  return nextResizeInfo;
};
var updateEdgePointByAnchors = function(nodeModel, graphModel) {
  var id = nodeModel.id, anchors = nodeModel.anchors;
  var edges = graphModel.getNodeEdges(id);
  forEach_default(edges, function(edge) {
    if (edge.sourceNodeId === id) {
      var anchorItem = find_default(anchors, function(anchor) {
        return anchor.id === edge.sourceAnchorId;
      });
      if (anchorItem) {
        edge.updateStartPoint({
          x: anchorItem.x,
          y: anchorItem.y
        });
      }
    } else if (edge.targetNodeId === id) {
      var anchorItem = find_default(anchors, function(anchor) {
        return anchor.id === edge.targetAnchorId;
      });
      if (anchorItem) {
        edge.updateEndPoint({
          x: anchorItem.x,
          y: anchorItem.y
        });
      }
    }
  });
};
var triggerResizeEvent = function(preNodeData, curNodeData, deltaX, deltaY, index, nodeModel, graphModel) {
  graphModel.eventCenter.emit(EventType.NODE_RESIZE, {
    preData: preNodeData,
    data: curNodeData,
    deltaX,
    deltaY,
    index,
    model: nodeModel
  });
};
var handleResize = function(_a2) {
  var x3 = _a2.x, y3 = _a2.y, deltaX = _a2.deltaX, deltaY = _a2.deltaY, index = _a2.index, nodeModel = _a2.nodeModel, graphModel = _a2.graphModel, cancelCallback = _a2.cancelCallback;
  var r3 = nodeModel.r, rx = nodeModel.rx, ry = nodeModel.ry, width = nodeModel.width, height = nodeModel.height, PCTResizeInfo = nodeModel.PCTResizeInfo, minWidth = nodeModel.minWidth, minHeight = nodeModel.minHeight, maxWidth = nodeModel.maxWidth, maxHeight = nodeModel.maxHeight, rotate = nodeModel.rotate, oldCenterX = nodeModel.x, oldCenterY = nodeModel.y;
  var isFreezeWidth = minWidth === maxWidth;
  var isFreezeHeight = minHeight === maxHeight;
  var resizeInfo = {
    width: r3 || rx || width,
    height: r3 || ry || height,
    deltaX,
    deltaY,
    PCTResizeInfo
  };
  var pct = r3 || rx && ry ? 1 / 2 : 1;
  var controlX = x3;
  var controlY = y3;
  var nextSize = recalcResizeInfo(index, resizeInfo, pct, isFreezeWidth, isFreezeHeight, rotate, controlX, controlY, oldCenterX, oldCenterY);
  if (nextSize.width < minWidth || nextSize.width > maxWidth || nextSize.height < minHeight || nextSize.height > maxHeight) {
    cancelCallback === null || cancelCallback === void 0 ? void 0 : cancelCallback();
    return;
  }
  if (rotate % (2 * Math.PI) == 0 || PCTResizeInfo || controlX === void 0 || controlY === void 0) {
    nextSize.deltaX = isFreezeWidth ? 0 : nextSize.deltaX;
    nextSize.deltaY = isFreezeHeight ? 0 : nextSize.deltaY;
  }
  var preNodeData = nodeModel.getData();
  var curNodeData = nodeModel.resize(nextSize);
  if (preNodeData.x === curNodeData.x && preNodeData.y === curNodeData.y) {
    return;
  }
  updateEdgePointByAnchors(nodeModel, graphModel);
  triggerResizeEvent(preNodeData, curNodeData, deltaX, deltaY, index, nodeModel, graphModel);
};
function calculateWidthAndHeight(startRotatedTouchControlPoint, endRotatedTouchControlPoint, oldCenter, angle2, freezeWidth, freezeHeight, oldWidth, oldHeight) {
  if (freezeWidth === void 0) {
    freezeWidth = false;
  }
  if (freezeHeight === void 0) {
    freezeHeight = false;
  }
  var freezePoint = {
    x: oldCenter.x - (startRotatedTouchControlPoint.x - oldCenter.x),
    y: oldCenter.y - (startRotatedTouchControlPoint.y - oldCenter.y)
  };
  var newCenter = getNewCenter(freezePoint, endRotatedTouchControlPoint);
  var endZeroTouchControlPoint = calculatePointAfterRotateAngle(endRotatedTouchControlPoint, newCenter, -angle2);
  var zeroFreezePoint = calculatePointAfterRotateAngle(freezePoint, newCenter, -angle2);
  if (freezeWidth) {
    var newWidth = Math.abs(endZeroTouchControlPoint.x - zeroFreezePoint.x);
    var widthDx = newWidth - oldWidth;
    if (newCenter.x > endZeroTouchControlPoint.x) {
      newCenter.x = newCenter.x + widthDx / 2;
    } else {
      newCenter.x = newCenter.x - widthDx / 2;
    }
  }
  if (freezeHeight) {
    var newHeight = Math.abs(endZeroTouchControlPoint.y - zeroFreezePoint.y);
    var heightDy = newHeight - oldHeight;
    if (newCenter.y > endZeroTouchControlPoint.y) {
      newCenter.y = newCenter.y + heightDy / 2;
    } else {
      newCenter.y = newCenter.y - heightDy / 2;
    }
  }
  if (freezeWidth || freezeHeight) {
    var nowFreezePoint = calculatePointAfterRotateAngle(zeroFreezePoint, newCenter, angle2);
    var dx = nowFreezePoint.x - freezePoint.x;
    var dy = nowFreezePoint.y - freezePoint.y;
    newCenter.x = newCenter.x - dx;
    newCenter.y = newCenter.y - dy;
    zeroFreezePoint = calculatePointAfterRotateAngle(freezePoint, newCenter, -angle2);
    endZeroTouchControlPoint = {
      x: newCenter.x - (zeroFreezePoint.x - newCenter.x),
      y: newCenter.y - (zeroFreezePoint.y - newCenter.y)
    };
  }
  var width = Math.abs(endZeroTouchControlPoint.x - zeroFreezePoint.x);
  var height = Math.abs(endZeroTouchControlPoint.y - zeroFreezePoint.y);
  if (freezeWidth) {
    width = oldWidth;
  }
  if (freezeHeight) {
    height = oldHeight;
  }
  return {
    width,
    height,
    center: newCenter
  };
}

// node_modules/@logicflow/core/es/util/sampling.js
var SAMPLING_FREQUENCY = 100;
var normal = {
  x: 1,
  y: 0,
  z: 0
};
function sampleCubic(p1, cp1, cp2, p22, offset) {
  var program = function(t4) {
    if (t4 < 0 || t4 > 1) {
      throw new RangeError('The value range of parameter "t" is [0,1]');
    }
    return {
      x: p1.x * Math.pow(1 - t4, 3) + 3 * cp1.x * t4 * Math.pow(1 - t4, 2) + 3 * cp2.x * Math.pow(t4, 2) * (1 - t4) + p22.x * Math.pow(t4, 3),
      y: p1.y * Math.pow(1 - t4, 3) + 3 * cp1.y * t4 * Math.pow(1 - t4, 2) + 3 * cp2.y * Math.pow(t4, 2) * (1 - t4) + p22.y * Math.pow(t4, 3)
    };
  };
  var arrowDistance = 0;
  var t3 = 2;
  var x1 = p22.x, y1 = p22.y;
  var point = p22;
  while (arrowDistance < offset && t3 < 50) {
    point = program(1 - t3 / SAMPLING_FREQUENCY);
    var x22 = point.x, y22 = point.y;
    arrowDistance = distance(x1, y1, x22, y22);
    t3++;
  }
  return point;
}
function crossByZ(v6, v1) {
  return v6.x * v1.y - v6.y * v1.x;
}
function dot(v6, w3) {
  var v1 = [v6.x, v6.y, v6.z];
  var v22 = [w3.x, w3.y, w3.z];
  return v22.reduce(function(prev, cur, index) {
    return prev + cur * v1[index];
  });
}
function angle(v1, v22) {
  var negative = crossByZ(v1, v22);
  var r3 = Math.acos(dot(normalize(v1), normalize(v22)));
  return negative >= 0 ? r3 : -r3;
}
function normalize(v6) {
  var len = Math.hypot(v6.x, v6.y);
  return {
    x: v6.x / len,
    y: v6.y / len,
    z: 0
  };
}
function getThetaOfVector(v6) {
  return angle(normal, v6);
}
function degrees(radians) {
  return radians * (180 / Math.PI);
}

// node_modules/@logicflow/core/es/util/theme.js
var defaultTheme = {
  baseNode: {
    fill: "#fff",
    stroke: "#000",
    strokeWidth: 2
  },
  baseEdge: {
    stroke: "#000",
    strokeWidth: 2
  },
  rect: {},
  circle: {},
  diamond: {},
  ellipse: {},
  polygon: {},
  text: {
    color: "#000",
    stroke: "none",
    fontSize: 12,
    background: {
      fill: "transparent"
    }
  },
  anchor: {
    stroke: "#000",
    fill: "#fff",
    r: 4,
    hover: {
      r: 10,
      fill: "#949494",
      fillOpacity: 0.5,
      stroke: "#949494"
    }
  },
  anchorLine: {
    stroke: "#000",
    strokeWidth: 2,
    strokeDasharray: "3,2"
  },
  nodeText: {
    color: "#000",
    overflowMode: "default",
    fontSize: 12,
    lineHeight: 1.2
  },
  edgeText: {
    textWidth: 100,
    overflowMode: "default",
    fontSize: 12,
    background: {
      fill: "#fff"
    }
  },
  line: {},
  polyline: {},
  bezier: {
    fill: "none",
    adjustLine: {
      stroke: "#949494"
    },
    adjustAnchor: {
      r: 4,
      fill: "#949494",
      fillOpacity: 1,
      stroke: "#949494"
    }
  },
  arrow: {
    offset: 10,
    verticalLength: 5
    // 
  },
  snapline: {
    stroke: "#949494",
    strokeWidth: 1
  },
  edgeAdjust: {
    r: 4,
    fill: "#fff",
    stroke: "#949494",
    strokeWidth: 2
  },
  outline: {
    fill: "transparent",
    stroke: "#949494",
    strokeDasharray: "3,3",
    hover: {
      stroke: "#949494"
    }
  },
  edgeAnimation: {
    stroke: "red",
    strokeDasharray: "10,10",
    strokeDashoffset: "100%",
    animationName: "lf_animate_dash",
    animationDuration: "20s",
    animationIterationCount: "infinite",
    animationTimingFunction: "linear",
    animationDirection: "normal"
  },
  rotateControl: {
    stroke: "#000",
    fill: "#fff",
    strokeWidth: 1.5
  },
  resizeControl: {
    width: 7,
    height: 7,
    fill: "#fff",
    stroke: "#000"
  },
  resizeOutline: {
    fill: "none",
    stroke: "transparent",
    // 
    strokeWidth: 1,
    strokeDasharray: "3,3"
  }
};
var setupTheme = function(customTheme) {
  var theme = cloneDeep_default(defaultTheme);
  if (customTheme) {
    theme = merge_default(theme, customTheme);
  }
  return theme;
};
var updateTheme = setupTheme;

// node_modules/@logicflow/core/es/util/zIndex.js
var maxIndex = 1e3;
var minIndex = 999;
var getZIndex = function() {
  return ++maxIndex;
};
var getMinIndex = function() {
  return --minIndex;
};

// node_modules/@logicflow/core/es/model/edge/BaseEdgeModel.js
var __assign13 = function() {
  __assign13 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign13.apply(this, arguments);
};
var __decorate = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var BaseEdgeModel = (
  /** @class */
  function() {
    function BaseEdgeModel2(data, graphModel) {
      var _a2;
      this.BaseType = ElementType.EDGE;
      this.id = "";
      this.type = "";
      this.sourceNodeId = "";
      this.targetNodeId = "";
      this.textMode = TextMode.TEXT;
      this.text = {
        value: "",
        x: 0,
        y: 0,
        draggable: false,
        editable: true
      };
      this.points = "";
      this.pointsList = [];
      this.virtual = false;
      this.isSelected = false;
      this.isHovered = false;
      this.isHitable = true;
      this.isHittable = true;
      this.draggable = true;
      this.visible = true;
      this.isAnimation = false;
      this.isShowAdjustPoint = false;
      this.zIndex = 0;
      this.state = ElementState.DEFAULT;
      this.modelType = ModelType.EDGE;
      this.customTextPosition = false;
      this.style = {};
      this.arrowConfig = {
        markerEnd: "url(#marker-end-".concat(this.id, ")"),
        markerStart: "url(#marker-start-".concat(this.id, ")")
      };
      this.graphModel = graphModel;
      this.properties = (_a2 = data.properties) !== null && _a2 !== void 0 ? _a2 : {};
      this.initEdgeData(data);
      this.setAttributes();
    }
    BaseEdgeModel2.prototype.initEdgeData = function(data) {
      if (!data.properties) {
        data.properties = {};
      }
      if (!data.id) {
        var idGenerator = this.graphModel.idGenerator;
        var globalId = idGenerator && idGenerator(data.type);
        var nodeId = this.createId();
        data.id = nodeId || globalId || createUuid();
      }
      this.arrowConfig.markerEnd = "url(#marker-end-".concat(data.id, ")");
      this.arrowConfig.markerStart = "url(#marker-start-".concat(data.id, ")");
      var adjustEdgeStartAndEnd = this.graphModel.editConfigModel.adjustEdgeStartAndEnd;
      this.isShowAdjustPoint = adjustEdgeStartAndEnd;
      assign_default(this, pickEdgeConfig(data));
      var overlapMode = this.graphModel.overlapMode;
      if (overlapMode === OverlapMode.INCREASE) {
        this.zIndex = data.zIndex || getZIndex();
      }
      this.setAnchors();
      this.initPoints();
      this.formatText(data);
    };
    BaseEdgeModel2.prototype.setAttributes = function() {
    };
    BaseEdgeModel2.prototype.createId = function() {
      return null;
    };
    BaseEdgeModel2.prototype.getEdgeStyle = function() {
      return __assign13(__assign13({}, this.graphModel.theme.baseEdge), this.style);
    };
    BaseEdgeModel2.prototype.getAdjustPointStyle = function() {
      return __assign13({}, this.graphModel.theme.edgeAdjust);
    };
    BaseEdgeModel2.prototype.getTextStyle = function() {
      var edgeText = this.graphModel.theme.edgeText;
      return cloneDeep_default(edgeText);
    };
    BaseEdgeModel2.prototype.getEdgeAnimationStyle = function() {
      var edgeAnimation = this.graphModel.theme.edgeAnimation;
      return cloneDeep_default(edgeAnimation);
    };
    BaseEdgeModel2.prototype.getArrowStyle = function() {
      var edgeStyle = this.getEdgeStyle();
      var edgeAnimationStyle = this.getEdgeAnimationStyle();
      var arrow = this.graphModel.theme.arrow;
      var stroke = this.isAnimation ? edgeAnimationStyle.stroke : edgeStyle.stroke;
      return __assign13(__assign13(__assign13({}, edgeStyle), { fill: stroke, stroke }), arrow);
    };
    BaseEdgeModel2.prototype.getOutlineStyle = function() {
      var graphModel = this.graphModel;
      var outline = graphModel.theme.outline;
      return cloneDeep_default(outline);
    };
    BaseEdgeModel2.prototype.getTextPosition = function() {
      return {
        x: 0,
        y: 0
      };
    };
    Object.defineProperty(BaseEdgeModel2.prototype, "sourceNode", {
      /**
       * 
       */
      get: function() {
        var _a2, _b;
        return (_b = (_a2 = this.graphModel) === null || _a2 === void 0 ? void 0 : _a2.nodesMap[this.sourceNodeId]) === null || _b === void 0 ? void 0 : _b.model;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseEdgeModel2.prototype, "targetNode", {
      /**
       * 
       */
      get: function() {
        var _a2, _b;
        return (_b = (_a2 = this.graphModel) === null || _a2 === void 0 ? void 0 : _a2.nodesMap[this.targetNodeId]) === null || _b === void 0 ? void 0 : _b.model;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseEdgeModel2.prototype, "textPosition", {
      get: function() {
        return this.getTextPosition();
      },
      enumerable: false,
      configurable: true
    });
    BaseEdgeModel2.prototype.getBeginAnchor = function(sourceNode, targetNode, sourceAnchorId) {
      var position;
      var minDistance;
      var sourceAnchors = getAnchors(sourceNode);
      if (sourceAnchorId) {
        position = find_default(sourceAnchors, function(anchor) {
          return anchor.id === sourceAnchorId;
        });
        if (position) {
          return position;
        }
        console.warn("".concat(sourceAnchorId, ""));
      }
      sourceAnchors.forEach(function(anchor) {
        var distance2 = twoPointDistance(anchor, targetNode);
        if (minDistance === void 0) {
          minDistance = distance2;
          position = anchor;
        } else if (distance2 < minDistance) {
          minDistance = distance2;
          position = anchor;
        }
      });
      return position;
    };
    BaseEdgeModel2.prototype.getEndAnchor = function(targetNode, targetAnchorId) {
      var _this = this;
      var position;
      var minDistance;
      var targetAnchors = getAnchors(targetNode);
      if (targetAnchorId) {
        position = find_default(targetAnchors, function(anchor) {
          return anchor.id === targetAnchorId;
        });
        if (position) {
          return position;
        }
        console.warn("".concat(targetAnchorId, ""));
      }
      targetAnchors.forEach(function(anchor) {
        if (!_this.startPoint)
          return;
        var distance2 = twoPointDistance(anchor, _this.startPoint);
        if (minDistance === void 0) {
          minDistance = distance2;
          position = anchor;
        } else if (distance2 < minDistance) {
          minDistance = distance2;
          position = anchor;
        }
      });
      return position;
    };
    BaseEdgeModel2.prototype.getProperties = function() {
      return toJS(this.properties);
    };
    BaseEdgeModel2.prototype.getData = function() {
      var properties = this.properties;
      if (isObservable(properties)) {
        properties = toJS(properties);
      }
      var data = {
        id: this.id,
        type: this.type,
        properties,
        sourceNodeId: this.sourceNodeId,
        targetNodeId: this.targetNodeId,
        sourceAnchorId: this.sourceAnchorId,
        targetAnchorId: this.targetAnchorId,
        startPoint: assign_default({}, this.startPoint),
        endPoint: assign_default({}, this.endPoint)
      };
      if (this.graphModel.overlapMode === OverlapMode.INCREASE) {
        data.zIndex = this.zIndex;
      }
      var _a2 = this.text, x3 = _a2.x, y3 = _a2.y, value = _a2.value;
      if (value) {
        data.text = {
          x: x3,
          y: y3,
          value
        };
      }
      return data;
    };
    BaseEdgeModel2.prototype.getHistoryData = function() {
      return this.getData();
    };
    BaseEdgeModel2.prototype.setProperty = function(key, val) {
      set(this.properties, key, formatData(val));
      this.setAttributes();
    };
    BaseEdgeModel2.prototype.deleteProperty = function(key) {
      delete this.properties[key];
      this.setAttributes();
    };
    BaseEdgeModel2.prototype.setProperties = function(properties) {
      this.properties = __assign13(__assign13({}, toJS(this.properties)), formatData(properties));
      this.setAttributes();
    };
    BaseEdgeModel2.prototype.changeEdgeId = function(id) {
      var _a2 = this.arrowConfig, markerEnd = _a2.markerEnd, markerStart = _a2.markerStart;
      if (markerStart && markerStart === "url(#marker-start-".concat(this.id, ")")) {
        this.arrowConfig.markerStart = "url(#marker-start-".concat(id, ")");
      }
      if (markerEnd && markerEnd === "url(#marker-end-".concat(this.id, ")")) {
        this.arrowConfig.markerEnd = "url(#marker-end-".concat(id, ")");
      }
      this.id = id;
    };
    BaseEdgeModel2.prototype.setStyle = function(key, val) {
      var _a2;
      this.style = __assign13(__assign13({}, this.style), (_a2 = {}, _a2[key] = formatData(val), _a2));
    };
    BaseEdgeModel2.prototype.setStyles = function(styles) {
      this.style = __assign13(__assign13({}, this.style), formatData(styles));
    };
    BaseEdgeModel2.prototype.updateStyles = function(styles) {
      this.style = __assign13({}, formatData(styles));
    };
    BaseEdgeModel2.prototype.setTextMode = function(mode) {
      this.textMode = mode;
    };
    BaseEdgeModel2.prototype.formatText = function(data) {
      var _a2, _b, _c;
      var _d = this.graphModel.editConfigModel, edgeTextDraggable = _d.edgeTextDraggable, edgeTextEdit = _d.edgeTextEdit;
      var _e = this.textPosition, x3 = _e.x, y3 = _e.y;
      var text = data.text;
      var textConfig = {
        value: "",
        x: x3,
        y: y3,
        draggable: edgeTextDraggable,
        editable: edgeTextEdit
      };
      if (text) {
        if (typeof text === "string") {
          textConfig = __assign13(__assign13({}, textConfig), { value: text });
        } else {
          textConfig = __assign13(__assign13({}, textConfig), { x: (_a2 = text.x) !== null && _a2 !== void 0 ? _a2 : x3, y: (_b = text.y) !== null && _b !== void 0 ? _b : y3, value: (_c = text.value) !== null && _c !== void 0 ? _c : "" });
          if (!isUndefined_default(text.draggable)) {
            textConfig.draggable = text.draggable;
          }
          if (!isUndefined_default(text.editable)) {
            textConfig.editable = text.editable;
          }
        }
      }
      this.text = textConfig;
    };
    BaseEdgeModel2.prototype.resetTextPosition = function() {
      var _a2 = this.textPosition, x3 = _a2.x, y3 = _a2.y;
      this.text.x = x3;
      this.text.y = y3;
    };
    BaseEdgeModel2.prototype.moveText = function(deltaX, deltaY) {
      var _a2 = this.text, x3 = _a2.x, y3 = _a2.y, value = _a2.value, draggable = _a2.draggable, editable = _a2.editable;
      this.text = {
        value,
        editable,
        draggable,
        x: x3 + deltaX,
        y: y3 + deltaY
      };
    };
    BaseEdgeModel2.prototype.setText = function(textConfig) {
      if (textConfig) {
        assign_default(this.text, textConfig);
      }
    };
    BaseEdgeModel2.prototype.updateText = function(value) {
      this.text = __assign13(__assign13({}, toJS(this.text)), { value });
    };
    BaseEdgeModel2.prototype.setAnchors = function() {
      if (!this.sourceAnchorId || !this.startPoint) {
        var anchor = this.getBeginAnchor(this.sourceNode, this.targetNode, this.sourceAnchorId);
        if (!anchor) {
          throw new Error("beginAnchoranchorsanchors");
        }
        if (!this.startPoint) {
          this.startPoint = {
            x: anchor.x,
            y: anchor.y
          };
        }
        if (!this.sourceAnchorId) {
          this.sourceAnchorId = anchor.id;
        }
      }
      if (!this.targetAnchorId || !this.endPoint) {
        var anchor = this.getEndAnchor(this.targetNode, this.targetAnchorId);
        if (!anchor) {
          throw new Error("endAnchoranchorsanchors");
        }
        if (!this.endPoint) {
          this.endPoint = {
            x: anchor.x,
            y: anchor.y
          };
        }
        if (!this.targetAnchorId) {
          this.targetAnchorId = anchor.id;
        }
      }
    };
    BaseEdgeModel2.prototype.setSelected = function(flag) {
      if (flag === void 0) {
        flag = true;
      }
      this.isSelected = flag;
    };
    BaseEdgeModel2.prototype.setHovered = function(flag) {
      if (flag === void 0) {
        flag = true;
      }
      this.isHovered = flag;
    };
    BaseEdgeModel2.prototype.setHitable = function(flag) {
      if (flag === void 0) {
        flag = true;
      }
      this.isHitable = flag;
    };
    BaseEdgeModel2.prototype.setHittable = function(flag) {
      if (flag === void 0) {
        flag = true;
      }
      this.isHittable = flag;
    };
    BaseEdgeModel2.prototype.openEdgeAnimation = function() {
      this.isAnimation = true;
    };
    BaseEdgeModel2.prototype.closeEdgeAnimation = function() {
      this.isAnimation = false;
    };
    BaseEdgeModel2.prototype.setElementState = function(state, additionStateData) {
      this.state = state;
      this.additionStateData = additionStateData;
    };
    BaseEdgeModel2.prototype.updateStartPoint = function(anchor) {
      this.startPoint = anchor;
    };
    BaseEdgeModel2.prototype.moveStartPoint = function(deltaX, deltaY) {
      if (this.startPoint) {
        this.startPoint.x += deltaX;
        this.startPoint.y += deltaY;
      }
    };
    BaseEdgeModel2.prototype.updateEndPoint = function(anchor) {
      this.endPoint = anchor;
    };
    BaseEdgeModel2.prototype.moveEndPoint = function(deltaX, deltaY) {
      if (this.endPoint) {
        this.endPoint.x += deltaX;
        this.endPoint.y += deltaY;
      }
    };
    BaseEdgeModel2.prototype.setZIndex = function(zIndex) {
      if (zIndex === void 0) {
        zIndex = 0;
      }
      this.zIndex = zIndex;
    };
    BaseEdgeModel2.prototype.initPoints = function() {
    };
    BaseEdgeModel2.prototype.updateAttributes = function(attributes) {
      assign_default(this, attributes);
    };
    BaseEdgeModel2.prototype.getAdjustStart = function() {
      return this.startPoint;
    };
    BaseEdgeModel2.prototype.getAdjustEnd = function() {
      return this.endPoint;
    };
    BaseEdgeModel2.prototype.updateAfterAdjustStartAndEnd = function(_a2) {
      var startPoint = _a2.startPoint, endPoint = _a2.endPoint;
      this.updateStartPoint({ x: startPoint.x, y: startPoint.y });
      this.updateEndPoint({ x: endPoint.x, y: endPoint.y });
    };
    BaseEdgeModel2.BaseType = ElementType.EDGE;
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "type", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "sourceNodeId", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "targetNodeId", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "startPoint", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "endPoint", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "textMode", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "text", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "properties", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "points", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "pointsList", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "isSelected", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "isHovered", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "isHitable", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "isHittable", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "draggable", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "visible", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "isAnimation", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "isShowAdjustPoint", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "zIndex", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "state", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "style", void 0);
    __decorate([
      observable
    ], BaseEdgeModel2.prototype, "arrowConfig", void 0);
    __decorate([
      computed
    ], BaseEdgeModel2.prototype, "sourceNode", null);
    __decorate([
      computed
    ], BaseEdgeModel2.prototype, "targetNode", null);
    __decorate([
      computed
    ], BaseEdgeModel2.prototype, "textPosition", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "setProperty", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "deleteProperty", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "setProperties", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "changeEdgeId", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "setStyle", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "setStyles", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "updateStyles", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "setTextMode", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "formatText", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "resetTextPosition", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "moveText", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "setText", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "updateText", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "setAnchors", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "setSelected", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "setHovered", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "setHitable", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "setHittable", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "openEdgeAnimation", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "closeEdgeAnimation", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "setElementState", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "updateStartPoint", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "moveStartPoint", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "updateEndPoint", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "moveEndPoint", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "setZIndex", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "initPoints", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "updateAttributes", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "getAdjustStart", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "getAdjustEnd", null);
    __decorate([
      action
    ], BaseEdgeModel2.prototype, "updateAfterAdjustStartAndEnd", null);
    return BaseEdgeModel2;
  }()
);
var BaseEdgeModel_default = BaseEdgeModel;

// node_modules/@logicflow/core/es/model/edge/BezierEdgeModel.js
var __extends5 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign14 = function() {
  __assign14 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign14.apply(this, arguments);
};
var __decorate2 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var __read15 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var BezierEdgeModel = (
  /** @class */
  function(_super) {
    __extends5(BezierEdgeModel2, _super);
    function BezierEdgeModel2(data, graphModel) {
      var _this = _super.call(this, data, graphModel) || this;
      _this.modelType = ModelType.BEZIER_EDGE;
      _this.path = "";
      _this.initEdgeData(data);
      _this.setAttributes();
      return _this;
    }
    BezierEdgeModel2.prototype.initEdgeData = function(data) {
      this.offset = 100;
      _super.prototype.initEdgeData.call(this, data);
    };
    BezierEdgeModel2.prototype.getEdgeStyle = function() {
      var bezier = this.graphModel.theme.bezier;
      var style = _super.prototype.getEdgeStyle.call(this);
      var _a2 = this.properties.style, customStyle = _a2 === void 0 ? {} : _a2;
      return __assign14(__assign14(__assign14({}, style), cloneDeep_default(bezier)), cloneDeep_default(customStyle));
    };
    BezierEdgeModel2.prototype.getTextPosition = function() {
      if (this.pointsList && this.pointsList.length > 0) {
        var pointsXSum_1 = 0;
        var pointsYSum_1 = 0;
        this.pointsList.forEach(function(_a2) {
          var x3 = _a2.x, y3 = _a2.y;
          pointsXSum_1 += x3;
          pointsYSum_1 += y3;
        });
        return {
          x: pointsXSum_1 / this.pointsList.length,
          y: pointsYSum_1 / this.pointsList.length
        };
      }
      return {
        x: (this.startPoint.x + this.endPoint.x) / 2,
        y: (this.startPoint.y + this.endPoint.y) / 2
      };
    };
    BezierEdgeModel2.prototype.getData = function() {
      var data = _super.prototype.getData.call(this);
      var pointsList = this.pointsList.map(function(_a2) {
        var x3 = _a2.x, y3 = _a2.y;
        return { x: x3, y: y3 };
      });
      return __assign14(__assign14({}, data), { pointsList });
    };
    BezierEdgeModel2.prototype.getControls = function() {
      var start = this.startPoint;
      var end = this.endPoint;
      var points = getBezierControlPoints({
        start,
        end,
        sourceNode: this.sourceNode,
        targetNode: this.targetNode,
        offset: this.offset
      });
      return points;
    };
    BezierEdgeModel2.prototype.getPath = function(points) {
      var _a2 = __read15(points, 4), start = _a2[0], sNext = _a2[1], ePre = _a2[2], end = _a2[3];
      return "M ".concat(start.x, " ").concat(start.y, "\n    C ").concat(sNext.x, " ").concat(sNext.y, ",\n    ").concat(ePre.x, " ").concat(ePre.y, ",\n    ").concat(end.x, " ").concat(end.y);
    };
    BezierEdgeModel2.prototype.initPoints = function() {
      if (this.pointsList.length > 0) {
        this.path = this.getPath(this.pointsList);
      } else {
        this.updatePoints();
      }
    };
    BezierEdgeModel2.prototype.updatePoints = function() {
      var _a2 = this.getControls(), sNext = _a2.sNext, ePre = _a2.ePre;
      this.updatePath(sNext, ePre);
    };
    BezierEdgeModel2.prototype.updatePath = function(sNext, ePre) {
      sNext = cloneDeep_default(sNext);
      ePre = cloneDeep_default(ePre);
      var start = {
        x: this.startPoint.x,
        y: this.startPoint.y
      };
      var end = {
        x: this.endPoint.x,
        y: this.endPoint.y
      };
      if (!sNext || !ePre) {
        var control = this.getControls();
        sNext = control.sNext;
        ePre = control.ePre;
      }
      this.pointsList = [start, sNext, ePre, end];
      this.path = this.getPath(this.pointsList);
    };
    BezierEdgeModel2.prototype.updateStartPoint = function(anchor) {
      this.startPoint = Object.assign({}, anchor);
      this.updatePoints();
    };
    BezierEdgeModel2.prototype.updateEndPoint = function(anchor) {
      this.endPoint = Object.assign({}, anchor);
      this.updatePoints();
    };
    BezierEdgeModel2.prototype.moveStartPoint = function(deltaX, deltaY) {
      this.startPoint.x += deltaX;
      this.startPoint.y += deltaY;
      var _a2 = __read15(this.pointsList, 3), sNext = _a2[1], ePre = _a2[2];
      sNext.x += deltaX;
      sNext.y += deltaY;
      this.updatePath(sNext, ePre);
    };
    BezierEdgeModel2.prototype.moveEndPoint = function(deltaX, deltaY) {
      this.endPoint.x += deltaX;
      this.endPoint.y += deltaY;
      var _a2 = __read15(this.pointsList, 3), sNext = _a2[1], ePre = _a2[2];
      ePre.x += deltaX;
      ePre.y += deltaY;
      this.updatePath(sNext, ePre);
    };
    BezierEdgeModel2.prototype.updateAdjustAnchor = function(anchor, type) {
      var _a2;
      if (type === "sNext") {
        this.pointsList[1] = anchor;
      } else if (type === "ePre") {
        this.pointsList[2] = anchor;
      }
      this.path = this.getPath(this.pointsList);
      if ((_a2 = this.text) === null || _a2 === void 0 ? void 0 : _a2.value) {
        this.setText(assign_default({}, this.text, this.textPosition));
      }
    };
    BezierEdgeModel2.prototype.getAdjustStart = function() {
      return this.pointsList[0] || this.startPoint;
    };
    BezierEdgeModel2.prototype.getAdjustEnd = function() {
      var pointsList = this.pointsList;
      return pointsList[pointsList.length - 1] || this.endPoint;
    };
    BezierEdgeModel2.prototype.updateAfterAdjustStartAndEnd = function(_a2) {
      var startPoint = _a2.startPoint, endPoint = _a2.endPoint, sourceNode = _a2.sourceNode, targetNode = _a2.targetNode;
      var _b = getBezierControlPoints({
        start: startPoint,
        end: endPoint,
        sourceNode,
        targetNode,
        offset: this.offset
      }), sNext = _b.sNext, ePre = _b.ePre;
      this.pointsList = [startPoint, sNext, ePre, endPoint];
      this.initPoints();
    };
    __decorate2([
      observable
    ], BezierEdgeModel2.prototype, "path", void 0);
    __decorate2([
      action
    ], BezierEdgeModel2.prototype, "initPoints", null);
    __decorate2([
      action
    ], BezierEdgeModel2.prototype, "updatePoints", null);
    __decorate2([
      action
    ], BezierEdgeModel2.prototype, "updateStartPoint", null);
    __decorate2([
      action
    ], BezierEdgeModel2.prototype, "updateEndPoint", null);
    __decorate2([
      action
    ], BezierEdgeModel2.prototype, "moveStartPoint", null);
    __decorate2([
      action
    ], BezierEdgeModel2.prototype, "moveEndPoint", null);
    __decorate2([
      action
    ], BezierEdgeModel2.prototype, "updateAdjustAnchor", null);
    __decorate2([
      action
    ], BezierEdgeModel2.prototype, "getAdjustStart", null);
    __decorate2([
      action
    ], BezierEdgeModel2.prototype, "getAdjustEnd", null);
    __decorate2([
      action
    ], BezierEdgeModel2.prototype, "updateAfterAdjustStartAndEnd", null);
    return BezierEdgeModel2;
  }(BaseEdgeModel_default)
);

// node_modules/@logicflow/core/es/model/edge/LineEdgeModel.js
var __extends6 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign15 = function() {
  __assign15 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign15.apply(this, arguments);
};
var __read16 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray4 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l3 = from.length, ar; i4 < l3; i4++) {
    if (ar || !(i4 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i4);
      ar[i4] = from[i4];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var LineEdgeModel = (
  /** @class */
  function(_super) {
    __extends6(LineEdgeModel2, _super);
    function LineEdgeModel2() {
      var _this = _super.apply(this, __spreadArray4([], __read16(arguments), false)) || this;
      _this.modelType = ModelType.LINE_EDGE;
      return _this;
    }
    LineEdgeModel2.prototype.getEdgeStyle = function() {
      var line = this.graphModel.theme.line;
      var style = _super.prototype.getEdgeStyle.call(this);
      var _a2 = this.properties.style, customStyle = _a2 === void 0 ? {} : _a2;
      return __assign15(__assign15(__assign15({}, style), cloneDeep_default(line)), cloneDeep_default(customStyle));
    };
    LineEdgeModel2.prototype.initEdgeData = function(data) {
      _super.prototype.initEdgeData.call(this, data);
      this.points = this.getPath([this.startPoint, this.endPoint]);
    };
    LineEdgeModel2.prototype.getPath = function(points) {
      var _a2 = __read16(points, 2), start = _a2[0], end = _a2[1];
      return "".concat(start.x, ",").concat(start.y, " ").concat(end.x, ",").concat(end.y);
    };
    LineEdgeModel2.prototype.getTextPosition = function() {
      return {
        x: (this.startPoint.x + this.endPoint.x) / 2,
        y: (this.startPoint.y + this.endPoint.y) / 2
      };
    };
    return LineEdgeModel2;
  }(BaseEdgeModel_default)
);

// node_modules/@logicflow/core/es/model/edge/PolylineEdgeModel.js
var __extends7 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign16 = function() {
  __assign16 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign16.apply(this, arguments);
};
var __decorate3 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var __read17 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray5 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l3 = from.length, ar; i4 < l3; i4++) {
    if (ar || !(i4 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i4);
      ar[i4] = from[i4];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var PolylineEdgeModel = (
  /** @class */
  function(_super) {
    __extends7(PolylineEdgeModel2, _super);
    function PolylineEdgeModel2() {
      var _this = _super.apply(this, __spreadArray5([], __read17(arguments), false)) || this;
      _this.modelType = ModelType.POLYLINE_EDGE;
      _this.draggingPointList = [];
      return _this;
    }
    PolylineEdgeModel2.prototype.initEdgeData = function(data) {
      this.offset = 30;
      if (data.pointsList) {
        this.pointsList = data.pointsList;
      }
      _super.prototype.initEdgeData.call(this, data);
    };
    PolylineEdgeModel2.prototype.getEdgeStyle = function() {
      var polyline = this.graphModel.theme.polyline;
      var style = _super.prototype.getEdgeStyle.call(this);
      var _a2 = this.properties.style, customStyle = _a2 === void 0 ? {} : _a2;
      return __assign16(__assign16(__assign16({}, style), cloneDeep_default(polyline)), cloneDeep_default(customStyle));
    };
    PolylineEdgeModel2.prototype.getTextPosition = function() {
      var _a2;
      var textValue = (_a2 = this.text) === null || _a2 === void 0 ? void 0 : _a2.value;
      if (this.dbClickPosition && !textValue) {
        var _b = this.dbClickPosition, x3 = _b.x, y3 = _b.y;
        return { x: x3, y: y3 };
      }
      var currentPositionList = points2PointsList(this.points);
      var _c = __read17(getLongestEdge(currentPositionList), 2), p1 = _c[0], p22 = _c[1];
      return {
        x: (p1.x + p22.x) / 2,
        y: (p1.y + p22.y) / 2
      };
    };
    PolylineEdgeModel2.prototype.getAfterAnchor = function(direction, position, anchorList) {
      var anchor;
      var minDistance;
      anchorList.forEach(function(item) {
        var distanceX;
        if (direction === SegmentDirection.HORIZONTAL) {
          distanceX = Math.abs(position.y - item.y);
        } else if (direction === SegmentDirection.VERTICAL) {
          distanceX = Math.abs(position.x - item.x);
        }
        if (!minDistance || minDistance > distanceX) {
          minDistance = distanceX;
          anchor = item;
        }
      });
      return anchor;
    };
    PolylineEdgeModel2.prototype.getCrossPoint = function(direction, start, end) {
      var position;
      if (direction === SegmentDirection.HORIZONTAL) {
        position = {
          x: end.x,
          y: start.y
        };
      } else if (direction === SegmentDirection.VERTICAL) {
        position = {
          x: start.x,
          y: end.y
        };
      }
      return position;
    };
    PolylineEdgeModel2.prototype.removeCrossPoints = function(startIndex, endIndex, pointList) {
      var list = pointList.map(function(i4) {
        return i4;
      });
      if (startIndex === 1) {
        var start_1 = list[startIndex];
        var end = list[endIndex];
        var pre_1 = list[startIndex - 1];
        var isInStartNode = isSegmentsInNode(pre_1, start_1, this.sourceNode);
        if (isInStartNode) {
          var isSegmentsCrossStartNode = isSegmentsCrossNode(start_1, end, this.sourceNode);
          if (isSegmentsCrossStartNode) {
            var point = getCrossPointInRect(start_1, end, this.sourceNode);
            if (point) {
              list[startIndex] = point;
              list.splice(startIndex - 1, 1);
              startIndex--;
              endIndex--;
            }
          }
        } else {
          var anchorList = this.sourceNode.anchors;
          anchorList.forEach(function(item) {
            if (item.x === pre_1.x && item.x === start_1.x || item.y === pre_1.y && item.y === start_1.y) {
              var distance1 = distance(item.x, item.y, start_1.x, start_1.y);
              var distance2 = distance(pre_1.x, pre_1.y, start_1.x, start_1.y);
              if (distance1 < distance2) {
                list[startIndex - 1] = item;
              }
            }
          });
        }
      }
      if (endIndex === pointList.length - 2) {
        var start = list[startIndex];
        var end_1 = list[endIndex];
        var next_1 = list[endIndex + 1];
        var isInEndNode = isSegmentsInNode(end_1, next_1, this.targetNode);
        if (isInEndNode) {
          var isSegmentsCrossStartNode = isSegmentsCrossNode(start, end_1, this.targetNode);
          if (isSegmentsCrossStartNode) {
            var point = getCrossPointInRect(start, end_1, this.targetNode);
            if (point) {
              list[endIndex] = point;
              list.splice(endIndex + 1, 1);
            }
          }
        } else {
          var anchorList = this.targetNode.anchors;
          anchorList.forEach(function(item) {
            if (item.x === next_1.x && item.x === end_1.x || item.y === next_1.y && item.y === end_1.y) {
              var distance1 = distance(item.x, item.y, end_1.x, end_1.y);
              var distance2 = distance(next_1.x, next_1.y, end_1.x, end_1.y);
              if (distance1 < distance2) {
                list[endIndex + 1] = item;
              }
            }
          });
        }
      }
      return list;
    };
    PolylineEdgeModel2.prototype.getDraggingPoints = function(direction, positionType, position, anchorList, draggingPointList) {
      var pointList = draggingPointList.map(function(i4) {
        return i4;
      });
      var anchor = this.getAfterAnchor(direction, position, anchorList);
      var crossPoint = this.getCrossPoint(direction, position, anchor);
      if (positionType === "start") {
        pointList.unshift(crossPoint);
        pointList.unshift(anchor);
      } else {
        pointList.push(crossPoint);
        pointList.push(anchor);
      }
      return pointList;
    };
    PolylineEdgeModel2.prototype.updateCrossPoints = function(pointList) {
      var list = pointList.map(function(i4) {
        return i4;
      });
      var start = pointList[0];
      var next = pointList[1];
      var pre = pointList[list.length - 2];
      var end = pointList[list.length - 1];
      var _a2 = this, sourceNode = _a2.sourceNode, targetNode = _a2.targetNode;
      var sourceModelType = sourceNode.modelType;
      var targetModelType = targetNode.modelType;
      var startPointDirection = segmentDirection(start, next);
      var startCrossPoint = list[0];
      switch (sourceModelType) {
        case ModelType.RECT_NODE:
          if (sourceNode.radius !== 0) {
            var inInnerNode = inStraightLineOfRect(start, sourceNode);
            if (!inInnerNode) {
              startCrossPoint = getClosestRadiusCenter(start, startPointDirection, sourceNode);
            }
          }
          break;
        case ModelType.CIRCLE_NODE:
          startCrossPoint = getCrossPointWithCircle(start, startPointDirection, sourceNode);
          break;
        case ModelType.ELLIPSE_NODE:
          startCrossPoint = getCrossPointWithEllipse(start, startPointDirection, sourceNode);
          break;
        case ModelType.DIAMOND_NODE:
          startCrossPoint = getCrossPointWithPolygon(start, startPointDirection, sourceNode);
          break;
        case ModelType.POLYGON_NODE:
          startCrossPoint = getCrossPointWithPolygon(start, startPointDirection, sourceNode);
          break;
        default:
          break;
      }
      if (startCrossPoint) {
        list[0] = startCrossPoint;
      }
      var endPointDirection = segmentDirection(pre, end);
      var endCrossPoint = list[list.length - 1];
      switch (targetModelType) {
        case ModelType.RECT_NODE:
          if (targetNode.radius !== 0) {
            var inInnerNode = inStraightLineOfRect(end, targetNode);
            if (!inInnerNode) {
              endCrossPoint = getClosestRadiusCenter(end, endPointDirection, targetNode);
            }
          }
          break;
        case ModelType.CIRCLE_NODE:
          endCrossPoint = getCrossPointWithCircle(end, endPointDirection, targetNode);
          break;
        case ModelType.ELLIPSE_NODE:
          endCrossPoint = getCrossPointWithEllipse(end, endPointDirection, targetNode);
          break;
        case ModelType.DIAMOND_NODE:
          endCrossPoint = getCrossPointWithPolygon(end, endPointDirection, targetNode);
          break;
        case ModelType.POLYGON_NODE:
          endCrossPoint = getCrossPointWithPolygon(end, endPointDirection, targetNode);
          break;
        default:
          break;
      }
      if (endCrossPoint) {
        list[list.length - 1] = endCrossPoint;
      }
      return list;
    };
    PolylineEdgeModel2.prototype.updatePath = function(pointList) {
      this.pointsList = pointList;
      this.points = this.getPath(this.pointsList);
    };
    PolylineEdgeModel2.prototype.getData = function() {
      var data = _super.prototype.getData.call(this);
      var pointsList = this.pointsList.map(function(_a2) {
        var x3 = _a2.x, y3 = _a2.y;
        return {
          x: x3,
          y: y3
        };
      });
      return Object.assign({}, data, {
        pointsList
      });
    };
    PolylineEdgeModel2.prototype.getPath = function(points) {
      return points.map(function(point) {
        return "".concat(point.x, ",").concat(point.y);
      }).join(" ");
    };
    PolylineEdgeModel2.prototype.initPoints = function() {
      if (this.pointsList.length > 0) {
        this.points = this.getPath(this.pointsList);
      } else {
        this.updatePoints();
      }
    };
    PolylineEdgeModel2.prototype.updatePoints = function() {
      var pointsList = getPolylinePoints({
        x: this.startPoint.x,
        y: this.startPoint.y
      }, {
        x: this.endPoint.x,
        y: this.endPoint.y
      }, this.sourceNode, this.targetNode, this.offset || 0);
      this.pointsList = pointsList;
      this.points = pointsList.map(function(point) {
        return "".concat(point.x, ",").concat(point.y);
      }).join(" ");
    };
    PolylineEdgeModel2.prototype.updateStartPoint = function(anchor) {
      this.startPoint = Object.assign({}, anchor);
      this.updatePoints();
    };
    PolylineEdgeModel2.prototype.moveStartPoint = function(deltaX, deltaY) {
      this.startPoint.x += deltaX;
      this.startPoint.y += deltaY;
      this.updatePoints();
    };
    PolylineEdgeModel2.prototype.updateEndPoint = function(anchor) {
      this.endPoint = Object.assign({}, anchor);
      this.updatePoints();
    };
    PolylineEdgeModel2.prototype.moveEndPoint = function(deltaX, deltaY) {
      this.endPoint.x += deltaX;
      this.endPoint.y += deltaY;
      this.updatePoints();
    };
    PolylineEdgeModel2.prototype.updatePointsList = function(deltaX, deltaY) {
      this.pointsList.forEach(function(item) {
        item.x += deltaX;
        item.y += deltaY;
      });
      var startPoint = this.pointsList[0];
      this.startPoint = Object.assign({}, startPoint);
      var endPoint = this.pointsList[this.pointsList.length - 1];
      this.endPoint = Object.assign({}, endPoint);
      this.initPoints();
    };
    PolylineEdgeModel2.prototype.dragAppendStart = function() {
      this.draggingPointList = this.pointsList.map(function(i4) {
        return i4;
      });
    };
    PolylineEdgeModel2.prototype.dragAppendSimple = function(appendInfo, dragInfo) {
      var _a2;
      this.isDragging = true;
      var start = appendInfo.start, end = appendInfo.end, startIndex = appendInfo.startIndex, endIndex = appendInfo.endIndex, direction = appendInfo.direction;
      var pointsList = this.pointsList;
      var draggingPointList = pointsList;
      if (direction === SegmentDirection.HORIZONTAL) {
        pointsList[startIndex] = {
          x: start.x,
          y: start.y + dragInfo.y
        };
        pointsList[endIndex] = {
          x: end.x,
          y: end.y + dragInfo.y
        };
        draggingPointList = this.pointsList.map(function(i4) {
          return i4;
        });
      } else if (direction === SegmentDirection.VERTICAL) {
        pointsList[startIndex] = {
          x: start.x + dragInfo.x,
          y: start.y
        };
        pointsList[endIndex] = {
          x: end.x + dragInfo.x,
          y: end.y
        };
        draggingPointList = this.pointsList.map(function(i4) {
          return i4;
        });
      }
      this.updatePointsAfterDrag(draggingPointList);
      this.draggingPointList = draggingPointList;
      if ((_a2 = this.text) === null || _a2 === void 0 ? void 0 : _a2.value) {
        this.setText(assign_default({}, this.text, this.textPosition));
      }
      return {
        start: assign_default({}, pointsList[startIndex]),
        end: assign_default({}, pointsList[endIndex]),
        startIndex,
        endIndex,
        direction
      };
    };
    PolylineEdgeModel2.prototype.dragAppend = function(appendInfo, dragInfo) {
      var _a2;
      this.isDragging = true;
      var start = appendInfo.start, end = appendInfo.end, startIndex = appendInfo.startIndex, endIndex = appendInfo.endIndex, direction = appendInfo.direction;
      var pointsList = this.pointsList;
      if (direction === SegmentDirection.HORIZONTAL) {
        pointsList[startIndex] = {
          x: start.x,
          y: start.y + dragInfo.y
        };
        pointsList[endIndex] = {
          x: end.x,
          y: end.y + dragInfo.y
        };
        var draggingPointList = this.pointsList.map(function(i4) {
          return i4;
        });
        if (startIndex !== 0 && endIndex !== this.pointsList.length - 1) {
          draggingPointList = this.removeCrossPoints(startIndex, endIndex, draggingPointList);
        }
        if (startIndex === 0) {
          var startPosition = {
            x: start.x,
            y: start.y + dragInfo.y
          };
          var inNode = isInNode(startPosition, this.sourceNode);
          if (!inNode) {
            var anchorList = this.sourceNode.anchors;
            draggingPointList = this.getDraggingPoints(direction, "start", startPosition, anchorList, draggingPointList);
          }
        }
        if (endIndex === this.pointsList.length - 1) {
          var endPosition = {
            x: end.x,
            y: end.y + dragInfo.y
          };
          var inNode = isInNode(endPosition, this.targetNode);
          if (!inNode) {
            var anchorList = this.targetNode.anchors;
            draggingPointList = this.getDraggingPoints(direction, "end", endPosition, anchorList, draggingPointList);
          }
        }
        this.updatePointsAfterDrag(draggingPointList);
        this.draggingPointList = draggingPointList;
      } else if (direction === SegmentDirection.VERTICAL) {
        pointsList[startIndex] = {
          x: start.x + dragInfo.x,
          y: start.y
        };
        pointsList[endIndex] = {
          x: end.x + dragInfo.x,
          y: end.y
        };
        var draggingPointList = this.pointsList.map(function(i4) {
          return i4;
        });
        if (startIndex !== 0 && endIndex !== this.pointsList.length - 1) {
          draggingPointList = this.removeCrossPoints(startIndex, endIndex, draggingPointList);
        }
        if (startIndex === 0) {
          var startPosition = {
            x: start.x + dragInfo.x,
            y: start.y
          };
          var inNode = isInNode(startPosition, this.sourceNode);
          if (!inNode) {
            var anchorList = this.sourceNode.anchors;
            draggingPointList = this.getDraggingPoints(direction, "start", startPosition, anchorList, draggingPointList);
          }
        }
        if (endIndex === this.pointsList.length - 1) {
          var endPosition = {
            x: end.x + dragInfo.x,
            y: end.y
          };
          var inNode = isInNode(endPosition, this.targetNode);
          if (!inNode) {
            var anchorList = this.targetNode.anchors;
            draggingPointList = this.getDraggingPoints(direction, "end", endPosition, anchorList, draggingPointList);
          }
        }
        this.updatePointsAfterDrag(draggingPointList);
        this.draggingPointList = draggingPointList;
      }
      if ((_a2 = this.text) === null || _a2 === void 0 ? void 0 : _a2.value) {
        this.setText(assign_default({}, this.text, this.textPosition));
      }
      return {
        start: assign_default({}, pointsList[startIndex]),
        end: assign_default({}, pointsList[endIndex]),
        startIndex,
        endIndex,
        direction
      };
    };
    PolylineEdgeModel2.prototype.dragAppendEnd = function() {
      if (this.draggingPointList) {
        var pointsList = pointFilter(points2PointsList(this.points));
        this.pointsList = pointsList.map(function(i4) {
          return i4;
        });
        this.draggingPointList = [];
        var startPoint = pointsList[0];
        this.startPoint = assign_default({}, startPoint);
        var endPoint = pointsList[pointsList.length - 1];
        this.endPoint = assign_default({}, endPoint);
      }
      this.isDragging = false;
    };
    PolylineEdgeModel2.prototype.updatePointsAfterDrag = function(pointsList) {
      var list = this.updateCrossPoints(pointsList);
      this.points = list.map(function(point) {
        return "".concat(point.x, ",").concat(point.y);
      }).join(" ");
    };
    PolylineEdgeModel2.prototype.getAdjustStart = function() {
      return this.pointsList[0] || this.startPoint;
    };
    PolylineEdgeModel2.prototype.getAdjustEnd = function() {
      var pointsList = this.pointsList;
      return pointsList[pointsList.length - 1] || this.endPoint;
    };
    PolylineEdgeModel2.prototype.updateAfterAdjustStartAndEnd = function(_a2) {
      var startPoint = _a2.startPoint, endPoint = _a2.endPoint, sourceNode = _a2.sourceNode, targetNode = _a2.targetNode;
      this.pointsList = getPolylinePoints({
        x: startPoint.x,
        y: startPoint.y
      }, {
        x: endPoint.x,
        y: endPoint.y
      }, sourceNode, targetNode, this.offset || 0);
      this.initPoints();
    };
    __decorate3([
      observable
    ], PolylineEdgeModel2.prototype, "dbClickPosition", void 0);
    __decorate3([
      action
    ], PolylineEdgeModel2.prototype, "initPoints", null);
    __decorate3([
      action
    ], PolylineEdgeModel2.prototype, "updatePoints", null);
    __decorate3([
      action
    ], PolylineEdgeModel2.prototype, "updateStartPoint", null);
    __decorate3([
      action
    ], PolylineEdgeModel2.prototype, "moveStartPoint", null);
    __decorate3([
      action
    ], PolylineEdgeModel2.prototype, "updateEndPoint", null);
    __decorate3([
      action
    ], PolylineEdgeModel2.prototype, "moveEndPoint", null);
    __decorate3([
      action
    ], PolylineEdgeModel2.prototype, "updatePointsList", null);
    __decorate3([
      action
    ], PolylineEdgeModel2.prototype, "dragAppendStart", null);
    __decorate3([
      action
    ], PolylineEdgeModel2.prototype, "dragAppendSimple", null);
    __decorate3([
      action
    ], PolylineEdgeModel2.prototype, "dragAppend", null);
    __decorate3([
      action
    ], PolylineEdgeModel2.prototype, "dragAppendEnd", null);
    __decorate3([
      action
    ], PolylineEdgeModel2.prototype, "updatePointsAfterDrag", null);
    __decorate3([
      action
    ], PolylineEdgeModel2.prototype, "getAdjustStart", null);
    __decorate3([
      action
    ], PolylineEdgeModel2.prototype, "getAdjustEnd", null);
    __decorate3([
      action
    ], PolylineEdgeModel2.prototype, "updateAfterAdjustStartAndEnd", null);
    return PolylineEdgeModel2;
  }(BaseEdgeModel)
);

// node_modules/@logicflow/core/es/model/node/BaseNodeModel.js
var __assign17 = function() {
  __assign17 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign17.apply(this, arguments);
};
var __decorate4 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var __values2 = function(o2) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o2[s3], i4 = 0;
  if (m3) return m3.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i4 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i4++], done: !o2 };
    }
  };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read18 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var BaseNodeModel = (
  /** @class */
  function() {
    function BaseNodeModel2(data, graphModel) {
      var _a2;
      this.BaseType = ElementType.NODE;
      this.id = "";
      this.type = "";
      this.x = 0;
      this.y = 0;
      this.textMode = TextMode.TEXT;
      this.text = {
        value: "",
        x: 0,
        y: 0,
        draggable: false,
        editable: true
      };
      this._width = 100;
      this._height = 80;
      this.minWidth = 30;
      this.minHeight = 30;
      this.maxWidth = 2e3;
      this.maxHeight = 2e3;
      this.anchorsOffset = [];
      this.virtual = false;
      this.isSelected = false;
      this.isHovered = false;
      this.isShowAnchor = false;
      this.isDragging = false;
      this.isHitable = true;
      this.isHittable = true;
      this.draggable = true;
      this.visible = true;
      this.rotatable = true;
      this.resizable = true;
      this.zIndex = 1;
      this.state = ElementState.DEFAULT;
      this.autoToFront = true;
      this.style = {};
      this._rotate = 0;
      this.modelType = ModelType.NODE;
      this.additionStateData = {};
      this.targetRules = [];
      this.sourceRules = [];
      this.moveRules = [];
      this.resizeRules = [];
      this.hasSetTargetRules = false;
      this.hasSetSourceRules = false;
      this.graphModel = graphModel;
      this.properties = (_a2 = data.properties) !== null && _a2 !== void 0 ? _a2 : {};
      this.initNodeData(data);
      this.setAttributes();
    }
    Object.defineProperty(BaseNodeModel2.prototype, "width", {
      get: function() {
        return this._width;
      },
      set: function(value) {
        this._width = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseNodeModel2.prototype, "height", {
      get: function() {
        return this._height;
      },
      set: function(value) {
        this._height = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseNodeModel2.prototype, "rotate", {
      get: function() {
        return this._rotate;
      },
      set: function(value) {
        this._rotate = value;
        var _a2 = this, _b = _a2.x, x3 = _b === void 0 ? 0 : _b, _c = _a2.y, y3 = _c === void 0 ? 0 : _c;
        this.transform = new TranslateMatrix(-x3, -y3).rotate(value).translate(x3, y3).toString();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseNodeModel2.prototype, "incoming", {
      /**
       * 
       */
      get: function() {
        return {
          nodes: this.graphModel.getNodeIncomingNode(this.id),
          edges: this.graphModel.getNodeIncomingEdge(this.id)
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseNodeModel2.prototype, "outgoing", {
      /*
       * 
       */
      get: function() {
        return {
          nodes: this.graphModel.getNodeOutgoingNode(this.id),
          edges: this.graphModel.getNodeOutgoingEdge(this.id)
        };
      },
      enumerable: false,
      configurable: true
    });
    BaseNodeModel2.prototype.initNodeData = function(data) {
      if (!data.properties) {
        data.properties = {};
      }
      if (!data.id) {
        var idGenerator = this.graphModel.idGenerator;
        var globalId = idGenerator && idGenerator(data.type);
        var nodeId = this.createId();
        data.id = nodeId || globalId || createUuid();
      }
      this.formatText(data);
      assign_default(this, pickNodeConfig(data));
      var overlapMode = this.graphModel.overlapMode;
      if (overlapMode === OverlapMode.INCREASE) {
        this.zIndex = data.zIndex || getZIndex();
      }
    };
    BaseNodeModel2.prototype.setAttributes = function() {
    };
    BaseNodeModel2.prototype.createId = function() {
      return null;
    };
    BaseNodeModel2.prototype.setTextMode = function(mode) {
      this.textMode = mode;
    };
    BaseNodeModel2.prototype.formatText = function(data) {
      var _a2, _b, _c;
      var _d = this.graphModel.editConfigModel, nodeTextDraggable = _d.nodeTextDraggable, nodeTextEdit = _d.nodeTextEdit;
      var x3 = data.x, y3 = data.y, text = data.text;
      var textConfig = {
        value: "",
        x: x3,
        y: y3,
        draggable: nodeTextDraggable,
        editable: nodeTextEdit
      };
      if (text) {
        if (typeof text === "string") {
          textConfig.value = text;
        } else {
          textConfig = __assign17(__assign17({}, textConfig), { x: (_a2 = text.x) !== null && _a2 !== void 0 ? _a2 : x3, y: (_b = text.y) !== null && _b !== void 0 ? _b : y3, value: (_c = text.value) !== null && _c !== void 0 ? _c : "" });
          if (!isUndefined_default(text.draggable)) {
            textConfig.draggable = text.draggable;
          }
          if (!isUndefined_default(text.editable)) {
            textConfig.editable = text.editable;
          }
        }
      }
      data.text = textConfig;
    };
    BaseNodeModel2.prototype.resize = function(resizeInfo) {
      var width = resizeInfo.width, height = resizeInfo.height, deltaX = resizeInfo.deltaX, deltaY = resizeInfo.deltaY;
      var isAllowResize = this.isAllowResizeNode(deltaX, deltaY, width, height);
      if (!isAllowResize) {
        return this.getData();
      }
      this.move(deltaX / 2, deltaY / 2);
      this.width = width;
      this.height = height;
      this.setProperties({
        width,
        height
      });
      return this.getData();
    };
    BaseNodeModel2.prototype.proportionalResize = function() {
    };
    BaseNodeModel2.prototype.getData = function() {
      var _a2 = this.text, x3 = _a2.x, y3 = _a2.y, value = _a2.value;
      var properties = this.properties;
      if (isObservable(properties)) {
        properties = toJS(properties);
      }
      if (isNil_default(properties.width)) {
        properties.width = this.width;
      }
      if (isNil_default(properties.height)) {
        properties.height = this.height;
      }
      var data = {
        id: this.id,
        type: this.type,
        x: this.x,
        y: this.y,
        properties
      };
      if (this.rotate) {
        data.rotate = this.rotate;
      }
      if (this.graphModel.overlapMode === OverlapMode.INCREASE) {
        data.zIndex = this.zIndex;
      }
      if (value) {
        data.text = {
          x: x3,
          y: y3,
          value
        };
      }
      return data;
    };
    BaseNodeModel2.prototype.getHistoryData = function() {
      return this.getData();
    };
    BaseNodeModel2.prototype.getProperties = function() {
      return toJS(this.properties);
    };
    BaseNodeModel2.prototype.getOuterGAttributes = function() {
      return {
        className: ""
      };
    };
    BaseNodeModel2.prototype.getNodeStyle = function() {
      return __assign17(__assign17({}, this.graphModel.theme.baseNode), this.style);
    };
    BaseNodeModel2.prototype.getTextStyle = function() {
      var nodeText = this.graphModel.theme.nodeText;
      var _a2 = this.properties.textStyle, textStyle = _a2 === void 0 ? {} : _a2;
      return __assign17(__assign17({}, cloneDeep_default(nodeText)), cloneDeep_default(textStyle));
    };
    BaseNodeModel2.prototype.getRotateControlStyle = function() {
      var rotateControl = this.graphModel.theme.rotateControl;
      return cloneDeep_default(rotateControl);
    };
    BaseNodeModel2.prototype.getResizeControlStyle = function() {
      var resizeControl = this.graphModel.theme.resizeControl;
      return cloneDeep_default(resizeControl);
    };
    BaseNodeModel2.prototype.getResizeOutlineStyle = function() {
      var resizeOutline = this.graphModel.theme.resizeOutline;
      return cloneDeep_default(resizeOutline);
    };
    BaseNodeModel2.prototype.getAnchorStyle = function(_anchorInfo) {
      var anchor = this.graphModel.theme.anchor;
      return cloneDeep_default(anchor);
    };
    BaseNodeModel2.prototype.getAnchorLineStyle = function(_anchorInfo) {
      var anchorLine = this.graphModel.theme.anchorLine;
      return cloneDeep_default(anchorLine);
    };
    BaseNodeModel2.prototype.getOutlineStyle = function() {
      var outline = this.graphModel.theme.outline;
      return cloneDeep_default(outline);
    };
    BaseNodeModel2.prototype.isAllowConnectedAsSource = function(target, sourceAnchor, targetAnchor, edgeId) {
      var rules = !this.hasSetSourceRules ? this.getConnectedSourceRules() : this.sourceRules;
      this.hasSetSourceRules = true;
      var isAllPass = true;
      var msg = "";
      for (var i4 = 0; i4 < rules.length; i4++) {
        var rule = rules[i4];
        if (!rule.validate.call(this, this, target, sourceAnchor, targetAnchor, edgeId)) {
          isAllPass = false;
          msg = rule.message;
          break;
        }
      }
      return {
        isAllPass,
        msg
      };
    };
    BaseNodeModel2.prototype.getConnectedSourceRules = function() {
      return this.sourceRules;
    };
    BaseNodeModel2.prototype.isAllowConnectedAsTarget = function(source, sourceAnchor, targetAnchor, edgeId) {
      var rules = !this.hasSetTargetRules ? this.getConnectedTargetRules() : this.targetRules;
      this.hasSetTargetRules = true;
      var isAllPass = true;
      var msg = "";
      for (var i4 = 0; i4 < rules.length; i4++) {
        var rule = rules[i4];
        if (!rule.validate.call(this, source, this, sourceAnchor, targetAnchor, edgeId)) {
          isAllPass = false;
          msg = rule.message;
          break;
        }
      }
      return {
        isAllPass,
        msg
      };
    };
    BaseNodeModel2.prototype.isAllowMoveNode = function(deltaX, deltaY) {
      var e_1, _a2;
      var isAllowMoveX = true;
      var isAllowMoveY = true;
      var rules = this.moveRules.concat(this.graphModel.nodeMoveRules);
      try {
        for (var rules_1 = __values2(rules), rules_1_1 = rules_1.next(); !rules_1_1.done; rules_1_1 = rules_1.next()) {
          var rule = rules_1_1.value;
          var r3 = rule(this, deltaX, deltaY);
          if (!r3)
            return false;
          if (typeof r3 === "object") {
            var r1 = r3;
            if (!r1.x && !r1.y) {
              return false;
            }
            isAllowMoveX = isAllowMoveX && r1.x;
            isAllowMoveY = isAllowMoveY && r1.y;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (rules_1_1 && !rules_1_1.done && (_a2 = rules_1.return)) _a2.call(rules_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return {
        x: isAllowMoveX,
        y: isAllowMoveY
      };
    };
    BaseNodeModel2.prototype.getConnectedTargetRules = function() {
      return this.targetRules;
    };
    BaseNodeModel2.prototype.getAnchorsByOffset = function() {
      var _a2 = this, anchorsOffset = _a2.anchorsOffset, id = _a2.id, x3 = _a2.x, y3 = _a2.y;
      if (anchorsOffset && anchorsOffset.length > 0) {
        return anchorsOffset.map(function(el, idx) {
          if (el.length) {
            el = el;
            return {
              id: "".concat(id, "_").concat(idx),
              x: x3 + el[0],
              y: y3 + el[1]
            };
          }
          el = el;
          return __assign17(__assign17({}, el), { x: x3 + el.x, y: y3 + el.y, id: el.id || "".concat(id, "_").concat(idx) });
        });
      }
      return this.getDefaultAnchor();
    };
    BaseNodeModel2.prototype.getDefaultAnchor = function() {
      return [];
    };
    BaseNodeModel2.prototype.getTargetAnchor = function(position) {
      return getClosestAnchor(position, this);
    };
    BaseNodeModel2.prototype.getBounds = function() {
      return {
        minX: this.x - this.width / 2,
        minY: this.y - this.height / 2,
        maxX: this.x + this.width / 2,
        maxY: this.y + this.height / 2
      };
    };
    Object.defineProperty(BaseNodeModel2.prototype, "anchors", {
      get: function() {
        var anchors = this.getAnchorsByOffset();
        var _a2 = this, x3 = _a2.x, y3 = _a2.y, rotate = _a2.rotate;
        anchors.forEach(function(anchor) {
          var anchorX = anchor.x, anchorY = anchor.y;
          var _a3 = __read18(new Matrix([anchorX, anchorY, 1]).translate(-x3, -y3).rotate(rotate).translate(x3, y3)[0], 2), e3 = _a3[0], f5 = _a3[1];
          anchor.x = e3;
          anchor.y = f5;
        });
        return anchors;
      },
      enumerable: false,
      configurable: true
    });
    BaseNodeModel2.prototype.getAnchorInfo = function(anchorId) {
      if (isNil_default(anchorId))
        return void 0;
      for (var i4 = 0; i4 < this.anchors.length; i4++) {
        var anchor = this.anchors[i4];
        if (anchor.id === anchorId) {
          return anchor;
        }
      }
    };
    BaseNodeModel2.prototype.addNodeMoveRules = function(fn2) {
      if (!this.moveRules.includes(fn2)) {
        this.moveRules.push(fn2);
      }
    };
    BaseNodeModel2.prototype.isAllowMoveByXORY = function(deltaX, deltaY, isIgnoreRule) {
      var isAllowMoveX;
      var isAllowMoveY;
      if (isIgnoreRule) {
        isAllowMoveX = true;
        isAllowMoveY = true;
      } else {
        var r3 = this.isAllowMoveNode(deltaX, deltaY);
        if (typeof r3 === "boolean") {
          isAllowMoveX = r3;
          isAllowMoveY = r3;
        } else {
          isAllowMoveX = r3.x;
          isAllowMoveY = r3.y;
        }
      }
      return {
        isAllowMoveX,
        isAllowMoveY
      };
    };
    BaseNodeModel2.prototype.move = function(deltaX, deltaY, isIgnoreRule) {
      if (isIgnoreRule === void 0) {
        isIgnoreRule = false;
      }
      var _a2 = this.isAllowMoveByXORY(deltaX, deltaY, isIgnoreRule), isAllowMoveX = _a2.isAllowMoveX, isAllowMoveY = _a2.isAllowMoveY;
      if (isAllowMoveX) {
        this.x = this.x + deltaX;
        this.text && this.moveText(deltaX, 0);
      }
      if (isAllowMoveY) {
        this.y = this.y + deltaY;
        this.text && this.moveText(0, deltaY);
      }
      if (isAllowMoveX || isAllowMoveY) {
        this.rotate = this._rotate;
      }
      return isAllowMoveX || isAllowMoveY;
    };
    BaseNodeModel2.prototype.getMoveDistance = function(deltaX, deltaY, isIgnoreRule) {
      if (isIgnoreRule === void 0) {
        isIgnoreRule = false;
      }
      var _a2 = this.isAllowMoveByXORY(deltaX, deltaY, isIgnoreRule), isAllowMoveX = _a2.isAllowMoveX, isAllowMoveY = _a2.isAllowMoveY;
      var moveX = 0;
      var moveY = 0;
      if (isAllowMoveX && deltaX) {
        this.x = this.x + deltaX;
        this.text && this.moveText(deltaX, 0);
        moveX = deltaX;
      }
      if (isAllowMoveY && deltaY) {
        this.y = this.y + deltaY;
        this.text && this.moveText(0, deltaY);
        moveY = deltaY;
      }
      return [moveX, moveY];
    };
    BaseNodeModel2.prototype.moveTo = function(x3, y3, isIgnoreRule) {
      if (isIgnoreRule === void 0) {
        isIgnoreRule = false;
      }
      var deltaX = x3 - this.x;
      var deltaY = y3 - this.y;
      if (!isIgnoreRule && !this.isAllowMoveNode(deltaX, deltaY))
        return false;
      this.text && this.moveText(deltaX, deltaY);
      this.x = x3;
      this.y = y3;
      return true;
    };
    BaseNodeModel2.prototype.moveText = function(deltaX, deltaY) {
      var _a2 = this.text, x3 = _a2.x, y3 = _a2.y, value = _a2.value, draggable = _a2.draggable, editable = _a2.editable;
      this.text = {
        value,
        editable,
        draggable,
        x: x3 + deltaX,
        y: y3 + deltaY
      };
    };
    BaseNodeModel2.prototype.updateText = function(value) {
      this.text = __assign17(__assign17({}, toJS(this.text)), { value });
    };
    BaseNodeModel2.prototype.addNodeResizeRules = function(fn2) {
      if (!this.resizeRules.includes(fn2)) {
        this.resizeRules.push(fn2);
      }
    };
    BaseNodeModel2.prototype.isAllowResizeNode = function(deltaX, deltaY, width, height) {
      var e_2, _a2;
      var rules = this.resizeRules.concat(this.graphModel.nodeResizeRules);
      try {
        for (var rules_2 = __values2(rules), rules_2_1 = rules_2.next(); !rules_2_1.done; rules_2_1 = rules_2.next()) {
          var rule = rules_2_1.value;
          var r3 = rule(this, deltaX, deltaY, width, height);
          if (!r3)
            return false;
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (rules_2_1 && !rules_2_1.done && (_a2 = rules_2.return)) _a2.call(rules_2);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
      return true;
    };
    BaseNodeModel2.prototype.setSelected = function(flag) {
      if (flag === void 0) {
        flag = true;
      }
      this.isSelected = flag;
    };
    BaseNodeModel2.prototype.setHovered = function(flag) {
      if (flag === void 0) {
        flag = true;
      }
      this.isHovered = flag;
      this.setIsShowAnchor(flag);
    };
    BaseNodeModel2.prototype.setIsShowAnchor = function(flag) {
      if (flag === void 0) {
        flag = true;
      }
      this.isShowAnchor = flag;
    };
    BaseNodeModel2.prototype.setRotatable = function(flag) {
      if (flag === void 0) {
        flag = true;
      }
      this.rotatable = flag;
    };
    BaseNodeModel2.prototype.setResizable = function(flag) {
      if (flag === void 0) {
        flag = true;
      }
      this.resizable = flag;
    };
    BaseNodeModel2.prototype.setHitable = function(flag) {
      if (flag === void 0) {
        flag = true;
      }
      this.isHitable = flag;
    };
    BaseNodeModel2.prototype.setHittable = function(flag) {
      if (flag === void 0) {
        flag = true;
      }
      this.isHittable = flag;
    };
    BaseNodeModel2.prototype.setElementState = function(state, additionStateData) {
      this.state = state;
      this.additionStateData = additionStateData;
    };
    BaseNodeModel2.prototype.updateProperties = function(nextProperties, updateKeys) {
      var preProperties = toJS(this.properties);
      this.properties = nextProperties;
      this.setAttributes();
      this.graphModel.eventCenter.emit(EventType.NODE_PROPERTIES_CHANGE, {
        id: this.id,
        keys: updateKeys,
        preProperties,
        properties: nextProperties
      });
    };
    BaseNodeModel2.prototype.setProperty = function(key, val) {
      var preProperties = toJS(this.properties);
      var nextProperties = cloneDeep_default(preProperties);
      set_default(nextProperties, key, formatData(val));
      this.updateProperties(nextProperties, [key]);
    };
    BaseNodeModel2.prototype.setProperties = function(properties) {
      var preProperties = toJS(this.properties);
      var nextProperties = __assign17(__assign17({}, preProperties), formatData(properties));
      var updateKeys = [];
      mapKeys_default(properties, function(val, key) {
        if (has_default(preProperties, key) && preProperties[key] !== val || !has_default(preProperties, key)) {
          updateKeys.push(key);
        }
      });
      this.updateProperties(nextProperties, updateKeys);
    };
    BaseNodeModel2.prototype.deleteProperty = function(key) {
      delete this.properties[key];
      this.setAttributes();
    };
    BaseNodeModel2.prototype.setStyle = function(key, val) {
      var _a2;
      this.style = __assign17(__assign17({}, this.style), (_a2 = {}, _a2[key] = formatData(val), _a2));
    };
    BaseNodeModel2.prototype.setStyles = function(styles) {
      this.style = __assign17(__assign17({}, this.style), formatData(styles));
    };
    BaseNodeModel2.prototype.updateStyles = function(styles) {
      this.style = __assign17({}, formatData(styles));
    };
    BaseNodeModel2.prototype.setZIndex = function(zIndex) {
      if (zIndex === void 0) {
        zIndex = 1;
      }
      this.zIndex = zIndex;
    };
    BaseNodeModel2.prototype.updateAttributes = function(attributes) {
      assign_default(this, attributes);
    };
    BaseNodeModel2.BaseType = ElementType.NODE;
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "type", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "x", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "y", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "textMode", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "text", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "properties", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "_width", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "_height", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "anchorsOffset", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "isSelected", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "isHovered", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "isShowAnchor", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "isDragging", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "isHitable", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "isHittable", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "draggable", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "visible", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "rotatable", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "resizable", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "zIndex", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "state", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "autoToFront", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "style", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "transform", void 0);
    __decorate4([
      observable
    ], BaseNodeModel2.prototype, "_rotate", void 0);
    __decorate4([
      computed
    ], BaseNodeModel2.prototype, "incoming", null);
    __decorate4([
      computed
    ], BaseNodeModel2.prototype, "outgoing", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "setTextMode", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "addNodeMoveRules", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "move", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "getMoveDistance", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "moveTo", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "moveText", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "updateText", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "addNodeResizeRules", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "setSelected", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "setHovered", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "setIsShowAnchor", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "setRotatable", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "setResizable", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "setHitable", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "setHittable", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "setElementState", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "setProperty", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "setProperties", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "deleteProperty", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "setStyle", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "setStyles", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "updateStyles", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "setZIndex", null);
    __decorate4([
      action
    ], BaseNodeModel2.prototype, "updateAttributes", null);
    return BaseNodeModel2;
  }()
);
var BaseNodeModel_default = BaseNodeModel;

// node_modules/@logicflow/core/es/model/node/CircleNodeModel.js
var __extends8 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign18 = function() {
  __assign18 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign18.apply(this, arguments);
};
var __decorate5 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var CircleNodeModel = (
  /** @class */
  function(_super) {
    __extends8(CircleNodeModel2, _super);
    function CircleNodeModel2(data, graphModel) {
      var _this = _super.call(this, data, graphModel) || this;
      _this.modelType = ModelType.CIRCLE_NODE;
      _this.r = 50;
      _this.initNodeData(data);
      _this.setAttributes();
      return _this;
    }
    Object.defineProperty(CircleNodeModel2.prototype, "width", {
      get: function() {
        return this.r * 2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CircleNodeModel2.prototype, "height", {
      get: function() {
        return this.r * 2;
      },
      enumerable: false,
      configurable: true
    });
    CircleNodeModel2.prototype.setAttributes = function() {
      _super.prototype.setAttributes.call(this);
      var r3 = this.properties.r;
      if (r3) {
        this.r = r3;
      }
    };
    CircleNodeModel2.prototype.getNodeStyle = function() {
      var style = _super.prototype.getNodeStyle.call(this);
      var circle = this.graphModel.theme.circle;
      var _a2 = this.properties.style, customStyle = _a2 === void 0 ? {} : _a2;
      return __assign18(__assign18(__assign18({}, style), cloneDeep_default(circle)), cloneDeep_default(customStyle));
    };
    CircleNodeModel2.prototype.getDefaultAnchor = function() {
      var _a2 = this, x3 = _a2.x, y3 = _a2.y, r3 = _a2.r;
      return [
        { x: x3, y: y3 - r3, id: "".concat(this.id, "_0") },
        { x: x3 + r3, y: y3, id: "".concat(this.id, "_1") },
        { x: x3, y: y3 + r3, id: "".concat(this.id, "_2") },
        { x: x3 - r3, y: y3, id: "".concat(this.id, "_3") }
      ];
    };
    CircleNodeModel2.prototype.resize = function(resizeInfo) {
      var width = resizeInfo.width, deltaX = resizeInfo.deltaX, deltaY = resizeInfo.deltaY;
      this.move(deltaX / 2, deltaY / 2);
      this.r = width;
      this.setProperties({
        r: width
      });
      return this.getData();
    };
    __decorate5([
      observable
    ], CircleNodeModel2.prototype, "r", void 0);
    __decorate5([
      computed
    ], CircleNodeModel2.prototype, "width", null);
    __decorate5([
      computed
    ], CircleNodeModel2.prototype, "height", null);
    return CircleNodeModel2;
  }(BaseNodeModel_default)
);

// node_modules/@logicflow/core/es/model/node/DiamondNodeModel.js
var __extends9 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign19 = function() {
  __assign19 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign19.apply(this, arguments);
};
var __decorate6 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var __read19 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var DiamondNodeModel = (
  /** @class */
  function(_super) {
    __extends9(DiamondNodeModel2, _super);
    function DiamondNodeModel2(data, graphModel) {
      var _this = _super.call(this, data, graphModel) || this;
      _this.modelType = ModelType.DIAMOND_NODE;
      _this.rx = 30;
      _this.ry = 50;
      _this.initNodeData(data);
      _this.setAttributes();
      return _this;
    }
    DiamondNodeModel2.prototype.setAttributes = function() {
      _super.prototype.setAttributes.call(this);
      var _a2 = this.properties, rx = _a2.rx, ry = _a2.ry;
      if (rx) {
        this.rx = rx;
      }
      if (ry) {
        this.ry = ry;
      }
    };
    DiamondNodeModel2.prototype.getNodeStyle = function() {
      var style = _super.prototype.getNodeStyle.call(this);
      var diamond = this.graphModel.theme.diamond;
      var _a2 = this.properties.style, customStyle = _a2 === void 0 ? {} : _a2;
      return __assign19(__assign19(__assign19({}, style), cloneDeep_default(diamond)), cloneDeep_default(customStyle));
    };
    Object.defineProperty(DiamondNodeModel2.prototype, "points", {
      get: function() {
        var _a2 = this, x3 = _a2.x, y3 = _a2.y, rx = _a2.rx, ry = _a2.ry;
        return [
          [x3, y3 - ry],
          [x3 + rx, y3],
          [x3, y3 + ry],
          [x3 - rx, y3]
        ];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DiamondNodeModel2.prototype, "pointsPosition", {
      get: function() {
        return map_default(this.points, function(_a2) {
          var _b = __read19(_a2, 2), x3 = _b[0], y3 = _b[1];
          return { x: x3, y: y3 };
        });
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DiamondNodeModel2.prototype, "width", {
      get: function() {
        var min = Number.MAX_SAFE_INTEGER;
        var max = Number.MIN_SAFE_INTEGER;
        forEach_default(this.points, function(_a2) {
          var _b = __read19(_a2, 1), x3 = _b[0];
          if (x3 < min) {
            min = x3;
          }
          if (x3 > max) {
            max = x3;
          }
        });
        return max - min;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DiamondNodeModel2.prototype, "height", {
      get: function() {
        var min = Number.MAX_SAFE_INTEGER;
        var max = Number.MIN_SAFE_INTEGER;
        forEach_default(this.points, function(_a2) {
          var _b = __read19(_a2, 2), y3 = _b[1];
          if (y3 < min) {
            min = y3;
          }
          if (y3 > max) {
            max = y3;
          }
        });
        return max - min;
      },
      enumerable: false,
      configurable: true
    });
    DiamondNodeModel2.prototype.getDefaultAnchor = function() {
      var _this = this;
      return map_default(this.points, function(_a2, idx) {
        var _b = __read19(_a2, 2), x3 = _b[0], y3 = _b[1];
        return {
          x: x3,
          y: y3,
          id: "".concat(_this.id, "_").concat(idx)
        };
      });
    };
    DiamondNodeModel2.prototype.resize = function(resizeInfo) {
      var width = resizeInfo.width, height = resizeInfo.height, deltaX = resizeInfo.deltaX, deltaY = resizeInfo.deltaY;
      this.move(deltaX / 2, deltaY / 2);
      this.rx = width;
      this.ry = height;
      this.setProperties({
        rx: width,
        ry: height
      });
      return this.getData();
    };
    __decorate6([
      observable
    ], DiamondNodeModel2.prototype, "rx", void 0);
    __decorate6([
      observable
    ], DiamondNodeModel2.prototype, "ry", void 0);
    __decorate6([
      computed
    ], DiamondNodeModel2.prototype, "points", null);
    __decorate6([
      computed
    ], DiamondNodeModel2.prototype, "pointsPosition", null);
    __decorate6([
      computed
    ], DiamondNodeModel2.prototype, "width", null);
    __decorate6([
      computed
    ], DiamondNodeModel2.prototype, "height", null);
    return DiamondNodeModel2;
  }(BaseNodeModel_default)
);

// node_modules/@logicflow/core/es/model/node/EllipseNodeModel.js
var __extends10 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign20 = function() {
  __assign20 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign20.apply(this, arguments);
};
var __decorate7 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var EllipseNodeModel = (
  /** @class */
  function(_super) {
    __extends10(EllipseNodeModel2, _super);
    function EllipseNodeModel2(data, graphModel) {
      var _this = _super.call(this, data, graphModel) || this;
      _this.modelType = ModelType.ELLIPSE_NODE;
      _this.rx = 30;
      _this.ry = 45;
      _this.initNodeData(data);
      _this.setAttributes();
      return _this;
    }
    EllipseNodeModel2.prototype.setAttributes = function() {
      _super.prototype.setAttributes.call(this);
      var _a2 = this.properties, rx = _a2.rx, ry = _a2.ry;
      if (rx) {
        this.rx = rx;
      }
      if (ry) {
        this.ry = ry;
      }
    };
    EllipseNodeModel2.prototype.getNodeStyle = function() {
      var style = _super.prototype.getNodeStyle.call(this);
      var ellipse = this.graphModel.theme.ellipse;
      var _a2 = this.properties.style, customStyle = _a2 === void 0 ? {} : _a2;
      return __assign20(__assign20(__assign20({}, style), cloneDeep_default(ellipse)), cloneDeep_default(customStyle));
    };
    Object.defineProperty(EllipseNodeModel2.prototype, "width", {
      get: function() {
        return this.rx * 2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(EllipseNodeModel2.prototype, "height", {
      get: function() {
        return this.ry * 2;
      },
      enumerable: false,
      configurable: true
    });
    EllipseNodeModel2.prototype.getDefaultAnchor = function() {
      var _a2 = this, x3 = _a2.x, y3 = _a2.y, rx = _a2.rx, ry = _a2.ry;
      return [
        { x: x3, y: y3 - ry, id: "".concat(this.id, "_0") },
        { x: x3 + rx, y: y3, id: "".concat(this.id, "_1") },
        { x: x3, y: y3 + ry, id: "".concat(this.id, "_2") },
        { x: x3 - rx, y: y3, id: "".concat(this.id, "_3") }
      ];
    };
    EllipseNodeModel2.prototype.resize = function(resizeInfo) {
      var width = resizeInfo.width, height = resizeInfo.height, deltaX = resizeInfo.deltaX, deltaY = resizeInfo.deltaY;
      this.move(deltaX / 2, deltaY / 2);
      this.rx = width;
      this.ry = height;
      this.setProperties({
        rx: width,
        ry: height
      });
      return this.getData();
    };
    __decorate7([
      observable
    ], EllipseNodeModel2.prototype, "rx", void 0);
    __decorate7([
      observable
    ], EllipseNodeModel2.prototype, "ry", void 0);
    __decorate7([
      computed
    ], EllipseNodeModel2.prototype, "width", null);
    __decorate7([
      computed
    ], EllipseNodeModel2.prototype, "height", null);
    return EllipseNodeModel2;
  }(BaseNodeModel_default)
);

// node_modules/@logicflow/core/es/model/node/PolygonNodeModel.js
var __extends11 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign21 = function() {
  __assign21 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign21.apply(this, arguments);
};
var __decorate8 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var __read20 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var PolygonNodeModel = (
  /** @class */
  function(_super) {
    __extends11(PolygonNodeModel2, _super);
    function PolygonNodeModel2(data, graphModel) {
      var _this = _super.call(this, data, graphModel) || this;
      _this.modelType = ModelType.POLYGON_NODE;
      _this.points = [
        [50, 0],
        [100, 50],
        [50, 100],
        [0, 50]
        // 
        // [0,100], [50,25], [50,75], [100,0] // 
        // [100, 10],
        // [40, 198],
        // [190, 78],
        // [10, 78],
        // [160, 198], // 
      ];
      _this.initNodeData(data);
      _this.setAttributes();
      return _this;
    }
    PolygonNodeModel2.prototype.setAttributes = function() {
      _super.prototype.setAttributes.call(this);
      var _a2 = this.properties, points = _a2.points, width = _a2.width, height = _a2.height;
      var nextPoints = points || this.points;
      this.points = normalizePolygon(nextPoints, width, height);
    };
    PolygonNodeModel2.prototype.getNodeStyle = function() {
      var style = _super.prototype.getNodeStyle.call(this);
      var polygon = this.graphModel.theme.polygon;
      var _a2 = this.properties.style, customStyle = _a2 === void 0 ? {} : _a2;
      return __assign21(__assign21(__assign21({}, style), cloneDeep_default(polygon)), cloneDeep_default(customStyle));
    };
    Object.defineProperty(PolygonNodeModel2.prototype, "pointsPosition", {
      /**
       * svg
       * logicflowpoints
       * 
       */
      get: function() {
        var _a2 = this, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
        return this.points.map(function(item) {
          return {
            x: item[0] + x3 - width / 2,
            y: item[1] + y3 - height / 2
          };
        });
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PolygonNodeModel2.prototype, "width", {
      get: function() {
        var min = Number.MAX_SAFE_INTEGER;
        var max = Number.MIN_SAFE_INTEGER;
        this.points.forEach(function(_a2) {
          var _b = __read20(_a2, 1), x3 = _b[0];
          if (x3 < min) {
            min = x3;
          }
          if (x3 > max) {
            max = x3;
          }
        });
        return max - min;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PolygonNodeModel2.prototype, "height", {
      get: function() {
        var min = Number.MAX_SAFE_INTEGER;
        var max = Number.MIN_SAFE_INTEGER;
        this.points.forEach(function(_a2) {
          var _b = __read20(_a2, 2), y3 = _b[1];
          if (y3 < min) {
            min = y3;
          }
          if (y3 > max) {
            max = y3;
          }
        });
        return max - min;
      },
      enumerable: false,
      configurable: true
    });
    PolygonNodeModel2.prototype.getDefaultAnchor = function() {
      var _this = this;
      var _a2 = this, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height, points = _a2.points;
      return points.map(function(_a3, idx) {
        var _b = __read20(_a3, 2), x1 = _b[0], y1 = _b[1];
        return {
          x: x3 + x1 - width / 2,
          y: y3 + y1 - height / 2,
          id: "".concat(_this.id, "_").concat(idx)
        };
      });
    };
    PolygonNodeModel2.prototype.resize = function(resizeInfo) {
      var _this = this;
      var width = resizeInfo.width, height = resizeInfo.height, deltaX = resizeInfo.deltaX, deltaY = resizeInfo.deltaY;
      this.move(deltaX / 2, deltaY / 2);
      var nextPoints = map_default(this.points, function(_a2) {
        var _b = __read20(_a2, 2), x3 = _b[0], y3 = _b[1];
        return [
          x3 * width / _this.width,
          y3 * height / _this.height
        ];
      });
      this.points = nextPoints;
      this.properties.points = nextPoints;
      return this.getData();
    };
    __decorate8([
      observable
    ], PolygonNodeModel2.prototype, "points", void 0);
    __decorate8([
      computed
    ], PolygonNodeModel2.prototype, "pointsPosition", null);
    __decorate8([
      computed
    ], PolygonNodeModel2.prototype, "width", null);
    __decorate8([
      computed
    ], PolygonNodeModel2.prototype, "height", null);
    return PolygonNodeModel2;
  }(BaseNodeModel_default)
);

// node_modules/@logicflow/core/es/model/node/RectNodeModel.js
var __extends12 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign22 = function() {
  __assign22 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign22.apply(this, arguments);
};
var __decorate9 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var RectNodeModel = (
  /** @class */
  function(_super) {
    __extends12(RectNodeModel2, _super);
    function RectNodeModel2(data, graphModel) {
      var _this = _super.call(this, data, graphModel) || this;
      _this.modelType = ModelType.RECT_NODE;
      _this.radius = 0;
      _this.initNodeData(data);
      _this.setAttributes();
      return _this;
    }
    RectNodeModel2.prototype.setAttributes = function() {
      _super.prototype.setAttributes.call(this);
      var _a2 = this.properties, width = _a2.width, height = _a2.height, radius = _a2.radius;
      if (!isNil_default(width))
        this.width = width;
      if (!isNil_default(height))
        this.height = height;
      if (!isNil_default(radius))
        this.radius = radius;
    };
    RectNodeModel2.prototype.getDefaultAnchor = function() {
      var _a2 = this, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
      return [
        { x: x3, y: y3 - height / 2, id: "".concat(this.id, "_0") },
        { x: x3 + width / 2, y: y3, id: "".concat(this.id, "_1") },
        { x: x3, y: y3 + height / 2, id: "".concat(this.id, "_2") },
        { x: x3 - width / 2, y: y3, id: "".concat(this.id, "_3") }
      ];
    };
    RectNodeModel2.prototype.getNodeStyle = function() {
      var style = _super.prototype.getNodeStyle.call(this);
      var rect = this.graphModel.theme.rect;
      var _a2 = this.properties.style, customStyle = _a2 === void 0 ? {} : _a2;
      return __assign22(__assign22(__assign22({}, style), cloneDeep_default(rect)), cloneDeep_default(customStyle));
    };
    __decorate9([
      observable
    ], RectNodeModel2.prototype, "radius", void 0);
    return RectNodeModel2;
  }(BaseNodeModel_default)
);

// node_modules/@logicflow/core/es/model/node/TextNodeModel.js
var __extends13 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign23 = function() {
  __assign23 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign23.apply(this, arguments);
};
var __decorate10 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var __read21 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray6 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l3 = from.length, ar; i4 < l3; i4++) {
    if (ar || !(i4 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i4);
      ar[i4] = from[i4];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var TextNodeModel = (
  /** @class */
  function(_super) {
    __extends13(TextNodeModel2, _super);
    function TextNodeModel2() {
      var _this = _super.apply(this, __spreadArray6([], __read21(arguments), false)) || this;
      _this.modelType = ModelType.TEXT_NODE;
      return _this;
    }
    TextNodeModel2.prototype.getTextStyle = function() {
      var style = _super.prototype.getTextStyle.call(this);
      var text = this.graphModel.theme.text;
      var textStyle = this.properties.textStyle;
      return __assign23(__assign23(__assign23({}, style), cloneDeep_default(text)), cloneDeep_default(textStyle));
    };
    Object.defineProperty(TextNodeModel2.prototype, "width", {
      get: function() {
        var rows = String(this.text.value).split(/[\r\n]/g);
        var fontSize = this.getTextStyle().fontSize;
        var width = getSvgTextWidthHeight({
          rows,
          fontSize,
          rowsLength: rows.length
        }).width;
        return width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextNodeModel2.prototype, "height", {
      get: function() {
        var rows = String(this.text.value).split(/[\r\n]/g);
        var fontSize = this.getTextStyle().fontSize;
        var height = getSvgTextWidthHeight({
          rows,
          fontSize,
          rowsLength: rows.length
        }).height;
        return height;
      },
      enumerable: false,
      configurable: true
    });
    __decorate10([
      computed
    ], TextNodeModel2.prototype, "width", null);
    __decorate10([
      computed
    ], TextNodeModel2.prototype, "height", null);
    return TextNodeModel2;
  }(BaseNodeModel_default)
);

// node_modules/@logicflow/core/es/model/node/HtmlNodeModel.js
var __extends14 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var HtmlNodeModel = (
  /** @class */
  function(_super) {
    __extends14(HtmlNodeModel2, _super);
    function HtmlNodeModel2(data, graphModel) {
      var _this = _super.call(this, data, graphModel) || this;
      _this.modelType = ModelType.HTML_NODE;
      _this.setAttributes();
      return _this;
    }
    HtmlNodeModel2.prototype.setAttributes = function() {
      _super.prototype.setAttributes.call(this);
      var _a2 = this.properties, width = _a2.width, height = _a2.height;
      if (width)
        this.width = width;
      if (height)
        this.height = height;
    };
    HtmlNodeModel2.prototype.getDefaultAnchor = function() {
      var _a2 = this, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
      return [
        { x: x3, y: y3 - height / 2, id: "".concat(this.id, "_0") },
        { x: x3 + width / 2, y: y3, id: "".concat(this.id, "_1") },
        { x: x3, y: y3 + height / 2, id: "".concat(this.id, "_2") },
        { x: x3 - width / 2, y: y3, id: "".concat(this.id, "_3") }
      ];
    };
    return HtmlNodeModel2;
  }(BaseNodeModel_default)
);

// node_modules/@logicflow/core/es/model/EditConfigModel.js
var __decorate11 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var silentModeConfig = {
  // SilentMode 
  stopZoomGraph: false,
  stopScrollGraph: false,
  stopMoveGraph: false,
  //  & 
  adjustEdge: false,
  adjustEdgeStartAndEnd: false,
  adjustNodePosition: false,
  hideAnchors: true,
  allowRotate: false,
  allowResize: false,
  nodeSelectedOutline: true,
  // 
  textEdit: false,
  nodeTextEdit: false,
  edgeTextEdit: false,
  textDraggable: false,
  nodeTextDraggable: false,
  edgeTextDraggable: false
};
var allKeys = [
  "isSilentMode",
  // 
  "stopZoomGraph",
  // 
  "stopScrollGraph",
  // 
  "stopMoveGraph",
  // 
  "snapGrid",
  // 
  "adjustEdge",
  // 
  "adjustEdgeMiddle",
  // 
  "adjustEdgeStartAndEnd",
  // 
  "adjustEdgeStart",
  // 
  "adjustEdgeEnd",
  // 
  "adjustNodePosition",
  // 
  "hideAnchors",
  // 
  "allowRotate",
  // 
  "allowResize",
  // 
  "autoExpand",
  // 
  "hoverOutline",
  // 
  "nodeSelectedOutline",
  //  outline
  "edgeSelectedOutline",
  //  outline
  "textEdit",
  // 
  "nodeTextEdit",
  // 
  "edgeTextEdit",
  // 
  "textDraggable",
  // 
  "nodeTextDraggable",
  // 
  "edgeTextDraggable",
  // 
  "multipleSelectKey",
  // 
  // 2.0.0 
  "textMode",
  // 
  "nodeTextMode",
  // 
  "edgeTextMode",
  // 
  "nodeTextMultiple",
  // 
  "edgeTextMultiple",
  // 
  "nodeTextVertical",
  // 
  "edgeTextVertical"
  // 
];
var EditConfigModel = (
  /** @class */
  function() {
    function EditConfigModel2(config) {
      this.isSilentMode = false;
      this.stopZoomGraph = false;
      this.stopMoveGraph = false;
      this.stopScrollGraph = false;
      this.snapGrid = false;
      this.textMode = TextMode.TEXT;
      this.textEdit = true;
      this.textDraggable = false;
      this.nodeTextEdit = true;
      this.nodeTextDraggable = false;
      this.nodeTextMultiple = false;
      this.nodeTextVertical = false;
      this.nodeTextMode = TextMode.TEXT;
      this.edgeTextMode = TextMode.TEXT;
      this.edgeTextEdit = true;
      this.edgeTextDraggable = false;
      this.edgeTextMultiple = false;
      this.edgeTextVertical = false;
      this.hideAnchors = false;
      this.allowRotate = false;
      this.allowResize = false;
      this.hoverOutline = true;
      this.nodeSelectedOutline = true;
      this.adjustNodePosition = true;
      this.autoExpand = false;
      this.adjustEdge = true;
      this.adjustEdgeMiddle = false;
      this.adjustEdgeStartAndEnd = false;
      this.adjustEdgeStart = false;
      this.adjustEdgeEnd = false;
      this.edgeSelectedOutline = true;
      this.multipleSelectKey = "";
      assign_default(this, this.computeConfig(config));
    }
    EditConfigModel2.prototype.updateEditConfig = function(config) {
      var newConfig = this.computeConfig(config);
      assign_default(this, newConfig);
    };
    EditConfigModel2.prototype.computeConfig = function(config) {
      var isSilentMode = config.isSilentMode, textDraggable = config.textDraggable, textMode = config.textMode, textEdit = config.textEdit, adjustEdgeStartAndEnd = config.adjustEdgeStartAndEnd;
      var conf = {};
      if (isSilentMode === false) {
        assign_default(conf, this.stagedConfig);
      }
      if (isSilentMode === true && isSilentMode !== this.isSilentMode) {
        var silentConfig = pick_default(silentModeConfig, allKeys);
        this.stagedConfig = pick_default(this, allKeys);
        assign_default(conf, silentConfig);
      }
      if (!isUndefined_default(textEdit)) {
        assign_default(conf, {
          nodeTextEdit: textEdit,
          edgeTextEdit: textEdit
        });
      }
      if (!isUndefined_default(textDraggable)) {
        assign_default(conf, {
          nodeTextDraggable: textDraggable,
          edgeTextDraggable: textDraggable
        });
      }
      if (textMode) {
        assign_default(conf, {
          nodeTextMode: textMode,
          edgeTextMode: textMode
        });
      }
      if (isBoolean_default(adjustEdgeStartAndEnd)) {
        assign_default(conf, {
          adjustEdgeStart: adjustEdgeStartAndEnd,
          adjustEdgeEnd: adjustEdgeStartAndEnd
        });
      }
      var userConfig = pick_default(config, allKeys);
      return assign_default(conf, userConfig);
    };
    EditConfigModel2.prototype.updateTextMode = function(textMode) {
      this.textMode = textMode;
      this.edgeTextMode = textMode;
      this.nodeTextMode = textMode;
    };
    EditConfigModel2.prototype.getConfig = function() {
      return pick_default(this, allKeys);
    };
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "isSilentMode", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "stopZoomGraph", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "stopMoveGraph", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "stopScrollGraph", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "snapGrid", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "textMode", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "textEdit", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "textDraggable", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "nodeTextEdit", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "nodeTextDraggable", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "nodeTextMultiple", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "nodeTextVertical", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "nodeTextMode", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "edgeTextMode", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "edgeTextEdit", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "edgeTextDraggable", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "edgeTextMultiple", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "edgeTextVertical", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "hideAnchors", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "allowRotate", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "allowResize", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "hoverOutline", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "nodeSelectedOutline", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "adjustNodePosition", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "autoExpand", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "adjustEdge", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "adjustEdgeMiddle", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "adjustEdgeStartAndEnd", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "adjustEdgeStart", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "adjustEdgeEnd", void 0);
    __decorate11([
      observable
    ], EditConfigModel2.prototype, "edgeSelectedOutline", void 0);
    __decorate11([
      action
    ], EditConfigModel2.prototype, "updateEditConfig", null);
    __decorate11([
      action
    ], EditConfigModel2.prototype, "updateTextMode", null);
    return EditConfigModel2;
  }()
);

// node_modules/@logicflow/core/es/event/eventEmitter.js
var WILDCARD = "*";
var EventEmitter = (
  /** @class */
  function() {
    function EventEmitter2() {
      this._events = {};
    }
    EventEmitter2.prototype.on = function(evt, callback, once2) {
      var _this = this;
      evt === null || evt === void 0 ? void 0 : evt.split(",").forEach(function(evKey) {
        evKey = evKey.trim();
        if (!_this._events[evKey]) {
          _this._events[evKey] = [];
        }
        _this._events[evKey].push({
          callback,
          once: !!once2
        });
      });
    };
    EventEmitter2.prototype.once = function(evt, callback) {
      var _this = this;
      evt === null || evt === void 0 ? void 0 : evt.split(",").forEach(function(evKey) {
        evKey = evKey.trim();
        _this.on(evKey, callback, true);
      });
    };
    EventEmitter2.prototype.emit = function(evts, eventArgs) {
      var _this = this;
      evts === null || evts === void 0 ? void 0 : evts.split(",").forEach(function(evt) {
        var events = _this._events[evt] || [];
        var wildcardEvents = _this._events[WILDCARD] || [];
        var doEmit = function(es) {
          var length = es.length;
          for (var i4 = 0; i4 < length; i4++) {
            if (!es[i4]) {
              continue;
            }
            var _a2 = es[i4], callback = _a2.callback, once2 = _a2.once;
            if (once2) {
              es.splice(i4, 1);
              if (es.length === 0) {
                delete _this._events[evt];
              }
              length--;
              i4--;
            }
            callback.apply(_this, [eventArgs]);
          }
        };
        doEmit(events);
        doEmit(wildcardEvents);
      });
    };
    EventEmitter2.prototype.off = function(evts, callback) {
      var _this = this;
      if (!evts) {
        this._events = {};
      }
      evts.split(",").forEach(function(evt) {
        if (!callback) {
          delete _this._events[evt];
        } else {
          var events = _this._events[evt] || [];
          var length_1 = events.length;
          for (var i4 = 0; i4 < length_1; i4++) {
            if (events[i4].callback === callback) {
              events.splice(i4, 1);
              length_1--;
              i4--;
            }
          }
          if (events.length === 0) {
            delete _this._events[evt];
          }
        }
      });
    };
    EventEmitter2.prototype.getEvents = function() {
      return this._events;
    };
    EventEmitter2.prototype.destroy = function() {
      this._events = {};
    };
    return EventEmitter2;
  }()
);
var eventEmitter_default = EventEmitter;

// node_modules/@logicflow/core/es/view/overlay/CanvasOverlay.js
var __extends15 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign24 = function() {
  __assign24 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign24.apply(this, arguments);
};
var __decorate12 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var CanvasOverlay = (
  /** @class */
  function(_super) {
    __extends15(CanvasOverlay2, _super);
    function CanvasOverlay2(props) {
      var _this = _super.call(this) || this;
      _this.stepScrollX = 0;
      _this.stepScrollY = 0;
      _this.onDragging = function(_a3) {
        var deltaX = _a3.deltaX, deltaY = _a3.deltaY;
        _this.setState({
          isDragging: true
        });
        var _b = _this.props.graphModel, transformModel = _b.transformModel, editConfigModel = _b.editConfigModel;
        if (editConfigModel.stopMoveGraph === true) {
          return;
        }
        transformModel.translate(deltaX, deltaY);
      };
      _this.onDragEnd = function() {
        _this.setState({
          isDragging: false
        });
      };
      _this.zoomHandler = function(ev) {
        var _a3 = _this.props, _b = _a3.graphModel, editConfigModel = _b.editConfigModel, transformModel = _b.transformModel, gridSize2 = _b.gridSize, graphModel = _a3.graphModel;
        var eX = ev.deltaX, eY = ev.deltaY;
        var stopScrollGraph = editConfigModel.stopScrollGraph, stopZoomGraph = editConfigModel.stopZoomGraph;
        if (!stopScrollGraph && !ev.ctrlKey && !ev.metaKey) {
          ev.preventDefault();
          _this.stepScrollX += eX;
          _this.stepScrollY += eY;
          if (Math.abs(_this.stepScrollX) >= gridSize2) {
            var remainderX = _this.stepScrollX % gridSize2;
            var moveDistance = _this.stepScrollX - remainderX;
            transformModel.translate(-moveDistance * transformModel.SCALE_X, 0);
            _this.stepScrollX = remainderX;
          }
          if (Math.abs(_this.stepScrollY) >= gridSize2) {
            var remainderY = _this.stepScrollY % gridSize2;
            var moveDistanceY = _this.stepScrollY - remainderY;
            transformModel.translate(0, -moveDistanceY * transformModel.SCALE_Y);
            _this.stepScrollY = remainderY;
          }
          return;
        }
        if (!stopZoomGraph) {
          ev.preventDefault();
          var position = graphModel.getPointByClient({
            x: ev.clientX,
            y: ev.clientY
          });
          var _c = position.canvasOverlayPosition, x3 = _c.x, y3 = _c.y;
          transformModel.zoom(ev.deltaY < 0, [x3, y3]);
        }
      };
      _this.clickHandler = function(ev) {
        var target = ev.target;
        if (target.getAttribute("name") === "canvas-overlay") {
          var graphModel = _this.props.graphModel;
          var selectElements = graphModel.selectElements;
          if (selectElements.size > 0) {
            graphModel.clearSelectElements();
          }
          graphModel.eventCenter.emit(EventType.BLANK_CLICK, { e: ev });
        }
      };
      _this.handleContextMenu = function(ev) {
        var target = ev.target;
        if (target.getAttribute("name") === "canvas-overlay") {
          ev.preventDefault();
          var graphModel = _this.props.graphModel;
          var position = graphModel.getPointByClient({
            x: ev.clientX,
            y: ev.clientY
          });
          graphModel.eventCenter.emit(EventType.BLANK_CONTEXTMENU, {
            e: ev,
            position
          });
        }
      };
      _this.mouseDownHandler = function(ev) {
        var _a3 = _this.props.graphModel, eventCenter2 = _a3.eventCenter, editConfigModel = _a3.editConfigModel, SCALE_X = _a3.transformModel.SCALE_X, gridSize2 = _a3.gridSize;
        var adjustEdge = editConfigModel.adjustEdge, adjustNodePosition = editConfigModel.adjustNodePosition, stopMoveGraph = editConfigModel.stopMoveGraph;
        var target = ev.target;
        var isFrozenElement = !adjustEdge && !adjustNodePosition;
        if (target.getAttribute("name") === "canvas-overlay" || isFrozenElement) {
          if (stopMoveGraph !== true) {
            _this.stepDrag.setStep(gridSize2 * SCALE_X);
            _this.stepDrag.handleMouseDown(ev);
          } else {
            eventCenter2.emit(EventType.BLANK_MOUSEDOWN, { e: ev });
          }
          _this.clickHandler(ev);
        }
      };
      var _a2 = props.graphModel, gridSize = _a2.gridSize, eventCenter = _a2.eventCenter;
      _this.stepDrag = new StepDrag({
        onDragging: _this.onDragging,
        onDragEnd: _this.onDragEnd,
        step: gridSize,
        eventType: "BLANK",
        isStopPropagation: false,
        eventCenter,
        model: void 0
      });
      _this.state = {
        isDragging: false
      };
      return _this;
    }
    CanvasOverlay2.prototype.render = function() {
      var transformModel = this.props.graphModel.transformModel;
      var transform = transformModel.getTransformStyle().transform;
      var _a2 = this.props, children = _a2.children, dnd = _a2.dnd;
      var isDragging = this.state.isDragging;
      return u3("svg", __assign24({ xmlns: "http://www.w3.org/2000/svg", width: "100%", height: "100%", name: "canvas-overlay", onWheel: this.zoomHandler, onMouseDown: this.mouseDownHandler, onContextMenu: this.handleContextMenu, className: isDragging ? "lf-canvas-overlay lf-dragging" : "lf-canvas-overlay lf-drag-able" }, dnd.eventMap(), { children: u3("g", { transform, children }) }));
    };
    CanvasOverlay2 = __decorate12([
      observer2
    ], CanvasOverlay2);
    return CanvasOverlay2;
  }(x)
);

// node_modules/@logicflow/core/es/view/overlay/BezierAdjustOverlay.js
var __extends16 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign25 = function() {
  __assign25 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign25.apply(this, arguments);
};
var __decorate13 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var __read22 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var BezierAdjustAnchor = (
  /** @class */
  function(_super) {
    __extends16(BezierAdjustAnchor2, _super);
    function BezierAdjustAnchor2() {
      var _this = _super.call(this) || this;
      _this.onDragging = function(_a2) {
        var event = _a2.event;
        var _b = _this.props, graphModel = _b.graphModel, bezierModel = _b.bezierModel, type = _b.type;
        var _c = graphModel.getPointByClient({
          x: event.clientX,
          y: event.clientY
        }).canvasOverlayPosition, x3 = _c.x, y3 = _c.y;
        bezierModel.updateAdjustAnchor({
          x: x3,
          y: y3
        }, type);
        graphModel.eventCenter.emit(EventType.EDGE_ADJUST, {
          data: bezierModel.getData()
        });
      };
      _this.onDragEnd = function() {
        var bezierModel = _this.props.bezierModel;
        bezierModel.isDragging = false;
      };
      _this.dragHandler = new StepDrag({
        onDragging: _this.onDragging,
        onDragEnd: _this.onDragEnd
      });
      return _this;
    }
    BezierAdjustAnchor2.prototype.render = function() {
      var _this = this;
      var position = this.props.position;
      var x3 = position.x, y3 = position.y;
      var bezierModel = this.props.bezierModel;
      var adjustAnchor = bezierModel.getEdgeStyle().adjustAnchor;
      return u3(Circle, __assign25({ className: "lf-bezier-adjust-anchor", x: x3, y: y3 }, adjustAnchor, { onMouseDown: function(ev) {
        _this.dragHandler.handleMouseDown(ev);
      } }));
    };
    return BezierAdjustAnchor2;
  }(x)
);
var BezierAdjustOverlay = (
  /** @class */
  function(_super) {
    __extends16(BezierAdjustOverlay2, _super);
    function BezierAdjustOverlay2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    BezierAdjustOverlay2.prototype.getBezierAdjust = function(bezier, graphModel) {
      var path = bezier.path, id = bezier.id;
      var pointsList = getBezierPoints(path);
      var _a2 = __read22(pointsList, 4), start = _a2[0], sNext = _a2[1], ePre = _a2[2], end = _a2[3];
      var adjustLine = bezier.getEdgeStyle().adjustLine;
      var result = [];
      result.push(u3(Line, __assign25({ x1: start.x, y1: start.y, x2: sNext.x, y2: sNext.y }, adjustLine)));
      result.push(u3(BezierAdjustAnchor, { position: sNext, bezierModel: bezier, graphModel, type: "sNext" }, "".concat(id, "_ePre")));
      result.push(u3(Line, __assign25({ x1: end.x, y1: end.y, x2: ePre.x, y2: ePre.y }, adjustLine)));
      result.push(u3(BezierAdjustAnchor, { position: ePre, bezierModel: bezier, graphModel, type: "ePre" }, "".concat(id, "_sNext")));
      return result;
    };
    BezierAdjustOverlay2.prototype.selectedBezierEdge = function() {
      var graphModel = this.props.graphModel;
      var edgeList = graphModel.edges;
      var edgeAdjust = [];
      for (var i4 = 0; i4 < edgeList.length; i4++) {
        var edge = edgeList[i4];
        if (edge.isSelected && edge.modelType === ModelType.BEZIER_EDGE && edge.draggable) {
          edgeAdjust.push(this.getBezierAdjust(edge, graphModel));
        }
      }
      return edgeAdjust;
    };
    BezierAdjustOverlay2.prototype.render = function() {
      return u3("g", { className: "lf-bezier-adjust", children: this.selectedBezierEdge() });
    };
    BezierAdjustOverlay2 = __decorate13([
      observer2
    ], BezierAdjustOverlay2);
    return BezierAdjustOverlay2;
  }(x)
);

// node_modules/@logicflow/core/es/view/overlay/BackgroundOverlay.js
var __extends17 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __decorate14 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var BackgroundOverlay = (
  /** @class */
  function(_super) {
    __extends17(BackgroundOverlay2, _super);
    function BackgroundOverlay2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    BackgroundOverlay2.prototype.render = function() {
      var background = this.props.background;
      return u3("div", { className: "lf-background", children: u3("div", { style: isObject_default(background) ? background : {}, className: "lf-background-area" }) });
    };
    BackgroundOverlay2 = __decorate14([
      observer2
    ], BackgroundOverlay2);
    return BackgroundOverlay2;
  }(x)
);

// node_modules/@logicflow/core/es/view/overlay/Grid.js
var __extends18 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __decorate15 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var Grid = (
  /** @class */
  function(_super) {
    __extends18(Grid2, _super);
    function Grid2(props) {
      var _this = _super.call(this, props) || this;
      _this.id = createUuid();
      _this.gridOptions = _this.props.graphModel.grid;
      return _this;
    }
    Grid2.prototype.renderDot = function() {
      var _a2 = this.gridOptions, config = _a2.config, _b = _a2.size, size = _b === void 0 ? 1 : _b, visible = _a2.visible;
      var _c = config !== null && config !== void 0 ? config : {}, color = _c.color, _d = _c.thickness, thickness = _d === void 0 ? 2 : _d;
      var radius = Math.min(Math.max(2, thickness), size / 4);
      var opacity = visible ? 1 : 0;
      return u3("g", { fill: color, opacity, children: [u3("circle", { cx: 0, cy: 0, r: radius / 2 }), u3("circle", { cx: 0, cy: size, r: radius / 2 }), u3("circle", { cx: size, cy: 0, r: radius / 2 }), u3("circle", { cx: size, cy: size, r: radius / 2 })] });
    };
    Grid2.prototype.renderMesh = function() {
      var _a2 = this.gridOptions, config = _a2.config, _b = _a2.size, size = _b === void 0 ? 1 : _b, visible = _a2.visible;
      var _c = config !== null && config !== void 0 ? config : {}, color = _c.color, _d = _c.thickness, thickness = _d === void 0 ? 1 : _d;
      var strokeWidth = Math.min(Math.max(1, thickness), size / 2);
      var d2 = "M 0 0 H ".concat(size, " V ").concat(size, " H 0 Z");
      var opacity = visible ? 1 : 0;
      return u3("path", { d: d2, stroke: color, strokeWidth: strokeWidth / 2, opacity, fill: "transparent" });
    };
    Grid2.prototype.render = function() {
      var transformModel = this.props.graphModel.transformModel;
      var _a2 = this.gridOptions, type = _a2.type, _b = _a2.size, size = _b === void 0 ? 1 : _b;
      var SCALE_X = transformModel.SCALE_X, SKEW_Y = transformModel.SKEW_Y, SKEW_X = transformModel.SKEW_X, SCALE_Y = transformModel.SCALE_Y, TRANSLATE_X = transformModel.TRANSLATE_X, TRANSLATE_Y = transformModel.TRANSLATE_Y;
      var matrixString = [
        SCALE_X,
        SKEW_Y,
        SKEW_X,
        SCALE_Y,
        TRANSLATE_X,
        TRANSLATE_Y
      ].join(",");
      var transform = "matrix(".concat(matrixString, ")");
      return u3("div", { className: "lf-grid", children: u3("svg", { xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "100%", height: "100%", children: [u3("defs", { children: u3("pattern", { id: this.id, patternUnits: "userSpaceOnUse", patternTransform: transform, x: "0", y: "0", width: size, height: size, children: [type === "dot" && this.renderDot(), type === "mesh" && this.renderMesh()] }) }), u3("rect", { width: "100%", height: "100%", fill: "url(#".concat(this.id, ")") })] }) });
    };
    Grid2 = __decorate15([
      observer2
    ], Grid2);
    return Grid2;
  }(x)
);
(function(Grid2) {
  Grid2.defaultProps = {
    size: DEFAULT_GRID_SIZE,
    visible: true,
    type: "dot",
    config: {
      color: "#ababab",
      thickness: 1
    }
  };
  function getGridOptions(options) {
    var defaultOptions2 = cloneDeep_default(Grid2.defaultProps);
    if (typeof options === "number") {
      return assign_default(defaultOptions2, { size: options });
    } else if (typeof options === "boolean") {
      return assign_default(defaultOptions2, { visible: options });
    } else {
      return assign_default(defaultOptions2, options);
    }
  }
  Grid2.getGridOptions = getGridOptions;
})(Grid || (Grid = {}));

// node_modules/@logicflow/core/es/view/overlay/ModificationOverlay.js
var __extends19 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __decorate16 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var ModificationOverlay = (
  /** @class */
  function(_super) {
    __extends19(ModificationOverlay2, _super);
    function ModificationOverlay2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ModificationOverlay2.prototype.render = function() {
      var transformModel = this.props.graphModel.transformModel;
      var transform = transformModel.getTransformStyle().transform;
      var children = this.props.children;
      return u3("svg", { xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "100%", height: "100%", className: "modification-overlay", children: u3("g", { transform, children }) });
    };
    ModificationOverlay2 = __decorate16([
      observer2
    ], ModificationOverlay2);
    return ModificationOverlay2;
  }(x)
);

// node_modules/@logicflow/core/es/view/overlay/OutlineOverlay.js
var __extends20 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign26 = function() {
  __assign26 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign26.apply(this, arguments);
};
var __decorate17 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var OutlineOverlay = (
  /** @class */
  function(_super) {
    __extends20(OutlineOverlay2, _super);
    function OutlineOverlay2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    OutlineOverlay2.prototype.getNodesOutline = function() {
      var graphModel = this.props.graphModel;
      var nodes = graphModel.nodes, _a2 = graphModel.editConfigModel, hoverOutline = _a2.hoverOutline, nodeSelectedOutline = _a2.nodeSelectedOutline;
      var nodeOutline = [];
      nodes.forEach(function(element) {
        if (element.isHovered || element.isSelected) {
          var isHovered = element.isHovered, isSelected = element.isSelected, x3 = element.x, y3 = element.y, width = element.width, height = element.height;
          if (nodeSelectedOutline && isSelected || hoverOutline && isHovered) {
            var style_1 = element.getOutlineStyle();
            var attributes_1 = {};
            Object.keys(style_1).forEach(function(key) {
              if (key !== "hover") {
                attributes_1[key] = style_1[key];
              }
            });
            if (isHovered) {
              var hoverStyle = style_1.hover;
              attributes_1 = __assign26(__assign26({}, attributes_1), hoverStyle);
            }
            nodeOutline.push(u3(Rect, __assign26({
              transform: element.transform,
              className: "lf-outline-node",
              x: x3,
              y: y3,
              // width: width + 10,
              // height: height + 10,
              width: width + 10,
              height: height + 10
            }, attributes_1)));
          }
        }
      });
      return nodeOutline;
    };
    OutlineOverlay2.prototype.getEdgeOutline = function() {
      var _a2 = this.props.graphModel, edgeList = _a2.edges, _b = _a2.editConfigModel, edgeSelectedOutline = _b.edgeSelectedOutline, hoverOutline = _b.hoverOutline;
      var edgeOutline = [];
      for (var i4 = 0; i4 < edgeList.length; i4++) {
        var edge = edgeList[i4];
        if (edgeSelectedOutline && edge.isSelected || hoverOutline && edge.isHovered) {
          if (edge.modelType === ModelType.LINE_EDGE) {
            edgeOutline.push(this.getLineOutline(edge));
          } else if (edge.modelType === ModelType.POLYLINE_EDGE) {
            edgeOutline.push(this.getPolylineOutline(edge));
          } else if (edge.modelType === ModelType.BEZIER_EDGE) {
            edgeOutline.push(this.getBezierOutline(edge));
          }
        }
      }
      return edgeOutline;
    };
    OutlineOverlay2.prototype.getLineOutline = function(line) {
      var startPoint = line.startPoint, endPoint = line.endPoint;
      var x3 = (startPoint.x + endPoint.x) / 2;
      var y3 = (startPoint.y + endPoint.y) / 2;
      var width = Math.abs(startPoint.x - endPoint.x) + 10;
      var height = Math.abs(startPoint.y - endPoint.y) + 10;
      var style = line.getOutlineStyle();
      return u3(Rect, __assign26({ className: "lf-outline-edge", x: x3, y: y3, width, height }, style));
    };
    OutlineOverlay2.prototype.getPolylineOutline = function(polyline) {
      var points = polyline.points;
      var pointsList = points2PointsList(points);
      var bbox = getBBoxOfPoints(pointsList, 8);
      var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
      var style = polyline.getOutlineStyle();
      return u3(Rect, __assign26({ className: "lf-outline", x: x3, y: y3, width, height }, style));
    };
    OutlineOverlay2.prototype.getBezierOutline = function(bezier) {
      var path = bezier.path;
      var pointsList = getBezierPoints(path);
      var bbox = getBBoxOfPoints(pointsList, 8);
      var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
      var style = bezier.getOutlineStyle();
      return u3(Rect, __assign26({ className: "lf-outline", x: x3, y: y3, width, height }, style));
    };
    OutlineOverlay2.prototype.render = function() {
      return u3("g", { className: "lf-outline", children: [this.getNodesOutline(), this.getEdgeOutline()] });
    };
    OutlineOverlay2 = __decorate17([
      observer2
    ], OutlineOverlay2);
    return OutlineOverlay2;
  }(x)
);

// node_modules/@logicflow/core/es/view/overlay/SnaplineOverlay.js
var __extends21 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign27 = function() {
  __assign27 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign27.apply(this, arguments);
};
var __decorate18 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var SnaplineOverlay = (
  /** @class */
  function(_super) {
    __extends21(SnaplineOverlay2, _super);
    function SnaplineOverlay2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SnaplineOverlay2.prototype.render = function() {
      var snaplineModel = this.props.snaplineModel;
      var _a2 = snaplineModel !== null && snaplineModel !== void 0 ? snaplineModel : {}, position = _a2.position, isShowHorizontal = _a2.isShowHorizontal, isShowVertical = _a2.isShowVertical;
      var style = snaplineModel === null || snaplineModel === void 0 ? void 0 : snaplineModel.getStyle();
      var _b = position !== null && position !== void 0 ? position : {}, _c = _b.x, x3 = _c === void 0 ? 0 : _c, _d = _b.y, y3 = _d === void 0 ? 0 : _d;
      var horizontalLine = __assign27(__assign27({ x1: -1e5, y1: y3, x2: 1e5, y2: y3 }, style), { stroke: isShowHorizontal ? style === null || style === void 0 ? void 0 : style.stroke : "none" });
      var verticalLine = __assign27(__assign27({ x1: x3, y1: -1e5, x2: x3, y2: 1e5 }, style), { stroke: isShowVertical ? style === null || style === void 0 ? void 0 : style.stroke : "none" });
      return u3("g", { className: "lf-snapline", children: [u3(Line_default, __assign27({}, horizontalLine)), u3(Line_default, __assign27({}, verticalLine))] });
    };
    SnaplineOverlay2 = __decorate18([
      observer2
    ], SnaplineOverlay2);
    return SnaplineOverlay2;
  }(x)
);

// node_modules/@logicflow/core/es/view/overlay/ToolOverlay.js
var __extends22 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __decorate19 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var ToolOverlay = (
  /** @class */
  function(_super) {
    __extends22(ToolOverlay2, _super);
    function ToolOverlay2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ToolOverlay2.prototype.componentDidMount = function() {
      this.triggerToolRender();
    };
    ToolOverlay2.prototype.componentDidUpdate = function() {
      this.triggerToolRender();
    };
    ToolOverlay2.prototype.getTools = function() {
      var _a2 = this.props, tool = _a2.tool, graphModel = _a2.graphModel;
      var textEditElement = graphModel.textEditElement;
      var tools = tool.getTools();
      var components = tools.map(function(t3) {
        return g(t3, {
          textEditElement,
          graphModel,
          lf: tool.instance
        });
      });
      tool.components = components;
      return components;
    };
    ToolOverlay2.prototype.triggerToolRender = function() {
      var _a2 = this.props, tool = _a2.tool, graphModel = _a2.graphModel;
      var ToolOverlayElement = document.querySelector("#ToolOverlay_".concat(graphModel.flowId));
      var lf = tool.getInstance();
      lf.components.forEach(function(render) {
        return render(lf, ToolOverlayElement);
      });
      lf.components = [];
    };
    ToolOverlay2.prototype.render = function() {
      var graphModel = this.props.graphModel;
      return u3("div", { className: "lf-tool-overlay", id: "ToolOverlay_".concat(graphModel.flowId), children: this.getTools() });
    };
    ToolOverlay2 = __decorate19([
      observer2
    ], ToolOverlay2);
    return ToolOverlay2;
  }(x)
);

// node_modules/@logicflow/core/es/model/GraphModel.js
var __assign28 = function() {
  __assign28 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign28.apply(this, arguments);
};
var __decorate20 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var __values3 = function(o2) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o2[s3], i4 = 0;
  if (m3) return m3.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i4 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i4++], done: !o2 };
    }
  };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read23 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray7 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l3 = from.length, ar; i4 < l3; i4++) {
    if (ar || !(i4 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i4);
      ar[i4] = from[i4];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var GraphModel = (
  /** @class */
  function() {
    function GraphModel2(options) {
      var _this = this;
      var _a2, _b;
      this.modelMap = /* @__PURE__ */ new Map();
      this.nodeModelMap = /* @__PURE__ */ new Map();
      this.edgeModelMap = /* @__PURE__ */ new Map();
      this.elementsModelMap = /* @__PURE__ */ new Map();
      this.nodeMoveRules = [];
      this.nodeResizeRules = [];
      this.nodes = [];
      this.edges = [];
      this.overlapMode = OverlapMode.DEFAULT;
      this.gridSize = 1;
      this.partial = false;
      this.waitCleanEffects = [];
      var container = options.container, partial = options.partial, _c = options.background, background = _c === void 0 ? {} : _c, grid = options.grid, idGenerator = options.idGenerator, edgeGenerator = options.edgeGenerator, animation = options.animation, customTrajectory = options.customTrajectory;
      this.rootEl = container;
      this.partial = !!partial;
      this.background = background;
      if (typeof grid === "object" && options.snapGrid) {
        this.gridSize = grid.size || 1;
      }
      this.theme = setupTheme(options.style);
      this.grid = Grid.getGridOptions(grid !== null && grid !== void 0 ? grid : false);
      this.edgeType = options.edgeType || "polyline";
      this.animation = setupAnimation(animation);
      this.overlapMode = options.overlapMode || OverlapMode.DEFAULT;
      this.width = (_a2 = options.width) !== null && _a2 !== void 0 ? _a2 : this.rootEl.getBoundingClientRect().width;
      this.isContainerWidth = isNil_default(options.width);
      this.height = (_b = options.height) !== null && _b !== void 0 ? _b : this.rootEl.getBoundingClientRect().height;
      this.isContainerHeight = isNil_default(options.height);
      var resizeObserver = new ResizeObserver(debounce_default(function(entries2) {
        var e_1, _a3;
        try {
          for (var entries_1 = __values3(entries2), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
            var entry = entries_1_1.value;
            if (entry.target === _this.rootEl) {
              _this.resize();
              _this.eventCenter.emit("graph:resize", {
                target: _this.rootEl,
                contentRect: entry.contentRect
              });
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (entries_1_1 && !entries_1_1.done && (_a3 = entries_1.return)) _a3.call(entries_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }, 16));
      resizeObserver.observe(this.rootEl);
      this.waitCleanEffects.push(function() {
        resizeObserver.disconnect();
      });
      this.eventCenter = new eventEmitter_default();
      this.editConfigModel = new EditConfigModel(options);
      this.transformModel = new TransformModel(this.eventCenter, options);
      this.flowId = createUuid();
      this.idGenerator = idGenerator;
      this.edgeGenerator = createEdgeGenerator(this, edgeGenerator);
      this.customTrajectory = customTrajectory;
    }
    Object.defineProperty(GraphModel2.prototype, "nodesMap", {
      get: function() {
        return this.nodes.reduce(function(nMap, model, index) {
          nMap[model.id] = {
            index,
            model
          };
          return nMap;
        }, {});
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(GraphModel2.prototype, "edgesMap", {
      get: function() {
        return this.edges.reduce(function(eMap, model, index) {
          eMap[model.id] = {
            index,
            model
          };
          return eMap;
        }, {});
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(GraphModel2.prototype, "modelsMap", {
      get: function() {
        return __spreadArray7(__spreadArray7([], __read23(this.nodes), false), __read23(this.edges), false).reduce(function(eMap, model) {
          eMap[model.id] = model;
          return eMap;
        }, {});
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(GraphModel2.prototype, "sortElements", {
      /**
       * zIndex
       * todo: 
       */
      get: function() {
        var elements = __spreadArray7(__spreadArray7([], __read23(this.nodes), false), __read23(this.edges), false).sort(function(a3, b2) {
          return a3.zIndex - b2.zIndex;
        });
        var visibleElements = [];
        var visibleLt = [
          -DEFAULT_VISIBLE_SPACE,
          -DEFAULT_VISIBLE_SPACE
        ];
        var visibleRb = [
          this.width + DEFAULT_VISIBLE_SPACE,
          this.height + DEFAULT_VISIBLE_SPACE
        ];
        for (var i4 = 0; i4 < elements.length; i4++) {
          var currentItem = elements[i4];
          if (currentItem.visible && (!this.partial || currentItem.isSelected || this.isElementInArea(currentItem, visibleLt, visibleRb, false, false))) {
            visibleElements.push(currentItem);
          }
        }
        return visibleElements;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(GraphModel2.prototype, "textEditElement", {
      /**
       * 
       */
      get: function() {
        var textEditNode = this.nodes.find(function(node) {
          return node.state === ElementState.TEXT_EDIT;
        });
        var textEditEdge = this.edges.find(function(edge) {
          return edge.state === ElementState.TEXT_EDIT;
        });
        return textEditNode || textEditEdge;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(GraphModel2.prototype, "selectElements", {
      /**
       * 
       */
      get: function() {
        var elements = /* @__PURE__ */ new Map();
        this.nodes.forEach(function(node) {
          if (node.isSelected) {
            elements.set(node.id, node);
          }
        });
        this.edges.forEach(function(edge) {
          if (edge.isSelected) {
            elements.set(edge.id, edge);
          }
        });
        return elements;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(GraphModel2.prototype, "selectNodes", {
      get: function() {
        var nodes = [];
        this.nodes.forEach(function(node) {
          if (node.isSelected) {
            nodes.push(node);
          }
        });
        return nodes;
      },
      enumerable: false,
      configurable: true
    });
    GraphModel2.prototype.getAreaElement = function(leftTopPoint, rightBottomPoint, wholeEdge, wholeNode, ignoreHideElement) {
      var _this = this;
      if (wholeEdge === void 0) {
        wholeEdge = true;
      }
      if (wholeNode === void 0) {
        wholeNode = true;
      }
      if (ignoreHideElement === void 0) {
        ignoreHideElement = false;
      }
      var areaElements = [];
      forEach_default(__spreadArray7(__spreadArray7([], __read23(this.nodes), false), __read23(this.edges), false), function(element) {
        var isElementInArea = _this.isElementInArea(element, leftTopPoint, rightBottomPoint, wholeEdge, wholeNode);
        if ((!ignoreHideElement || element.visible) && isElementInArea) {
          areaElements.push(element);
        }
      });
      return areaElements;
    };
    GraphModel2.prototype.getModel = function(type) {
      return this.modelMap.get(type);
    };
    GraphModel2.prototype.getNodeModelById = function(nodeId) {
      var _a2;
      if (this.fakeNode && nodeId === this.fakeNode.id) {
        return this.fakeNode;
      }
      return (_a2 = this.nodesMap[nodeId]) === null || _a2 === void 0 ? void 0 : _a2.model;
    };
    GraphModel2.prototype.getPointByClient = function(_a2) {
      var x1 = _a2.x, y1 = _a2.y;
      var bbox = this.rootEl.getBoundingClientRect();
      var domOverlayPosition = {
        x: x1 - bbox.left,
        y: y1 - bbox.top
      };
      var _b = __read23(this.transformModel.HtmlPointToCanvasPoint([
        domOverlayPosition.x,
        domOverlayPosition.y
      ]), 2), x3 = _b[0], y3 = _b[1];
      var canvasOverlayPosition = { x: x3, y: y3 };
      return {
        domOverlayPosition,
        canvasOverlayPosition
      };
    };
    GraphModel2.prototype.isElementInArea = function(element, lt, rb, wholeEdge, wholeNode) {
      var _a2;
      if (wholeEdge === void 0) {
        wholeEdge = true;
      }
      if (wholeNode === void 0) {
        wholeNode = true;
      }
      if (element.BaseType === ElementType.NODE) {
        element = element;
        var _b = getNodeBBox(element), minX = _b.minX, minY = _b.minY, maxX = _b.maxX, maxY = _b.maxY;
        var bboxPointsList = [
          {
            x: minX,
            y: minY
          },
          {
            x: maxX,
            y: minY
          },
          {
            x: maxX,
            y: maxY
          },
          {
            x: minX,
            y: maxY
          }
        ];
        var inArea = wholeNode;
        for (var i4 = 0; i4 < bboxPointsList.length; i4++) {
          var _c = bboxPointsList[i4], x3 = _c.x, y3 = _c.y;
          _a2 = __read23(this.transformModel.CanvasPointToHtmlPoint([x3, y3]), 2), x3 = _a2[0], y3 = _a2[1];
          if (isPointInArea([x3, y3], lt, rb) !== wholeNode) {
            inArea = !wholeNode;
            break;
          }
        }
        return inArea;
      }
      if (element.BaseType === ElementType.EDGE) {
        element = element;
        var startPoint = element.startPoint, endPoint = element.endPoint;
        var startHtmlPoint = this.transformModel.CanvasPointToHtmlPoint([
          startPoint.x,
          startPoint.y
        ]);
        var endHtmlPoint = this.transformModel.CanvasPointToHtmlPoint([
          endPoint.x,
          endPoint.y
        ]);
        var isStartInArea = isPointInArea(startHtmlPoint, lt, rb);
        var isEndInArea = isPointInArea(endHtmlPoint, lt, rb);
        return wholeEdge ? isStartInArea && isEndInArea : isStartInArea || isEndInArea;
      }
      return false;
    };
    GraphModel2.prototype.graphDataToModel = function(graphData) {
      var _this = this;
      if (!graphData) {
        this.clearData();
        return;
      }
      this.elementsModelMap.clear();
      this.nodeModelMap.clear();
      this.edgeModelMap.clear();
      if (graphData.nodes) {
        this.nodes = map_default(graphData.nodes, function(node) {
          var nodeModel = _this.getModelAfterSnapToGrid(node);
          _this.elementsModelMap.set(nodeModel.id, nodeModel);
          _this.nodeModelMap.set(nodeModel.id, nodeModel);
          return nodeModel;
        });
      } else {
        this.nodes = [];
      }
      if (graphData.edges) {
        var currEdgeType_1 = this.edgeType;
        this.edges = map_default(graphData.edges, function(edge) {
          var _a2;
          var Model = _this.getModel((_a2 = edge.type) !== null && _a2 !== void 0 ? _a2 : currEdgeType_1);
          if (!Model) {
            throw new Error("".concat(edge.type, ""));
          }
          var edgeModel = new Model(edge, _this);
          _this.edgeModelMap.set(edgeModel.id, edgeModel);
          _this.elementsModelMap.set(edgeModel.id, edgeModel);
          return edgeModel;
        });
      } else {
        this.edges = [];
      }
    };
    GraphModel2.prototype.modelToGraphData = function() {
      var edges = [];
      this.edges.forEach(function(edge) {
        var data = edge.getData();
        if (data && !edge.virtual)
          edges.push(data);
      });
      var nodes = [];
      this.nodes.forEach(function(node) {
        var data = node.getData();
        if (data && !node.virtual)
          nodes.push(data);
      });
      return {
        nodes,
        edges
      };
    };
    GraphModel2.prototype.modelToHistoryData = function() {
      var nodeDragging = false;
      var nodes = [];
      for (var i4 = 0; i4 < this.nodes.length; i4++) {
        var nodeModel = this.nodes[i4];
        if (nodeModel.isDragging) {
          nodeDragging = true;
          break;
        } else {
          nodes.push(nodeModel.getHistoryData());
        }
      }
      if (nodeDragging) {
        return false;
      }
      var edgeDragging = false;
      var edges = [];
      for (var j4 = 0; j4 < this.edges.length; j4++) {
        var edgeMode = this.edges[j4];
        if (edgeMode.isDragging) {
          edgeDragging = true;
          break;
        } else {
          edges.push(edgeMode.getHistoryData());
        }
      }
      if (edgeDragging) {
        return false;
      }
      return {
        nodes,
        edges
      };
    };
    GraphModel2.prototype.getEdgeModelById = function(edgeId) {
      var _a2;
      return (_a2 = this.edgesMap[edgeId]) === null || _a2 === void 0 ? void 0 : _a2.model;
    };
    GraphModel2.prototype.getElement = function(id) {
      return this.modelsMap[id];
    };
    GraphModel2.prototype.getNodeEdges = function(nodeId) {
      var edges = [];
      for (var i4 = 0; i4 < this.edges.length; i4++) {
        var edgeModel = this.edges[i4];
        var nodeAsSource = edgeModel.sourceNodeId === nodeId;
        var nodeAsTarget = edgeModel.targetNodeId === nodeId;
        if (nodeAsSource || nodeAsTarget) {
          edges.push(edgeModel);
        }
      }
      return edges;
    };
    GraphModel2.prototype.getSelectElements = function(isIgnoreCheck) {
      if (isIgnoreCheck === void 0) {
        isIgnoreCheck = true;
      }
      var elements = this.selectElements;
      var graphData = {
        nodes: [],
        edges: []
      };
      elements.forEach(function(element) {
        if (element.BaseType === ElementType.NODE) {
          graphData.nodes.push(element.getData());
        }
        if (element.BaseType === ElementType.EDGE) {
          var edgeData = element.getData();
          var isNodeSelected = elements.get(edgeData.sourceNodeId) && elements.get(edgeData.targetNodeId);
          if (isIgnoreCheck || isNodeSelected) {
            graphData.edges.push(edgeData);
          }
        }
      });
      return graphData;
    };
    GraphModel2.prototype.updateAttributes = function(id, attributes) {
      var element = this.getElement(id);
      element === null || element === void 0 ? void 0 : element.updateAttributes(attributes);
    };
    GraphModel2.prototype.changeNodeId = function(nodeId, newId) {
      if (!newId) {
        newId = createUuid();
      }
      if (this.nodesMap[newId]) {
        console.warn("".concat(newId, ", "));
        return "";
      }
      if (!this.nodesMap[nodeId]) {
        console.warn("".concat(nodeId, ", "));
        return "";
      }
      this.edges.forEach(function(edge) {
        if (edge.sourceNodeId === nodeId) {
          edge.sourceNodeId = newId;
        }
        if (edge.targetNodeId === nodeId) {
          edge.targetNodeId = newId;
        }
      });
      this.nodesMap[nodeId].model.id = newId;
      this.nodesMap[newId] = this.nodesMap[nodeId];
      return newId;
    };
    GraphModel2.prototype.changeEdgeId = function(oldId, newId) {
      if (!newId) {
        newId = createUuid();
      }
      if (this.edgesMap[newId]) {
        console.warn(": ".concat(newId, ", "));
        return "";
      }
      if (!this.edgesMap[oldId]) {
        console.warn(": ".concat(newId, ", "));
        return "";
      }
      this.edges.forEach(function(edge) {
        if (edge.id === oldId) {
          edge.changeEdgeId(newId);
        }
      });
      return newId;
    };
    GraphModel2.prototype.getTextModel = function(model) {
      var _a2 = this.editConfigModel, textMode = _a2.textMode, nodeTextMode = _a2.nodeTextMode, edgeTextMode = _a2.edgeTextMode;
      if (model.BaseType === ElementType.NODE) {
        return model.textMode || nodeTextMode || textMode || TextMode.TEXT;
      }
      if (model.BaseType === ElementType.EDGE) {
        return model.textMode || edgeTextMode || textMode || TextMode.TEXT;
      }
    };
    GraphModel2.prototype.setTextMode = function(mode, model) {
      if (model) {
      }
      this.editConfigModel.updateEditConfig({ textMode: mode });
    };
    GraphModel2.prototype.setFakeNode = function(nodeModel) {
      this.fakeNode = nodeModel;
    };
    GraphModel2.prototype.removeFakeNode = function() {
      this.fakeNode = null;
    };
    GraphModel2.prototype.setModel = function(type, ModelClass) {
      return this.modelMap.set(type, ModelClass);
    };
    GraphModel2.prototype.toFront = function(id) {
      var _a2, _b, _c;
      var element = ((_a2 = this.nodesMap[id]) === null || _a2 === void 0 ? void 0 : _a2.model) || ((_b = this.edgesMap[id]) === null || _b === void 0 ? void 0 : _b.model);
      if (element) {
        if (this.overlapMode === OverlapMode.DEFAULT) {
          (_c = this.topElement) === null || _c === void 0 ? void 0 : _c.setZIndex();
          element.setZIndex(ELEMENT_MAX_Z_INDEX);
          this.topElement = element;
        }
        if (this.overlapMode === OverlapMode.INCREASE) {
          this.setElementZIndex(id, "top");
        }
      }
    };
    GraphModel2.prototype.setElementZIndex = function(id, zIndex) {
      var _a2, _b;
      var element = ((_a2 = this.nodesMap[id]) === null || _a2 === void 0 ? void 0 : _a2.model) || ((_b = this.edgesMap[id]) === null || _b === void 0 ? void 0 : _b.model);
      if (element) {
        var index = void 0;
        if (typeof zIndex === "number") {
          index = zIndex;
        } else {
          if (zIndex === "top") {
            index = getZIndex();
          }
          if (zIndex === "bottom") {
            index = getMinIndex();
          }
        }
        element.setZIndex(index);
      }
    };
    GraphModel2.prototype.deleteNode = function(nodeId) {
      var nodeModel = this.nodesMap[nodeId].model;
      var nodeData = nodeModel.getData();
      this.deleteEdgeBySource(nodeId);
      this.deleteEdgeByTarget(nodeId);
      this.nodes.splice(this.nodesMap[nodeId].index, 1);
      this.eventCenter.emit(EventType.NODE_DELETE, {
        data: nodeData,
        model: nodeModel
      });
    };
    GraphModel2.prototype.addNode = function(nodeConfig, eventType, event) {
      if (eventType === void 0) {
        eventType = EventType.NODE_ADD;
      }
      var originNodeData = formatData(nodeConfig);
      var id = originNodeData.id;
      if (id && this.nodesMap[id]) {
        delete originNodeData.id;
      }
      var nodeModel = this.getModelAfterSnapToGrid(originNodeData);
      this.nodes.push(nodeModel);
      var nodeData = nodeModel.getData();
      var eventData = { data: nodeData };
      if (event) {
        eventData.e = event;
      }
      this.eventCenter.emit(eventType, eventData);
      return nodeModel;
    };
    GraphModel2.prototype.getModelAfterSnapToGrid = function(node) {
      var Model = this.getModel(node.type);
      var snapGrid = this.editConfigModel.snapGrid;
      if (!Model) {
        throw new Error("".concat(node.type, ""));
      }
      var nodeX = node.x, nodeY = node.y;
      if (nodeX && nodeY) {
        node.x = snapToGrid(nodeX, this.gridSize, snapGrid);
        node.y = snapToGrid(nodeY, this.gridSize, snapGrid);
        if (typeof node.text === "object" && node.text !== null) {
          node.text.x += node.x - nodeX;
          node.text.y += node.y - nodeY;
        }
      }
      var nodeModel = new Model(node, this);
      this.nodeModelMap.set(nodeModel.id, nodeModel);
      this.elementsModelMap.set(nodeModel.id, nodeModel);
      return nodeModel;
    };
    GraphModel2.prototype.cloneNode = function(nodeId) {
      var targetNode = this.getNodeModelById(nodeId);
      var data = targetNode === null || targetNode === void 0 ? void 0 : targetNode.getData();
      if (data) {
        data.x += 30;
        data.y += 30;
        data.id = "";
        if (typeof data.text === "object" && data.text !== null) {
          data.text.x += 30;
          data.text.y += 30;
        }
        var nodeModel = this.addNode(data);
        nodeModel.setSelected(true);
        targetNode === null || targetNode === void 0 ? void 0 : targetNode.setSelected(false);
        return nodeModel.getData();
      }
    };
    GraphModel2.prototype.moveNode = function(nodeId, deltaX, deltaY, isIgnoreRule) {
      var _a2;
      if (isIgnoreRule === void 0) {
        isIgnoreRule = false;
      }
      var node = this.nodesMap[nodeId];
      if (!node) {
        console.warn("id".concat(nodeId, ""));
        return;
      }
      var nodeModel = node.model;
      _a2 = __read23(nodeModel.getMoveDistance(deltaX, deltaY, isIgnoreRule), 2), deltaX = _a2[0], deltaY = _a2[1];
      this.moveEdge(nodeId, deltaX, deltaY);
    };
    GraphModel2.prototype.moveNode2Coordinate = function(nodeId, x3, y3, isIgnoreRule) {
      if (isIgnoreRule === void 0) {
        isIgnoreRule = false;
      }
      var node = this.nodesMap[nodeId];
      if (!node) {
        console.warn("id".concat(nodeId, ""));
        return;
      }
      var nodeModel = node.model;
      var originX = nodeModel.x, originY = nodeModel.y;
      var deltaX = x3 - originX;
      var deltaY = y3 - originY;
      this.moveNode(nodeId, deltaX, deltaY, isIgnoreRule);
    };
    GraphModel2.prototype.editText = function(id) {
      this.setElementStateById(id, ElementState.TEXT_EDIT);
    };
    GraphModel2.prototype.addEdge = function(edgeConfig) {
      var edgeOriginData = formatData(edgeConfig);
      var type = edgeOriginData.type;
      if (!type) {
        type = this.edgeType;
      }
      if (edgeOriginData.id && this.edgesMap[edgeOriginData.id]) {
        delete edgeOriginData.id;
      }
      var Model = this.getModel(type);
      if (!Model) {
        throw new Error("".concat(type, ""));
      }
      var edgeModel = new Model(__assign28(__assign28({}, edgeOriginData), { type }), this);
      this.edgeModelMap.set(edgeModel.id, edgeModel);
      this.elementsModelMap.set(edgeModel.id, edgeModel);
      var edgeData = edgeModel.getData();
      this.edges.push(edgeModel);
      this.eventCenter.emit(EventType.EDGE_ADD, { data: edgeData });
      return edgeModel;
    };
    GraphModel2.prototype.moveEdge = function(nodeId, deltaX, deltaY) {
      for (var i4 = 0; i4 < this.edges.length; i4++) {
        var edgeModel = this.edges[i4];
        var _a2 = edgeModel.textPosition, x3 = _a2.x, y3 = _a2.y;
        var nodeAsSource = this.edges[i4].sourceNodeId === nodeId;
        var nodeAsTarget = this.edges[i4].targetNodeId === nodeId;
        if (nodeAsSource) {
          edgeModel.moveStartPoint(deltaX, deltaY);
        }
        if (nodeAsTarget) {
          edgeModel.moveEndPoint(deltaX, deltaY);
        }
        if (nodeAsSource || nodeAsTarget) {
          this.handleEdgeTextMove(edgeModel, x3, y3);
        }
      }
    };
    GraphModel2.prototype.handleEdgeTextMove = function(edgeModel, x3, y3) {
      var _a2;
      if (edgeModel.customTextPosition) {
        edgeModel.resetTextPosition();
        return;
      }
      if (edgeModel.modelType === ModelType.POLYLINE_EDGE && ((_a2 = edgeModel.text) === null || _a2 === void 0 ? void 0 : _a2.value)) {
        var textPosition = edgeModel.text;
        var newPoint = getClosestPointOfPolyline(textPosition, edgeModel.points);
        edgeModel.moveText(newPoint.x - textPosition.x, newPoint.y - textPosition.y);
      }
      var _b = edgeModel.textPosition, x1 = _b.x, y1 = _b.y;
      edgeModel.moveText(x1 - x3, y1 - y3);
    };
    GraphModel2.prototype.deleteEdgeBySourceAndTarget = function(sourceNodeId, targetNodeId) {
      for (var i4 = 0; i4 < this.edges.length; i4++) {
        if (this.edges[i4].sourceNodeId === sourceNodeId && this.edges[i4].targetNodeId === targetNodeId) {
          var edgeData = this.edges[i4].getData();
          this.edges.splice(i4, 1);
          i4--;
          this.eventCenter.emit(EventType.EDGE_DELETE, { data: edgeData });
        }
      }
    };
    GraphModel2.prototype.deleteEdgeById = function(id) {
      var edge = this.edgesMap[id];
      if (!edge) {
        return;
      }
      var idx = this.edgesMap[id].index;
      var edgeData = this.edgesMap[id].model.getData();
      this.edges.splice(idx, 1);
      this.eventCenter.emit(EventType.EDGE_DELETE, { data: edgeData });
    };
    GraphModel2.prototype.deleteEdgeBySource = function(sourceNodeId) {
      for (var i4 = 0; i4 < this.edges.length; i4++) {
        if (this.edges[i4].sourceNodeId === sourceNodeId) {
          var edgeData = this.edges[i4].getData();
          this.edges.splice(i4, 1);
          i4--;
          this.eventCenter.emit(EventType.EDGE_DELETE, { data: edgeData });
        }
      }
    };
    GraphModel2.prototype.deleteEdgeByTarget = function(targetNodeId) {
      for (var i4 = 0; i4 < this.edges.length; i4++) {
        if (this.edges[i4].targetNodeId === targetNodeId) {
          var edgeData = this.edges[i4].getData();
          this.edges.splice(i4, 1);
          i4--;
          this.eventCenter.emit(EventType.EDGE_DELETE, { data: edgeData });
        }
      }
    };
    GraphModel2.prototype.setElementStateById = function(id, state, additionStateData) {
      this.nodes.forEach(function(node) {
        if (node.id === id) {
          node.setElementState(state, additionStateData);
        } else {
          node.setElementState(ElementState.DEFAULT);
        }
      });
      this.edges.forEach(function(edge) {
        if (edge.id === id) {
          edge.setElementState(state, additionStateData);
        } else {
          edge.setElementState(ElementState.DEFAULT);
        }
      });
    };
    GraphModel2.prototype.updateText = function(id, value) {
      var element = find_default(__spreadArray7(__spreadArray7([], __read23(this.nodes), false), __read23(this.edges), false), function(item) {
        return item.id === id;
      });
      element === null || element === void 0 ? void 0 : element.updateText(value);
    };
    GraphModel2.prototype.selectNodeById = function(id, multiple) {
      var _a2;
      if (multiple === void 0) {
        multiple = false;
      }
      if (!multiple) {
        this.clearSelectElements();
      }
      var selectElement = (_a2 = this.nodesMap[id]) === null || _a2 === void 0 ? void 0 : _a2.model;
      selectElement === null || selectElement === void 0 ? void 0 : selectElement.setSelected(true);
    };
    GraphModel2.prototype.selectEdgeById = function(id, multiple) {
      var _a2;
      if (multiple === void 0) {
        multiple = false;
      }
      if (!multiple) {
        this.clearSelectElements();
      }
      var selectElement = (_a2 = this.edgesMap[id]) === null || _a2 === void 0 ? void 0 : _a2.model;
      selectElement === null || selectElement === void 0 ? void 0 : selectElement.setSelected(true);
    };
    GraphModel2.prototype.selectElementById = function(id, multiple) {
      if (multiple === void 0) {
        multiple = false;
      }
      if (!multiple) {
        this.clearSelectElements();
      }
      var selectElement = this.getElement(id);
      selectElement === null || selectElement === void 0 ? void 0 : selectElement.setSelected(true);
    };
    GraphModel2.prototype.clearSelectElements = function() {
      var _a2;
      this.selectElements.forEach(function(element) {
        element === null || element === void 0 ? void 0 : element.setSelected(false);
      });
      this.selectElements.clear();
      if (this.overlapMode === OverlapMode.DEFAULT) {
        (_a2 = this.topElement) === null || _a2 === void 0 ? void 0 : _a2.setZIndex();
      }
    };
    GraphModel2.prototype.moveNodes = function(nodeIds, deltaX, deltaY, isIgnoreRule) {
      var _a2, _b, _c;
      var _this = this;
      if (isIgnoreRule === void 0) {
        isIgnoreRule = false;
      }
      var nodeIdMap = nodeIds.reduce(function(acc, cur) {
        var _a3;
        var nodeModel = (_a3 = _this.nodesMap[cur]) === null || _a3 === void 0 ? void 0 : _a3.model;
        if (nodeModel) {
          acc[cur] = nodeModel.getMoveDistance(deltaX, deltaY, isIgnoreRule);
        }
        return acc;
      }, {});
      for (var i4 = 0; i4 < this.edges.length; i4++) {
        var edgeModel = this.edges[i4];
        var _d = edgeModel.textPosition, x3 = _d.x, y3 = _d.y;
        var sourceMoveDistance = nodeIdMap[edgeModel.sourceNodeId];
        var targetMoveDistance = nodeIdMap[edgeModel.targetNodeId];
        var textDistanceX = void 0;
        var textDistanceY = void 0;
        if (sourceMoveDistance && targetMoveDistance && edgeModel.modelType === ModelType.POLYLINE_EDGE) {
          ;
          _a2 = __read23(sourceMoveDistance, 2), textDistanceX = _a2[0], textDistanceY = _a2[1];
          edgeModel.updatePointsList(textDistanceX, textDistanceY);
        } else {
          if (sourceMoveDistance) {
            ;
            _b = __read23(sourceMoveDistance, 2), textDistanceX = _b[0], textDistanceY = _b[1];
            edgeModel.moveStartPoint(textDistanceX, textDistanceY);
          }
          if (targetMoveDistance) {
            ;
            _c = __read23(targetMoveDistance, 2), textDistanceX = _c[0], textDistanceY = _c[1];
            edgeModel.moveEndPoint(textDistanceX, textDistanceY);
          }
        }
        if (sourceMoveDistance || targetMoveDistance) {
          this.handleEdgeTextMove(edgeModel, x3, y3);
        }
      }
    };
    GraphModel2.prototype.addNodeMoveRules = function(fn2) {
      if (!this.nodeMoveRules.includes(fn2)) {
        this.nodeMoveRules.push(fn2);
      }
    };
    GraphModel2.prototype.addNodeResizeRules = function(fn2) {
      if (!this.nodeResizeRules.includes(fn2)) {
        this.nodeResizeRules.push(fn2);
      }
    };
    GraphModel2.prototype.setDefaultEdgeType = function(type) {
      this.edgeType = type;
    };
    GraphModel2.prototype.changeNodeType = function(id, type) {
      var nodeModel = this.getNodeModelById(id);
      if (!nodeModel) {
        console.warn("id".concat(id, ""));
        return;
      }
      var data = nodeModel.getData();
      data.type = type;
      var Model = this.getModel(type);
      if (!Model) {
        throw new Error("".concat(type, ""));
      }
      var newNodeModel = new Model(data, this);
      this.nodes.splice(this.nodesMap[id].index, 1, newNodeModel);
      var edgeModels = this.getNodeEdges(id);
      edgeModels.forEach(function(edge) {
        if (edge.sourceNodeId === id) {
          var point = getNodeAnchorPosition(newNodeModel, edge.startPoint, newNodeModel.width, newNodeModel.height);
          edge.updateStartPoint(point);
        }
        if (edge.targetNodeId === id) {
          var point = getNodeAnchorPosition(newNodeModel, edge.endPoint, newNodeModel.width, newNodeModel.height);
          edge.updateEndPoint(point);
        }
      });
    };
    GraphModel2.prototype.changeEdgeType = function(id, type) {
      var edgeModel = this.getEdgeModelById(id);
      if (!edgeModel) {
        console.warn("id".concat(id, ""));
        return;
      }
      if (edgeModel.type === type) {
        return;
      }
      var data = edgeModel.getData();
      data.type = type;
      var Model = this.getModel(type);
      if (!Model) {
        throw new Error("".concat(type, ""));
      }
      delete data.pointsList;
      var newEdgeModel = new Model(data, this);
      this.edges.splice(this.edgesMap[id].index, 1, newEdgeModel);
    };
    GraphModel2.prototype.getNodeIncomingEdge = function(nodeId) {
      var edges = [];
      this.edges.forEach(function(edge) {
        if (edge.targetNodeId === nodeId) {
          edges.push(edge);
        }
      });
      return edges;
    };
    GraphModel2.prototype.getNodeOutgoingEdge = function(nodeId) {
      var edges = [];
      this.edges.forEach(function(edge) {
        if (edge.sourceNodeId === nodeId) {
          edges.push(edge);
        }
      });
      return edges;
    };
    GraphModel2.prototype.getAnchorIncomingEdge = function(anchorId) {
      var edges = [];
      this.edges.forEach(function(edge) {
        if (edge.targetAnchorId === anchorId) {
          edges.push(edge);
        }
      });
      return edges;
    };
    GraphModel2.prototype.getAnchorOutgoingEdge = function(anchorId) {
      var edges = [];
      this.edges.forEach(function(edge) {
        if (edge.sourceAnchorId === anchorId) {
          edges.push(edge);
        }
      });
      return edges;
    };
    GraphModel2.prototype.getNodeIncomingNode = function(nodeId) {
      var _this = this;
      var nodes = [];
      this.edges.forEach(function(edge) {
        var _a2;
        if (edge.targetNodeId === nodeId) {
          nodes.push((_a2 = _this.nodesMap[edge.sourceNodeId]) === null || _a2 === void 0 ? void 0 : _a2.model);
        }
      });
      return nodes;
    };
    GraphModel2.prototype.getNodeOutgoingNode = function(nodeId) {
      var _this = this;
      var nodes = [];
      this.edges.forEach(function(edge) {
        if (edge.sourceNodeId === nodeId) {
          nodes.push(_this.nodesMap[edge.targetNodeId].model);
        }
      });
      return nodes;
    };
    GraphModel2.prototype.setTheme = function(style) {
      this.theme = updateTheme(__assign28(__assign28({}, this.theme), style));
    };
    GraphModel2.prototype.updateGridOptions = function(options) {
      merge_default(this.grid, options);
    };
    GraphModel2.prototype.updateGridSize = function(size) {
      this.gridSize = size;
    };
    GraphModel2.prototype.updateBackgroundOptions = function(options) {
      if (isBoolean_default(options) || isBoolean_default(this.background)) {
        this.background = options;
      } else {
        this.background = __assign28(__assign28({}, this.background), options);
      }
    };
    GraphModel2.prototype.resize = function(width, height) {
      this.width = width !== null && width !== void 0 ? width : this.rootEl.getBoundingClientRect().width;
      this.isContainerWidth = isNil_default(width);
      this.height = height !== null && height !== void 0 ? height : this.rootEl.getBoundingClientRect().height;
      this.isContainerHeight = isNil_default(height);
      if (!this.width || !this.height) {
        console.warn("containerDOM@see https://github.com/didi/LogicFlow/issues/675");
      }
    };
    GraphModel2.prototype.clearData = function() {
      this.nodes = [];
      this.edges = [];
      this.edgeModelMap.clear();
      this.nodeModelMap.clear();
      this.elementsModelMap.clear();
    };
    GraphModel2.prototype.getVirtualRectSize = function() {
      var nodes = this.nodes;
      var nodesX = [];
      var nodesY = [];
      nodes.forEach(function(node) {
        var x3 = node.x, y3 = node.y, width = node.width, height = node.height;
        var _a2 = node.getNodeStyle().strokeWidth, strokeWidth = _a2 === void 0 ? 0 : _a2;
        var maxX2 = x3 + width / 2 + strokeWidth;
        var minX2 = x3 - width / 2 - strokeWidth;
        var maxY2 = y3 + height / 2 + strokeWidth;
        var minY2 = y3 - height / 2 - strokeWidth;
        nodesX = nodesX.concat([maxX2, minX2].filter(function(num) {
          return !Number.isNaN(num);
        }));
        nodesY = nodesY.concat([maxY2, minY2].filter(function(num) {
          return !Number.isNaN(num);
        }));
      });
      var minX = Math.min.apply(Math, __spreadArray7([], __read23(nodesX), false));
      var maxX = Math.max.apply(Math, __spreadArray7([], __read23(nodesX), false));
      var minY = Math.min.apply(Math, __spreadArray7([], __read23(nodesY), false));
      var maxY = Math.max.apply(Math, __spreadArray7([], __read23(nodesY), false));
      var virtualRectWidth = maxX - minX || 0;
      var virtualRectHeight = maxY - minY || 0;
      var virtualRectCenterPositionX = minX + virtualRectWidth / 2;
      var virtualRectCenterPositionY = minY + virtualRectHeight / 2;
      return {
        width: virtualRectWidth,
        height: virtualRectHeight,
        x: virtualRectCenterPositionX,
        y: virtualRectCenterPositionY
      };
    };
    GraphModel2.prototype.translateCenter = function() {
      var _a2 = this, nodes = _a2.nodes, width = _a2.width, height = _a2.height, rootEl = _a2.rootEl, transformModel = _a2.transformModel;
      if (!nodes.length) {
        return;
      }
      var containerWidth = width || rootEl.clientWidth;
      var containerHeight = height || rootEl.clientHeight;
      var _b = this.getVirtualRectSize(), virtualRectCenterPositionX = _b.x, virtualRectCenterPositionY = _b.y;
      transformModel.focusOn(virtualRectCenterPositionX, virtualRectCenterPositionY, containerWidth, containerHeight);
    };
    GraphModel2.prototype.fitView = function(verticalOffset, horizontalOffset) {
      if (verticalOffset === void 0) {
        verticalOffset = 20;
      }
      if (horizontalOffset === void 0) {
        horizontalOffset = 20;
      }
      var _a2 = this, nodes = _a2.nodes, width = _a2.width, height = _a2.height, rootEl = _a2.rootEl, transformModel = _a2.transformModel;
      if (!nodes.length) {
        return;
      }
      var containerWidth = width || rootEl.clientWidth;
      var containerHeight = height || rootEl.clientHeight;
      var _b = this.getVirtualRectSize(), virtualRectWidth = _b.width, virtualRectHeight = _b.height, virtualRectCenterPositionX = _b.x, virtualRectCenterPositionY = _b.y;
      var zoomRatioX = (virtualRectWidth + horizontalOffset) / containerWidth;
      var zoomRatioY = (virtualRectHeight + verticalOffset) / containerHeight;
      var zoomRatio = 1 / Math.max(zoomRatioX, zoomRatioY);
      var point = [containerWidth / 2, containerHeight / 2];
      transformModel.zoom(zoomRatio, point);
      transformModel.focusOn(virtualRectCenterPositionX, virtualRectCenterPositionY, containerWidth, containerHeight);
    };
    GraphModel2.prototype.openEdgeAnimation = function(edgeId) {
      var edgeModel = this.getEdgeModelById(edgeId);
      edgeModel === null || edgeModel === void 0 ? void 0 : edgeModel.openEdgeAnimation();
    };
    GraphModel2.prototype.closeEdgeAnimation = function(edgeId) {
      var edgeModel = this.getEdgeModelById(edgeId);
      edgeModel === null || edgeModel === void 0 ? void 0 : edgeModel.closeEdgeAnimation();
    };
    GraphModel2.prototype.getPartial = function() {
      return this.partial;
    };
    GraphModel2.prototype.setPartial = function(partial) {
      this.partial = partial;
    };
    GraphModel2.prototype.destroy = function() {
      try {
        this.waitCleanEffects.forEach(function(fn2) {
          fn2();
        });
      } catch (err) {
        console.warn("error on destroy GraphModel", err);
      }
      this.waitCleanEffects.length = 0;
      this.eventCenter.destroy();
    };
    __decorate20([
      observable
    ], GraphModel2.prototype, "width", void 0);
    __decorate20([
      observable
    ], GraphModel2.prototype, "height", void 0);
    __decorate20([
      observable
    ], GraphModel2.prototype, "grid", void 0);
    __decorate20([
      observable
    ], GraphModel2.prototype, "edgeType", void 0);
    __decorate20([
      observable
    ], GraphModel2.prototype, "nodes", void 0);
    __decorate20([
      observable
    ], GraphModel2.prototype, "edges", void 0);
    __decorate20([
      observable
    ], GraphModel2.prototype, "fakeNode", void 0);
    __decorate20([
      observable
    ], GraphModel2.prototype, "overlapMode", void 0);
    __decorate20([
      observable
    ], GraphModel2.prototype, "background", void 0);
    __decorate20([
      observable
    ], GraphModel2.prototype, "gridSize", void 0);
    __decorate20([
      observable
    ], GraphModel2.prototype, "transformModel", void 0);
    __decorate20([
      observable
    ], GraphModel2.prototype, "editConfigModel", void 0);
    __decorate20([
      observable
    ], GraphModel2.prototype, "partial", void 0);
    __decorate20([
      computed
    ], GraphModel2.prototype, "nodesMap", null);
    __decorate20([
      computed
    ], GraphModel2.prototype, "edgesMap", null);
    __decorate20([
      computed
    ], GraphModel2.prototype, "modelsMap", null);
    __decorate20([
      computed
    ], GraphModel2.prototype, "sortElements", null);
    __decorate20([
      computed
    ], GraphModel2.prototype, "textEditElement", null);
    __decorate20([
      computed
    ], GraphModel2.prototype, "selectElements", null);
    __decorate20([
      computed
    ], GraphModel2.prototype, "selectNodes", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "setTextMode", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "setFakeNode", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "removeFakeNode", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "setModel", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "toFront", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "setElementZIndex", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "deleteNode", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "addNode", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "cloneNode", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "moveNode", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "moveNode2Coordinate", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "editText", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "addEdge", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "moveEdge", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "deleteEdgeBySourceAndTarget", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "deleteEdgeById", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "deleteEdgeBySource", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "deleteEdgeByTarget", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "setElementStateById", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "updateText", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "selectNodeById", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "selectEdgeById", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "selectElementById", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "clearSelectElements", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "moveNodes", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "setDefaultEdgeType", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "changeNodeType", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "changeEdgeType", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "getNodeIncomingEdge", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "getNodeOutgoingEdge", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "getAnchorIncomingEdge", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "getAnchorOutgoingEdge", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "getNodeIncomingNode", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "getNodeOutgoingNode", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "setTheme", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "resize", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "clearData", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "translateCenter", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "fitView", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "openEdgeAnimation", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "closeEdgeAnimation", null);
    __decorate20([
      action
    ], GraphModel2.prototype, "setPartial", null);
    return GraphModel2;
  }()
);

// node_modules/@logicflow/core/es/model/SnaplineModel.js
var __assign29 = function() {
  __assign29 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign29.apply(this, arguments);
};
var __decorate21 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var SnaplineModel = (
  /** @class */
  function() {
    function SnaplineModel2(graphModel) {
      this.isShowHorizontal = false;
      this.isShowVertical = false;
      this.position = {
        x: 0,
        y: 0
      };
      this.graphModel = graphModel;
    }
    SnaplineModel2.prototype.getStyle = function() {
      return __assign29({}, this.graphModel.theme.snapline);
    };
    SnaplineModel2.prototype.getCenterSnapLine = function(draggingNode, nodes) {
      var x3 = draggingNode.x, y3 = draggingNode.y;
      var isShowVertical = false;
      var isShowHorizontal = false;
      for (var i4 = 0; i4 < nodes.length; i4++) {
        var item = nodes[i4];
        if (item.id !== draggingNode.id) {
          if (x3 === item.x) {
            isShowVertical = true;
          }
          if (y3 === item.y) {
            isShowHorizontal = true;
          }
          if (isShowVertical && isShowHorizontal) {
            break;
          }
        }
      }
      return {
        isShowVertical,
        isShowHorizontal,
        position: {
          x: x3,
          y: y3
        }
      };
    };
    SnaplineModel2.prototype.getHorizontalSnapline = function(draggingNode, nodes) {
      var isShowHorizontal = false;
      var horizontalY = 0;
      var id = draggingNode.id;
      var draggingData;
      if (id) {
        var fakeNode = this.graphModel.fakeNode;
        if (fakeNode && fakeNode.id === id) {
          draggingData = getNodeBBox(fakeNode);
        } else {
          var nodeModel = this.graphModel.getNodeModelById(id);
          if (nodeModel) {
            draggingData = getNodeBBox(nodeModel);
          }
        }
      }
      for (var i4 = 0; i4 < nodes.length; i4++) {
        var item = nodes[i4];
        if (item.id !== draggingNode.id) {
          var itemData = getNodeBBox(item);
          if (itemData.minY === (draggingData === null || draggingData === void 0 ? void 0 : draggingData.minY) || itemData.maxY === (draggingData === null || draggingData === void 0 ? void 0 : draggingData.minY)) {
            isShowHorizontal = true;
            horizontalY = draggingData.minY;
            break;
          }
          if (itemData.minY === (draggingData === null || draggingData === void 0 ? void 0 : draggingData.maxY) || itemData.maxY === (draggingData === null || draggingData === void 0 ? void 0 : draggingData.maxY)) {
            isShowHorizontal = true;
            horizontalY = draggingData.maxY;
            break;
          }
        }
      }
      return {
        isShowHorizontal,
        isShowVertical: this.isShowVertical,
        position: __assign29(__assign29({}, this.position), { y: horizontalY })
      };
    };
    SnaplineModel2.prototype.getVerticalSnapline = function(draggingNode, nodes) {
      var isShowVertical = false;
      var verticalX = 0;
      var id = draggingNode.id;
      var draggingData;
      if (id) {
        var fakeNode = this.graphModel.fakeNode;
        if (fakeNode && fakeNode.id === id) {
          draggingData = getNodeBBox(fakeNode);
        } else {
          var nodeModel = this.graphModel.getNodeModelById(id);
          if (nodeModel) {
            draggingData = getNodeBBox(nodeModel);
          }
        }
      }
      for (var i4 = 0; i4 < nodes.length; i4++) {
        var item = nodes[i4];
        if (item.id !== draggingNode.id) {
          var itemData = getNodeBBox(item);
          if (itemData.minX === (draggingData === null || draggingData === void 0 ? void 0 : draggingData.minX) || itemData.maxX === (draggingData === null || draggingData === void 0 ? void 0 : draggingData.minX)) {
            isShowVertical = true;
            verticalX = draggingData.minX;
            break;
          }
          if (itemData.minX === (draggingData === null || draggingData === void 0 ? void 0 : draggingData.maxX) || itemData.maxX === (draggingData === null || draggingData === void 0 ? void 0 : draggingData.maxX)) {
            isShowVertical = true;
            verticalX = draggingData.maxX;
            break;
          }
        }
      }
      return {
        isShowHorizontal: this.isShowHorizontal,
        isShowVertical,
        position: __assign29(__assign29({}, this.position), { x: verticalX })
      };
    };
    SnaplineModel2.prototype.getSnapLinePosition = function(draggingNode, nodes) {
      var snaplineInfo = this.getCenterSnapLine(draggingNode, nodes);
      var isShowHorizontal = snaplineInfo.isShowHorizontal, isShowVertical = snaplineInfo.isShowVertical;
      if (!isShowHorizontal) {
        var horizontalSnapline = this.getHorizontalSnapline(draggingNode, nodes);
        if (horizontalSnapline.isShowHorizontal) {
          snaplineInfo.isShowHorizontal = horizontalSnapline.isShowHorizontal;
          snaplineInfo.position.y = horizontalSnapline.position.y;
        }
      }
      if (!isShowVertical) {
        var verticalSnapline = this.getVerticalSnapline(draggingNode, nodes);
        if (verticalSnapline.isShowVertical) {
          snaplineInfo.isShowVertical = verticalSnapline.isShowVertical;
          snaplineInfo.position.x = verticalSnapline.position.x;
        }
      }
      return snaplineInfo;
    };
    SnaplineModel2.prototype.setSnaplineInfo = function(snaplineInfo) {
      var isShowHorizontal = snaplineInfo.isShowHorizontal, isShowVertical = snaplineInfo.isShowVertical, position = snaplineInfo.position;
      this.position = position;
      this.isShowHorizontal = isShowHorizontal;
      this.isShowVertical = isShowVertical;
    };
    SnaplineModel2.prototype.clearSnapline = function() {
      this.position = {
        x: 0,
        y: 0
      };
      this.isShowHorizontal = false;
      this.isShowVertical = false;
    };
    SnaplineModel2.prototype.setNodeSnapLine = function(nodeData) {
      var nodes = this.graphModel.nodes;
      var info = this.getSnapLinePosition(nodeData, nodes);
      this.setSnaplineInfo(info);
    };
    __decorate21([
      observable
    ], SnaplineModel2.prototype, "isShowHorizontal", void 0);
    __decorate21([
      observable
    ], SnaplineModel2.prototype, "isShowVertical", void 0);
    __decorate21([
      observable
    ], SnaplineModel2.prototype, "position", void 0);
    __decorate21([
      action
    ], SnaplineModel2.prototype, "clearSnapline", null);
    __decorate21([
      action
    ], SnaplineModel2.prototype, "setNodeSnapLine", null);
    return SnaplineModel2;
  }()
);

// node_modules/@logicflow/core/es/model/TransformModel.js
var __decorate22 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var __read24 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var translateLimitsMap = {
  false: [-Infinity, -Infinity, Infinity, Infinity],
  true: [-Infinity, -Infinity, Infinity, Infinity],
  vertical: [-Infinity, 0, Infinity, 0],
  horizontal: [0, -Infinity, 0, Infinity]
};
var TransformModel = (
  /** @class */
  function() {
    function TransformModel2(eventCenter, options) {
      this.MINI_SCALE_SIZE = 0.2;
      this.MAX_SCALE_SIZE = 16;
      this.SCALE_X = 1;
      this.SKEW_Y = 0;
      this.SKEW_X = 0;
      this.SCALE_Y = 1;
      this.TRANSLATE_X = 0;
      this.TRANSLATE_Y = 0;
      this.ZOOM_SIZE = 0.04;
      this.translateLimitMinX = -Infinity;
      this.translateLimitMinY = -Infinity;
      this.translateLimitMaxX = Infinity;
      this.translateLimitMaxY = Infinity;
      this.eventCenter = eventCenter;
      var _a2 = options.stopMoveGraph, stopMoveGraph = _a2 === void 0 ? false : _a2;
      this.updateTranslateLimits(stopMoveGraph);
    }
    TransformModel2.prototype.setZoomMiniSize = function(size) {
      this.MINI_SCALE_SIZE = size;
    };
    TransformModel2.prototype.setZoomMaxSize = function(size) {
      this.MAX_SCALE_SIZE = size;
    };
    TransformModel2.prototype.HtmlPointToCanvasPoint = function(point) {
      var _a2 = __read24(point, 2), x3 = _a2[0], y3 = _a2[1];
      return [
        (x3 - this.TRANSLATE_X) / this.SCALE_X,
        (y3 - this.TRANSLATE_Y) / this.SCALE_Y
      ];
    };
    TransformModel2.prototype.CanvasPointToHtmlPoint = function(point) {
      var _a2 = __read24(point, 2), x3 = _a2[0], y3 = _a2[1];
      return [
        x3 * this.SCALE_X + this.TRANSLATE_X,
        y3 * this.SCALE_Y + this.TRANSLATE_Y
      ];
    };
    TransformModel2.prototype.moveCanvasPointByHtml = function(point, directionX, directionY) {
      var _a2 = __read24(point, 2), x3 = _a2[0], y3 = _a2[1];
      return [x3 + directionX / this.SCALE_X, y3 + directionY / this.SCALE_Y];
    };
    TransformModel2.prototype.fixDeltaXY = function(deltaX, deltaY) {
      return [deltaX / this.SCALE_X, deltaY / this.SCALE_Y];
    };
    TransformModel2.prototype.getTransformStyle = function() {
      var matrixString = [
        this.SCALE_X,
        this.SKEW_Y,
        this.SKEW_X,
        this.SCALE_Y,
        this.TRANSLATE_X,
        this.TRANSLATE_Y
      ].join(",");
      return {
        transform: "matrix(".concat(matrixString, ")")
      };
    };
    TransformModel2.prototype.zoom = function(zoomSize, point) {
      if (zoomSize === void 0) {
        zoomSize = false;
      }
      var newScaleX = this.SCALE_X;
      var newScaleY = this.SCALE_Y;
      if (typeof zoomSize === "number") {
        newScaleX = zoomSize;
        newScaleY = zoomSize;
      } else {
        if (zoomSize) {
          newScaleX += this.ZOOM_SIZE;
          newScaleY += this.ZOOM_SIZE;
        } else {
          newScaleX -= this.ZOOM_SIZE;
          newScaleY -= this.ZOOM_SIZE;
        }
      }
      if (newScaleX < this.MINI_SCALE_SIZE || newScaleX > this.MAX_SCALE_SIZE) {
        return "".concat(this.SCALE_X * 100, "%");
      }
      if (point) {
        this.TRANSLATE_X -= (newScaleX - this.SCALE_X) * point[0];
        this.TRANSLATE_Y -= (newScaleY - this.SCALE_Y) * point[1];
      }
      this.SCALE_X = newScaleX;
      this.SCALE_Y = newScaleY;
      this.emitGraphTransform("zoom");
      return "".concat(this.SCALE_X * 100, "%");
    };
    TransformModel2.prototype.emitGraphTransform = function(type) {
      this.eventCenter.emit(EventType.GRAPH_TRANSFORM, {
        type,
        transform: {
          SCALE_X: this.SCALE_X,
          SKEW_Y: this.SKEW_Y,
          SKEW_X: this.SKEW_X,
          SCALE_Y: this.SCALE_Y,
          TRANSLATE_X: this.TRANSLATE_X,
          TRANSLATE_Y: this.TRANSLATE_Y
        }
      });
    };
    TransformModel2.prototype.resetZoom = function() {
      this.SCALE_X = 1;
      this.SCALE_Y = 1;
      this.emitGraphTransform("resetZoom");
    };
    TransformModel2.prototype.translate = function(x3, y3) {
      if (this.TRANSLATE_X + x3 <= this.translateLimitMaxX && this.TRANSLATE_X + x3 >= this.translateLimitMinX) {
        this.TRANSLATE_X += x3;
      }
      if (this.TRANSLATE_Y + y3 <= this.translateLimitMaxY && this.TRANSLATE_Y + y3 >= this.translateLimitMinY) {
        this.TRANSLATE_Y += y3;
      }
      this.emitGraphTransform("translate");
    };
    TransformModel2.prototype.focusOn = function(targetX, targetY, width, height) {
      var _a2 = __read24(this.CanvasPointToHtmlPoint([targetX, targetY]), 2), x3 = _a2[0], y3 = _a2[1];
      var _b = __read24([width / 2 - x3, height / 2 - y3], 2), deltaX = _b[0], deltaY = _b[1];
      this.TRANSLATE_X += deltaX;
      this.TRANSLATE_Y += deltaY;
      this.emitGraphTransform("focusOn");
    };
    TransformModel2.prototype.updateTranslateLimits = function(limit) {
      var _a2;
      ;
      _a2 = __read24(Array.isArray(limit) && limit.length === 4 ? limit : translateLimitsMap[limit.toString()], 4), this.translateLimitMinX = _a2[0], this.translateLimitMinY = _a2[1], this.translateLimitMaxX = _a2[2], this.translateLimitMaxY = _a2[3];
    };
    __decorate22([
      observable
    ], TransformModel2.prototype, "SCALE_X", void 0);
    __decorate22([
      observable
    ], TransformModel2.prototype, "SKEW_Y", void 0);
    __decorate22([
      observable
    ], TransformModel2.prototype, "SKEW_X", void 0);
    __decorate22([
      observable
    ], TransformModel2.prototype, "SCALE_Y", void 0);
    __decorate22([
      observable
    ], TransformModel2.prototype, "TRANSLATE_X", void 0);
    __decorate22([
      observable
    ], TransformModel2.prototype, "TRANSLATE_Y", void 0);
    __decorate22([
      observable
    ], TransformModel2.prototype, "ZOOM_SIZE", void 0);
    __decorate22([
      action
    ], TransformModel2.prototype, "zoom", null);
    __decorate22([
      action
    ], TransformModel2.prototype, "resetZoom", null);
    __decorate22([
      action
    ], TransformModel2.prototype, "translate", null);
    __decorate22([
      action
    ], TransformModel2.prototype, "focusOn", null);
    return TransformModel2;
  }()
);

// node_modules/@logicflow/core/es/view/Graph.js
var __extends23 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __decorate23 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var __read25 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray8 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l3 = from.length, ar; i4 < l3; i4++) {
    if (ar || !(i4 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i4);
      ar[i4] = from[i4];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Graph = (
  /** @class */
  function(_super) {
    __extends23(Graph2, _super);
    function Graph2() {
      var _this = _super.apply(this, __spreadArray8([], __read25(arguments), false)) || this;
      _this.handleResize = function() {
        var _a2 = _this.props, graphModel = _a2.graphModel, options = _a2.options;
        var width = graphModel.width, height = graphModel.height, isContainerWidth = graphModel.isContainerWidth, isContainerHeight = graphModel.isContainerHeight;
        var resizeWidth = width;
        var resizeHeight = height;
        var needUpdate = false;
        if (isContainerWidth) {
          resizeWidth = void 0;
          needUpdate = true;
        }
        if (isContainerHeight) {
          resizeHeight = void 0;
          needUpdate = true;
        }
        if (needUpdate) {
          graphModel.resize(resizeWidth, resizeHeight);
        }
        options.width = width;
        options.height = height;
      };
      _this.throttleResize = throttle_default(_this.handleResize, 200);
      return _this;
    }
    Graph2.prototype.componentDidMount = function() {
      window.addEventListener("resize", this.throttleResize);
    };
    Graph2.prototype.componentDidUpdate = function() {
      var data = this.props.graphModel.modelToGraphData();
      this.props.graphModel.eventCenter.emit(EventType.GRAPH_UPDATED, { data });
    };
    Graph2.prototype.componentWillUnmount = function() {
      window.removeEventListener("resize", this.throttleResize);
    };
    Graph2.prototype.getComponent = function(model, graphModel, overlay) {
      if (overlay === void 0) {
        overlay = "canvas-overlay";
      }
      var getView = this.props.getView;
      var View = getView(model.type);
      if (View) {
        return u3(View, { model, graphModel, overlay }, model.id);
      }
      return null;
    };
    Graph2.prototype.render = function() {
      var _this = this;
      var _a2 = this.props, graphModel = _a2.graphModel, tool = _a2.tool, options = _a2.options, dnd = _a2.dnd, snaplineModel = _a2.snaplineModel;
      var style = {};
      if (options.width) {
        style.width = "".concat(graphModel.width, "px");
      }
      if (options.height) {
        style.height = "".concat(graphModel.height, "px");
      }
      var fakeNode = graphModel.fakeNode, editConfigModel = graphModel.editConfigModel, background = graphModel.background;
      var adjustEdge = editConfigModel.adjustEdge;
      return u3("div", { className: "lf-graph", "flow-id": graphModel.flowId, style, children: [u3(CanvasOverlay, { graphModel, dnd, children: [u3("g", { className: "lf-base", children: map_default(graphModel.sortElements, function(nodeModel) {
        return _this.getComponent(nodeModel, graphModel);
      }) }), fakeNode ? this.getComponent(fakeNode, graphModel) : ""] }), u3(ModificationOverlay, { graphModel, children: [u3(OutlineOverlay, { graphModel }), adjustEdge ? u3(BezierAdjustOverlay, { graphModel }) : "", options.snapline !== false ? u3(SnaplineOverlay, { snaplineModel }) : ""] }), u3(ToolOverlay, { graphModel, tool }), background && u3(BackgroundOverlay, { background }), u3(Grid, { graphModel })] });
    };
    Graph2 = __decorate23([
      observer2
    ], Graph2);
    return Graph2;
  }(x)
);
var Graph_default = Graph;

// node_modules/@logicflow/core/es/view/Anchor.js
var __extends24 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign30 = function() {
  __assign30 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign30.apply(this, arguments);
};
var __read26 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var Anchor = (
  /** @class */
  function(_super) {
    __extends24(Anchor2, _super);
    function Anchor2() {
      var _this = _super.call(this) || this;
      _this.onDragStart = function(_a2) {
        var event = _a2.event;
        var _b = _this.props, anchorData = _b.anchorData, nodeModel = _b.nodeModel, graphModel = _b.graphModel;
        graphModel.selectNodeById(nodeModel.id);
        if (nodeModel.autoToFront) {
          graphModel.toFront(nodeModel.id);
        }
        graphModel.eventCenter.emit(EventType.ANCHOR_DRAGSTART, {
          data: anchorData,
          e: event,
          nodeModel
        });
        _this.setState({
          startX: anchorData.x,
          startY: anchorData.y,
          endX: anchorData.x,
          endY: anchorData.y
        });
      };
      _this.onDragging = function(_a2) {
        var event = _a2.event;
        var _b = _this.props, graphModel = _b.graphModel, nodeModel = _b.nodeModel, anchorData = _b.anchorData;
        var transformModel = graphModel.transformModel, eventCenter = graphModel.eventCenter, width = graphModel.width, height = graphModel.height, _c = graphModel.editConfigModel, autoExpand = _c.autoExpand, stopMoveGraph = _c.stopMoveGraph;
        if (!event)
          return;
        var clientX = event.clientX, clientY = event.clientY;
        var _d = graphModel.getPointByClient({
          x: clientX,
          y: clientY
        }), _e = _d.domOverlayPosition, x3 = _e.x, y3 = _e.y, _f = _d.canvasOverlayPosition, x1 = _f.x, y1 = _f.y;
        if (_this.t) {
          cancelRaf(_this.t);
        }
        var nearBoundary = [];
        var size = 10;
        if (x3 < 10) {
          nearBoundary = [size, 0];
        } else if (x3 + 10 > width) {
          nearBoundary = [-size, 0];
        } else if (y3 < 10) {
          nearBoundary = [0, size];
        } else if (y3 + 10 > height) {
          nearBoundary = [0, -size];
        }
        _this.setState({
          endX: x1,
          endY: y1,
          dragging: true
        });
        _this.moveAnchorEnd(x1, y1);
        if (nearBoundary.length > 0 && !stopMoveGraph && autoExpand) {
          _this.t = createRaf(function() {
            var _a3 = __read26(nearBoundary, 2), translateX = _a3[0], translateY = _a3[1];
            transformModel.translate(translateX, translateY);
            var _b2 = _this.state, endX = _b2.endX, endY = _b2.endY;
            _this.setState({
              endX: endX - translateX,
              endY: endY - translateY
            });
            _this.moveAnchorEnd(endX - translateX, endY - translateY);
          });
        }
        eventCenter.emit(EventType.ANCHOR_DRAG, {
          data: anchorData,
          e: event,
          nodeModel
        });
      };
      _this.onDragEnd = function(_a2) {
        var event = _a2.event;
        if (_this.t) {
          cancelRaf(_this.t);
        }
        var edgeModel = _this.checkEnd(event);
        _this.setState({
          startX: 0,
          startY: 0,
          endX: 0,
          endY: 0,
          dragging: false
        });
        _this.sourceRuleResults.clear();
        _this.targetRuleResults.clear();
        var _b = _this.props, graphModel = _b.graphModel, nodeModel = _b.nodeModel, anchorData = _b.anchorData;
        graphModel.eventCenter.emit(EventType.ANCHOR_DRAGEND, {
          data: anchorData,
          e: event,
          nodeModel,
          edgeModel: edgeModel !== null && edgeModel !== void 0 ? edgeModel : void 0
        });
      };
      _this.checkEnd = function(event) {
        var _a2;
        var _b = _this.props, graphModel = _b.graphModel, nodeModel = _b.nodeModel, _c = _b.anchorData, x3 = _c.x, y3 = _c.y, id = _c.id;
        var _d = _this.state, endX = _d.endX, endY = _d.endY, dragging = _d.dragging;
        var info = targetNodeInfo({
          x: endX,
          y: endY
        }, graphModel);
        if (_this.preTargetNode && _this.preTargetNode.state !== ElementState.DEFAULT) {
          _this.preTargetNode.setElementState(ElementState.DEFAULT);
        }
        if (!dragging)
          return;
        if (info && info.node) {
          var targetNode = info.node;
          var anchorId = info.anchor.id;
          var targetInfoId = "".concat(nodeModel.id, "_").concat(targetNode.id, "_").concat(anchorId, "_").concat(id);
          var _e = _this.sourceRuleResults.get(targetInfoId) || {}, isSourcePass = _e.isAllPass, sourceMsg = _e.msg;
          var _f = _this.targetRuleResults.get(targetInfoId) || {}, isTargetPass = _f.isAllPass, targetMsg = _f.msg;
          if (isSourcePass && isTargetPass) {
            targetNode.setElementState(ElementState.DEFAULT);
            var targetNodeModel = graphModel.getNodeModelById(info.node.id);
            var edgeData = (_a2 = graphModel.edgeGenerator) === null || _a2 === void 0 ? void 0 : _a2.call(graphModel, nodeModel.getData(), targetNodeModel === null || targetNodeModel === void 0 ? void 0 : targetNodeModel.getData());
            var edgeModel = graphModel.addEdge(__assign30(__assign30({}, edgeData), { sourceNodeId: nodeModel.id, sourceAnchorId: id, startPoint: {
              x: x3,
              y: y3
            }, targetNodeId: info.node.id, targetAnchorId: info.anchor.id, endPoint: {
              x: info.anchor.x,
              y: info.anchor.y
            } }));
            var anchorData = _this.props.anchorData;
            graphModel.eventCenter.emit(EventType.ANCHOR_DROP, {
              data: anchorData,
              e: event,
              nodeModel,
              edgeModel
            });
            return edgeModel;
          }
          var nodeData = targetNode.getData();
          graphModel.eventCenter.emit(EventType.CONNECTION_NOT_ALLOWED, {
            data: nodeData,
            msg: targetMsg || sourceMsg || ""
          });
          return null;
        }
      };
      _this.sourceRuleResults = /* @__PURE__ */ new Map();
      _this.targetRuleResults = /* @__PURE__ */ new Map();
      _this.state = {
        startX: 0,
        startY: 0,
        endX: 0,
        endY: 0,
        dragging: false
      };
      _this.dragHandler = new StepDrag({
        onDragStart: _this.onDragStart,
        onDragging: _this.onDragging,
        onDragEnd: _this.onDragEnd
      });
      return _this;
    }
    Anchor2.prototype.getAnchorShape = function() {
      var _a2 = this.props, anchorData = _a2.anchorData, style = _a2.style, node = _a2.node;
      var anchorShape = node.getAnchorShape(anchorData);
      if (anchorShape)
        return anchorShape;
      var x3 = anchorData.x, y3 = anchorData.y;
      var hoverStyle = __assign30(__assign30({}, style), style === null || style === void 0 ? void 0 : style.hover);
      return u3("g", { children: [u3(Circle, __assign30({ className: "lf-node-anchor-hover" }, hoverStyle, { x: x3, y: y3 })), u3(Circle, __assign30({ className: "lf-node-anchor" }, style, { x: x3, y: y3 }))] });
    };
    Object.defineProperty(Anchor2.prototype, "customTrajectory", {
      get: function() {
        var customTrajectory = this.props.graphModel.customTrajectory;
        return customTrajectory;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Anchor2.prototype, "relateEdges", {
      get: function() {
        var _a2 = this.props, _b = _a2.graphModel, getAnchorIncomingEdge = _b.getAnchorIncomingEdge, getAnchorOutgoingEdge = _b.getAnchorOutgoingEdge, id = _a2.anchorData.id;
        return {
          incomingEdgeList: getAnchorIncomingEdge(id),
          outgoingEdgeList: getAnchorOutgoingEdge(id)
        };
      },
      enumerable: false,
      configurable: true
    });
    Anchor2.prototype.moveAnchorEnd = function(endX, endY) {
      var _a2, _b;
      var _c = this.props, graphModel = _c.graphModel, nodeModel = _c.nodeModel, anchorData = _c.anchorData;
      var info = targetNodeInfo({
        x: endX,
        y: endY
      }, graphModel);
      if (info) {
        var targetNode = info.node;
        var anchorId = info.anchor.id;
        if (this.preTargetNode && this.preTargetNode !== info.node) {
          this.preTargetNode.setElementState(ElementState.DEFAULT);
        }
        if (anchorData.id === anchorId) {
          return;
        }
        this.preTargetNode = targetNode;
        var targetInfoId = "".concat(nodeModel.id, "_").concat(targetNode.id, "_").concat(anchorId, "_").concat(anchorData.id);
        if (!this.targetRuleResults.has(targetInfoId)) {
          var targetAnchor = info.anchor;
          var sourceRuleResult = nodeModel.isAllowConnectedAsSource(targetNode, anchorData, targetAnchor);
          var targetRuleResult = targetNode.isAllowConnectedAsTarget(nodeModel, anchorData, targetAnchor);
          this.sourceRuleResults.set(targetInfoId, formatAnchorConnectValidateData(sourceRuleResult));
          this.targetRuleResults.set(targetInfoId, formatAnchorConnectValidateData(targetRuleResult));
        }
        var isSourcePass = ((_a2 = this.sourceRuleResults.get(targetInfoId)) !== null && _a2 !== void 0 ? _a2 : {}).isAllPass;
        var isTargetPass = ((_b = this.targetRuleResults.get(targetInfoId)) !== null && _b !== void 0 ? _b : {}).isAllPass;
        if (isSourcePass && isTargetPass) {
          targetNode.setElementState(ElementState.ALLOW_CONNECT);
        } else {
          targetNode.setElementState(ElementState.NOT_ALLOW_CONNECT);
        }
      } else if (this.preTargetNode && this.preTargetNode.state !== ElementState.DEFAULT) {
        this.preTargetNode.setElementState(ElementState.DEFAULT);
      }
    };
    Anchor2.prototype.isShowLine = function() {
      var _a2 = this.state, startX = _a2.startX, startY = _a2.startY, endX = _a2.endX, endY = _a2.endY;
      var v6 = distance(startX, startY, endX, endY);
      return v6 > 10;
    };
    Anchor2.prototype.render = function() {
      var _this = this;
      var _a2 = this.state, startX = _a2.startX, startY = _a2.startY, endX = _a2.endX, endY = _a2.endY;
      var _b = this.props, edgeAddable = _b.anchorData.edgeAddable, edgeStyle = _b.edgeStyle;
      return (
        // className="lf-anchor" 
        u3("g", { className: "lf-anchor", children: [u3("g", { onMouseDown: function(ev) {
          if (edgeAddable !== false) {
            _this.dragHandler.handleMouseDown(ev);
          }
        }, children: this.getAnchorShape() }), this.isShowLine() && (this.customTrajectory ? this.customTrajectory(__assign30({ sourcePoint: {
          x: startX,
          y: startY
        }, targetPoint: {
          x: endX,
          y: endY
        } }, edgeStyle)) : u3(Line, __assign30({ x1: startX, y1: startY, x2: endX, y2: endY }, edgeStyle, { "pointer-events": "none" })))] })
      );
    };
    return Anchor2;
  }(x)
);
var Anchor_default = Anchor;

// node_modules/@logicflow/core/es/view/Rotate.js
var __extends25 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign31 = function() {
  __assign31 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign31.apply(this, arguments);
};
var RotateControlPoint = (
  /** @class */
  function(_super) {
    __extends25(RotateControlPoint2, _super);
    function RotateControlPoint2(props) {
      var _this = _super.call(this, props) || this;
      _this.style = {};
      _this.onDragging = function(_a2) {
        var _b;
        var event = _a2.event;
        var _c = _this.props, graphModel = _c.graphModel, nodeModel = _c.nodeModel, eventCenter = _c.eventCenter;
        var selectNodes = graphModel.selectNodes;
        var x3 = nodeModel.x, y3 = nodeModel.y;
        var clientX = event.clientX, clientY = event.clientY;
        var _d = graphModel.getPointByClient({
          x: clientX,
          y: clientY
        }).canvasOverlayPosition, cx = _d.x, cy = _d.y;
        var v6 = new Vector(cx - x3, cy - y3);
        var angle2 = ((_b = _this.normal) === null || _b === void 0 ? void 0 : _b.angle(v6)) - _this.defaultAngle;
        var matrix = new TranslateMatrix(-x3, -y3).rotate(angle2).translate(x3, y3).toString();
        nodeModel.transform = matrix;
        nodeModel.rotate = angle2;
        var nodeIds = map_default(selectNodes, function(node) {
          return node.id;
        });
        if (nodeIds.indexOf(nodeModel.id) === -1) {
          nodeIds = [nodeModel.id];
        }
        var nodeIdMap = reduce_default(nodeIds, function(acc, nodeId) {
          var node = graphModel.getNodeModelById(nodeId);
          acc[nodeId] = node === null || node === void 0 ? void 0 : node.getMoveDistance(0, 0, false);
          return acc;
        }, {});
        nodeIds.forEach(function(nodeId) {
          var edges = graphModel.getNodeEdges(nodeId);
          edges.forEach(function(edge) {
            if (nodeIdMap[edge.sourceNodeId]) {
              var model = graphModel.getNodeModelById(edge.sourceNodeId);
              var anchor = model.anchors.find(function(item) {
                return item.id === edge.sourceAnchorId;
              });
              edge.updateStartPoint(anchor);
            }
            if (nodeIdMap[edge.targetNodeId]) {
              var model = graphModel.getNodeModelById(edge.targetNodeId);
              var anchor = model.anchors.find(function(item) {
                return item.id === edge.targetAnchorId;
              });
              edge.updateEndPoint(anchor);
            }
          });
        });
        eventCenter.emit(EventType.NODE_ROTATE, {
          e: event,
          model: nodeModel,
          data: nodeModel.getData()
        });
      };
      _this.style = props.style;
      _this.stepperDrag = new StepDrag({
        onDragging: _this.onDragging
      });
      return _this;
    }
    RotateControlPoint2.prototype.render = function() {
      var _this = this;
      var nodeModel = this.props.nodeModel;
      var x3 = nodeModel.x, y3 = nodeModel.y, width = nodeModel.width, height = nodeModel.height;
      var cx = x3 + width / 2 + 20;
      var cy = y3 - height / 2 - 20;
      this.normal = new Vector(1, 0);
      this.defaultAngle = this.normal.angle(new Vector(cx - x3, cy - y3));
      nodeModel.defaultAngle = this.defaultAngle;
      return u3("g", { className: "lf-rotate-control", children: u3("g", { onMouseDown: function(ev) {
        _this.stepperDrag.handleMouseDown(ev);
      }, children: u3(Circle_default, __assign31({}, this.style, { cx, cy })) }) });
    };
    return RotateControlPoint2;
  }(x)
);
var Rotate_default = RotateControlPoint;

// node_modules/@logicflow/core/es/view/text/BaseText.js
var import_classnames = __toESM(require_classnames());
var __extends26 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign32 = function() {
  __assign32 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign32.apply(this, arguments);
};
var __read27 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var BaseText = (
  /** @class */
  function(_super) {
    __extends26(BaseText2, _super);
    function BaseText2(props) {
      var _this = _super.call(this) || this;
      _this.mouseDownHandler = function(e3) {
        var _a2 = _this.props, draggable2 = _a2.draggable, model = _a2.model, graphModel = _a2.graphModel;
        var nodeTextDraggable = graphModel.editConfigModel.nodeTextDraggable;
        if (draggable2 !== null && draggable2 !== void 0 ? draggable2 : nodeTextDraggable) {
          e3.stopPropagation();
          _this.stepperDrag.model = model;
          _this.stepperDrag.handleMouseDown(e3);
        }
      };
      _this.onDragging = function(_a2) {
        var deltaX = _a2.deltaX, deltaY = _a2.deltaY;
        var _b = _this.props, model = _b.model, transformModel = _b.graphModel.transformModel;
        if (deltaX || deltaY) {
          var _c = __read27(transformModel.fixDeltaXY(deltaX, deltaY), 2), curDeltaX = _c[0], curDeltaY = _c[1];
          model.moveText(curDeltaX, curDeltaY);
        }
      };
      _this.dbClickHandler = function() {
        var _a2 = _this.props, editable = _a2.editable, eventCenter = _a2.graphModel.eventCenter, model = _a2.model;
        if (editable) {
          model.setElementState(ElementState.TEXT_EDIT);
        }
        eventCenter.emit(EventType.TEXT_DBCLICK, {
          data: model.text,
          model
        });
      };
      var draggable = props.draggable;
      _this.stepperDrag = new StepDrag({
        onDragging: _this.onDragging,
        step: 1,
        // model,
        eventType: "TEXT",
        isStopPropagation: draggable
      });
      return _this;
    }
    BaseText2.prototype.getShape = function() {
      var _a2 = this.props, model = _a2.model, graphModel = _a2.graphModel;
      var editConfigModel = graphModel.editConfigModel;
      var _b = model.text, value = _b.value, x3 = _b.x, y3 = _b.y, editable = _b.editable, draggable = _b.draggable;
      var attr = {
        x: x3,
        y: y3,
        className: "",
        value
      };
      var style = model.getTextStyle();
      var isDraggable = editConfigModel.nodeTextDraggable || draggable;
      return u3(Text, __assign32({}, attr, style, { className: (0, import_classnames.default)({
        "lf-element-text": editable,
        "lf-text-draggable": !editable && isDraggable,
        "lf-text-disabled": !editable && !isDraggable
      }), model }));
    };
    BaseText2.prototype.render = function() {
      var text = this.props.model.text;
      if (text) {
        return u3("g", { onMouseDown: this.mouseDownHandler, onDblClick: this.dbClickHandler, children: this.getShape() });
      }
    };
    return BaseText2;
  }(x)
);

// node_modules/@logicflow/core/es/view/text/LineText.js
var __extends27 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign33 = function() {
  __assign33 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign33.apply(this, arguments);
};
var __read28 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var LineText = (
  /** @class */
  function(_super) {
    __extends27(LineText2, _super);
    function LineText2(props) {
      var _this = _super.call(this, props) || this;
      _this.setHoverOn = function() {
        _this.setState({
          isHovered: true
        });
      };
      _this.setHoverOff = function() {
        _this.setState({
          isHovered: false
        });
      };
      _this.state = {
        isHovered: false
      };
      return _this;
    }
    LineText2.prototype.getBackground = function() {
      var isHovered = this.state.isHovered;
      var model = this.props.model;
      var text = model.text;
      var style = model.getTextStyle();
      var backgroundStyle = style.background || {};
      if (isHovered && style.hover && style.hover.background) {
        backgroundStyle = __assign33(__assign33({}, backgroundStyle), style.hover.background);
      }
      if ((text === null || text === void 0 ? void 0 : text.value) && (backgroundStyle === null || backgroundStyle === void 0 ? void 0 : backgroundStyle.fill) !== "transparent") {
        var fontSize = style.fontSize, textWidth = style.textWidth, lineHeight = style.lineHeight, overflowMode = style.overflowMode;
        var wrapPadding = backgroundStyle.wrapPadding;
        var rows = text === null || text === void 0 ? void 0 : text.value.split(/[\r\n]/g);
        var rowsLength = rows.length;
        var x3 = text.x, y3 = text.y;
        var rectAttr = {};
        if (overflowMode === "autoWrap" && textWidth) {
          var textHeight = getHtmlTextHeight({
            rows,
            style: {
              fontSize: "".concat(fontSize, "px"),
              width: "".concat(textWidth, "px"),
              lineHeight,
              padding: wrapPadding
            },
            rowsLength,
            className: "lf-get-text-height"
          });
          rectAttr = __assign33(__assign33({}, backgroundStyle), { x: x3, y: y3, width: textWidth, height: textHeight });
        } else {
          var _a2 = getSvgTextSize({ rows, rowsLength, fontSize }), width = _a2.width, height = _a2.height;
          if (overflowMode === "ellipsis") {
            width = textWidth;
            height = fontSize + 2;
          }
          if (typeof backgroundStyle.wrapPadding === "string") {
            var padding = backgroundStyle.wrapPadding.split(",").filter(function(padding2) {
              return padding2.trim();
            }).map(function(padding2) {
              return parseFloat(padding2.trim());
            });
            if (padding.length > 0 && padding.length <= 4) {
              if (padding.length === 1) {
                var _b = __read28(padding, 1), allSides = _b[0];
                padding = [allSides, allSides, allSides, allSides];
              } else if (padding.length === 2) {
                var _c = __read28(padding, 2), vertical = _c[0], horizontal = _c[1];
                padding = [vertical, horizontal, vertical, horizontal];
              } else if (padding.length === 3) {
                var _d = __read28(padding, 3), top_1 = _d[0], horizontal = _d[1], bottom_1 = _d[2];
                padding = [top_1, horizontal, bottom_1, horizontal];
              }
              var _e = __read28(padding, 4), top_2 = _e[0], right = _e[1], bottom = _e[2], left = _e[3];
              width += right + left;
              height += top_2 + bottom;
              x3 = x3 + (right - left) / 2;
              y3 = y3 + (bottom - top_2) / 2;
            }
          }
          rectAttr = __assign33(__assign33({}, backgroundStyle), { x: x3 - 1, y: y3 - 1, width, height });
        }
        return u3(Rect, __assign33({}, rectAttr));
      }
      return null;
    };
    LineText2.prototype.getShape = function() {
      var model = this.props.model;
      var _a2 = model.text, x3 = _a2.x, y3 = _a2.y, value = _a2.value;
      if (!value)
        return null;
      var style = model.getTextStyle();
      var attrs = __assign33({ x: x3, y: y3, value, model, className: "lf-element-text" }, style);
      return u3("g", { className: "lf-line-text", onMouseEnter: this.setHoverOn, onMouseLeave: this.setHoverOff, children: [this.getBackground(), u3(Text, __assign33({}, attrs))] });
    };
    return LineText2;
  }(BaseText)
);

// node_modules/@logicflow/core/es/view/node/BaseNode.js
var __extends28 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign34 = function() {
  __assign34 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign34.apply(this, arguments);
};
var __rest3 = function(s3, e3) {
  var t3 = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t3[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p3 = Object.getOwnPropertySymbols(s3); i4 < p3.length; i4++) {
      if (e3.indexOf(p3[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i4]))
        t3[p3[i4]] = s3[p3[i4]];
    }
  return t3;
};
var __read29 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var BaseNode = (
  /** @class */
  function(_super) {
    __extends28(BaseNode2, _super);
    function BaseNode2(props) {
      var _this = _super.call(this) || this;
      _this.onDragStart = function(_a3) {
        var event = _a3.event;
        var _b = _this.props, model2 = _b.model, graphModel = _b.graphModel;
        if (event) {
          var _c = graphModel.getPointByClient({
            x: event.clientX,
            y: event.clientY
          }).canvasOverlayPosition, x3 = _c.x, y3 = _c.y;
          _this.moveOffset = {
            dx: model2.x - x3,
            dy: model2.y - y3
          };
        }
      };
      _this.onDragging = function(_a3) {
        var _b, _c, _d, _e;
        var event = _a3.event;
        var _f = _this.props, model2 = _f.model, graphModel = _f.graphModel;
        var _g = graphModel.editConfigModel, stopMoveGraph = _g.stopMoveGraph, autoExpand = _g.autoExpand, snapGrid = _g.snapGrid, transformModel = graphModel.transformModel, selectNodes = graphModel.selectNodes, width = graphModel.width, height = graphModel.height, gridSize2 = graphModel.gridSize;
        model2.isDragging = true;
        var _h = event, clientX = _h.clientX, clientY = _h.clientY;
        var _j = graphModel.getPointByClient({
          x: clientX,
          y: clientY
        }).canvasOverlayPosition, x3 = _j.x, y3 = _j.y;
        var _k = __read29(transformModel.CanvasPointToHtmlPoint([x3, y3]), 2), x1 = _k[0], y1 = _k[1];
        x3 = x3 + ((_c = (_b = _this.moveOffset) === null || _b === void 0 ? void 0 : _b.dx) !== null && _c !== void 0 ? _c : 0);
        y3 = y3 + ((_e = (_d = _this.moveOffset) === null || _d === void 0 ? void 0 : _d.dy) !== null && _e !== void 0 ? _e : 0);
        x3 = snapToGrid(x3, gridSize2, snapGrid);
        y3 = snapToGrid(y3, gridSize2, snapGrid);
        if (!width || !height) {
          graphModel.moveNode2Coordinate(model2.id, x3, y3);
          return;
        }
        var isOutCanvas = x1 < 0 || y1 < 0 || x1 > width || y1 > height;
        if (autoExpand && !stopMoveGraph && isOutCanvas) {
          return;
        }
        var _l = __read29(transformModel.CanvasPointToHtmlPoint([
          x3 - model2.width / 2,
          y3 - model2.height / 2
        ]), 2), leftTopX = _l[0], leftTopY = _l[1];
        var _m = __read29(transformModel.CanvasPointToHtmlPoint([
          x3 + model2.width / 2,
          y3 + model2.height / 2
        ]), 2), rightBottomX = _m[0], rightBottomY = _m[1];
        var size = Math.max(gridSize2, 20);
        var nearBoundary = [];
        if (leftTopX < 0) {
          nearBoundary = [size, 0];
        } else if (rightBottomX > graphModel.width) {
          nearBoundary = [-size, 0];
        } else if (leftTopY < 0) {
          nearBoundary = [0, size];
        } else if (rightBottomY > graphModel.height) {
          nearBoundary = [0, -size];
        }
        if (_this.t) {
          cancelRaf(_this.t);
        }
        model2.transform = new TranslateMatrix(-x3, -y3).rotate(model2.rotate).translate(x3, y3).toString();
        var moveNodes = selectNodes.map(function(node) {
          return node.id;
        });
        if (moveNodes.indexOf(model2.id) === -1) {
          moveNodes = [model2.id];
        }
        if (nearBoundary.length > 0 && !stopMoveGraph && autoExpand) {
          _this.t = createRaf(function() {
            var _a4 = __read29(nearBoundary, 2), translateX = _a4[0], translateY = _a4[1];
            transformModel.translate(translateX !== null && translateX !== void 0 ? translateX : 0, translateY !== null && translateY !== void 0 ? translateY : 0);
            var deltaX = -(translateX !== null && translateX !== void 0 ? translateX : 0) / transformModel.SCALE_X;
            var deltaY = -(translateY !== null && translateY !== void 0 ? translateY : 0) / transformModel.SCALE_X;
            graphModel.moveNodes(moveNodes, deltaX, deltaY);
          });
        } else {
          graphModel.moveNodes(moveNodes, x3 - model2.x, y3 - model2.y);
        }
      };
      _this.onDragEnd = function() {
        if (_this.t) {
          cancelRaf(_this.t);
        }
        var model2 = _this.props.model;
        model2.isDragging = false;
      };
      _this.onMouseOut = function(ev) {
        if (isIe()) {
          _this.setHoverOff(ev);
        }
      };
      _this.handleMouseUp = function() {
        var model2 = _this.props.model;
        _this.mouseUpDrag = model2.isDragging;
      };
      _this.handleClick = function(e3) {
        var isDragging = _this.mouseUpDrag === false;
        if (!_this.startTime)
          return;
        var _a3 = _this.props, model2 = _a3.model, graphModel = _a3.graphModel;
        if (!isDragging)
          return;
        var nodeData = model2.getData();
        var position = graphModel.getPointByClient({
          x: e3.clientX,
          y: e3.clientY
        });
        var eventOptions = {
          data: nodeData,
          e: e3,
          position,
          isSelected: false,
          isMultiple: false
        };
        var isRightClick = e3.button === 2;
        var isDoubleClick = e3.detail === 2;
        if (isRightClick)
          return;
        var editConfigModel = graphModel.editConfigModel;
        var isMultiple = isMultipleSelect(e3, editConfigModel);
        eventOptions.isMultiple = isMultiple;
        if (model2.isSelected && !isDoubleClick && isMultiple) {
          eventOptions.isSelected = false;
          model2.setSelected(false);
        } else {
          graphModel.selectNodeById(model2.id, isMultiple);
          eventOptions.isSelected = true;
          if (!editConfigModel.isSilentMode) {
            _this.toFront();
          }
        }
        if (isDoubleClick) {
          if (editConfigModel.nodeTextEdit) {
            if (model2.text.editable && editConfigModel.textMode === TextMode.TEXT) {
              model2.setSelected(false);
              graphModel.setElementStateById(model2.id, ElementState.TEXT_EDIT);
            }
          }
          graphModel.eventCenter.emit(EventType.NODE_DBCLICK, eventOptions);
        } else {
          graphModel.eventCenter.emit(EventType.ELEMENT_CLICK, eventOptions);
          graphModel.eventCenter.emit(EventType.NODE_CLICK, eventOptions);
        }
      };
      _this.handleContextMenu = function(ev) {
        ev.preventDefault();
        var _a3 = _this.props, model2 = _a3.model, graphModel = _a3.graphModel;
        var editConfigModel = graphModel.editConfigModel;
        var nodeData = model2.getData();
        var position = graphModel.getPointByClient({
          x: ev.clientX,
          y: ev.clientY
        });
        graphModel.setElementStateById(model2.id, ElementState.SHOW_MENU, position.domOverlayPosition);
        if (!model2.isSelected) {
          graphModel.selectNodeById(model2.id);
        }
        graphModel.eventCenter.emit(EventType.NODE_CONTEXTMENU, {
          data: nodeData,
          e: ev,
          position
        });
        if (!editConfigModel.isSilentMode) {
          _this.toFront();
        }
      };
      _this.handleMouseDown = function(ev) {
        var _a3 = _this.props, model2 = _a3.model, graphModel = _a3.graphModel;
        _this.startTime = (/* @__PURE__ */ new Date()).getTime();
        var editConfigModel = graphModel.editConfigModel;
        if (editConfigModel.adjustNodePosition && model2.draggable) {
          _this.stepDrag && _this.stepDrag.handleMouseDown(ev);
        }
      };
      _this.handleFocus = function() {
        var _a3 = _this.props, model2 = _a3.model, graphModel = _a3.graphModel;
        graphModel.eventCenter.emit(EventType.NODE_FOCUS, {
          data: model2.getData()
        });
      };
      _this.handleBlur = function() {
        var _a3 = _this.props, model2 = _a3.model, graphModel = _a3.graphModel;
        graphModel.eventCenter.emit(EventType.NODE_BLUR, {
          data: model2.getData()
        });
      };
      _this.setHoverOn = function(ev) {
        var _a3 = _this.props, model2 = _a3.model, graphModel = _a3.graphModel;
        if (model2.isHovered)
          return;
        var nodeData = model2.getData();
        model2.setHovered(true);
        graphModel.eventCenter.emit(EventType.NODE_MOUSEENTER, {
          data: nodeData,
          e: ev
        });
      };
      _this.setHoverOff = function(ev) {
        var _a3 = _this.props, model2 = _a3.model, graphModel = _a3.graphModel;
        var nodeData = model2.getData();
        if (!model2.isHovered)
          return;
        model2.setHovered(false);
        graphModel.eventCenter.emit(EventType.NODE_MOUSELEAVE, {
          data: nodeData,
          e: ev
        });
      };
      var _a2 = props.graphModel, gridSize = _a2.gridSize, eventCenter = _a2.eventCenter, model = props.model;
      _this.stepDrag = new StepDrag({
        onDragStart: _this.onDragStart,
        onDragging: _this.onDragging,
        onDragEnd: _this.onDragEnd,
        step: gridSize,
        eventType: "NODE",
        isStopPropagation: false,
        eventCenter,
        model
      });
      _this.modelDisposer = reaction(function() {
        return _this.props;
      }, function(newProps) {
        if (newProps && newProps.model) {
          _this.stepDrag.setModel(newProps.model);
        }
      });
      return _this;
    }
    BaseNode2.prototype.componentWillUnmount = function() {
      if (this.modelDisposer) {
        this.modelDisposer();
      }
      if (this.render.$mobx) {
        this.render.$mobx.dispose();
      }
    };
    BaseNode2.prototype.componentDidMount = function() {
    };
    BaseNode2.prototype.componentDidUpdate = function() {
    };
    BaseNode2.prototype.getAnchorShape = function(_anchorData) {
      return null;
    };
    BaseNode2.prototype.getAnchors = function() {
      var _this = this;
      var _a2 = this.props, model = _a2.model, graphModel = _a2.graphModel;
      var isSelected = model.isSelected, isHitable = model.isHitable, isDragging = model.isDragging, isShowAnchor = model.isShowAnchor;
      if (isHitable && (isSelected || isShowAnchor) && !isDragging) {
        return map_default(model.anchors, function(anchor, index) {
          var edgeStyle = model.getAnchorLineStyle(anchor);
          var style = model.getAnchorStyle(anchor);
          return u3(Anchor_default, { anchorData: anchor, node: _this, style, edgeStyle, anchorIndex: index, nodeModel: model, graphModel, setHoverOff: _this.setHoverOff });
        });
      }
      return [];
    };
    BaseNode2.prototype.getRotateControl = function() {
      var _a2 = this.props, model = _a2.model, graphModel = _a2.graphModel;
      var _b = graphModel.editConfigModel, isSilentMode = _b.isSilentMode, allowRotate = _b.allowRotate;
      var isSelected = model.isSelected, isHitable = model.isHitable, rotatable = model.rotatable, isHovered = model.isHovered;
      var canRotate = allowRotate && rotatable;
      var style = model.getRotateControlStyle();
      if (!isSilentMode && isHitable && (isSelected || isHovered) && canRotate) {
        return u3(Rotate_default, { graphModel, nodeModel: model, eventCenter: graphModel.eventCenter, style });
      }
    };
    BaseNode2.prototype.getResizeControl = function() {
      var _a2 = this.props, model = _a2.model, graphModel = _a2.graphModel;
      var _b = graphModel.editConfigModel, isSilentMode = _b.isSilentMode, allowResize = _b.allowResize;
      var isSelected = model.isSelected, isHitable = model.isHitable, resizable = model.resizable, isHovered = model.isHovered;
      var canResize = allowResize && resizable;
      var style = model.getResizeControlStyle();
      if (!isSilentMode && isHitable && (isSelected || isHovered) && canResize) {
        return u3(Control_default, { style, model, graphModel });
      }
      return null;
    };
    BaseNode2.prototype.getText = function() {
      var _a2;
      var _b = this.props, model = _b.model, graphModel = _b.graphModel;
      var editConfigModel = graphModel.editConfigModel;
      if (editConfigModel.nodeTextMode !== TextMode.TEXT)
        return null;
      if (model.state === ElementState.TEXT_EDIT)
        return null;
      if (model.text) {
        var draggable = false;
        if (editConfigModel.nodeTextDraggable && model.text.draggable) {
          draggable = true;
        }
        return u3(BaseText, { editable: editConfigModel.nodeTextEdit && ((_a2 = model.text.editable) !== null && _a2 !== void 0 ? _a2 : true), model, graphModel, draggable });
      }
      return null;
    };
    BaseNode2.prototype.getStateClassName = function() {
      var _a2 = this.props.model, state = _a2.state, isDragging = _a2.isDragging, isSelected = _a2.isSelected;
      var className = "lf-node";
      switch (state) {
        case ElementState.ALLOW_CONNECT:
          className += " lf-node-allow";
          break;
        case ElementState.NOT_ALLOW_CONNECT:
          className += " lf-node-not-allow";
          break;
        default:
          className += " lf-node-default";
          break;
      }
      if (isDragging) {
        className += " lf-dragging";
      }
      if (isSelected) {
        className += " lf-node-selected";
      }
      return className;
    };
    BaseNode2.prototype.toFront = function() {
      var _a2 = this.props, model = _a2.model, graphModel = _a2.graphModel;
      if (model.autoToFront) {
        graphModel.toFront(model.id);
      }
    };
    BaseNode2.prototype.render = function() {
      var _a2 = this.props, model = _a2.model, graphModel = _a2.graphModel;
      var _b = graphModel.editConfigModel, hideAnchors = _b.hideAnchors, adjustNodePosition = _b.adjustNodePosition, allowRotate = _b.allowRotate, allowResize = _b.allowResize, gridSize = graphModel.gridSize, SCALE_X = graphModel.transformModel.SCALE_X;
      var isHitable = model.isHitable, draggable = model.draggable, transform = model.transform;
      var _c = model.getOuterGAttributes(), _d = _c.className, className = _d === void 0 ? "" : _d, restAttributes = __rest3(_c, ["className"]);
      var nodeShapeInner = u3("g", { className: "lf-node-content", children: [u3("g", { transform, children: [this.getShape(), this.getText(), allowRotate && this.getRotateControl(), allowResize && this.getResizeControl()] }), !hideAnchors && this.getAnchors()] });
      var nodeShape;
      if (!isHitable) {
        nodeShape = u3("g", __assign34({ className: "".concat(this.getStateClassName(), " ").concat(className) }, restAttributes, { children: nodeShapeInner }));
      } else {
        if (adjustNodePosition && draggable) {
          this.stepDrag.setStep(gridSize * SCALE_X);
        }
        nodeShape = u3("g", __assign34({ className: "".concat(this.getStateClassName(), " ").concat(className), onMouseDown: this.handleMouseDown, onMouseUp: this.handleMouseUp, onClick: this.handleClick, onMouseEnter: this.setHoverOn, onMouseOver: this.setHoverOn, onMouseLeave: this.setHoverOff, onMouseOut: this.onMouseOut, onContextMenu: this.handleContextMenu, onFocus: this.handleFocus, onBlur: this.handleBlur }, restAttributes, { children: nodeShapeInner }));
      }
      return nodeShape;
    };
    BaseNode2.isObserved = false;
    return BaseNode2;
  }(x)
);
var BaseNode_default = BaseNode;

// node_modules/@logicflow/core/es/view/node/RectNode.js
var __extends29 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign35 = function() {
  __assign35 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign35.apply(this, arguments);
};
var RectNode = (
  /** @class */
  function(_super) {
    __extends29(RectNode2, _super);
    function RectNode2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    RectNode2.prototype.getShape = function() {
      var model = this.props.model;
      var style = model.getNodeStyle();
      return u3(Rect, __assign35({}, style, { x: model.x, y: model.y, width: model.width, height: model.height, radius: model.radius }));
    };
    return RectNode2;
  }(BaseNode_default)
);

// node_modules/@logicflow/core/es/view/node/CircleNode.js
var __extends30 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign36 = function() {
  __assign36 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign36.apply(this, arguments);
};
var CircleNode = (
  /** @class */
  function(_super) {
    __extends30(CircleNode2, _super);
    function CircleNode2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CircleNode2.prototype.getShape = function() {
      var model = this.props.model;
      var x3 = model.x, y3 = model.y, r3 = model.r;
      var style = model.getNodeStyle();
      return u3(Circle_default, __assign36({}, style, { x: x3, y: y3, r: r3 }));
    };
    return CircleNode2;
  }(BaseNode_default)
);

// node_modules/@logicflow/core/es/view/node/PolygonNode.js
var __extends31 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign37 = function() {
  __assign37 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign37.apply(this, arguments);
};
var PolygonNode = (
  /** @class */
  function(_super) {
    __extends31(PolygonNode2, _super);
    function PolygonNode2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PolygonNode2.prototype.getShape = function() {
      var model = this.props.model;
      var _a2 = model, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height, points = _a2.points;
      var style = model.getNodeStyle();
      var attr = {
        transform: "matrix(1 0 0 1 ".concat(x3 - width / 2, " ").concat(y3 - height / 2, ")")
      };
      return u3("g", __assign37({}, attr, { children: u3(Polygon, __assign37({}, style, { points, x: x3, y: y3 })) }));
    };
    return PolygonNode2;
  }(BaseNode_default)
);

// node_modules/@logicflow/core/es/view/node/DiamondNode.js
var __extends32 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign38 = function() {
  __assign38 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign38.apply(this, arguments);
};
var DiamondNode = (
  /** @class */
  function(_super) {
    __extends32(DiamondNode2, _super);
    function DiamondNode2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DiamondNode2.prototype.getShape = function() {
      var model = this.props.model;
      var style = model.getNodeStyle();
      return u3("g", { children: u3(Polygon_default, __assign38({}, style, { points: model.points, x: model.x, y: model.y })) });
    };
    return DiamondNode2;
  }(BaseNode_default)
);

// node_modules/@logicflow/core/es/view/node/EllipseNode.js
var __extends33 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign39 = function() {
  __assign39 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign39.apply(this, arguments);
};
var EllipseNode = (
  /** @class */
  function(_super) {
    __extends33(EllipseNode2, _super);
    function EllipseNode2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    EllipseNode2.prototype.getShape = function() {
      var model = this.props.model;
      var style = model.getNodeStyle();
      return u3(Ellipse_default, __assign39({}, style, { x: model.x, y: model.y, rx: model.rx, ry: model.ry }));
    };
    return EllipseNode2;
  }(BaseNode_default)
);

// node_modules/@logicflow/core/es/view/node/TextNode.js
var __extends34 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign40 = function() {
  __assign40 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign40.apply(this, arguments);
};
var TextNode = (
  /** @class */
  function(_super) {
    __extends34(TextNode2, _super);
    function TextNode2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TextNode2.prototype.getBackground = function() {
      var model = this.props.model;
      var style = model.getTextStyle();
      var width = model.width, height = model.height, x3 = model.x, y3 = model.y;
      var rectAttr = __assign40(__assign40({}, style.background), { x: x3, y: y3, width, height });
      return u3(Rect_default, __assign40({}, rectAttr));
    };
    TextNode2.prototype.getResizeControl = function() {
      return null;
    };
    TextNode2.prototype.getShape = function() {
      return u3("g", { children: this.getBackground() });
    };
    return TextNode2;
  }(BaseNode_default)
);

// node_modules/@logicflow/core/es/view/node/HtmlNode.js
var __extends35 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign41 = function() {
  __assign41 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign41.apply(this, arguments);
};
var __read30 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray9 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l3 = from.length, ar; i4 < l3; i4++) {
    if (ar || !(i4 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i4);
      ar[i4] = from[i4];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var HtmlNode = (
  /** @class */
  function(_super) {
    __extends35(HtmlNode2, _super);
    function HtmlNode2() {
      var _this = _super.apply(this, __spreadArray9([], __read30(arguments), false)) || this;
      _this.ref = b();
      return _this;
    }
    Object.defineProperty(HtmlNode2.prototype, "rootEl", {
      get: function() {
        return this.ref.current;
      },
      enumerable: false,
      configurable: true
    });
    HtmlNode2.prototype.setHtml = function(rootEl) {
      rootEl.appendChild(document.createElement("div"));
    };
    HtmlNode2.prototype.confirmUpdate = function(rootEl) {
      this.setHtml(rootEl);
    };
    HtmlNode2.prototype.shouldUpdate = function() {
      if (this.preProperties && this.preProperties === this.currentProperties) {
        return false;
      }
      this.preProperties = this.currentProperties;
      return true;
    };
    HtmlNode2.prototype.componentDidMount = function() {
      if (this.shouldUpdate() && this.rootEl) {
        this.setHtml(this.rootEl);
      }
    };
    HtmlNode2.prototype.componentDidUpdate = function() {
      if (this.shouldUpdate() && this.rootEl) {
        this.confirmUpdate(this.rootEl);
      }
    };
    HtmlNode2.prototype.componentWillUnmount = function() {
      _super.prototype.componentWillUnmount.call(this);
      this.rootEl.innerHTML = "";
    };
    HtmlNode2.prototype.getShape = function() {
      var model = this.props.model;
      var x3 = model.x, y3 = model.y, height = model.height, width = model.width;
      var style = model.getNodeStyle();
      this.currentProperties = JSON.stringify(model.properties);
      return u3("foreignObject", __assign41({}, style, { x: x3 - width / 2, y: y3 - height / 2, width, height, ref: this.ref }));
    };
    return HtmlNode2;
  }(BaseNode_default)
);

// node_modules/@logicflow/core/es/view/edge/AdjustPoint.js
var __extends36 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign42 = function() {
  __assign42 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign42.apply(this, arguments);
};
var __rest4 = function(s3, e3) {
  var t3 = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t3[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p3 = Object.getOwnPropertySymbols(s3); i4 < p3.length; i4++) {
      if (e3.indexOf(p3[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i4]))
        t3[p3[i4]] = s3[p3[i4]];
    }
  return t3;
};
var __read31 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var AdjustType;
(function(AdjustType2) {
  AdjustType2["SOURCE"] = "SOURCE";
  AdjustType2["TARGET"] = "TARGET";
})(AdjustType || (AdjustType = {}));
var AdjustPoint = (
  /** @class */
  function(_super) {
    __extends36(AdjustPoint2, _super);
    function AdjustPoint2(props) {
      var _this = _super.call(this) || this;
      _this.handleMouseDown = function(ev) {
        if (_this.stepDrag) {
          _this.stepDrag.handleMouseDown(ev);
        }
      };
      _this.onDragStart = function() {
        var _a2 = _this.props, x3 = _a2.x, y3 = _a2.y, edgeModel2 = _a2.edgeModel;
        var startPoint = edgeModel2.startPoint, endPoint = edgeModel2.endPoint, pointsList = edgeModel2.pointsList;
        _this.oldEdge = {
          startPoint,
          endPoint,
          pointsList
        };
        _this.setState({
          endX: x3,
          endY: y3,
          dragging: true
        });
      };
      _this.onDragging = function(_a2) {
        var deltaX = _a2.deltaX, deltaY = _a2.deltaY;
        var _b = _this.state, endX = _b.endX, endY = _b.endY;
        var _c = _this.props, graphModel2 = _c.graphModel, type2 = _c.type;
        var transformModel = graphModel2.transformModel, editConfigModel = graphModel2.editConfigModel;
        var _d = __read31(transformModel.moveCanvasPointByHtml([endX, endY], deltaX, deltaY), 2), x3 = _d[0], y3 = _d[1];
        _this.setState({
          endX: x3,
          endY: y3,
          dragging: true
        });
        var edgeModel2 = _this.props.edgeModel;
        var info = targetNodeInfo({
          x: endX,
          y: endY
        }, graphModel2);
        if (info && info.node && _this.isAllowAdjust(info).pass) {
          var startPoint = edgeModel2.startPoint, endPoint = edgeModel2.endPoint, sourceNode = edgeModel2.sourceNode, targetNode = edgeModel2.targetNode;
          var params = type2 === AdjustType.SOURCE ? {
            startPoint: {
              x: info.anchor.x,
              y: info.anchor.y
            },
            endPoint: {
              x: endPoint.x,
              y: endPoint.y
            },
            sourceNode: info.node,
            targetNode
          } : {
            startPoint: {
              x: startPoint.x,
              y: startPoint.y
            },
            endPoint: {
              x: info.anchor.x,
              y: info.anchor.y
            },
            sourceNode,
            targetNode: info.node
          };
          edgeModel2.updateAfterAdjustStartAndEnd(params);
        } else {
          type2 === AdjustType.SOURCE ? edgeModel2.updateStartPoint({ x: x3, y: y3 }) : edgeModel2.updateEndPoint({ x: x3, y: y3 });
        }
        if (edgeModel2.text.value && editConfigModel.adjustEdge) {
          edgeModel2.setText(Object.assign({}, edgeModel2.text, edgeModel2.textPosition));
        }
      };
      _this.onDragEnd = function(_a2) {
        var _b, _c, _d;
        var event = _a2.event;
        try {
          _this.setState({
            dragging: false
          });
          var _e = _this.props, graphModel2 = _e.graphModel, edgeModel2 = _e.edgeModel, type2 = _e.type;
          var _f = _this.state, endX = _f.endX, endY = _f.endY, dragging = _f.dragging;
          var info = targetNodeInfo({
            x: endX,
            y: endY
          }, graphModel2);
          if (!dragging)
            return;
          var needRecoveryEdge = false;
          var createEdgeInfo = void 0;
          if (info && info.node) {
            var _g = _this.isAllowAdjust(info), pass = _g.pass, msg = _g.msg, newTargetNode = _g.newTargetNode;
            if (pass) {
              var _h = edgeModel2.getData(), text = _h.text, _j = _h.sourceAnchorId, sourceAnchorId = _j === void 0 ? "" : _j, _k = _h.targetAnchorId, targetAnchorId = _k === void 0 ? "" : _k, rest = __rest4(_h, ["text", "sourceAnchorId", "targetAnchorId"]);
              createEdgeInfo = __assign42(__assign42({ sourceAnchorId, targetAnchorId }, rest), { text: (text === null || text === void 0 ? void 0 : text.value) || "" });
              if (type2 === AdjustType.SOURCE) {
                var sourceNode = graphModel2.getNodeModelById(info.node.id);
                var targetNode = graphModel2.getNodeModelById(edgeModel2.targetNodeId);
                var edgeInfo = (_b = graphModel2.edgeGenerator) === null || _b === void 0 ? void 0 : _b.call(graphModel2, sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.getData(), targetNode === null || targetNode === void 0 ? void 0 : targetNode.getData(), createEdgeInfo);
                createEdgeInfo = __assign42(__assign42({}, edgeInfo), { sourceNodeId: info.node.id, sourceAnchorId: info.anchor.id, startPoint: {
                  x: info.anchor.x,
                  y: info.anchor.y
                }, targetNodeId: edgeModel2.targetNodeId, endPoint: __assign42({}, edgeModel2.endPoint) });
                if (edgeModel2.sourceNodeId === info.node.id && edgeModel2.sourceAnchorId === info.anchor.id) {
                  needRecoveryEdge = true;
                }
              } else if (type2 === AdjustType.TARGET) {
                var sourceNode = graphModel2.getNodeModelById(edgeModel2.sourceNodeId);
                var targetNode = graphModel2.getNodeModelById(info.node.id);
                var edgeInfo = (_c = graphModel2.edgeGenerator) === null || _c === void 0 ? void 0 : _c.call(graphModel2, sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.getData(), targetNode === null || targetNode === void 0 ? void 0 : targetNode.getData(), createEdgeInfo);
                createEdgeInfo = __assign42(__assign42({}, edgeInfo), { sourceNodeId: edgeModel2.sourceNodeId, startPoint: __assign42({}, edgeModel2.startPoint), targetNodeId: info.node.id, targetAnchorId: info.anchor.id, endPoint: {
                  x: info.anchor.x,
                  y: info.anchor.y
                } });
                if (edgeModel2.targetNodeId === info.node.id && edgeModel2.targetAnchorId === info.anchor.id) {
                  needRecoveryEdge = true;
                }
              }
            } else {
              needRecoveryEdge = true;
              var nodeData = newTargetNode.getData();
              graphModel2.eventCenter.emit(EventType.CONNECTION_NOT_ALLOWED, {
                data: nodeData,
                msg
              });
            }
          } else {
            needRecoveryEdge = true;
          }
          if (!needRecoveryEdge) {
            var oldEdgeData = edgeModel2.getData();
            graphModel2.deleteEdgeById(edgeModel2.id);
            var edge = graphModel2.addEdge(__assign42({}, createEdgeInfo));
            graphModel2.eventCenter.emit(EventType.EDGE_EXCHANGE_NODE, {
              data: {
                newEdge: edge.getData(),
                oldEdge: oldEdgeData
              }
            });
          } else {
            _this.recoveryEdge();
          }
          (_d = _this.preTargetNode) === null || _d === void 0 ? void 0 : _d.setElementState(ElementState.DEFAULT);
        } finally {
          var graphModel2 = _this.props.graphModel;
          graphModel2.eventCenter.emit(EventType.ADJUST_POINT_DRAGEND, {
            e: event,
            data: _this.stepDragData
          });
        }
      };
      _this.recoveryEdge = function() {
        var edgeModel2 = _this.props.edgeModel;
        var _a2 = _this.oldEdge, startPoint = _a2.startPoint, endPoint = _a2.endPoint, pointsList = _a2.pointsList;
        edgeModel2.updateStartPoint(startPoint);
        edgeModel2.updateEndPoint(endPoint);
        if (edgeModel2.modelType !== ModelType.LINE_EDGE) {
          edgeModel2.pointsList = pointsList !== null && pointsList !== void 0 ? pointsList : [];
          edgeModel2.initPoints();
        }
      };
      _this.getAdjustPointStyle = function() {
        var theme = _this.props.graphModel.theme;
        var edgeAdjust = theme.edgeAdjust;
        return edgeAdjust;
      };
      _this.state = {
        dragging: false,
        endX: 0,
        endY: 0
      };
      _this.targetRuleResults = /* @__PURE__ */ new Map();
      _this.sourceRuleResults = /* @__PURE__ */ new Map();
      var type = props.type, edgeModel = props.edgeModel, graphModel = props.graphModel;
      var eventCenter = graphModel.eventCenter;
      _this.stepDragData = {
        type,
        edgeData: edgeModel.getData()
      };
      _this.stepDrag = new StepDrag({
        onDragStart: _this.onDragStart,
        onDragging: _this.onDragging,
        onDragEnd: _this.onDragEnd,
        eventType: "ADJUST_POINT",
        isStopPropagation: false,
        eventCenter,
        data: _this.stepDragData
      });
      return _this;
    }
    AdjustPoint2.prototype.isAllowAdjust = function(info) {
      var _a2 = this.props, _b = _a2.edgeModel, id = _b.id, sourceNode = _b.sourceNode, targetNode = _b.targetNode, sourceAnchorId = _b.sourceAnchorId, targetAnchorId = _b.targetAnchorId, type = _a2.type;
      var newSourceNode;
      var newTargetNode;
      var newSourceAnchor;
      var newTargetAnchor;
      if (type === AdjustType.SOURCE) {
        newSourceNode = info.node;
        newTargetNode = targetNode;
        newSourceAnchor = info.anchor;
        newTargetAnchor = targetNode.getAnchorInfo(targetAnchorId);
      } else {
        newSourceNode = sourceNode;
        newTargetNode = info.node;
        newTargetAnchor = info.anchor;
        newSourceAnchor = sourceNode.getAnchorInfo(sourceAnchorId);
      }
      if (this.preTargetNode && this.preTargetNode !== info.node) {
        this.preTargetNode.setElementState(ElementState.DEFAULT);
      }
      this.preTargetNode = info.node;
      if (newTargetAnchor.id === newSourceAnchor.id) {
        return {
          pass: false,
          msg: "",
          newTargetNode
        };
      }
      var targetInfoId = "".concat(newSourceNode.id, "_").concat(newTargetNode.id, "_").concat(newSourceAnchor.id, "_").concat(newTargetAnchor.id);
      if (!this.targetRuleResults.has(targetInfoId)) {
        var sourceRuleResult = newSourceNode.isAllowConnectedAsSource(newTargetNode, newSourceAnchor, newTargetAnchor, id);
        var targetRuleResult = newTargetNode.isAllowConnectedAsTarget(newSourceNode, newSourceAnchor, newTargetAnchor, id);
        this.sourceRuleResults.set(targetInfoId, formatAnchorConnectValidateData(sourceRuleResult));
        this.targetRuleResults.set(targetInfoId, formatAnchorConnectValidateData(targetRuleResult));
      }
      var _c = this.sourceRuleResults.get(targetInfoId), isSourcePass = _c.isAllPass, sourceMsg = _c.msg;
      var _d = this.targetRuleResults.get(targetInfoId), isTargetPass = _d.isAllPass, targetMsg = _d.msg;
      var state = isSourcePass && isTargetPass ? ElementState.ALLOW_CONNECT : ElementState.NOT_ALLOW_CONNECT;
      if (type === AdjustType.SOURCE) {
        newSourceNode.setElementState(state);
      } else {
        newTargetNode.setElementState(state);
      }
      return {
        pass: isSourcePass && isTargetPass,
        msg: targetMsg || sourceMsg,
        newTargetNode
      };
    };
    AdjustPoint2.prototype.render = function() {
      var _a2 = this.props, x3 = _a2.x, y3 = _a2.y, getAdjustPointShape = _a2.getAdjustPointShape, edgeModel = _a2.edgeModel;
      var dragging = this.state.dragging;
      return u3("g", { pointerEvents: dragging ? "none" : "", onMouseDown: this.handleMouseDown, children: !dragging ? getAdjustPointShape(x3, y3, edgeModel) : "" });
    };
    return AdjustPoint2;
  }(x)
);
var AdjustPoint_default = AdjustPoint;

// node_modules/@logicflow/core/es/view/edge/Arrow.js
var __extends37 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign43 = function() {
  __assign43 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign43.apply(this, arguments);
};
var Arrow = (
  /** @class */
  function(_super) {
    __extends37(Arrow2, _super);
    function Arrow2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Arrow2.prototype.getArrowAttributes = function() {
      var _a2 = this.props, arrowInfo = _a2.arrowInfo, style = _a2.style;
      var start = arrowInfo.start, end = arrowInfo.end;
      var config = {
        start,
        end,
        offset: style.offset,
        verticalLength: style.verticalLength,
        type: "end"
      };
      var _b = getVerticalPointOfLine(config), leftX = _b.leftX, leftY = _b.leftY, rightX = _b.rightX, rightY = _b.rightY;
      return __assign43({ d: "M".concat(leftX, " ").concat(leftY, " L").concat(end.x, " ").concat(end.y, " L").concat(rightX, " ").concat(rightY, " z") }, style);
    };
    Arrow2.prototype.getShape = function() {
      var _a2 = this.getArrowAttributes(), d2 = _a2.d, strokeWidth = _a2.strokeWidth, stroke = _a2.stroke, fill = _a2.fill;
      return u3(Path, { d: d2, fill, strokeWidth, stroke });
    };
    Arrow2.prototype.render = function() {
      return u3("g", { className: "lf-arrow", children: this.getShape() });
    };
    return Arrow2;
  }(x)
);

// node_modules/@logicflow/core/es/view/edge/BaseEdge.js
var __extends38 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign44 = function() {
  __assign44 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign44.apply(this, arguments);
};
var __read32 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var BaseEdge = (
  /** @class */
  function(_super) {
    __extends38(BaseEdge2, _super);
    function BaseEdge2() {
      var _this = _super.call(this) || this;
      _this.textRef = b();
      _this.handleHover = function(hovered, ev) {
        var _a2 = _this.props, model = _a2.model, eventCenter = _a2.graphModel.eventCenter;
        model.setHovered(hovered);
        var eventName = hovered ? EventType.EDGE_MOUSEENTER : EventType.EDGE_MOUSELEAVE;
        var nodeData = model.getData();
        eventCenter.emit(eventName, {
          data: nodeData,
          e: ev
        });
      };
      _this.setHoverOn = function(ev) {
        var isHovered = _this.props.model.isHovered;
        if (isHovered)
          return;
        _this.textRef && _this.textRef.current && _this.textRef.current.setHoverOn();
        _this.handleHover(true, ev);
      };
      _this.setHoverOff = function(ev) {
        var isHovered = _this.props.model.isHovered;
        if (!isHovered)
          return;
        _this.textRef && _this.textRef.current && _this.textRef.current.setHoverOff();
        _this.handleHover(false, ev);
      };
      _this.handleContextMenu = function(ev) {
        ev.preventDefault();
        _this.contextMenuTime = (/* @__PURE__ */ new Date()).getTime();
        if (_this.clickTimer) {
          clearTimeout(_this.clickTimer);
        }
        var _a2 = _this.props, model = _a2.model, graphModel = _a2.graphModel;
        var editConfigModel = graphModel.editConfigModel;
        var position = graphModel.getPointByClient({
          x: ev.clientX,
          y: ev.clientY
        });
        graphModel.setElementStateById(model.id, ElementState.SHOW_MENU, position.domOverlayPosition);
        if (!editConfigModel.isSilentMode) {
          _this.toFront();
        }
        if (!model.isSelected) {
          graphModel.selectEdgeById(model.id);
        }
        var edgeData = model === null || model === void 0 ? void 0 : model.getData();
        graphModel.eventCenter.emit(EventType.EDGE_CONTEXTMENU, {
          data: edgeData,
          e: ev,
          position
        });
      };
      _this.handleMouseDown = function(e3) {
        e3.stopPropagation();
        _this.startTime = (/* @__PURE__ */ new Date()).getTime();
      };
      _this.handleMouseUp = function() {
        var model = _this.props.model;
        _this.mouseUpDrag = model.isDragging;
      };
      _this.handleClick = function(e3) {
        if (!_this.startTime)
          return;
        if (_this.mouseUpDrag)
          return;
        var isRightClick = e3.button === 2;
        if (isRightClick)
          return;
        var isDoubleClick = e3.detail === 2;
        var _a2 = _this.props, model = _a2.model, graphModel = _a2.graphModel;
        var edgeData = model === null || model === void 0 ? void 0 : model.getData();
        var position = graphModel.getPointByClient({
          x: e3.clientX,
          y: e3.clientY
        });
        if (isDoubleClick) {
          var editConfigModel_1 = graphModel.editConfigModel, textEditElement = graphModel.textEditElement;
          var id = model.id, text = model.text, modelType = model.modelType;
          if (textEditElement && textEditElement.id === id) {
            graphModel.setElementStateById(id, ElementState.DEFAULT);
          }
          if (editConfigModel_1.edgeTextEdit && text.editable) {
            model.setSelected(false);
            graphModel.setElementStateById(id, ElementState.TEXT_EDIT);
          }
          if (modelType === ModelType.POLYLINE_EDGE) {
            var polylineEdgeModel = model;
            var _b = graphModel.getPointByClient({
              x: e3.x,
              y: e3.y
            }).canvasOverlayPosition, x3 = _b.x, y3 = _b.y;
            polylineEdgeModel.dbClickPosition = getClosestPointOfPolyline({
              x: x3,
              y: y3
            }, polylineEdgeModel.points);
          }
          graphModel.eventCenter.emit(EventType.EDGE_DBCLICK, {
            data: edgeData,
            e: e3,
            position
          });
        } else {
          graphModel.eventCenter.emit(EventType.ELEMENT_CLICK, {
            data: edgeData,
            e: e3,
            position
          });
          graphModel.eventCenter.emit(EventType.EDGE_CLICK, {
            data: edgeData,
            e: e3,
            position
          });
        }
        var editConfigModel = graphModel.editConfigModel;
        graphModel.selectEdgeById(model.id, isMultipleSelect(e3, editConfigModel));
        if (!editConfigModel.isSilentMode) {
          _this.toFront();
        }
      };
      _this.handleFocus = function() {
        var _a2 = _this.props, model = _a2.model, graphModel = _a2.graphModel;
        graphModel.eventCenter.emit(EventType.EDGE_FOCUS, {
          data: model.getData()
        });
      };
      _this.handleBlur = function() {
        var _a2 = _this.props, model = _a2.model, graphModel = _a2.graphModel;
        graphModel.eventCenter.emit(EventType.EDGE_BLUR, {
          data: model.getData()
        });
      };
      return _this;
    }
    BaseEdge2.prototype.getShape = function() {
      return u3("g", { children: this.getEdge() });
    };
    BaseEdge2.prototype.getTextStyle = function() {
    };
    BaseEdge2.prototype.getText = function() {
      var _a2;
      var _b = this.props, model = _b.model, graphModel = _b.graphModel;
      var editConfigModel = graphModel.editConfigModel;
      if (editConfigModel.edgeTextMode !== TextMode.TEXT)
        return null;
      if (model.state === ElementState.TEXT_EDIT)
        return null;
      if (model.text) {
        var draggable = false;
        if (editConfigModel.edgeTextDraggable && model.text.draggable) {
          draggable = true;
        }
        return u3(LineText, { ref: this.textRef, editable: editConfigModel.edgeTextEdit && ((_a2 = model.text.editable) !== null && _a2 !== void 0 ? _a2 : true), model, graphModel, draggable });
      }
      return null;
    };
    BaseEdge2.prototype.getArrowInfo = function() {
      var model = this.props.model;
      var startPoint = model.startPoint, endPoint = model.endPoint, isSelected = model.isSelected;
      var hover = this.state.hover;
      return {
        start: startPoint,
        end: endPoint,
        hover,
        isSelected
      };
    };
    BaseEdge2.prototype.getLastTwoPoints = function() {
      var model = this.props.model;
      var startPoint = model.startPoint, endPoint = model.endPoint;
      return [startPoint, endPoint];
    };
    BaseEdge2.prototype.getArrowStyle = function() {
      console.error("getArrowStyle is deprecated in 1.2.0, please use model.getArrowStyle");
      return null;
    };
    BaseEdge2.prototype.getArrow = function() {
      var model = this.props.model;
      var id = model.id;
      var _a2 = model.getArrowStyle(), _b = _a2.refY, refY = _b === void 0 ? 0 : _b, _c = _a2.refX, refX = _c === void 0 ? 2 : _c;
      var _d = __read32(this.getLastTwoPoints(), 2), start = _d[0], end = _d[1];
      var theta = "auto";
      if (start !== null && end !== null) {
        theta = degrees(getThetaOfVector({
          x: end.x - start.x,
          y: end.y - start.y,
          z: 0
        }));
      }
      return u3("g", { children: u3("defs", { children: [u3("marker", { id: "marker-start-".concat(id), refX: -refX, refY, overflow: "visible", orient: "auto", markerUnits: "userSpaceOnUse", children: this.getStartArrow() }), u3("marker", { id: "marker-end-".concat(id), refX, refY, overflow: "visible", orient: theta, markerUnits: "userSpaceOnUse", children: this.getEndArrow() })] }) });
    };
    BaseEdge2.prototype.getStartArrow = function() {
      return u3("path", {});
    };
    BaseEdge2.prototype.getEndArrow = function() {
      var model = this.props.model;
      var _a2 = model.getArrowStyle(), stroke = _a2.stroke, strokeWidth = _a2.strokeWidth, offset = _a2.offset, verticalLength = _a2.verticalLength;
      return u3("path", { stroke, fill: stroke, strokeWidth, transform: "rotate(180)", d: "M 0 0 L ".concat(offset, " -").concat(verticalLength, " L ").concat(offset, " ").concat(verticalLength, " Z") });
    };
    BaseEdge2.prototype.getAdjustPointShape = function(x3, y3, model) {
      var style = model.getAdjustPointStyle();
      return u3(Circle, __assign44({ className: "lf-edge-adjust-point" }, style, { x: x3, y: y3 }));
    };
    BaseEdge2.prototype.getAdjustPoints = function() {
      var _a2 = this.props, model = _a2.model, graphModel = _a2.graphModel;
      var _b = graphModel.editConfigModel, adjustEdgeStartAndEnd = _b.adjustEdgeStartAndEnd, adjustEdgeStart = _b.adjustEdgeStart, adjustEdgeEnd = _b.adjustEdgeEnd;
      var start = model.getAdjustStart();
      var end = model.getAdjustEnd();
      return u3("g", { children: [adjustEdgeStartAndEnd && adjustEdgeStart && u3(AdjustPoint_default, __assign44({ type: AdjustType.SOURCE }, start, { getAdjustPointShape: this.getAdjustPointShape, edgeModel: model, graphModel })), adjustEdgeStartAndEnd && adjustEdgeEnd && u3(AdjustPoint_default, __assign44({ type: AdjustType.TARGET }, end, { getAdjustPointShape: this.getAdjustPointShape, edgeModel: model, graphModel }))] });
    };
    BaseEdge2.prototype.getAnimation = function() {
      console.error("getAnimation is deprecated in 1.2.0, please use model.getEdgeAnimationStyle");
    };
    BaseEdge2.prototype.getAppendWidth = function() {
      return u3("g", {});
    };
    BaseEdge2.prototype.getAppend = function() {
      return u3("g", { className: "lf-edge-append", children: this.getAppendWidth() });
    };
    BaseEdge2.prototype.getEdge = function() {
      return null;
    };
    BaseEdge2.prototype.toFront = function() {
      var _a2 = this.props, graphModel = _a2.graphModel, model = _a2.model;
      graphModel.toFront(model.id);
    };
    BaseEdge2.prototype.render = function() {
      var _a2 = this.props.model, isSelected = _a2.isSelected, isHitable = _a2.isHitable, isShowAdjustPoint = _a2.isShowAdjustPoint;
      return u3("g", { children: [u3("g", { className: [
        "lf-edge",
        !isHitable && "pointer-none",
        isSelected && "lf-edge-selected"
      ].filter(Boolean).join(" "), onMouseDown: this.handleMouseDown, onMouseUp: this.handleMouseUp, onClick: this.handleClick, onContextMenu: this.handleContextMenu, onMouseOver: this.setHoverOn, onMouseEnter: this.setHoverOn, onMouseLeave: this.setHoverOff, onFocus: this.handleFocus, onBlur: this.handleBlur, children: [this.getShape(), this.getAppend(), this.getText(), this.getArrow()] }), isShowAdjustPoint && isSelected ? this.getAdjustPoints() : ""] });
    };
    BaseEdge2.isObserved = false;
    return BaseEdge2;
  }(x)
);
var BaseEdge_default = BaseEdge;

// node_modules/@logicflow/core/es/view/edge/BezierEdge.js
var __extends39 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign45 = function() {
  __assign45 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign45.apply(this, arguments);
};
var __read33 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var BezierEdge = (
  /** @class */
  function(_super) {
    __extends39(BezierEdge2, _super);
    function BezierEdge2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    BezierEdge2.prototype.getEdge = function() {
      var model = this.props.model;
      var style = model.getEdgeStyle();
      var _a2 = model, path = _a2.path, isAnimation = _a2.isAnimation, arrowConfig = _a2.arrowConfig;
      var animationStyle = model.getEdgeAnimationStyle();
      var strokeDasharray = animationStyle.strokeDasharray, stroke = animationStyle.stroke, strokeDashoffset = animationStyle.strokeDashoffset, animationName = animationStyle.animationName, animationDuration = animationStyle.animationDuration, animationIterationCount = animationStyle.animationIterationCount, animationTimingFunction = animationStyle.animationTimingFunction, animationDirection = animationStyle.animationDirection;
      return u3(Path, __assign45({ d: path }, style, arrowConfig, isAnimation ? {
        strokeDasharray,
        stroke,
        style: {
          strokeDashoffset,
          animationName,
          animationDuration,
          animationIterationCount,
          animationTimingFunction,
          animationDirection
        }
      } : {}));
    };
    BezierEdge2.prototype.getAppendWidth = function() {
      var path = this.props.model.path;
      return u3(Path, { d: path, strokeWidth: 10, stroke: "transparent", fill: "none" });
    };
    BezierEdge2.prototype.getArrowInfo = function() {
      var model = this.props.model;
      var hover = this.state.hover;
      var isSelected = model.isSelected;
      var offset = model.getArrowStyle().offset;
      var points = model.pointsList.map(function(point) {
        return {
          x: point.x,
          y: point.y
        };
      });
      var _a2 = __read33(getEndTangent(points, offset), 2), ePre = _a2[0], end = _a2[1];
      var arrowInfo = {
        start: ePre,
        end,
        hover,
        isSelected
      };
      return arrowInfo;
    };
    BezierEdge2.prototype.getLastTwoPoints = function() {
      var model = this.props.model;
      var offset = model.getArrowStyle().offset;
      var points = model.pointsList.map(function(point) {
        return {
          x: point.x,
          y: point.y
        };
      });
      return getEndTangent(points, offset);
    };
    return BezierEdge2;
  }(BaseEdge_default)
);

// node_modules/@logicflow/core/es/view/edge/LineEdge.js
var __extends40 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign46 = function() {
  __assign46 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign46.apply(this, arguments);
};
var LineEdge = (
  /** @class */
  function(_super) {
    __extends40(LineEdge2, _super);
    function LineEdge2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LineEdge2.prototype.getEdge = function() {
      var model = this.props.model;
      var startPoint = model.startPoint, endPoint = model.endPoint, isAnimation = model.isAnimation, arrowConfig = model.arrowConfig;
      var style = model.getEdgeStyle();
      var animationStyle = model.getEdgeAnimationStyle();
      var strokeDasharray = animationStyle.strokeDasharray, stroke = animationStyle.stroke, strokeDashoffset = animationStyle.strokeDashoffset, animationName = animationStyle.animationName, animationDuration = animationStyle.animationDuration, animationIterationCount = animationStyle.animationIterationCount, animationTimingFunction = animationStyle.animationTimingFunction, animationDirection = animationStyle.animationDirection;
      return u3(Line, __assign46({}, style, { x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y }, arrowConfig, isAnimation ? {
        strokeDasharray,
        stroke,
        style: {
          strokeDashoffset,
          animationName,
          animationDuration,
          animationIterationCount,
          animationTimingFunction,
          animationDirection
        }
      } : {}));
    };
    LineEdge2.prototype.getAppendWidth = function() {
      var model = this.props.model;
      var startPoint = model.startPoint, endPoint = model.endPoint;
      var appendInfo = {
        start: startPoint,
        end: endPoint
      };
      var _a2 = getAppendAttributes(appendInfo), d2 = _a2.d, strokeWidth = _a2.strokeWidth, fill = _a2.fill, strokeDasharray = _a2.strokeDasharray, stroke = _a2.stroke;
      return u3(Path, { d: d2, fill, strokeWidth, stroke, strokeDasharray });
    };
    return LineEdge2;
  }(BaseEdge_default)
);

// node_modules/@logicflow/core/es/view/edge/PolylineEdge.js
var __extends41 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign47 = function() {
  __assign47 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign47.apply(this, arguments);
};
var __read34 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var PolylineEdge = (
  /** @class */
  function(_super) {
    __extends41(PolylineEdge2, _super);
    function PolylineEdge2() {
      var _this = _super.call(this) || this;
      _this.onDragStart = function() {
        var polylineModel = _this.props.model;
        polylineModel.dragAppendStart();
        _this.isShowAdjustPointTemp = polylineModel.isShowAdjustPoint;
        polylineModel.isShowAdjustPoint = false;
      };
      _this.onDragging = function(_a2) {
        var deltaX = _a2.deltaX, deltaY = _a2.deltaY;
        var _b = _this.props, model = _b.model, graphModel = _b.graphModel;
        _this.isDragging = true;
        var transformModel = graphModel.transformModel, editConfigModel = graphModel.editConfigModel;
        var _c = __read34(transformModel.fixDeltaXY(deltaX, deltaY), 2), curDeltaX = _c[0], curDeltaY = _c[1];
        var polylineModel = model;
        var adjustEdgeMiddle = editConfigModel.adjustEdgeMiddle;
        if (adjustEdgeMiddle) {
          _this.appendInfo = polylineModel.dragAppendSimple(_this.appendInfo, {
            x: curDeltaX,
            y: curDeltaY
          });
        } else {
          _this.appendInfo = polylineModel.dragAppend(_this.appendInfo, {
            x: curDeltaX,
            y: curDeltaY
          });
        }
      };
      _this.onDragEnd = function() {
        var _a2;
        var _b = _this.props, model = _b.model, eventCenter = _b.graphModel.eventCenter;
        var polylineModel = model;
        polylineModel.dragAppendEnd();
        _this.isDragging = false;
        polylineModel.isShowAdjustPoint = (_a2 = _this.isShowAdjustPointTemp) !== null && _a2 !== void 0 ? _a2 : false;
        _this.appendInfo = void 0;
        eventCenter.emit(EventType.EDGE_ADJUST, { data: polylineModel.getData() });
      };
      _this.beforeDragStart = function(e3, appendInfo) {
        if (appendInfo.draggable) {
          _this.drag.handleMouseDown(e3);
        }
        _this.appendInfo = appendInfo;
      };
      _this.drag = new StepDrag({
        onDragStart: _this.onDragStart,
        onDragging: _this.onDragging,
        onDragEnd: _this.onDragEnd,
        isStopPropagation: false
      });
      return _this;
    }
    PolylineEdge2.prototype.getEdge = function() {
      var model = this.props.model;
      var points = model.points, isAnimation = model.isAnimation, arrowConfig = model.arrowConfig;
      var style = model.getEdgeStyle();
      var animationStyle = model.getEdgeAnimationStyle();
      var strokeDasharray = animationStyle.strokeDasharray, stroke = animationStyle.stroke, strokeDashoffset = animationStyle.strokeDashoffset, animationName = animationStyle.animationName, animationDuration = animationStyle.animationDuration, animationIterationCount = animationStyle.animationIterationCount, animationTimingFunction = animationStyle.animationTimingFunction, animationDirection = animationStyle.animationDirection;
      return u3(Polyline, __assign47({ points }, style, arrowConfig, isAnimation ? {
        strokeDasharray,
        stroke,
        style: {
          strokeDashoffset,
          animationName,
          animationDuration,
          animationIterationCount,
          animationTimingFunction,
          animationDirection
        }
      } : {}));
    };
    PolylineEdge2.prototype.getArrowInfo = function() {
      var model = this.props.model;
      var points = model.points, isSelected = model.isSelected;
      var hover = this.state.hover;
      var currentPositionList = points2PointsList(points);
      var startPoint = currentPositionList[0];
      var endPoint = currentPositionList[0];
      if (currentPositionList.length >= 2) {
        startPoint = currentPositionList[currentPositionList.length - 2];
        endPoint = currentPositionList[currentPositionList.length - 1];
      }
      return {
        start: startPoint,
        end: endPoint,
        hover,
        isSelected
      };
    };
    PolylineEdge2.prototype.getLastTwoPoints = function() {
      var model = this.props.model;
      var points = model.points;
      var currentPositionList = points2PointsList(points);
      var startPoint = currentPositionList[0];
      var endPoint = currentPositionList[0];
      if (currentPositionList.length >= 2) {
        startPoint = currentPositionList[currentPositionList.length - 2];
        endPoint = currentPositionList[currentPositionList.length - 1];
      }
      return [startPoint, endPoint];
    };
    PolylineEdge2.prototype.getAppendAttributes = function(appendInfo) {
      var start = appendInfo.start, end = appendInfo.end;
      var d2;
      if (start.x === end.x && start.y === end.y) {
        d2 = "";
      } else {
        var config = {
          start,
          end,
          offset: 10,
          verticalLength: 5
        };
        var startPosition = getVerticalPointOfLine(__assign47(__assign47({}, config), { type: "start" }));
        var endPosition = getVerticalPointOfLine(__assign47(__assign47({}, config), { type: "end" }));
        d2 = "M".concat(startPosition.leftX, " ").concat(startPosition.leftY, "\n      L").concat(startPosition.rightX, " ").concat(startPosition.rightY, "\n      L").concat(endPosition.rightX, " ").concat(endPosition.rightY, "\n      L").concat(endPosition.leftX, " ").concat(endPosition.leftY, " z");
      }
      return {
        d: d2,
        fill: "transparent",
        stroke: "transparent",
        strokeWidth: 1,
        strokeDasharray: "4, 4"
      };
    };
    PolylineEdge2.prototype.getAppendShape = function(appendInfo) {
      var _a2 = this.getAppendAttributes(appendInfo), d2 = _a2.d, strokeWidth = _a2.strokeWidth, fill = _a2.fill, strokeDasharray = _a2.strokeDasharray, stroke = _a2.stroke;
      return u3(Path, { d: d2, fill, strokeWidth, stroke, strokeDasharray });
    };
    PolylineEdge2.prototype.getAppendWidth = function() {
      var _this = this;
      var _a2 = this.props, model = _a2.model, graphModel = _a2.graphModel;
      var pointsList = model.pointsList, draggable = model.draggable;
      var LineAppendList = [];
      var pointsLen = pointsList.length;
      var _loop_1 = function(i5) {
        var className = "lf-polyline-append";
        var appendInfo = {
          start: {
            x: pointsList[i5].x,
            y: pointsList[i5].y
          },
          end: {
            x: pointsList[i5 + 1].x,
            y: pointsList[i5 + 1].y
          },
          startIndex: i5,
          endIndex: i5 + 1,
          direction: SegmentDirection.HORIZONTAL,
          draggable: true
        };
        var append = u3("g", { className, children: this_1.getAppendShape(appendInfo) });
        var editConfigModel = graphModel.editConfigModel;
        var adjustEdge = editConfigModel.adjustEdge, adjustEdgeMiddle = editConfigModel.adjustEdgeMiddle;
        if (adjustEdge && draggable) {
          var startIndex = appendInfo.startIndex, endIndex = appendInfo.endIndex;
          var dragDisable = adjustEdgeMiddle && (startIndex === 0 || endIndex === pointsLen - 1);
          appendInfo.draggable = !dragDisable;
          if (appendInfo.start.x === appendInfo.end.x) {
            if (appendInfo.draggable) {
              className += "-ew-resize";
            }
            appendInfo.direction = SegmentDirection.VERTICAL;
          } else if (appendInfo.start.y === appendInfo.end.y) {
            if (appendInfo.draggable) {
              className += "-ns-resize";
            }
            appendInfo.direction = SegmentDirection.HORIZONTAL;
          }
          append = u3("g", { className: this_1.isDragging ? "lf-dragging" : "lf-drag-able", onMouseDown: function(e3) {
            return _this.beforeDragStart(e3, appendInfo);
          }, children: u3("g", { className, children: this_1.getAppendShape(appendInfo) }) });
        }
        LineAppendList.push(append);
      };
      var this_1 = this;
      for (var i4 = 0; i4 < pointsLen - 1; i4++) {
        _loop_1(i4);
      }
      return u3("g", { children: LineAppendList });
    };
    return PolylineEdge2;
  }(BaseEdge_default)
);

// node_modules/@logicflow/core/es/view/behavior/dnd.js
var __assign48 = function() {
  __assign48 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign48.apply(this, arguments);
};
var Dnd = (
  /** @class */
  function() {
    function Dnd2(params) {
      var _this = this;
      this.nodeConfig = null;
      this.fakeNode = null;
      this.stopDrag = function() {
        _this.nodeConfig = null;
        window.document.removeEventListener("mouseup", _this.stopDrag);
      };
      this.dragEnter = function(e3) {
        if (!_this.nodeConfig || _this.fakeNode)
          return;
        _this.fakeNode = _this.lf.createFakeNode(__assign48(__assign48({}, _this.nodeConfig), _this.clientToLocalPoint({
          x: e3.clientX,
          y: e3.clientY
        })));
      };
      this.onDragOver = function(e3) {
        e3.preventDefault();
        if (_this.fakeNode) {
          var _a2 = _this.clientToLocalPoint({
            x: e3.clientX,
            y: e3.clientY
          }), x3 = _a2.x, y3 = _a2.y;
          _this.fakeNode.moveTo(x3, y3);
          var nodeData = _this.fakeNode.getData();
          _this.lf.setNodeSnapLine(nodeData);
          _this.lf.graphModel.eventCenter.emit(EventType.NODE_DND_DRAG, {
            data: nodeData,
            e: e3
          });
        }
        return false;
      };
      this.onDragLeave = function() {
        if (_this.fakeNode) {
          _this.lf.removeNodeSnapLine();
          _this.lf.graphModel.removeFakeNode();
          _this.fakeNode = null;
        }
      };
      this.onDrop = function(e3) {
        if (!_this.lf.graphModel || !e3 || !_this.nodeConfig) {
          return;
        }
        _this.lf.addNode(__assign48(__assign48({}, _this.nodeConfig), _this.clientToLocalPoint({
          x: e3.clientX,
          y: e3.clientY
        })), EventType.NODE_DND_ADD, e3);
        e3.preventDefault();
        e3.stopPropagation();
        _this.nodeConfig = null;
        _this.lf.removeNodeSnapLine();
        _this.lf.graphModel.removeFakeNode();
        _this.fakeNode = null;
      };
      var lf = params.lf;
      this.lf = lf;
    }
    Dnd2.prototype.clientToLocalPoint = function(_a2) {
      var x3 = _a2.x, y3 = _a2.y;
      var gridSize = get_default(this.lf.options, ["grid", "size"]);
      var position = this.lf.graphModel.getPointByClient({
        x: x3,
        y: y3
      });
      var _b = position.canvasOverlayPosition, x1 = _b.x, y1 = _b.y;
      var snapGrid = this.lf.graphModel.editConfigModel.snapGrid;
      return {
        x: snapToGrid(x1, gridSize, snapGrid),
        y: snapToGrid(y1, gridSize, snapGrid)
      };
    };
    Dnd2.prototype.startDrag = function(nodeConfig) {
      var editConfigModel = this.lf.graphModel.editConfigModel;
      if (!(editConfigModel === null || editConfigModel === void 0 ? void 0 : editConfigModel.isSilentMode)) {
        this.nodeConfig = nodeConfig;
        window.document.addEventListener("mouseup", this.stopDrag);
      }
    };
    Dnd2.prototype.eventMap = function() {
      return {
        onMouseEnter: this.dragEnter,
        onMouseOver: this.dragEnter,
        // IE11
        onMouseMove: this.onDragOver,
        onMouseLeave: this.onDragLeave,
        // onMouseOut: this.onDragLeave, // IE11
        onMouseUp: this.onDrop
      };
    };
    return Dnd2;
  }()
);

// node_modules/@logicflow/core/es/view/behavior/snapline.js
function snapline(eventCenter, snaplineModel) {
  eventCenter.on("node:mousemove", function(_a2) {
    var data = _a2.data;
    snaplineModel.setNodeSnapLine(data);
  });
  eventCenter.on("node:mouseup", function() {
    snaplineModel.clearSnapline();
  });
}

// node_modules/@logicflow/core/es/tool/TextEditTool.js
var __extends42 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign49 = function() {
  __assign49 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign49.apply(this, arguments);
};
var __decorate24 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var __read35 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var TextEditTool = (
  /** @class */
  function(_super) {
    __extends42(TextEditTool2, _super);
    function TextEditTool2(props) {
      var _this = _super.call(this, props) || this;
      _this.ref = b();
      _this.__prevText = {
        type: "",
        text: "",
        id: ""
      };
      _this.keyupHandler = function(ev) {
        var textEditElement = _this.props.graphModel.textEditElement;
        if (ev.key === "Enter" && ev.altKey) {
          textEditElement === null || textEditElement === void 0 ? void 0 : textEditElement.setElementState(ElementState.DEFAULT);
        }
      };
      _this.inputHandler = function(ev) {
        var value = ev.target.innerText;
        var textEditElement = _this.props.graphModel.textEditElement;
        if (textEditElement) {
          _this.__prevText = {
            type: textEditElement.type,
            text: value.replace(/(\r\n)+$|(\n)+$/, ""),
            // fix #488: 
            id: textEditElement.id
          };
        }
      };
      _this.keydownHandler = function(ev) {
        ev.stopPropagation();
      };
      _this.state = {
        style: {
          left: 0,
          top: 0
        }
      };
      return _this;
    }
    TextEditTool2.getDerivedStateFromProps = function(props) {
      var _a2;
      var textEditElement = props.textEditElement, graphModel = props.graphModel;
      var transformModel = graphModel.transformModel, theme = graphModel.theme;
      var inputText = theme.inputText;
      var autoStyle;
      if (textEditElement) {
        if (!((_a2 = textEditElement.text) === null || _a2 === void 0 ? void 0 : _a2.value)) {
          if (textEditElement.BaseType === ElementType.EDGE) {
            var textConfig = textEditElement.text;
            var _b = textEditElement.textPosition, x_1 = _b.x, y_1 = _b.y;
            textConfig.x = x_1;
            textConfig.y = y_1;
            textEditElement.setText(textConfig);
          }
        }
        var commonAutoStyle = {
          resize: "auto",
          whiteSpace: "normal",
          wordBreak: "break-all"
        };
        if (textEditElement.BaseType === ElementType.EDGE) {
          var _c = theme.edgeText, overflowMode = _c.overflowMode, lineHeight = _c.lineHeight, wrapPadding = _c.wrapPadding, textWidth = _c.textWidth;
          if (textWidth && overflowMode === "autoWrap") {
            autoStyle = __assign49(__assign49({}, commonAutoStyle), { width: textWidth, minWidth: textWidth, lineHeight, padding: wrapPadding });
          }
        } else if (textEditElement.BaseType === ElementType.NODE) {
          var _d = theme.nodeText, overflowMode = _d.overflowMode, lineHeight = _d.lineHeight, wrapPadding = _d.wrapPadding, textWidth = _d.textWidth;
          var width = textEditElement.width, modelType = textEditElement.modelType, nodeTextWidth = textEditElement.textWidth;
          var finalTextWidth = nodeTextWidth || textWidth || width;
          if (modelType !== ModelType.TEXT_NODE && overflowMode === "autoWrap" || modelType === ModelType.TEXT_NODE && textWidth) {
            autoStyle = __assign49(__assign49({}, commonAutoStyle), { width: finalTextWidth, minWidth: finalTextWidth, lineHeight, padding: wrapPadding });
          }
        }
        var _e = textEditElement.text, x3 = _e.x, y3 = _e.y;
        var _f = __read35(transformModel.CanvasPointToHtmlPoint([x3, y3]), 2), left = _f[0], top_1 = _f[1];
        return {
          style: __assign49(__assign49({ left, top: top_1 }, autoStyle), inputText)
        };
      }
      return null;
    };
    TextEditTool2.prototype.componentDidUpdate = function() {
      var graphModel = this.props.graphModel;
      if (this.ref.current) {
        this.ref.current.focus();
        this.placeCaretAtEnd(this.ref.current);
      }
      if (this.__prevText.id !== "") {
        var _a2 = this.__prevText, text = _a2.text, id = _a2.id;
        graphModel.updateText(id, text);
        graphModel.eventCenter.emit(EventType.TEXT_UPDATE, {
          data: __assign49({}, this.__prevText)
        });
        this.__prevText.id = "";
        this.__prevText.text = "";
        this.__prevText.type = "";
      }
    };
    TextEditTool2.prototype.placeCaretAtEnd = function(el) {
      if (window.getSelection !== void 0 && document.createRange !== void 0) {
        var range = document.createRange();
        range.selectNodeContents(el);
        range.collapse(false);
        var sel = window.getSelection();
        sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
        sel === null || sel === void 0 ? void 0 : sel.addRange(range);
      }
    };
    TextEditTool2.prototype.render = function() {
      var _a2;
      var textEditElement = this.props.graphModel.textEditElement;
      var style = this.state.style;
      return textEditElement ? u3("div", { contentEditable: true, className: "lf-text-input", style, ref: this.ref, onKeyUp: this.keyupHandler, onKeyDown: this.keydownHandler, onKeyPress: this.keydownHandler, onInput: this.inputHandler, children: (_a2 = textEditElement.text) === null || _a2 === void 0 ? void 0 : _a2.value }, textEditElement.id) : null;
    };
    TextEditTool2.toolName = "text-edit-tool";
    TextEditTool2 = __decorate24([
      observer2
    ], TextEditTool2);
    return TextEditTool2;
  }(x)
);
var TextEditTool_default = TextEditTool;

// node_modules/@logicflow/core/es/tool/MultipleSelectTool.js
var __extends43 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __decorate25 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var __read36 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray10 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l3 = from.length, ar; i4 < l3; i4++) {
    if (ar || !(i4 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i4);
      ar[i4] = from[i4];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var MultipleSelect = (
  /** @class */
  function(_super) {
    __extends43(MultipleSelect2, _super);
    function MultipleSelect2(props) {
      var _this = _super.call(this, props) || this;
      _this.handleMouseDown = function(ev) {
        _this.stepDrag.handleMouseDown(ev);
      };
      _this.handleWheelEvent = function(ev) {
        var _a3, _b;
        ev.preventDefault();
        var deltaX = ev.deltaX, deltaY = ev.deltaY, clientX = ev.clientX, clientY = ev.clientY, ctrlKey = ev.ctrlKey;
        var newEvent = new WheelEvent("wheel", {
          deltaX,
          deltaY,
          clientX,
          clientY,
          ctrlKey
        });
        (_b = (_a3 = _this.props.lf.container) === null || _a3 === void 0 ? void 0 : _a3.querySelector('.lf-canvas-overlay[name="canvas-overlay"]')) === null || _b === void 0 ? void 0 : _b.dispatchEvent(newEvent);
      };
      _this.onDragging = function(_a3) {
        var deltaX = _a3.deltaX, deltaY = _a3.deltaY;
        var _b = _this.props, graphModel = _b.graphModel, lf = _b.lf;
        var _c = lf.getTransform(), SCALE_X = _c.SCALE_X, SCALE_Y = _c.SCALE_Y;
        var selectElements = graphModel.getSelectElements(true);
        graphModel.moveNodes(selectElements.nodes.map(function(node) {
          return node.id;
        }), deltaX / SCALE_X, deltaY / SCALE_Y);
      };
      _this.handleContextMenu = function(ev) {
        ev.preventDefault();
        var _a3 = _this.props, graphModel = _a3.graphModel, _b = _a3.graphModel, eventCenter2 = _b.eventCenter, selectElements = _b.selectElements;
        var position = graphModel.getPointByClient({
          x: ev.clientX,
          y: ev.clientY
        });
        var selectGraphData = {
          nodes: [],
          edges: []
        };
        var models = __spreadArray10([], __read36(selectElements.values()), false);
        models.forEach(function(model) {
          if (model.BaseType === ElementType.NODE) {
            selectGraphData.nodes.push(model.getData());
          }
          if (model.BaseType === ElementType.EDGE) {
            selectGraphData.edges.push(model.getData());
          }
        });
        eventCenter2.emit(EventType.SELECTION_CONTEXTMENU, {
          data: selectGraphData,
          e: ev,
          position
        });
      };
      var _a2 = props.graphModel, gridSize = _a2.gridSize, eventCenter = _a2.eventCenter;
      _this.stepDrag = new StepDrag({
        onDragging: _this.onDragging,
        step: gridSize,
        eventType: "SELECTION",
        eventCenter
      });
      return _this;
    }
    MultipleSelect2.prototype.render = function() {
      var _a2, _b;
      var _c = this.props.graphModel, selectElements = _c.selectElements, transformModel = _c.transformModel;
      var _d = this.props.lf.getTransform(), SCALE_X = _d.SCALE_X, SCALE_Y = _d.SCALE_Y;
      if (selectElements.size <= 1)
        return;
      var x3 = Number.MAX_SAFE_INTEGER;
      var y3 = Number.MAX_SAFE_INTEGER;
      var x1 = Number.MIN_SAFE_INTEGER;
      var y1 = Number.MIN_SAFE_INTEGER;
      selectElements.forEach(function(element) {
        var outline;
        if (element.BaseType === ElementType.NODE) {
          outline = getNodeOutline(element);
        }
        if (element.BaseType === ElementType.EDGE) {
          outline = getEdgeOutline(element);
        }
        if (outline !== void 0) {
          x3 = Math.min(x3, outline.x);
          y3 = Math.min(y3, outline.y);
          x1 = Math.max(x1, outline.x1);
          y1 = Math.max(y1, outline.y1);
        }
      });
      _a2 = __read36(transformModel.CanvasPointToHtmlPoint([x3, y3]), 2), x3 = _a2[0], y3 = _a2[1];
      _b = __read36(transformModel.CanvasPointToHtmlPoint([x1, y1]), 2), x1 = _b[0], y1 = _b[1];
      var style = {
        left: "".concat(x3 - 20 * SCALE_X / 2, "px"),
        top: "".concat(y3 - 20 * SCALE_Y / 2, "px"),
        width: "".concat(x1 - x3 + 20 * SCALE_X, "px"),
        height: "".concat(y1 - y3 + 20 * SCALE_Y, "px"),
        "border-width": "".concat(2 * SCALE_X, "px")
      };
      return u3("div", { className: "lf-multiple-select", style, onMouseDown: this.handleMouseDown, onContextMenu: this.handleContextMenu, onWheel: this.handleWheelEvent });
    };
    MultipleSelect2.toolName = "multiple-select-tool";
    MultipleSelect2 = __decorate25([
      observer2
    ], MultipleSelect2);
    return MultipleSelect2;
  }(x)
);
var MultipleSelectTool_default = MultipleSelect;

// node_modules/@logicflow/core/es/tool/index.js
var __decorate26 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var defaultTools = [TextEditTool_default, MultipleSelectTool_default];
var Tool = (
  /** @class */
  function() {
    function Tool2(instance) {
      var _this = this;
      this.toolMap = /* @__PURE__ */ new Map();
      this.disabledToolMap = /* @__PURE__ */ new Map();
      this.instance = instance;
      forEach_default(defaultTools, function(tool) {
        if (!_this.isDisabled(tool.toolName)) {
          _this.registerTool(tool.toolName, tool);
        }
      });
      var graphModel = instance.graphModel;
      var eventCenter = graphModel.eventCenter;
      eventCenter.on("".concat(EventType.GRAPH_TRANSFORM, ",").concat(EventType.NODE_CLICK, ",").concat(EventType.BLANK_CLICK, " "), function() {
        var _a2;
        var textEditElement = graphModel.textEditElement, _b = graphModel.editConfigModel, edgeTextEdit = _b.edgeTextEdit, nodeTextEdit = _b.nodeTextEdit;
        if ((edgeTextEdit || nodeTextEdit) && textEditElement) {
          (_a2 = graphModel.textEditElement) === null || _a2 === void 0 ? void 0 : _a2.setElementState(ElementState.DEFAULT);
        }
      });
    }
    Tool2.prototype.isDisabled = function(toolName) {
      var _a2;
      return ((_a2 = this.instance.options.disabledTools) === null || _a2 === void 0 ? void 0 : _a2.indexOf(toolName)) !== -1;
    };
    Tool2.prototype.registerTool = function(name, component) {
      this.toolMap.set(name, component);
    };
    Tool2.prototype.disableTool = function(name) {
      var tool = this.toolMap.get(name);
      if (tool) {
        this.disabledToolMap.set(name, tool);
        this.toolMap.delete(name);
        return true;
      }
      throw new Error(" ${tool} ");
    };
    Tool2.prototype.enableTool = function(name) {
      var tool = this.disabledToolMap.get(name);
      if (tool) {
        this.toolMap.set(name, tool);
        this.disabledToolMap.delete(name);
        return true;
      }
      throw new Error(" ${tool} ");
    };
    Tool2.prototype.getTools = function() {
      return Array.from(this.toolMap.values());
    };
    Tool2.prototype.getInstance = function() {
      return this.instance;
    };
    Tool2.prototype.destroy = function() {
      this.toolMap.clear();
      this.disabledToolMap.clear();
    };
    __decorate26([
      observable
    ], Tool2.prototype, "toolMap", void 0);
    __decorate26([
      action
    ], Tool2.prototype, "disableTool", null);
    __decorate26([
      action
    ], Tool2.prototype, "enableTool", null);
    return Tool2;
  }()
);
var tool_default = Tool;

// node_modules/mobx-utils/mobx-utils.module.js
function fail$1(message) {
  throw new Error("[mobx-utils] " + message);
}
function invariant2(cond, message) {
  if (message === void 0) {
    message = "Illegal state";
  }
  if (!cond)
    fail$1(message);
}
var deepFields = function(x3) {
  return x3 && x3 !== Object.prototype && Object.getOwnPropertyNames(x3).concat(deepFields(Object.getPrototypeOf(x3)) || []);
};
var distinctDeepFields = function(x3) {
  var deepFieldsIndistinct = deepFields(x3);
  var deepFieldsDistinct = deepFieldsIndistinct.filter(function(item, index) {
    return deepFieldsIndistinct.indexOf(item) === index;
  });
  return deepFieldsDistinct;
};
var getAllMethodsAndProperties = function(x3) {
  return distinctDeepFields(x3).filter(function(name) {
    return name !== "constructor" && !~name.indexOf("__");
  });
};
var PENDING = "pending";
var FULFILLED = "fulfilled";
var REJECTED = "rejected";
function caseImpl(handlers) {
  switch (this.state) {
    case PENDING:
      return handlers.pending && handlers.pending(this.value);
    case REJECTED:
      return handlers.rejected && handlers.rejected(this.value);
    case FULFILLED:
      return handlers.fulfilled ? handlers.fulfilled(this.value) : this.value;
  }
}
function fromPromise(origPromise, oldPromise) {
  invariant2(arguments.length <= 2, "fromPromise expects up to two arguments");
  invariant2(typeof origPromise === "function" || typeof origPromise === "object" && origPromise && typeof origPromise.then === "function", "Please pass a promise or function to fromPromise");
  if (origPromise.isPromiseBasedObservable === true)
    return origPromise;
  if (typeof origPromise === "function") {
    origPromise = new Promise(origPromise);
  }
  var promise = origPromise;
  origPromise.then(action("observableFromPromise-resolve", function(value) {
    promise.value = value;
    promise.state = FULFILLED;
  }), action("observableFromPromise-reject", function(reason) {
    promise.value = reason;
    promise.state = REJECTED;
  }));
  promise.isPromiseBasedObservable = true;
  promise.case = caseImpl;
  var oldData = oldPromise && oldPromise.state === FULFILLED ? oldPromise.value : void 0;
  extendObservable(promise, {
    value: oldData,
    state: PENDING
  }, {}, { deep: false });
  return promise;
}
(function(fromPromise2) {
  fromPromise2.reject = action("fromPromise.reject", function(reason) {
    var p3 = fromPromise2(Promise.reject(reason));
    p3.state = REJECTED;
    p3.value = reason;
    return p3;
  });
  function resolveBase(value) {
    if (value === void 0) {
      value = void 0;
    }
    var p3 = fromPromise2(Promise.resolve(value));
    p3.state = FULFILLED;
    p3.value = value;
    return p3;
  }
  fromPromise2.resolve = action("fromPromise.resolve", resolveBase);
})(fromPromise || (fromPromise = {}));
var __decorate27 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var StreamListener = (
  /** @class */
  function() {
    function StreamListener2(observable2, initialValue) {
      var _this = this;
      runInAction(function() {
        _this.current = initialValue;
        _this.subscription = observable2.subscribe(_this);
      });
    }
    StreamListener2.prototype.dispose = function() {
      if (this.subscription) {
        this.subscription.unsubscribe();
      }
    };
    StreamListener2.prototype.next = function(value) {
      this.current = value;
    };
    StreamListener2.prototype.complete = function() {
      this.dispose();
    };
    StreamListener2.prototype.error = function(value) {
      this.current = value;
      this.dispose();
    };
    __decorate27([
      observable.ref
    ], StreamListener2.prototype, "current", void 0);
    __decorate27([
      action.bound
    ], StreamListener2.prototype, "next", null);
    __decorate27([
      action.bound
    ], StreamListener2.prototype, "complete", null);
    __decorate27([
      action.bound
    ], StreamListener2.prototype, "error", null);
    return StreamListener2;
  }()
);
var __assign50 = function() {
  __assign50 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign50.apply(this, arguments);
};
var __decorate$1 = function(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d2 = decorators[i4]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var RESERVED_NAMES = ["model", "reset", "submit", "isDirty", "isPropertyDirty", "resetProperty"];
var ViewModel = (
  /** @class */
  function() {
    function ViewModel2(model) {
      var _this = this;
      this.model = model;
      this.localValues = observable.map({});
      this.localComputedValues = observable.map({});
      this.isPropertyDirty = function(key) {
        return _this.localValues.has(key);
      };
      invariant2(isObservableObject(model), "createViewModel expects an observable object");
      getAllMethodsAndProperties(model).forEach(function(key) {
        if (key === $mobx || key === "__mobxDidRunLazyInitializers") {
          return;
        }
        invariant2(RESERVED_NAMES.indexOf(key) === -1, "The propertyname " + key + " is reserved and cannot be used with viewModels");
        if (isComputedProp(model, key)) {
          var derivation = getAdministration(model, key).derivation;
          _this.localComputedValues.set(key, computed(derivation.bind(_this)));
        }
        var descriptor = Object.getOwnPropertyDescriptor(model, key);
        var additionalDescriptor = descriptor ? { enumerable: descriptor.enumerable } : {};
        Object.defineProperty(_this, key, __assign50(__assign50({}, additionalDescriptor), { configurable: true, get: function() {
          if (isComputedProp(model, key))
            return _this.localComputedValues.get(key).get();
          if (_this.isPropertyDirty(key))
            return _this.localValues.get(key);
          else
            return _this.model[key];
        }, set: action(function(value) {
          if (value !== _this.model[key]) {
            _this.localValues.set(key, value);
          } else {
            _this.localValues.delete(key);
          }
        }) }));
      });
    }
    Object.defineProperty(ViewModel2.prototype, "isDirty", {
      get: function() {
        return this.localValues.size > 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewModel2.prototype, "changedValues", {
      get: function() {
        return this.localValues.toJS();
      },
      enumerable: false,
      configurable: true
    });
    ViewModel2.prototype.submit = function() {
      var _this = this;
      keys(this.localValues).forEach(function(key) {
        var source = _this.localValues.get(key);
        var destination = _this.model[key];
        if (isObservableArray(destination)) {
          destination.replace(source);
        } else if (isObservableMap(destination)) {
          destination.clear();
          destination.merge(source);
        } else if (!isComputed(source)) {
          _this.model[key] = source;
        }
      });
      this.localValues.clear();
    };
    ViewModel2.prototype.reset = function() {
      this.localValues.clear();
    };
    ViewModel2.prototype.resetProperty = function(key) {
      this.localValues.delete(key);
    };
    __decorate$1([
      computed
    ], ViewModel2.prototype, "isDirty", null);
    __decorate$1([
      computed
    ], ViewModel2.prototype, "changedValues", null);
    __decorate$1([
      action.bound
    ], ViewModel2.prototype, "submit", null);
    __decorate$1([
      action.bound
    ], ViewModel2.prototype, "reset", null);
    __decorate$1([
      action.bound
    ], ViewModel2.prototype, "resetProperty", null);
    return ViewModel2;
  }()
);
function buildPath(entry) {
  if (!entry)
    return "ROOT";
  var res = [];
  while (entry.parent) {
    res.push(entry.path);
    entry = entry.parent;
  }
  return res.reverse().join("/");
}
function isRecursivelyObservable(thing) {
  return isObservableObject(thing) || isObservableArray(thing) || isObservableMap(thing);
}
function deepObserve(target, listener) {
  var entrySet = /* @__PURE__ */ new WeakMap();
  function genericListener(change) {
    var entry = entrySet.get(change.object);
    processChange(change, entry);
    listener(change, buildPath(entry), target);
  }
  function processChange(change, parent) {
    switch (change.type) {
      case "add":
        observeRecursively(change.newValue, parent, change.name);
        break;
      case "update":
        unobserveRecursively(change.oldValue);
        observeRecursively(change.newValue, parent, change.name || "" + change.index);
        break;
      case "remove":
      case "delete":
        unobserveRecursively(change.oldValue);
        break;
      case "splice":
        change.removed.map(unobserveRecursively);
        change.added.forEach(function(value, idx) {
          return observeRecursively(value, parent, "" + (change.index + idx));
        });
        for (var i4 = change.index + change.addedCount; i4 < change.object.length; i4++) {
          if (isRecursivelyObservable(change.object[i4])) {
            var entry = entrySet.get(change.object[i4]);
            if (entry)
              entry.path = "" + i4;
          }
        }
        break;
    }
  }
  function observeRecursively(thing, parent, path) {
    if (isRecursivelyObservable(thing)) {
      var entry = entrySet.get(thing);
      if (entry) {
        if (entry.parent !== parent || entry.path !== path)
          throw new Error("The same observable object cannot appear twice in the same tree," + (" trying to assign it to '" + buildPath(parent) + "/" + path + "',") + (" but it already exists at '" + buildPath(entry.parent) + "/" + entry.path + "'"));
      } else {
        var entry_1 = {
          parent,
          path,
          dispose: observe(thing, genericListener)
        };
        entrySet.set(thing, entry_1);
        entries(thing).forEach(function(_a2) {
          var key = _a2[0], value = _a2[1];
          return observeRecursively(value, entry_1, key);
        });
      }
    }
  }
  function unobserveRecursively(thing) {
    if (isRecursivelyObservable(thing)) {
      var entry = entrySet.get(thing);
      if (!entry)
        return;
      entrySet.delete(thing);
      entry.dispose();
      values(thing).forEach(unobserveRecursively);
    }
  }
  observeRecursively(target, void 0, "");
  return function() {
    unobserveRecursively(target);
  };
}
var __extends44 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3) if (b3.hasOwnProperty(p3)) d3[p3] = b3[p3];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var ObservableGroupMap = (
  /** @class */
  function(_super) {
    __extends44(ObservableGroupMap2, _super);
    function ObservableGroupMap2(base, groupBy, _a2) {
      var _b = _a2 === void 0 ? {} : _a2, _c = _b.name, name = _c === void 0 ? "ogm" + (Math.random() * 1e3 | 0) : _c, _d = _b.keyToName, keyToName = _d === void 0 ? function(x3) {
        return "" + x3;
      } : _d;
      var _this = _super.call(this) || this;
      _this._keyToName = keyToName;
      _this._groupBy = groupBy;
      _this._ogmInfoKey = Symbol("ogmInfo" + name);
      _this._base = base;
      for (var i4 = 0; i4 < base.length; i4++) {
        _this._addItem(base[i4]);
      }
      _this._disposeBaseObserver = observe(_this._base, function(change) {
        if ("splice" === change.type) {
          transaction(function() {
            for (var _i = 0, _a3 = change.removed; _i < _a3.length; _i++) {
              var removed = _a3[_i];
              _this._removeItem(removed);
            }
            for (var _b2 = 0, _c2 = change.added; _b2 < _c2.length; _b2++) {
              var added = _c2[_b2];
              _this._addItem(added);
            }
          });
        } else if ("update" === change.type) {
          transaction(function() {
            _this._removeItem(change.oldValue);
            _this._addItem(change.newValue);
          });
        } else {
          throw new Error("illegal state");
        }
      });
      return _this;
    }
    ObservableGroupMap2.prototype.clear = function() {
      throw new Error("not supported");
    };
    ObservableGroupMap2.prototype.delete = function(_key) {
      throw new Error("not supported");
    };
    ObservableGroupMap2.prototype.set = function(_key, _value) {
      throw new Error("not supported");
    };
    ObservableGroupMap2.prototype.dispose = function() {
      this._disposeBaseObserver();
      for (var i4 = 0; i4 < this._base.length; i4++) {
        var item = this._base[i4];
        var grouperItemInfo = item[this._ogmInfoKey];
        grouperItemInfo.reaction();
        delete item[this._ogmInfoKey];
      }
    };
    ObservableGroupMap2.prototype._getGroupArr = function(key) {
      var result = _super.prototype.get.call(this, key);
      if (void 0 === result) {
        result = observable([], { name: "GroupArray[" + this._keyToName(key) + "]", deep: false });
        _super.prototype.set.call(this, key, result);
      }
      return result;
    };
    ObservableGroupMap2.prototype._removeFromGroupArr = function(key, itemIndex) {
      var arr = _super.prototype.get.call(this, key);
      if (1 === arr.length) {
        _super.prototype.delete.call(this, key);
      } else if (itemIndex === arr.length - 1) {
        arr.length--;
      } else {
        arr[itemIndex] = arr[arr.length - 1];
        arr[itemIndex][this._ogmInfoKey].groupArrIndex = itemIndex;
        arr.length--;
      }
    };
    ObservableGroupMap2.prototype._addItem = function(item) {
      var _this = this;
      var groupByValue = this._groupBy(item);
      var groupArr = this._getGroupArr(groupByValue);
      var value = {
        groupByValue,
        groupArrIndex: groupArr.length,
        reaction: reaction(function() {
          return _this._groupBy(item);
        }, function(newGroupByValue, _r) {
          var grouperItemInfo = item[_this._ogmInfoKey];
          _this._removeFromGroupArr(grouperItemInfo.groupByValue, grouperItemInfo.groupArrIndex);
          var newGroupArr = _this._getGroupArr(newGroupByValue);
          var newGroupArrIndex = newGroupArr.length;
          newGroupArr.push(item);
          grouperItemInfo.groupByValue = newGroupByValue;
          grouperItemInfo.groupArrIndex = newGroupArrIndex;
        })
      };
      Object.defineProperty(item, this._ogmInfoKey, {
        configurable: true,
        enumerable: false,
        value
      });
      groupArr.push(item);
    };
    ObservableGroupMap2.prototype._removeItem = function(item) {
      var grouperItemInfo = item[this._ogmInfoKey];
      this._removeFromGroupArr(grouperItemInfo.groupByValue, grouperItemInfo.groupArrIndex);
      grouperItemInfo.reaction();
      delete item[this._ogmInfoKey];
    };
    return ObservableGroupMap2;
  }(ObservableMap)
);
var DeepMapEntry = (
  /** @class */
  function() {
    function DeepMapEntry2(base, args) {
      this.base = base;
      this.args = args;
      this.closestIdx = 0;
      this.isDisposed = false;
      var current = this.closest = this.root = base;
      var i4 = 0;
      for (; i4 < this.args.length - 1; i4++) {
        current = current.get(args[i4]);
        if (current)
          this.closest = current;
        else
          break;
      }
      this.closestIdx = i4;
    }
    DeepMapEntry2.prototype.exists = function() {
      this.assertNotDisposed();
      var l3 = this.args.length;
      return this.closestIdx >= l3 - 1 && this.closest.has(this.args[l3 - 1]);
    };
    DeepMapEntry2.prototype.get = function() {
      this.assertNotDisposed();
      if (!this.exists())
        throw new Error("Entry doesn't exist");
      return this.closest.get(this.args[this.args.length - 1]);
    };
    DeepMapEntry2.prototype.set = function(value) {
      this.assertNotDisposed();
      var l3 = this.args.length;
      var current = this.closest;
      for (var i4 = this.closestIdx; i4 < l3 - 1; i4++) {
        var m3 = /* @__PURE__ */ new Map();
        current.set(this.args[i4], m3);
        current = m3;
      }
      this.closestIdx = l3 - 1;
      this.closest = current;
      current.set(this.args[l3 - 1], value);
    };
    DeepMapEntry2.prototype.delete = function() {
      this.assertNotDisposed();
      if (!this.exists())
        throw new Error("Entry doesn't exist");
      var l3 = this.args.length;
      this.closest.delete(this.args[l3 - 1]);
      var c3 = this.root;
      var maps = [c3];
      for (var i4 = 0; i4 < l3 - 1; i4++) {
        c3 = c3.get(this.args[i4]);
        maps.push(c3);
      }
      for (var i4 = maps.length - 1; i4 > 0; i4--) {
        if (maps[i4].size === 0)
          maps[i4 - 1].delete(this.args[i4 - 1]);
      }
      this.isDisposed = true;
    };
    DeepMapEntry2.prototype.assertNotDisposed = function() {
      if (this.isDisposed)
        throw new Error("Concurrent modification exception");
    };
    return DeepMapEntry2;
  }()
);
var DeepMap = (
  /** @class */
  function() {
    function DeepMap2() {
      this.store = /* @__PURE__ */ new Map();
      this.argsLength = -1;
    }
    DeepMap2.prototype.entry = function(args) {
      if (this.argsLength === -1)
        this.argsLength = args.length;
      else if (this.argsLength !== args.length)
        throw new Error("DeepMap should be used with functions with a consistent length, expected: " + this.argsLength + ", got: " + args.length);
      if (this.last)
        this.last.isDisposed = true;
      return this.last = new DeepMapEntry(this.store, args);
    };
    return DeepMap2;
  }()
);
var inOrderExecution;
{
  taskOrderPromise_1 = Promise.resolve();
  if (typeof queueMicrotask !== "undefined") {
    queueMicrotaskPolyfill_1 = queueMicrotask;
  } else if (typeof process !== "undefined" && process.nextTick) {
    queueMicrotaskPolyfill_1 = function(cb) {
      process.nextTick(cb);
    };
  } else {
    queueMicrotaskPolyfill_1 = function(cb) {
      setTimeout(cb, 0);
    };
  }
  idle_1 = function() {
    return new Promise(function(r3) {
      queueMicrotaskPolyfill_1(r3);
    });
  };
  inOrderExecution = function() {
    taskOrderPromise_1 = taskOrderPromise_1.then(idle_1);
    return taskOrderPromise_1;
  };
}
var taskOrderPromise_1;
var queueMicrotaskPolyfill_1;
var idle_1;

// node_modules/@logicflow/core/es/history/index.js
var __assign51 = function() {
  __assign51 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign51.apply(this, arguments);
};
var History = (
  /** @class */
  function() {
    function History2(eventCenter) {
      this.undos = [];
      this.redos = [];
      this.callbacks = [];
      this.stopWatch = null;
      this.curData = null;
      this.maxSize = 50;
      this.waitTime = 100;
      this.eventCenter = eventCenter;
    }
    History2.prototype.add = function(data) {
      if (isEqual_default(last_default(this.undos), data))
        return;
      this.undos.push(data);
      if (!isEqual_default(this.curData, data)) {
        this.redos = [];
      }
      this.eventCenter.emit(EventType.HISTORY_CHANGE, {
        data: {
          undos: this.undos,
          redos: this.redos,
          undoAble: this.undoAble(),
          redoAble: this.redoAble()
        }
      });
      if (this.undos.length > this.maxSize) {
        this.undos.shift();
      }
    };
    History2.prototype.undoAble = function() {
      return this.undos.length > 1;
    };
    History2.prototype.undo = function() {
      if (!this.undoAble())
        return;
      var preData = this.undos.pop();
      this.redos.push(preData);
      var curData = this.undos.pop();
      this.curData = cloneDeep_default(curData);
      return curData;
    };
    History2.prototype.redoAble = function() {
      return this.redos.length > 0;
    };
    History2.prototype.redo = function() {
      if (!this.redoAble())
        return;
      var curData = this.redos.pop();
      this.curData = cloneDeep_default(curData);
      return curData;
    };
    History2.prototype.watch = function(model) {
      var _this = this;
      this.stopWatch && this.stopWatch();
      this.undos.push(model.modelToGraphData());
      this.stopWatch = deepObserve(
        // TODOThe same observable object cannot appear twice in the same tree 
        //  setAttributes  nodeModel  observable 
        // eg:
        // setAttributes() {
        //   this.width = 120
        //   this.height = 50
        //
        //   if (this.text) {
        //     this.properties.text = this.text;
        //     this.text.value = '';
        //   }
        // }
        //  cloneDeep  observable 
        // https://stackoverflow.com/questions/55328504/a-node-cannot-exists-twice-in-the-state-tree-mobx-state-tree
        // cloneDeep(model),
        model,
        debounce_default(function() {
          var data = model.modelToHistoryData();
          if (data) {
            _this.add(__assign51({}, data));
          }
        }, this.waitTime)
      );
    };
    History2.prototype.destroy = function() {
      this.undos = [];
      this.redos = [];
      this.curData = null;
      this.stopWatch && this.stopWatch();
    };
    return History2;
  }()
);
var history_default = History;

// node_modules/@logicflow/core/es/keyboard/index.js
var import_mousetrap = __toESM(require_mousetrap());

// node_modules/@logicflow/core/es/keyboard/shortcut.js
var __assign52 = function() {
  __assign52 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign52.apply(this, arguments);
};
var __rest5 = function(s3, e3) {
  var t3 = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t3[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p3 = Object.getOwnPropertySymbols(s3); i4 < p3.length; i4++) {
      if (e3.indexOf(p3[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i4]))
        t3[p3[i4]] = s3[p3[i4]];
    }
  return t3;
};
var selected = null;
function translateNodeData(nodeData, distance2) {
  nodeData.x += distance2;
  nodeData.y += distance2;
  if (!isEmpty_default(nodeData.text)) {
    nodeData.text.x += distance2;
    nodeData.text.y += distance2;
  }
  return nodeData;
}
function translateEdgeData(edgeData, distance2) {
  if (edgeData.startPoint) {
    edgeData.startPoint.x += distance2;
    edgeData.startPoint.y += distance2;
  }
  if (edgeData.endPoint) {
    edgeData.endPoint.x += distance2;
    edgeData.endPoint.y += distance2;
  }
  if (edgeData.pointsList && edgeData.pointsList.length > 0) {
    edgeData.pointsList.forEach(function(point) {
      point.x += distance2;
      point.y += distance2;
    });
  }
  if (!isEmpty_default(edgeData.text)) {
    edgeData.text.x += distance2;
    edgeData.text.y += distance2;
  }
  return edgeData;
}
function transformNodeData(nodeData, distance2) {
  var x3 = nodeData.x, y3 = nodeData.y, text = nodeData.text;
  var nextText = text ? {
    x: text.x + distance2,
    y: text.y + distance2,
    value: text.value
  } : void 0;
  return __assign52(__assign52({}, nodeData), { id: "", x: x3 + distance2, y: y3 + distance2, text: nextText });
}
function transformEdgeData(edgeData, distance2) {
  var startPoint = edgeData.startPoint, endPoint = edgeData.endPoint, pointsList = edgeData.pointsList, text = edgeData.text, edgeConfig = __rest5(
    edgeData,
    ["startPoint", "endPoint", "pointsList", "text"]
  );
  edgeConfig.id = "";
  var nextStartPoint = {
    x: startPoint.x + distance2,
    y: startPoint.y + distance2
  };
  var nextEndPoint = {
    x: endPoint.x + distance2,
    y: endPoint.y + distance2
  };
  var newPointsList = map_default(pointsList, function(point) {
    return {
      x: point.x + distance2,
      y: point.y + distance2
    };
  });
  var nextText = text ? __assign52(__assign52({}, text), { x: text.x + distance2, y: text.y + distance2 }) : void 0;
  return __assign52(__assign52({}, edgeConfig), { startPoint: nextStartPoint, endPoint: nextEndPoint, pointsList: newPointsList, text: nextText });
}
var TRANSLATION_DISTANCE = 40;
var CHILDREN_TRANSLATION_DISTANCE = 40;
function initDefaultShortcut(lf, graph) {
  var keyboard = lf.keyboard;
  var keyboardOptions = keyboard.options.keyboard;
  keyboard.on(["cmd + c", "ctrl + c"], function() {
    CHILDREN_TRANSLATION_DISTANCE = TRANSLATION_DISTANCE;
    if (!(keyboardOptions === null || keyboardOptions === void 0 ? void 0 : keyboardOptions.enabled))
      return true;
    if (graph.textEditElement)
      return true;
    var guards = lf.options.guards;
    var elements = graph.getSelectElements(false);
    var enabledClone = guards && guards.beforeClone ? guards.beforeClone(elements) : true;
    if (!enabledClone || elements.nodes.length === 0 && elements.edges.length === 0) {
      selected = null;
      return true;
    }
    selected = elements;
    selected.nodes.forEach(function(node) {
      return translateNodeData(node, TRANSLATION_DISTANCE);
    });
    selected.edges.forEach(function(edge) {
      return translateEdgeData(edge, TRANSLATION_DISTANCE);
    });
    return false;
  });
  keyboard.on(["cmd + v", "ctrl + v"], function() {
    if (!(keyboardOptions === null || keyboardOptions === void 0 ? void 0 : keyboardOptions.enabled))
      return true;
    if (graph.textEditElement)
      return true;
    if (selected && (selected.nodes || selected.edges)) {
      lf.clearSelectElements();
      var addElements = lf.addElements(selected, CHILDREN_TRANSLATION_DISTANCE);
      if (!addElements)
        return true;
      addElements.nodes.forEach(function(node) {
        return lf.selectElementById(node.id, true);
      });
      addElements.edges.forEach(function(edge) {
        return lf.selectElementById(edge.id, true);
      });
      selected.nodes.forEach(function(node) {
        return translateNodeData(node, TRANSLATION_DISTANCE);
      });
      selected.edges.forEach(function(edge) {
        return translateEdgeData(edge, TRANSLATION_DISTANCE);
      });
      CHILDREN_TRANSLATION_DISTANCE = CHILDREN_TRANSLATION_DISTANCE + TRANSLATION_DISTANCE;
    }
    return false;
  });
  keyboard.on(["cmd + z", "ctrl + z"], function() {
    if (!(keyboardOptions === null || keyboardOptions === void 0 ? void 0 : keyboardOptions.enabled))
      return true;
    if (graph.textEditElement)
      return true;
    lf.undo();
    return false;
  });
  keyboard.on(["cmd + y", "ctrl + y"], function() {
    if (!(keyboardOptions === null || keyboardOptions === void 0 ? void 0 : keyboardOptions.enabled))
      return true;
    if (graph.textEditElement)
      return true;
    lf.redo();
    return false;
  });
  keyboard.on(["backspace"], function() {
    if (!(keyboardOptions === null || keyboardOptions === void 0 ? void 0 : keyboardOptions.enabled))
      return true;
    if (graph.textEditElement)
      return true;
    var elements = graph.getSelectElements(true);
    lf.clearSelectElements();
    elements.edges.forEach(function(edge) {
      return edge.id && lf.deleteEdge(edge.id);
    });
    elements.nodes.forEach(function(node) {
      return node.id && lf.deleteNode(node.id);
    });
    return false;
  });
}

// node_modules/@logicflow/core/es/keyboard/index.js
var Keyboard = (
  /** @class */
  function() {
    function Keyboard2(options) {
      if (!options.keyboard) {
        options.keyboard = { enabled: false };
      }
      this.options = options;
      var lf = options.lf;
      this.target = lf.container;
      this.mousetrap = new import_mousetrap.default(this.target);
      if (options.keyboard.enabled && !lf.options.isSilentMode) {
        this.enable(true);
      }
    }
    Keyboard2.prototype.initShortcuts = function() {
      var _this = this;
      var _a2;
      var shortcuts = ((_a2 = this.options.keyboard) !== null && _a2 !== void 0 ? _a2 : {}).shortcuts;
      if (shortcuts) {
        if (isArray_default(shortcuts)) {
          shortcuts.forEach(function(_a3) {
            var keys3 = _a3.keys, callback2 = _a3.callback, action4 = _a3.action;
            return _this.on(keys3, callback2, action4);
          });
        } else {
          var keys2 = shortcuts.keys, callback = shortcuts.callback, action3 = shortcuts.action;
          this.on(keys2, callback, action3);
        }
      }
    };
    Keyboard2.prototype.on = function(keys2, callback, action3) {
      this.mousetrap.bind(this.getKeys(keys2), callback, action3);
    };
    Object.defineProperty(Keyboard2.prototype, "disabled", {
      get: function() {
        var _a2, _b;
        return ((_b = (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.keyboard) === null || _b === void 0 ? void 0 : _b.enabled) !== true;
      },
      enumerable: false,
      configurable: true
    });
    Keyboard2.prototype.off = function(keys2, action3) {
      this.mousetrap.unbind(this.getKeys(keys2), action3);
    };
    Keyboard2.prototype.enable = function(force) {
      if (this.disabled || force) {
        if (this.options.keyboard) {
          this.options.keyboard.enabled = true;
        }
        if (this.target instanceof HTMLElement) {
          this.target.setAttribute("tabindex", "-1");
          this.target.style.outline = "none";
        }
      }
    };
    Keyboard2.prototype.disable = function() {
      if (!this.disabled) {
        if (this.options.keyboard) {
          this.options.keyboard.enabled = false;
        }
        if (this.target instanceof HTMLElement) {
          this.target.removeAttribute("tabindex");
        }
      }
    };
    Keyboard2.prototype.destroy = function() {
      this.mousetrap.reset();
    };
    Keyboard2.prototype.getKeys = function(keys2) {
      var _this = this;
      return (Array.isArray(keys2) ? keys2 : [keys2]).map(function(key) {
        return _this.formatKey(key);
      });
    };
    Keyboard2.prototype.formatKey = function(key) {
      return key.toLowerCase().replace(/\s/g, "").replace("delete", "del").replace("cmd", "command");
    };
    return Keyboard2;
  }()
);
var keyboard_default = Keyboard;

// node_modules/@logicflow/core/es/LogicFlow.js
var __assign53 = function() {
  __assign53 = Object.assign || function(t3) {
    for (var s3, i4 = 1, n2 = arguments.length; i4 < n2; i4++) {
      s3 = arguments[i4];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign53.apply(this, arguments);
};
var __read37 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r3, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i4.next()).done) ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray11 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l3 = from.length, ar; i4 < l3; i4++) {
    if (ar || !(i4 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i4);
      ar[i4] = from[i4];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var pluginFlag = Symbol("plugin registered by Logicflow.use");
var LogicFlow = (
  /** @class */
  function() {
    function LogicFlow2(options) {
      var _this = this;
      var _a2;
      this.viewMap = /* @__PURE__ */ new Map();
      this.components = [];
      this.extension = {};
      this.setView = function(type, component) {
        return _this.viewMap.set(type, component);
      };
      this.getView = function(type) {
        return _this.viewMap.get(type);
      };
      var initOptions = Options.get(options);
      var container = initOptions.container, width = initOptions.width, height = initOptions.height;
      this.options = initOptions;
      this.container = this.initContainer(container, width, height);
      this.graphModel = new GraphModel(__assign53(__assign53({}, initOptions), { container: this.container }));
      this.plugins = (_a2 = initOptions.plugins) !== null && _a2 !== void 0 ? _a2 : [];
      var eventCenter = this.graphModel.eventCenter;
      this.tool = new tool_default(this);
      this.dnd = new Dnd({ lf: this });
      this.history = new history_default(eventCenter);
      this.keyboard = new keyboard_default({
        lf: this,
        keyboard: initOptions.keyboard
      });
      if (initOptions.snapline !== false) {
        this.snaplineModel = new SnaplineModel(this.graphModel);
        snapline(eventCenter, this.snaplineModel);
      }
      if (!initOptions.isSilentMode) {
        initDefaultShortcut(this, this.graphModel);
        this.keyboard.initShortcuts();
      }
      this.defaultRegister();
      this.installPlugins(initOptions.disabledPlugins);
    }
    LogicFlow2.prototype.initContainer = function(container, width, height) {
      var lfContainer = document.createElement("div");
      lfContainer.style.position = "relative";
      lfContainer.style.width = width ? "".concat(width, "px") : "100%";
      lfContainer.style.height = height ? "".concat(height, "px") : "100%";
      container.innerHTML = "";
      container.appendChild(lfContainer);
      return lfContainer;
    };
    Object.defineProperty(LogicFlow2.prototype, Symbol.toStringTag, {
      get: function() {
        return LogicFlow2.toStringTag;
      },
      enumerable: false,
      configurable: true
    });
    LogicFlow2.prototype.register = function(element, fn2, isObserverView) {
      if (isObserverView === void 0) {
        isObserverView = true;
      }
      if (typeof element !== "string") {
        this.registerElement(element);
        return;
      }
      var registerParam = {
        BaseEdge,
        BaseEdgeModel,
        BaseNode,
        BaseNodeModel,
        RectNode,
        RectNodeModel,
        CircleNode,
        CircleNodeModel,
        PolygonNode,
        PolygonNodeModel,
        TextNode,
        TextNodeModel,
        LineEdge,
        LineEdgeModel,
        DiamondNode,
        DiamondNodeModel,
        PolylineEdge,
        PolylineEdgeModel,
        BezierEdge,
        BezierEdgeModel,
        EllipseNode,
        EllipseNodeModel,
        HtmlNode,
        HtmlNodeModel,
        // mobx,
        h: g,
        type: element
      };
      this.viewMap.forEach(function(component) {
        var key = component.extendKey;
        if (key) {
          registerParam[key] = component;
        }
      });
      this.graphModel.modelMap.forEach(function(component) {
        var key = component.extendKey;
        if (key) {
          registerParam[key] = component;
        }
      });
      if (fn2) {
        var _a2 = fn2(registerParam), ViewClass = _a2.view, ModelClass = _a2.model;
        var vClass = ViewClass;
        if (isObserverView && !vClass.isObserved) {
          vClass.isObserved = true;
          vClass = observer2(vClass);
        }
        this.setView(element, vClass);
        this.graphModel.setModel(element, ModelClass);
      }
    };
    LogicFlow2.prototype.registerElement = function(config) {
      var ViewComp = config.view;
      if (config.isObserverView !== false && !ViewComp.isObserved) {
        ViewComp.isObserved = true;
        ViewComp = observer2(ViewComp);
      }
      this.setView(config.type, ViewComp);
      this.graphModel.setModel(config.type, config.model);
    };
    LogicFlow2.prototype.batchRegister = function(elements) {
      var _this = this;
      if (elements === void 0) {
        elements = [];
      }
      forEach_default(elements, function(element) {
        _this.registerElement(element);
      });
    };
    LogicFlow2.prototype.defaultRegister = function() {
      var defaultElements = [
        // Node
        {
          type: "rect",
          view: RectNode,
          model: RectNodeModel
        },
        {
          type: "circle",
          view: CircleNode,
          model: CircleNodeModel
        },
        {
          type: "polygon",
          view: PolygonNode,
          model: PolygonNodeModel
        },
        {
          type: "text",
          view: TextNode,
          model: TextNodeModel
        },
        {
          type: "ellipse",
          view: EllipseNode,
          model: EllipseNodeModel
        },
        {
          type: "diamond",
          view: DiamondNode,
          model: DiamondNodeModel
        },
        {
          type: "html",
          view: HtmlNode,
          model: HtmlNodeModel
        },
        // Edge
        {
          type: "line",
          view: LineEdge,
          model: LineEdgeModel
        },
        {
          type: "polyline",
          view: PolylineEdge,
          model: PolylineEdgeModel
        },
        {
          type: "bezier",
          view: BezierEdge,
          model: BezierEdgeModel
        }
      ];
      this.batchRegister(defaultElements);
    };
    LogicFlow2.prototype.addNode = function(nodeConfig, eventType, e3) {
      if (eventType === void 0) {
        eventType = EventType.NODE_ADD;
      }
      return this.graphModel.addNode(nodeConfig, eventType, e3);
    };
    LogicFlow2.prototype.deleteNode = function(nodeId) {
      var nodeModel = this.graphModel.getNodeModelById(nodeId);
      if (!nodeModel)
        return false;
      var nodeData = nodeModel.getData();
      var guards = this.options.guards;
      var isEnableDelete = (guards === null || guards === void 0 ? void 0 : guards.beforeDelete) ? guards.beforeDelete(nodeData) : true;
      if (isEnableDelete) {
        this.graphModel.deleteNode(nodeId);
      }
      return isEnableDelete;
    };
    LogicFlow2.prototype.cloneNode = function(nodeId) {
      var nodeModel = this.graphModel.getNodeModelById(nodeId);
      var nodeData = nodeModel === null || nodeModel === void 0 ? void 0 : nodeModel.getData();
      if (nodeData) {
        var guards = this.options.guards;
        var isEnableClone = (guards === null || guards === void 0 ? void 0 : guards.beforeClone) ? guards.beforeClone(nodeData) : true;
        if (isEnableClone) {
          return this.graphModel.cloneNode(nodeId);
        }
      }
    };
    LogicFlow2.prototype.changeNodeId = function(nodeId, newId) {
      return this.graphModel.changeNodeId(nodeId, newId);
    };
    LogicFlow2.prototype.changeNodeType = function(nodeId, type) {
      this.graphModel.changeNodeType(nodeId, type);
    };
    LogicFlow2.prototype.getNodeModelById = function(nodeId) {
      return this.graphModel.getNodeModelById(nodeId);
    };
    LogicFlow2.prototype.getNodeDataById = function(nodeId) {
      var nodeModel = this.getNodeModelById(nodeId);
      return nodeModel === null || nodeModel === void 0 ? void 0 : nodeModel.getData();
    };
    LogicFlow2.prototype.getNodeIncomingEdge = function(nodeId) {
      return this.graphModel.getNodeIncomingEdge(nodeId);
    };
    LogicFlow2.prototype.getNodeOutgoingEdge = function(nodeId) {
      return this.graphModel.getNodeOutgoingEdge(nodeId);
    };
    LogicFlow2.prototype.getNodeIncomingNode = function(nodeId) {
      return this.graphModel.getNodeIncomingNode(nodeId);
    };
    LogicFlow2.prototype.getNodeOutgoingNode = function(nodeId) {
      return this.graphModel.getNodeOutgoingNode(nodeId);
    };
    LogicFlow2.prototype.createFakeNode = function(nodeConfig) {
      var Model = this.graphModel.modelMap.get(nodeConfig.type);
      if (!Model) {
        console.warn("".concat(nodeConfig.type, ""));
        return null;
      }
      var fakeNodeModel = new Model(__assign53(__assign53({}, nodeConfig), { virtual: true }), this.graphModel);
      this.graphModel.setFakeNode(fakeNodeModel);
      return fakeNodeModel;
    };
    LogicFlow2.prototype.removeFakeNode = function() {
      this.graphModel.removeFakeNode();
    };
    LogicFlow2.prototype.setNodeSnapLine = function(data) {
      var _a2;
      (_a2 = this.snaplineModel) === null || _a2 === void 0 ? void 0 : _a2.setNodeSnapLine(data);
    };
    LogicFlow2.prototype.removeNodeSnapLine = function() {
      var _a2;
      (_a2 = this.snaplineModel) === null || _a2 === void 0 ? void 0 : _a2.clearSnapline();
    };
    LogicFlow2.prototype.setDefaultEdgeType = function(type) {
      this.graphModel.setDefaultEdgeType(type);
    };
    LogicFlow2.prototype.addEdge = function(edgeConfig) {
      return this.graphModel.addEdge(edgeConfig);
    };
    LogicFlow2.prototype.getEdgeDataById = function(edgeId) {
      var edgeModel = this.getEdgeModelById(edgeId);
      return edgeModel === null || edgeModel === void 0 ? void 0 : edgeModel.getData();
    };
    LogicFlow2.prototype.getEdgeModelById = function(edgeId) {
      return this.graphModel.getEdgeModelById(edgeId);
    };
    LogicFlow2.prototype.getEdgeModels = function(_a2) {
      var sourceNodeId = _a2.sourceNodeId, targetNodeId = _a2.targetNodeId;
      var results = [];
      var edges = this.graphModel.edges;
      if (sourceNodeId && targetNodeId) {
        forEach_default(edges, function(edge) {
          if (edge.sourceNodeId === sourceNodeId && edge.targetNodeId === targetNodeId) {
            results.push(edge);
          }
        });
      } else if (sourceNodeId) {
        forEach_default(edges, function(edge) {
          if (edge.sourceNodeId === sourceNodeId) {
            results.push(edge);
          }
        });
      } else if (targetNodeId) {
        forEach_default(edges, function(edge) {
          if (edge.targetNodeId === targetNodeId) {
            results.push(edge);
          }
        });
      }
      return results;
    };
    LogicFlow2.prototype.changeEdgeId = function(edgeId, newId) {
      return this.graphModel.changeEdgeId(edgeId, newId);
    };
    LogicFlow2.prototype.changeEdgeType = function(edgeId, type) {
      this.graphModel.changeEdgeType(edgeId, type);
    };
    LogicFlow2.prototype.deleteEdge = function(edgeId) {
      var edgeModel = this.graphModel.getEdgeModelById(edgeId);
      if (!edgeModel)
        return false;
      var edgeData = edgeModel.getData();
      var guards = this.options.guards;
      var isEnableDelete = (guards === null || guards === void 0 ? void 0 : guards.beforeDelete) ? guards.beforeDelete(edgeData) : true;
      if (isEnableDelete) {
        this.graphModel.deleteEdgeById(edgeId);
      }
      return isEnableDelete;
    };
    LogicFlow2.prototype.deleteEdgeByNodeId = function(_a2) {
      var sourceNodeId = _a2.sourceNodeId, targetNodeId = _a2.targetNodeId;
      if (sourceNodeId && targetNodeId) {
        this.graphModel.deleteEdgeBySourceAndTarget(sourceNodeId, targetNodeId);
      } else if (sourceNodeId) {
        this.graphModel.deleteEdgeBySource(sourceNodeId);
      } else if (targetNodeId) {
        this.graphModel.deleteEdgeByTarget(targetNodeId);
      }
    };
    LogicFlow2.prototype.getNodeEdges = function(nodeId) {
      return this.graphModel.getNodeEdges(nodeId);
    };
    LogicFlow2.prototype.addElements = function(_a2, distance2) {
      var _this = this;
      var nodes = _a2.nodes, edges = _a2.edges;
      if (distance2 === void 0) {
        distance2 = 40;
      }
      console.log("distance", distance2);
      var nodeIdMap = {};
      var elements = {
        nodes: [],
        edges: []
      };
      forEach_default(nodes, function(node) {
        var nodeId = node.id;
        var nodeModel = _this.addNode(node);
        if (nodeId)
          nodeIdMap[nodeId] = nodeModel.id;
        elements.nodes.push(nodeModel);
      });
      forEach_default(edges, function(edge) {
        var sourceNodeId = edge.sourceNodeId, targetNodeId = edge.targetNodeId;
        if (nodeIdMap[sourceNodeId])
          sourceNodeId = nodeIdMap[sourceNodeId];
        if (nodeIdMap[targetNodeId])
          targetNodeId = nodeIdMap[targetNodeId];
        var edgeModel = _this.graphModel.addEdge(__assign53(__assign53({}, edge), { sourceNodeId, targetNodeId }));
        elements.edges.push(edgeModel);
      });
      return elements;
    };
    LogicFlow2.prototype.selectElementById = function(id, multiple, toFront) {
      if (multiple === void 0) {
        multiple = false;
      }
      if (toFront === void 0) {
        toFront = true;
      }
      this.graphModel.selectElementById(id, multiple);
      if (!multiple && toFront) {
        this.graphModel.toFront(id);
      }
    };
    LogicFlow2.prototype.getSelectElements = function(isIgnoreCheck) {
      if (isIgnoreCheck === void 0) {
        isIgnoreCheck = true;
      }
      return this.graphModel.getSelectElements(isIgnoreCheck);
    };
    LogicFlow2.prototype.clearSelectElements = function() {
      this.graphModel.clearSelectElements();
    };
    LogicFlow2.prototype.getModelById = function(id) {
      return this.graphModel.getElement(id);
    };
    LogicFlow2.prototype.getDataById = function(id) {
      var _a2;
      return (_a2 = this.graphModel.getElement(id)) === null || _a2 === void 0 ? void 0 : _a2.getData();
    };
    LogicFlow2.prototype.deleteElement = function(id) {
      var _a2;
      var _b, _c;
      var model = this.getModelById(id);
      if (!model)
        return false;
      var callback = (_a2 = {}, _a2[ElementType.NODE] = this.deleteNode, _a2[ElementType.EDGE] = this.deleteEdge, _a2);
      return (_c = (_b = callback[model.BaseType]) === null || _b === void 0 ? void 0 : _b.call(this, id)) !== null && _c !== void 0 ? _c : false;
    };
    LogicFlow2.prototype.setElementZIndex = function(id, zIndex) {
      return this.graphModel.setElementZIndex(id, zIndex);
    };
    LogicFlow2.prototype.getAreaElement = function(leftTopPoint, rightBottomPoint, wholeEdge, wholeNode, ignoreHideElement) {
      if (wholeEdge === void 0) {
        wholeEdge = true;
      }
      if (wholeNode === void 0) {
        wholeNode = true;
      }
      if (ignoreHideElement === void 0) {
        ignoreHideElement = false;
      }
      return this.graphModel.getAreaElement(leftTopPoint, rightBottomPoint, wholeEdge, wholeNode, ignoreHideElement).map(function(element) {
        return element.getData();
      });
    };
    LogicFlow2.prototype.setProperties = function(id, properties) {
      var _a2;
      (_a2 = this.graphModel.getElement(id)) === null || _a2 === void 0 ? void 0 : _a2.setProperties(formatData(properties));
    };
    LogicFlow2.prototype.getProperties = function(id) {
      var _a2;
      return (_a2 = this.graphModel.getElement(id)) === null || _a2 === void 0 ? void 0 : _a2.getProperties();
    };
    LogicFlow2.prototype.deleteProperty = function(id, key) {
      var _a2;
      (_a2 = this.graphModel.getElement(id)) === null || _a2 === void 0 ? void 0 : _a2.deleteProperty(key);
    };
    LogicFlow2.prototype.updateAttributes = function(id, attributes) {
      this.graphModel.updateAttributes(id, attributes);
    };
    LogicFlow2.prototype.editText = function(id) {
      this.graphModel.editText(id);
    };
    LogicFlow2.prototype.updateText = function(id, value) {
      this.graphModel.updateText(id, value);
    };
    LogicFlow2.prototype.updateEditConfig = function(config) {
      var _a2 = this.graphModel, editConfigModel = _a2.editConfigModel, transformModel = _a2.transformModel;
      var currentSnapGrid = editConfigModel.snapGrid;
      editConfigModel.updateEditConfig(config);
      if ((config === null || config === void 0 ? void 0 : config.stopMoveGraph) !== void 0) {
        transformModel.updateTranslateLimits(config.stopMoveGraph);
      }
      (config === null || config === void 0 ? void 0 : config.isSilentMode) ? this.keyboard.disable() : this.keyboard.enable(true);
      if (!isNil_default(config === null || config === void 0 ? void 0 : config.snapGrid) && config.snapGrid !== currentSnapGrid) {
        var _b = this.graphModel.grid.size, size = _b === void 0 ? 1 : _b;
        this.graphModel.updateGridSize(config.snapGrid ? size : 1);
      }
    };
    LogicFlow2.prototype.getEditConfig = function() {
      return this.graphModel.editConfigModel.getConfig();
    };
    LogicFlow2.prototype.setTheme = function(style) {
      this.graphModel.setTheme(style);
    };
    LogicFlow2.prototype.focusByElement = function(id) {
      var coordinate = void 0;
      var nodeModel = this.getNodeModelById(id);
      if (nodeModel) {
        var _a2 = nodeModel.getData(), x3 = _a2.x, y3 = _a2.y;
        coordinate = {
          x: x3,
          y: y3
        };
      }
      var edgeModel = this.getEdgeModelById(id);
      if (edgeModel) {
        var _b = edgeModel.textPosition, x3 = _b.x, y3 = _b.y;
        coordinate = {
          x: x3,
          y: y3
        };
      }
      if (coordinate) {
        this.focusByCoordinate(coordinate);
      }
    };
    LogicFlow2.prototype.focusByCoordinate = function(coordinate) {
      var _a2 = this.graphModel, transformModel = _a2.transformModel, width = _a2.width, height = _a2.height;
      var x3 = coordinate.x, y3 = coordinate.y;
      transformModel.focusOn(x3, y3, width, height);
    };
    LogicFlow2.prototype.focusOn = function(focusOnArgs) {
      if (typeof focusOnArgs === "string") {
        this.focusByElement(focusOnArgs);
      } else if ("x" in focusOnArgs && "y" in focusOnArgs) {
        this.focusByCoordinate(focusOnArgs);
      } else {
        var id = focusOnArgs.id, coordinate = focusOnArgs.coordinate;
        if (id) {
          this.focusByElement(id);
        }
        if (coordinate) {
          this.focusByCoordinate(coordinate);
        }
      }
    };
    LogicFlow2.prototype.resize = function(width, height) {
      this.graphModel.resize(width, height);
      this.options.width = this.graphModel.width;
      this.options.height = this.graphModel.height;
    };
    LogicFlow2.prototype.toFront = function(id) {
      this.graphModel.toFront(id);
    };
    LogicFlow2.prototype.getPointByClient = function(x3, y3) {
      if (typeof x3 === "object") {
        return this.graphModel.getPointByClient(x3);
      } else if (typeof y3 === "number") {
        return this.graphModel.getPointByClient({
          x: x3,
          y: y3
        });
      }
    };
    LogicFlow2.prototype.getGraphData = function() {
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      var data = this.getGraphRawData();
      if (this.adapterOut) {
        return this.adapterOut.apply(this, __spreadArray11([data], __read37(params), false));
      }
      return data;
    };
    LogicFlow2.prototype.getGraphRawData = function() {
      return this.graphModel.modelToGraphData();
    };
    LogicFlow2.prototype.clearData = function() {
      this.graphModel.clearData();
      this.render({});
    };
    LogicFlow2.prototype.renderRawData = function(graphRawData) {
      this.graphModel.graphDataToModel(formatData(graphRawData));
      if (this.options.history !== false) {
        this.history.watch(this.graphModel);
      }
      nn(u3(Graph_default, { getView: this.getView, tool: this.tool, options: this.options, dnd: this.dnd, snaplineModel: this.snaplineModel, graphModel: this.graphModel }), this.container);
      this.emit(EventType.GRAPH_RENDERED, {
        data: this.graphModel.modelToGraphData(),
        graphModel: this.graphModel
      });
    };
    LogicFlow2.prototype.render = function(graphData) {
      var graphRawData = cloneDeep_default(graphData);
      if (this.adapterIn) {
        graphRawData = this.adapterIn(graphRawData);
      }
      this.renderRawData(graphRawData);
    };
    LogicFlow2.prototype.undo = function() {
      if (!this.history.undoAble())
        return;
      var graphData = formatData(this.history.undo());
      this.clearSelectElements();
      this.graphModel.graphDataToModel(graphData);
    };
    LogicFlow2.prototype.redo = function() {
      if (!this.history.redoAble())
        return;
      var graphData = formatData(this.history.redo());
      this.clearSelectElements();
      this.graphModel.graphDataToModel(graphData);
    };
    LogicFlow2.prototype.zoom = function(zoomSize, point) {
      var transformModel = this.graphModel.transformModel;
      return transformModel.zoom(zoomSize, point);
    };
    LogicFlow2.prototype.resetZoom = function() {
      var transformModel = this.graphModel.transformModel;
      transformModel.resetZoom();
    };
    LogicFlow2.prototype.setZoomMiniSize = function(size) {
      var transformModel = this.graphModel.transformModel;
      transformModel.setZoomMiniSize(size);
    };
    LogicFlow2.prototype.setZoomMaxSize = function(size) {
      var transformModel = this.graphModel.transformModel;
      transformModel.setZoomMaxSize(size);
    };
    LogicFlow2.prototype.getTransform = function() {
      var _a2 = this.graphModel.transformModel, SCALE_X = _a2.SCALE_X, SCALE_Y = _a2.SCALE_Y, TRANSLATE_X = _a2.TRANSLATE_X, TRANSLATE_Y = _a2.TRANSLATE_Y;
      return {
        SCALE_X,
        SCALE_Y,
        TRANSLATE_X,
        TRANSLATE_Y
      };
    };
    LogicFlow2.prototype.translate = function(x3, y3) {
      var transformModel = this.graphModel.transformModel;
      transformModel.translate(x3, y3);
    };
    LogicFlow2.prototype.resetTranslate = function() {
      var transformModel = this.graphModel.transformModel;
      var TRANSLATE_X = transformModel.TRANSLATE_X, TRANSLATE_Y = transformModel.TRANSLATE_Y;
      this.translate(-TRANSLATE_X, -TRANSLATE_Y);
    };
    LogicFlow2.prototype.translateCenter = function() {
      this.graphModel.translateCenter();
    };
    LogicFlow2.prototype.fitView = function(verticalOffset, horizontalOffset) {
      if (horizontalOffset === void 0) {
        horizontalOffset = verticalOffset;
      }
      this.graphModel.fitView(verticalOffset, horizontalOffset);
    };
    LogicFlow2.prototype.openEdgeAnimation = function(edgeId) {
      this.graphModel.openEdgeAnimation(edgeId);
    };
    LogicFlow2.prototype.closeEdgeAnimation = function(edgeId) {
      this.graphModel.closeEdgeAnimation(edgeId);
    };
    LogicFlow2.prototype.on = function(evt, callback) {
      this.graphModel.eventCenter.on(evt, callback);
    };
    LogicFlow2.prototype.off = function(evt, callback) {
      this.graphModel.eventCenter.off(evt, callback);
    };
    LogicFlow2.prototype.once = function(evt, callback) {
      this.graphModel.eventCenter.once(evt, callback);
    };
    LogicFlow2.prototype.emit = function(evt, arg) {
      this.graphModel.eventCenter.emit(evt, arg);
    };
    LogicFlow2.use = function(extension, props) {
      var _a2;
      var pluginName = extension.pluginName;
      if (!pluginName) {
        throw new Error(" pluginName!");
      }
      this.extensions.set(pluginName, (_a2 = {}, _a2[pluginFlag] = pluginFlag, _a2.extension = extension, _a2.props = props, _a2));
    };
    LogicFlow2.prototype.installPlugins = function(disabledPlugins) {
      var _this = this;
      if (disabledPlugins === void 0) {
        disabledPlugins = [];
      }
      var extensionsAddByUse = Array.from(LogicFlow2.extensions, function(_a2) {
        var _b = __read37(_a2, 2), extension = _b[1];
        return extension;
      });
      var extensions = __spreadArray11(__spreadArray11([], __read37(this.plugins), false), __read37(extensionsAddByUse), false);
      forEach_default(extensions, function(ext) {
        var extension;
        var props;
        if (pluginFlag in ext) {
          extension = ext.extension;
          props = ext.props;
        } else {
          extension = ext;
        }
        var pluginName = extension === null || extension === void 0 ? void 0 : extension.pluginName;
        if (indexOf_default(disabledPlugins, pluginName) === -1) {
          _this.installPlugin(extension, props);
        }
      });
    };
    LogicFlow2.prototype.installPlugin = function(extension, props) {
      var _a2, _b;
      if ("pluginName" in extension && "install" in extension) {
        var pluginName_1 = extension.pluginName, install = extension.install, render_1 = extension.render;
        if (pluginName_1) {
          install && install.call(extension, this, LogicFlow2);
          render_1 && this.components.push(render_1.bind(extension));
          this.extension[pluginName_1] = extension;
        }
        return;
      }
      var ExtensionCtor = extension;
      var pluginName = ExtensionCtor.pluginName;
      var extensionIns = new ExtensionCtor({
        lf: this,
        LogicFlow: LogicFlow2,
        props,
        // TODO:  options  options options
        //  this.options.pluginsOptions[ExtensionCtor.pluginName] ?? {}
        options: (_b = (_a2 = this.options.pluginsOptions) === null || _a2 === void 0 ? void 0 : _a2[pluginName]) !== null && _b !== void 0 ? _b : {}
      });
      extensionIns.render && this.components.push(extensionIns.render.bind(extensionIns));
      this.extension[pluginName] = extensionIns;
    };
    LogicFlow2.prototype.destroy = function() {
      this.clearData();
      nn(null, this.container);
      this.keyboard.destroy();
      this.graphModel.destroy();
      this.tool.destroy();
      this.history.destroy();
    };
    LogicFlow2.extensions = /* @__PURE__ */ new Map();
    return LogicFlow2;
  }()
);
(function(LogicFlow2) {
  LogicFlow2.toStringTag = "LF.".concat(LogicFlow2.name);
})(LogicFlow || (LogicFlow = {}));
var LogicFlow_default = LogicFlow;

// node_modules/@logicflow/core/es/index.js
function observer2(props) {
  return observer(props);
}
var es_default = LogicFlow_default;

export {
  g,
  b,
  x,
  observable,
  computed,
  action,
  reaction,
  configure,
  isObservable,
  toJS,
  u3 as u,
  Options,
  defaultAnimationOffConfig,
  defaultAnimationOnConfig,
  setupAnimation,
  updateAnimation,
  isIe,
  formatData,
  DEFAULT_VISIBLE_SPACE,
  ELEMENT_MAX_Z_INDEX,
  DEFAULT_GRID_SIZE,
  ElementState,
  ElementType,
  ModelType,
  EventType,
  OverlapMode,
  SegmentDirection,
  TextMode,
  StepDrag,
  getNodeOutline,
  getLineOutline,
  getPolylineOutline,
  getBezierOutline,
  getEdgeOutline,
  getCrossPointOfLine,
  isInSegment,
  getVerticalPointOfLine,
  setupEdgeModel,
  isBboxOverLapping,
  filterRepeatPoints,
  getSimplePolyline,
  getExpandedBBox,
  pointDirection,
  getExpandedBBoxPoint,
  mergeBBox,
  getBBoxOfPoints,
  getPointsFromBBox,
  isPointOutsideBBox,
  getBBoxXCrossPoints,
  getBBoxYCrossPoints,
  getBBoxCrossPointsByPoint,
  estimateDistance,
  costByPoints,
  heuristicCostEstimate,
  rebuildPath,
  removeClosePointFromOpenList,
  isSegmentsIntersected,
  isSegmentCrossingBBox,
  getNextNeighborPoints,
  pathFinder,
  getBoxByOriginNode,
  pointFilter,
  getPolylinePoints,
  getLongestEdge,
  isSegmentsInNode,
  isSegmentsCrossNode,
  getCrossPointInRect,
  segmentDirection,
  points2PointsList,
  getSimplePoints,
  getBytesLength,
  getTextWidth,
  getAppendAttributes,
  getBezierControlPoints,
  getBezierPoints,
  getEndTangent,
  getClosestPointOfPolyline,
  pickEdgeConfig,
  twoPointDistance,
  createEdgeGenerator,
  getSvgTextSize,
  snapToGrid,
  getGridOffset,
  normalizePolygon,
  isPointInArea,
  isMultipleSelect,
  Vector,
  Point,
  Matrix,
  RotateMatrix,
  ScaleMatrix,
  TranslateMatrix,
  getAnchors,
  targetNodeInfo,
  getClosestAnchor,
  distance,
  isInNode,
  isInNodeBbox,
  getNodeBBox,
  getRectRadiusCircle,
  getClosestRadiusCenter,
  getCrossPointWithCircle,
  pointEdgeDirection,
  inStraightLineOfRect,
  getCrossPointWithEllipse,
  getCrossPointWithPolygon,
  pickNodeConfig,
  getNodeAnchorPosition,
  getHtmlTextHeight,
  getSvgTextWidthHeight,
  formatAnchorConnectValidateData,
  createUuid,
  refreshGraphId,
  createRaf,
  cancelRaf,
  Text,
  renderHtmlText,
  Line,
  Rect,
  Path,
  Circle,
  Ellipse,
  Polygon,
  Polyline,
  recalcResizeInfo,
  updateEdgePointByAnchors,
  triggerResizeEvent,
  handleResize,
  calculateWidthAndHeight,
  sampleCubic,
  getThetaOfVector,
  degrees,
  defaultTheme,
  setupTheme,
  updateTheme,
  getZIndex,
  getMinIndex,
  util_exports,
  BaseEdgeModel,
  BezierEdgeModel,
  LineEdgeModel,
  PolylineEdgeModel,
  BaseNodeModel,
  CircleNodeModel,
  DiamondNodeModel,
  EllipseNodeModel,
  PolygonNodeModel,
  RectNodeModel,
  TextNodeModel,
  HtmlNodeModel,
  EditConfigModel,
  EventEmitter,
  GraphModel,
  SnaplineModel,
  TransformModel,
  require_classnames,
  BaseText,
  LineText,
  BaseNode,
  RectNode,
  CircleNode,
  PolygonNode,
  DiamondNode,
  EllipseNode,
  TextNode,
  HtmlNode,
  AdjustType,
  AdjustPoint,
  Arrow,
  BaseEdge,
  BezierEdge,
  LineEdge,
  PolylineEdge,
  Tool,
  translateNodeData,
  translateEdgeData,
  transformNodeData,
  transformEdgeData,
  initDefaultShortcut,
  Keyboard,
  LogicFlow_default,
  observer2 as observer,
  es_default
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

mobx/lib/mobx.module.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
*/
//# sourceMappingURL=chunk-FIRYSKPA.js.map
