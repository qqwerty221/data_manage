import {
  CircleNode,
  CircleNodeModel,
  DiamondNode,
  DiamondNodeModel,
  ElementState,
  ElementType,
  EllipseNode,
  EllipseNodeModel,
  EventType,
  HtmlNode,
  HtmlNodeModel,
  ModelType,
  Polygon,
  PolygonNode,
  PolygonNodeModel,
  PolylineEdge,
  PolylineEdgeModel,
  Rect,
  RectNode,
  RectNodeModel,
  StepDrag,
  TextMode,
  b,
  createUuid,
  formatAnchorConnectValidateData,
  g,
  handleResize,
  observable,
  observer,
  require_classnames,
  toJS,
  transformEdgeData,
  transformNodeData,
  twoPointDistance,
  u,
  util_exports,
  x
} from "./chunk-FIRYSKPA.js";
import {
  assign_default,
  cloneDeep_default,
  concat_default,
  filter_default,
  findIndex_default,
  forEach_default,
  get_default,
  has_default,
  isArray_default,
  isEmpty_default,
  isEqual_default,
  isFinite_default,
  isNil_default,
  isObject_default,
  lodash_default_default,
  map_default,
  merge_default,
  reduce_default,
  sortBy_default
} from "./chunk-SERHAQMS.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/medium-editor/dist/js/medium-editor.js
var require_medium_editor = __commonJS({
  "node_modules/medium-editor/dist/js/medium-editor.js"(exports, module) {
    if (!("classList" in document.createElement("_"))) {
      (function(view) {
        "use strict";
        if (!("Element" in view)) return;
        var classListProp = "classList", protoProp = "prototype", elemCtrProto = view.Element[protoProp], objCtr = Object, strTrim = String[protoProp].trim || function() {
          return this.replace(/^\s+|\s+$/g, "");
        }, arrIndexOf = Array[protoProp].indexOf || function(item) {
          var i = 0, len = this.length;
          for (; i < len; i++) {
            if (i in this && this[i] === item) {
              return i;
            }
          }
          return -1;
        }, DOMEx = function(type3, message) {
          this.name = type3;
          this.code = DOMException[type3];
          this.message = message;
        }, checkTokenAndGetIndex = function(classList, token) {
          if (token === "") {
            throw new DOMEx(
              "SYNTAX_ERR",
              "An invalid or illegal string was specified"
            );
          }
          if (/\s/.test(token)) {
            throw new DOMEx(
              "INVALID_CHARACTER_ERR",
              "String contains an invalid character"
            );
          }
          return arrIndexOf.call(classList, token);
        }, ClassList = function(elem) {
          var trimmedClasses = strTrim.call(elem.getAttribute("class") || ""), classes = trimmedClasses ? trimmedClasses.split(/\s+/) : [], i = 0, len = classes.length;
          for (; i < len; i++) {
            this.push(classes[i]);
          }
          this._updateClassName = function() {
            elem.setAttribute("class", this.toString());
          };
        }, classListProto = ClassList[protoProp] = [], classListGetter = function() {
          return new ClassList(this);
        };
        DOMEx[protoProp] = Error[protoProp];
        classListProto.item = function(i) {
          return this[i] || null;
        };
        classListProto.contains = function(token) {
          token += "";
          return checkTokenAndGetIndex(this, token) !== -1;
        };
        classListProto.add = function() {
          var tokens = arguments, i = 0, l = tokens.length, token, updated = false;
          do {
            token = tokens[i] + "";
            if (checkTokenAndGetIndex(this, token) === -1) {
              this.push(token);
              updated = true;
            }
          } while (++i < l);
          if (updated) {
            this._updateClassName();
          }
        };
        classListProto.remove = function() {
          var tokens = arguments, i = 0, l = tokens.length, token, updated = false, index;
          do {
            token = tokens[i] + "";
            index = checkTokenAndGetIndex(this, token);
            while (index !== -1) {
              this.splice(index, 1);
              updated = true;
              index = checkTokenAndGetIndex(this, token);
            }
          } while (++i < l);
          if (updated) {
            this._updateClassName();
          }
        };
        classListProto.toggle = function(token, force) {
          token += "";
          var result = this.contains(token), method = result ? force !== true && "remove" : force !== false && "add";
          if (method) {
            this[method](token);
          }
          if (force === true || force === false) {
            return force;
          } else {
            return !result;
          }
        };
        classListProto.toString = function() {
          return this.join(" ");
        };
        if (objCtr.defineProperty) {
          var classListPropDesc = {
            get: classListGetter,
            enumerable: true,
            configurable: true
          };
          try {
            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
          } catch (ex) {
            if (ex.number === -2146823252) {
              classListPropDesc.enumerable = false;
              objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
            }
          }
        } else if (objCtr[protoProp].__defineGetter__) {
          elemCtrProto.__defineGetter__(classListProp, classListGetter);
        }
      })(self);
    }
    (function(view) {
      "use strict";
      view.URL = view.URL || view.webkitURL;
      if (view.Blob && view.URL) {
        try {
          new Blob();
          return;
        } catch (e) {
        }
      }
      var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || function(view2) {
        var get_class = function(object) {
          return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
        }, FakeBlobBuilder = function BlobBuilder2() {
          this.data = [];
        }, FakeBlob = function Blob2(data, type3, encoding) {
          this.data = data;
          this.size = data.length;
          this.type = type3;
          this.encoding = encoding;
        }, FBB_proto = FakeBlobBuilder.prototype, FB_proto = FakeBlob.prototype, FileReaderSync = view2.FileReaderSync, FileException = function(type3) {
          this.code = this[this.name = type3];
        }, file_ex_codes = "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR".split(" "), file_ex_code = file_ex_codes.length, real_URL = view2.URL || view2.webkitURL || view2, real_create_object_URL = real_URL.createObjectURL, real_revoke_object_URL = real_URL.revokeObjectURL, URL2 = real_URL, btoa = view2.btoa, atob = view2.atob, ArrayBuffer = view2.ArrayBuffer, Uint8Array2 = view2.Uint8Array, origin = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/;
        FakeBlob.fake = FB_proto.fake = true;
        while (file_ex_code--) {
          FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
        }
        if (!real_URL.createObjectURL) {
          URL2 = view2.URL = function(uri) {
            var uri_info = document.createElementNS("http://www.w3.org/1999/xhtml", "a"), uri_origin;
            uri_info.href = uri;
            if (!("origin" in uri_info)) {
              if (uri_info.protocol.toLowerCase() === "data:") {
                uri_info.origin = null;
              } else {
                uri_origin = uri.match(origin);
                uri_info.origin = uri_origin && uri_origin[1];
              }
            }
            return uri_info;
          };
        }
        URL2.createObjectURL = function(blob) {
          var type3 = blob.type, data_URI_header;
          if (type3 === null) {
            type3 = "application/octet-stream";
          }
          if (blob instanceof FakeBlob) {
            data_URI_header = "data:" + type3;
            if (blob.encoding === "base64") {
              return data_URI_header + ";base64," + blob.data;
            } else if (blob.encoding === "URI") {
              return data_URI_header + "," + decodeURIComponent(blob.data);
            }
            if (btoa) {
              return data_URI_header + ";base64," + btoa(blob.data);
            } else {
              return data_URI_header + "," + encodeURIComponent(blob.data);
            }
          } else if (real_create_object_URL) {
            return real_create_object_URL.call(real_URL, blob);
          }
        };
        URL2.revokeObjectURL = function(object_URL) {
          if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
            real_revoke_object_URL.call(real_URL, object_URL);
          }
        };
        FBB_proto.append = function(data) {
          var bb = this.data;
          if (Uint8Array2 && (data instanceof ArrayBuffer || data instanceof Uint8Array2)) {
            var str = "", buf = new Uint8Array2(data), i = 0, buf_len = buf.length;
            for (; i < buf_len; i++) {
              str += String.fromCharCode(buf[i]);
            }
            bb.push(str);
          } else if (get_class(data) === "Blob" || get_class(data) === "File") {
            if (FileReaderSync) {
              var fr = new FileReaderSync();
              bb.push(fr.readAsBinaryString(data));
            } else {
              throw new FileException("NOT_READABLE_ERR");
            }
          } else if (data instanceof FakeBlob) {
            if (data.encoding === "base64" && atob) {
              bb.push(atob(data.data));
            } else if (data.encoding === "URI") {
              bb.push(decodeURIComponent(data.data));
            } else if (data.encoding === "raw") {
              bb.push(data.data);
            }
          } else {
            if (typeof data !== "string") {
              data += "";
            }
            bb.push(unescape(encodeURIComponent(data)));
          }
        };
        FBB_proto.getBlob = function(type3) {
          if (!arguments.length) {
            type3 = null;
          }
          return new FakeBlob(this.data.join(""), type3, "raw");
        };
        FBB_proto.toString = function() {
          return "[object BlobBuilder]";
        };
        FB_proto.slice = function(start, end, type3) {
          var args = arguments.length;
          if (args < 3) {
            type3 = null;
          }
          return new FakeBlob(
            this.data.slice(start, args > 1 ? end : this.data.length),
            type3,
            this.encoding
          );
        };
        FB_proto.toString = function() {
          return "[object Blob]";
        };
        FB_proto.close = function() {
          this.size = 0;
          delete this.data;
        };
        return FakeBlobBuilder;
      }(view);
      view.Blob = function(blobParts, options) {
        var type3 = options ? options.type || "" : "";
        var builder = new BlobBuilder();
        if (blobParts) {
          for (var i = 0, len = blobParts.length; i < len; i++) {
            if (Uint8Array && blobParts[i] instanceof Uint8Array) {
              builder.append(blobParts[i].buffer);
            } else {
              builder.append(blobParts[i]);
            }
          }
        }
        var blob = builder.getBlob(type3);
        if (!blob.slice && blob.webkitSlice) {
          blob.slice = blob.webkitSlice;
        }
        return blob;
      };
      var getPrototypeOf = Object.getPrototypeOf || function(object) {
        return object.__proto__;
      };
      view.Blob.prototype = getPrototypeOf(new view.Blob());
    })(typeof self !== "undefined" && self || typeof window !== "undefined" && window || exports.content || exports);
    (function(root, factory) {
      "use strict";
      var isElectron = typeof module === "object" && typeof process !== "undefined" && process && process.versions && process.versions.electron;
      if (!isElectron && typeof module === "object") {
        module.exports = factory;
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return factory;
        });
      } else {
        root.MediumEditor = factory;
      }
    })(exports, function() {
      "use strict";
      function MediumEditor2(elements, options) {
        "use strict";
        return this.init(elements, options);
      }
      MediumEditor2.extensions = {};
      (function(window2) {
        "use strict";
        function copyInto(overwrite, dest) {
          var prop, sources = Array.prototype.slice.call(arguments, 2);
          dest = dest || {};
          for (var i = 0; i < sources.length; i++) {
            var source = sources[i];
            if (source) {
              for (prop in source) {
                if (source.hasOwnProperty(prop) && typeof source[prop] !== "undefined" && (overwrite || dest.hasOwnProperty(prop) === false)) {
                  dest[prop] = source[prop];
                }
              }
            }
          }
          return dest;
        }
        var nodeContainsWorksWithTextNodes = false;
        try {
          var testParent = document.createElement("div"), testText = document.createTextNode(" ");
          testParent.appendChild(testText);
          nodeContainsWorksWithTextNodes = testParent.contains(testText);
        } catch (exc) {
        }
        var Util = {
          // http://stackoverflow.com/questions/17907445/how-to-detect-ie11#comment30165888_17907562
          // by rg89
          isIE: navigator.appName === "Microsoft Internet Explorer" || navigator.appName === "Netscape" && new RegExp("Trident/.*rv:([0-9]{1,}[.0-9]{0,})").exec(navigator.userAgent) !== null,
          isEdge: /Edge\/\d+/.exec(navigator.userAgent) !== null,
          // if firefox
          isFF: navigator.userAgent.toLowerCase().indexOf("firefox") > -1,
          // http://stackoverflow.com/a/11752084/569101
          isMac: window2.navigator.platform.toUpperCase().indexOf("MAC") >= 0,
          // https://github.com/jashkenas/underscore
          // Lonely letter MUST USE the uppercase code
          keyCode: {
            BACKSPACE: 8,
            TAB: 9,
            ENTER: 13,
            ESCAPE: 27,
            SPACE: 32,
            DELETE: 46,
            K: 75,
            // K keycode, and not k
            M: 77,
            V: 86
          },
          /**
           * Returns true if it's metaKey on Mac, or ctrlKey on non-Mac.
           * See #591
           */
          isMetaCtrlKey: function(event) {
            if (Util.isMac && event.metaKey || !Util.isMac && event.ctrlKey) {
              return true;
            }
            return false;
          },
          /**
           * Returns true if the key associated to the event is inside keys array
           *
           * @see : https://github.com/jquery/jquery/blob/0705be475092aede1eddae01319ec931fb9c65fc/src/event.js#L473-L484
           * @see : http://stackoverflow.com/q/4471582/569101
           */
          isKey: function(event, keys) {
            var keyCode = Util.getKeyCode(event);
            if (false === Array.isArray(keys)) {
              return keyCode === keys;
            }
            if (-1 === keys.indexOf(keyCode)) {
              return false;
            }
            return true;
          },
          getKeyCode: function(event) {
            var keyCode = event.which;
            if (null === keyCode) {
              keyCode = event.charCode !== null ? event.charCode : event.keyCode;
            }
            return keyCode;
          },
          blockContainerElementNames: [
            // elements our editor generates
            "p",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "blockquote",
            "pre",
            "ul",
            "li",
            "ol",
            // all other known block elements
            "address",
            "article",
            "aside",
            "audio",
            "canvas",
            "dd",
            "dl",
            "dt",
            "fieldset",
            "figcaption",
            "figure",
            "footer",
            "form",
            "header",
            "hgroup",
            "main",
            "nav",
            "noscript",
            "output",
            "section",
            "video",
            "table",
            "thead",
            "tbody",
            "tfoot",
            "tr",
            "th",
            "td"
          ],
          emptyElementNames: ["br", "col", "colgroup", "hr", "img", "input", "source", "wbr"],
          extend: function extend() {
            var args = [true].concat(Array.prototype.slice.call(arguments));
            return copyInto.apply(this, args);
          },
          defaults: function defaults() {
            var args = [false].concat(Array.prototype.slice.call(arguments));
            return copyInto.apply(this, args);
          },
          /*
           * Create a link around the provided text nodes which must be adjacent to each other and all be
           * descendants of the same closest block container. If the preconditions are not met, unexpected
           * behavior will result.
           */
          createLink: function(document2, textNodes, href, target) {
            var anchor = document2.createElement("a");
            Util.moveTextRangeIntoElement(textNodes[0], textNodes[textNodes.length - 1], anchor);
            anchor.setAttribute("href", href);
            if (target) {
              if (target === "_blank") {
                anchor.setAttribute("rel", "noopener noreferrer");
              }
              anchor.setAttribute("target", target);
            }
            return anchor;
          },
          /*
           * Given the provided match in the format {start: 1, end: 2} where start and end are indices into the
           * textContent of the provided element argument, modify the DOM inside element to ensure that the text
           * identified by the provided match can be returned as text nodes that contain exactly that text, without
           * any additional text at the beginning or end of the returned array of adjacent text nodes.
           *
           * The only DOM manipulation performed by this function is splitting the text nodes, non-text nodes are
           * not affected in any way.
           */
          findOrCreateMatchingTextNodes: function(document2, element, match) {
            var treeWalker = document2.createTreeWalker(element, NodeFilter.SHOW_ALL, null, false), matchedNodes = [], currentTextIndex = 0, startReached = false, currentNode = null, newNode = null;
            while ((currentNode = treeWalker.nextNode()) !== null) {
              if (currentNode.nodeType > 3) {
                continue;
              } else if (currentNode.nodeType === 3) {
                if (!startReached && match.start < currentTextIndex + currentNode.nodeValue.length) {
                  startReached = true;
                  newNode = Util.splitStartNodeIfNeeded(currentNode, match.start, currentTextIndex);
                }
                if (startReached) {
                  Util.splitEndNodeIfNeeded(currentNode, newNode, match.end, currentTextIndex);
                }
                if (startReached && currentTextIndex === match.end) {
                  break;
                } else if (startReached && currentTextIndex > match.end + 1) {
                  throw new Error("PerformLinking overshot the target!");
                }
                if (startReached) {
                  matchedNodes.push(newNode || currentNode);
                }
                currentTextIndex += currentNode.nodeValue.length;
                if (newNode !== null) {
                  currentTextIndex += newNode.nodeValue.length;
                  treeWalker.nextNode();
                }
                newNode = null;
              } else if (currentNode.tagName.toLowerCase() === "img") {
                if (!startReached && match.start <= currentTextIndex) {
                  startReached = true;
                }
                if (startReached) {
                  matchedNodes.push(currentNode);
                }
              }
            }
            return matchedNodes;
          },
          /*
           * Given the provided text node and text coordinates, split the text node if needed to make it align
           * precisely with the coordinates.
           *
           * This function is intended to be called from Util.findOrCreateMatchingTextNodes.
           */
          splitStartNodeIfNeeded: function(currentNode, matchStartIndex, currentTextIndex) {
            if (matchStartIndex !== currentTextIndex) {
              return currentNode.splitText(matchStartIndex - currentTextIndex);
            }
            return null;
          },
          /*
           * Given the provided text node and text coordinates, split the text node if needed to make it align
           * precisely with the coordinates. The newNode argument should from the result of Util.splitStartNodeIfNeeded,
           * if that function has been called on the same currentNode.
           *
           * This function is intended to be called from Util.findOrCreateMatchingTextNodes.
           */
          splitEndNodeIfNeeded: function(currentNode, newNode, matchEndIndex, currentTextIndex) {
            var textIndexOfEndOfFarthestNode, endSplitPoint;
            textIndexOfEndOfFarthestNode = currentTextIndex + currentNode.nodeValue.length + (newNode ? newNode.nodeValue.length : 0) - 1;
            endSplitPoint = matchEndIndex - currentTextIndex - (newNode ? currentNode.nodeValue.length : 0);
            if (textIndexOfEndOfFarthestNode >= matchEndIndex && currentTextIndex !== textIndexOfEndOfFarthestNode && endSplitPoint !== 0) {
              (newNode || currentNode).splitText(endSplitPoint);
            }
          },
          /*
          * Take an element, and break up all of its text content into unique pieces such that:
           * 1) All text content of the elements are in separate blocks. No piece of text content should span
           *    across multiple blocks. This means no element return by this function should have
           *    any blocks as children.
           * 2) The union of the textcontent of all of the elements returned here covers all
           *    of the text within the element.
           *
           *
           * EXAMPLE:
           * In the event that we have something like:
           *
           * <blockquote>
           *   <p>Some Text</p>
           *   <ol>
           *     <li>List Item 1</li>
           *     <li>List Item 2</li>
           *   </ol>
           * </blockquote>
           *
           * This function would return these elements as an array:
           *   [ <p>Some Text</p>, <li>List Item 1</li>, <li>List Item 2</li> ]
           *
           * Since the <blockquote> and <ol> elements contain blocks within them they are not returned.
           * Since the <p> and <li>'s don't contain block elements and cover all the text content of the
           * <blockquote> container, they are the elements returned.
           */
          splitByBlockElements: function(element) {
            if (element.nodeType !== 3 && element.nodeType !== 1) {
              return [];
            }
            var toRet = [], blockElementQuery = MediumEditor2.util.blockContainerElementNames.join(",");
            if (element.nodeType === 3 || element.querySelectorAll(blockElementQuery).length === 0) {
              return [element];
            }
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType === 3) {
                toRet.push(child);
              } else if (child.nodeType === 1) {
                var blockElements = child.querySelectorAll(blockElementQuery);
                if (blockElements.length === 0) {
                  toRet.push(child);
                } else {
                  toRet = toRet.concat(MediumEditor2.util.splitByBlockElements(child));
                }
              }
            }
            return toRet;
          },
          // Find the next node in the DOM tree that represents any text that is being
          // displayed directly next to the targetNode (passed as an argument)
          // Text that appears directly next to the current node can be:
          //  - A sibling text node
          //  - A descendant of a sibling element
          //  - A sibling text node of an ancestor
          //  - A descendant of a sibling element of an ancestor
          findAdjacentTextNodeWithContent: function findAdjacentTextNodeWithContent(rootNode, targetNode, ownerDocument) {
            var pastTarget = false, nextNode, nodeIterator = ownerDocument.createNodeIterator(rootNode, NodeFilter.SHOW_TEXT, null, false);
            nextNode = nodeIterator.nextNode();
            while (nextNode) {
              if (nextNode === targetNode) {
                pastTarget = true;
              } else if (pastTarget) {
                if (nextNode.nodeType === 3 && nextNode.nodeValue && nextNode.nodeValue.trim().length > 0) {
                  break;
                }
              }
              nextNode = nodeIterator.nextNode();
            }
            return nextNode;
          },
          // Find an element's previous sibling within a medium-editor element
          // If one doesn't exist, find the closest ancestor's previous sibling
          findPreviousSibling: function(node2) {
            if (!node2 || Util.isMediumEditorElement(node2)) {
              return false;
            }
            var previousSibling = node2.previousSibling;
            while (!previousSibling && !Util.isMediumEditorElement(node2.parentNode)) {
              node2 = node2.parentNode;
              previousSibling = node2.previousSibling;
            }
            return previousSibling;
          },
          isDescendant: function isDescendant(parent, child, checkEquality) {
            if (!parent || !child) {
              return false;
            }
            if (parent === child) {
              return !!checkEquality;
            }
            if (parent.nodeType !== 1) {
              return false;
            }
            if (nodeContainsWorksWithTextNodes || child.nodeType !== 3) {
              return parent.contains(child);
            }
            var node2 = child.parentNode;
            while (node2 !== null) {
              if (node2 === parent) {
                return true;
              }
              node2 = node2.parentNode;
            }
            return false;
          },
          // https://github.com/jashkenas/underscore
          isElement: function isElement(obj) {
            return !!(obj && obj.nodeType === 1);
          },
          // https://github.com/jashkenas/underscore
          throttle: function(func, wait) {
            var THROTTLE_INTERVAL = 50, context, args, result, timeout = null, previous = 0, later = function() {
              previous = Date.now();
              timeout = null;
              result = func.apply(context, args);
              if (!timeout) {
                context = args = null;
              }
            };
            if (!wait && wait !== 0) {
              wait = THROTTLE_INTERVAL;
            }
            return function() {
              var now = Date.now(), remaining = wait - (now - previous);
              context = this;
              args = arguments;
              if (remaining <= 0 || remaining > wait) {
                if (timeout) {
                  clearTimeout(timeout);
                  timeout = null;
                }
                previous = now;
                result = func.apply(context, args);
                if (!timeout) {
                  context = args = null;
                }
              } else if (!timeout) {
                timeout = setTimeout(later, remaining);
              }
              return result;
            };
          },
          traverseUp: function(current, testElementFunction) {
            if (!current) {
              return false;
            }
            do {
              if (current.nodeType === 1) {
                if (testElementFunction(current)) {
                  return current;
                }
                if (Util.isMediumEditorElement(current)) {
                  return false;
                }
              }
              current = current.parentNode;
            } while (current);
            return false;
          },
          htmlEntities: function(str) {
            return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
          },
          // http://stackoverflow.com/questions/6690752/insert-html-at-caret-in-a-contenteditable-div
          insertHTMLCommand: function(doc, html) {
            var selection, range, el, fragment, node2, lastNode, toReplace, res = false, ecArgs = ["insertHTML", false, html];
            if (!MediumEditor2.util.isEdge && doc.queryCommandSupported("insertHTML")) {
              try {
                return doc.execCommand.apply(doc, ecArgs);
              } catch (ignore) {
              }
            }
            selection = doc.getSelection();
            if (selection.rangeCount) {
              range = selection.getRangeAt(0);
              toReplace = range.commonAncestorContainer;
              if (Util.isMediumEditorElement(toReplace) && !toReplace.firstChild) {
                range.selectNode(toReplace.appendChild(doc.createTextNode("")));
              } else if (toReplace.nodeType === 3 && range.startOffset === 0 && range.endOffset === toReplace.nodeValue.length || toReplace.nodeType !== 3 && toReplace.innerHTML === range.toString()) {
                while (!Util.isMediumEditorElement(toReplace) && toReplace.parentNode && toReplace.parentNode.childNodes.length === 1 && !Util.isMediumEditorElement(toReplace.parentNode)) {
                  toReplace = toReplace.parentNode;
                }
                range.selectNode(toReplace);
              }
              range.deleteContents();
              el = doc.createElement("div");
              el.innerHTML = html;
              fragment = doc.createDocumentFragment();
              while (el.firstChild) {
                node2 = el.firstChild;
                lastNode = fragment.appendChild(node2);
              }
              range.insertNode(fragment);
              if (lastNode) {
                range = range.cloneRange();
                range.setStartAfter(lastNode);
                range.collapse(true);
                MediumEditor2.selection.selectRange(doc, range);
              }
              res = true;
            }
            if (doc.execCommand.callListeners) {
              doc.execCommand.callListeners(ecArgs, res);
            }
            return res;
          },
          execFormatBlock: function(doc, tagName) {
            var blockContainer = Util.getTopBlockContainer(MediumEditor2.selection.getSelectionStart(doc)), childNodes;
            if (tagName === "blockquote") {
              if (blockContainer) {
                childNodes = Array.prototype.slice.call(blockContainer.childNodes);
                if (childNodes.some(function(childNode) {
                  return Util.isBlockContainer(childNode);
                })) {
                  return doc.execCommand("outdent", false, null);
                }
              }
              if (Util.isIE) {
                return doc.execCommand("indent", false, tagName);
              }
            }
            if (blockContainer && tagName === blockContainer.nodeName.toLowerCase()) {
              tagName = "p";
            }
            if (Util.isIE) {
              tagName = "<" + tagName + ">";
            }
            if (blockContainer && blockContainer.nodeName.toLowerCase() === "blockquote") {
              if (Util.isIE && tagName === "<p>") {
                return doc.execCommand("outdent", false, tagName);
              }
              if ((Util.isFF || Util.isEdge) && tagName === "p") {
                childNodes = Array.prototype.slice.call(blockContainer.childNodes);
                if (childNodes.some(function(childNode) {
                  return !Util.isBlockContainer(childNode);
                })) {
                  doc.execCommand("formatBlock", false, tagName);
                }
                return doc.execCommand("outdent", false, tagName);
              }
            }
            return doc.execCommand("formatBlock", false, tagName);
          },
          /**
           * Set target to blank on the given el element
           *
           * TODO: not sure if this should be here
           *
           * When creating a link (using core -> createLink) the selection returned by Firefox will be the parent of the created link
           * instead of the created link itself (as it is for Chrome for example), so we retrieve all "a" children to grab the good one by
           * using `anchorUrl` to ensure that we are adding target="_blank" on the good one.
           * This isn't a bulletproof solution anyway ..
           */
          setTargetBlank: function(el, anchorUrl) {
            var i, url = anchorUrl || false;
            if (el.nodeName.toLowerCase() === "a") {
              el.target = "_blank";
              el.rel = "noopener noreferrer";
            } else {
              el = el.getElementsByTagName("a");
              for (i = 0; i < el.length; i += 1) {
                if (false === url || url === el[i].attributes.href.value) {
                  el[i].target = "_blank";
                  el[i].rel = "noopener noreferrer";
                }
              }
            }
          },
          /*
           * this function is called to explicitly remove the target='_blank' as FF holds on to _blank value even
           * after unchecking the checkbox on anchor form
           */
          removeTargetBlank: function(el, anchorUrl) {
            var i;
            if (el.nodeName.toLowerCase() === "a") {
              el.removeAttribute("target");
              el.removeAttribute("rel");
            } else {
              el = el.getElementsByTagName("a");
              for (i = 0; i < el.length; i += 1) {
                if (anchorUrl === el[i].attributes.href.value) {
                  el[i].removeAttribute("target");
                  el[i].removeAttribute("rel");
                }
              }
            }
          },
          /*
           * this function adds one or several classes on an a element.
           * if el parameter is not an a, it will look for a children of el.
           * if no a children are found, it will look for the a parent.
           */
          addClassToAnchors: function(el, buttonClass) {
            var classes = buttonClass.split(" "), i, j;
            if (el.nodeName.toLowerCase() === "a") {
              for (j = 0; j < classes.length; j += 1) {
                el.classList.add(classes[j]);
              }
            } else {
              var aChildren = el.getElementsByTagName("a");
              if (aChildren.length === 0) {
                var parentAnchor = Util.getClosestTag(el, "a");
                el = parentAnchor ? [parentAnchor] : [];
              } else {
                el = aChildren;
              }
              for (i = 0; i < el.length; i += 1) {
                for (j = 0; j < classes.length; j += 1) {
                  el[i].classList.add(classes[j]);
                }
              }
            }
          },
          isListItem: function(node2) {
            if (!node2) {
              return false;
            }
            if (node2.nodeName.toLowerCase() === "li") {
              return true;
            }
            var parentNode = node2.parentNode, tagName = parentNode.nodeName.toLowerCase();
            while (tagName === "li" || !Util.isBlockContainer(parentNode) && tagName !== "div") {
              if (tagName === "li") {
                return true;
              }
              parentNode = parentNode.parentNode;
              if (parentNode) {
                tagName = parentNode.nodeName.toLowerCase();
              } else {
                return false;
              }
            }
            return false;
          },
          cleanListDOM: function(ownerDocument, element) {
            if (element.nodeName.toLowerCase() !== "li") {
              return;
            }
            var list = element.parentElement;
            if (list.parentElement.nodeName.toLowerCase() === "p") {
              Util.unwrap(list.parentElement, ownerDocument);
              MediumEditor2.selection.moveCursor(ownerDocument, element.firstChild, element.firstChild.textContent.length);
            }
          },
          /* splitDOMTree
           *
           * Given a root element some descendant element, split the root element
           * into its own element containing the descendant element and all elements
           * on the left or right side of the descendant ('right' is default)
           *
           * example:
           *
           *         <div>
           *      /    |   \
           *  <span> <span> <span>
           *   / \    / \    / \
           *  1   2  3   4  5   6
           *
           *  If I wanted to split this tree given the <div> as the root and "4" as the leaf
           *  the result would be (the prime ' marks indicates nodes that are created as clones):
           *
           *   SPLITTING OFF 'RIGHT' TREE       SPLITTING OFF 'LEFT' TREE
           *
           *     <div>            <div>'              <div>'      <div>
           *      / \              / \                 / \          |
           * <span> <span>   <span>' <span>       <span> <span>   <span>
           *   / \    |        |      / \           /\     /\       /\
           *  1   2   3        4     5   6         1  2   3  4     5  6
           *
           *  The above example represents splitting off the 'right' or 'left' part of a tree, where
           *  the <div>' would be returned as an element not appended to the DOM, and the <div>
           *  would remain in place where it was
           *
          */
          splitOffDOMTree: function(rootNode, leafNode, splitLeft) {
            var splitOnNode = leafNode, createdNode = null, splitRight = !splitLeft;
            while (splitOnNode !== rootNode) {
              var currParent = splitOnNode.parentNode, newParent = currParent.cloneNode(false), targetNode = splitRight ? splitOnNode : currParent.firstChild, appendLast;
              if (createdNode) {
                if (splitRight) {
                  newParent.appendChild(createdNode);
                } else {
                  appendLast = createdNode;
                }
              }
              createdNode = newParent;
              while (targetNode) {
                var sibling = targetNode.nextSibling;
                if (targetNode === splitOnNode) {
                  if (!targetNode.hasChildNodes()) {
                    targetNode.parentNode.removeChild(targetNode);
                  } else {
                    targetNode = targetNode.cloneNode(false);
                  }
                  if (targetNode.textContent) {
                    createdNode.appendChild(targetNode);
                  }
                  targetNode = splitRight ? sibling : null;
                } else {
                  targetNode.parentNode.removeChild(targetNode);
                  if (targetNode.hasChildNodes() || targetNode.textContent) {
                    createdNode.appendChild(targetNode);
                  }
                  targetNode = sibling;
                }
              }
              if (appendLast) {
                createdNode.appendChild(appendLast);
              }
              splitOnNode = currParent;
            }
            return createdNode;
          },
          moveTextRangeIntoElement: function(startNode, endNode, newElement) {
            if (!startNode || !endNode) {
              return false;
            }
            var rootNode = Util.findCommonRoot(startNode, endNode);
            if (!rootNode) {
              return false;
            }
            if (endNode === startNode) {
              var temp = startNode.parentNode, sibling = startNode.nextSibling;
              temp.removeChild(startNode);
              newElement.appendChild(startNode);
              if (sibling) {
                temp.insertBefore(newElement, sibling);
              } else {
                temp.appendChild(newElement);
              }
              return newElement.hasChildNodes();
            }
            var rootChildren = [], firstChild, lastChild, nextNode;
            for (var i = 0; i < rootNode.childNodes.length; i++) {
              nextNode = rootNode.childNodes[i];
              if (!firstChild) {
                if (Util.isDescendant(nextNode, startNode, true)) {
                  firstChild = nextNode;
                }
              } else {
                if (Util.isDescendant(nextNode, endNode, true)) {
                  lastChild = nextNode;
                  break;
                } else {
                  rootChildren.push(nextNode);
                }
              }
            }
            var afterLast = lastChild.nextSibling, fragment = rootNode.ownerDocument.createDocumentFragment();
            if (firstChild === startNode) {
              firstChild.parentNode.removeChild(firstChild);
              fragment.appendChild(firstChild);
            } else {
              fragment.appendChild(Util.splitOffDOMTree(firstChild, startNode));
            }
            rootChildren.forEach(function(element) {
              element.parentNode.removeChild(element);
              fragment.appendChild(element);
            });
            if (lastChild === endNode) {
              lastChild.parentNode.removeChild(lastChild);
              fragment.appendChild(lastChild);
            } else {
              fragment.appendChild(Util.splitOffDOMTree(lastChild, endNode, true));
            }
            newElement.appendChild(fragment);
            if (lastChild.parentNode === rootNode) {
              rootNode.insertBefore(newElement, lastChild);
            } else if (afterLast) {
              rootNode.insertBefore(newElement, afterLast);
            } else {
              rootNode.appendChild(newElement);
            }
            return newElement.hasChildNodes();
          },
          /* based on http://stackoverflow.com/a/6183069 */
          depthOfNode: function(inNode) {
            var theDepth = 0, node2 = inNode;
            while (node2.parentNode !== null) {
              node2 = node2.parentNode;
              theDepth++;
            }
            return theDepth;
          },
          findCommonRoot: function(inNode1, inNode2) {
            var depth1 = Util.depthOfNode(inNode1), depth2 = Util.depthOfNode(inNode2), node1 = inNode1, node2 = inNode2;
            while (depth1 !== depth2) {
              if (depth1 > depth2) {
                node1 = node1.parentNode;
                depth1 -= 1;
              } else {
                node2 = node2.parentNode;
                depth2 -= 1;
              }
            }
            while (node1 !== node2) {
              node1 = node1.parentNode;
              node2 = node2.parentNode;
            }
            return node1;
          },
          /* END - based on http://stackoverflow.com/a/6183069 */
          isElementAtBeginningOfBlock: function(node2) {
            var textVal, sibling;
            while (!Util.isBlockContainer(node2) && !Util.isMediumEditorElement(node2)) {
              sibling = node2;
              while (sibling = sibling.previousSibling) {
                textVal = sibling.nodeType === 3 ? sibling.nodeValue : sibling.textContent;
                if (textVal.length > 0) {
                  return false;
                }
              }
              node2 = node2.parentNode;
            }
            return true;
          },
          isMediumEditorElement: function(element) {
            return element && element.getAttribute && !!element.getAttribute("data-medium-editor-element");
          },
          getContainerEditorElement: function(element) {
            return Util.traverseUp(element, function(node2) {
              return Util.isMediumEditorElement(node2);
            });
          },
          isBlockContainer: function(element) {
            return element && element.nodeType !== 3 && Util.blockContainerElementNames.indexOf(element.nodeName.toLowerCase()) !== -1;
          },
          /* Finds the closest ancestor which is a block container element
           * If element is within editor element but not within any other block element,
           * the editor element is returned
           */
          getClosestBlockContainer: function(node2) {
            return Util.traverseUp(node2, function(node3) {
              return Util.isBlockContainer(node3) || Util.isMediumEditorElement(node3);
            });
          },
          /* Finds highest level ancestor element which is a block container element
           * If element is within editor element but not within any other block element,
           * the editor element is returned
           */
          getTopBlockContainer: function(element) {
            var topBlock = Util.isBlockContainer(element) ? element : false;
            Util.traverseUp(element, function(el) {
              if (Util.isBlockContainer(el)) {
                topBlock = el;
              }
              if (!topBlock && Util.isMediumEditorElement(el)) {
                topBlock = el;
                return true;
              }
              return false;
            });
            return topBlock;
          },
          getFirstSelectableLeafNode: function(element) {
            while (element && element.firstChild) {
              element = element.firstChild;
            }
            element = Util.traverseUp(element, function(el) {
              return Util.emptyElementNames.indexOf(el.nodeName.toLowerCase()) === -1;
            });
            if (element.nodeName.toLowerCase() === "table") {
              var firstCell = element.querySelector("th, td");
              if (firstCell) {
                element = firstCell;
              }
            }
            return element;
          },
          // TODO: remove getFirstTextNode AND _getFirstTextNode when jumping in 6.0.0 (no code references)
          getFirstTextNode: function(element) {
            Util.warn("getFirstTextNode is deprecated and will be removed in version 6.0.0");
            return Util._getFirstTextNode(element);
          },
          _getFirstTextNode: function(element) {
            if (element.nodeType === 3) {
              return element;
            }
            for (var i = 0; i < element.childNodes.length; i++) {
              var textNode = Util._getFirstTextNode(element.childNodes[i]);
              if (textNode !== null) {
                return textNode;
              }
            }
            return null;
          },
          ensureUrlHasProtocol: function(url) {
            if (url.indexOf("://") === -1) {
              return "http://" + url;
            }
            return url;
          },
          warn: function() {
            if (window2.console !== void 0 && typeof window2.console.warn === "function") {
              window2.console.warn.apply(window2.console, arguments);
            }
          },
          deprecated: function(oldName, newName, version) {
            var m = oldName + " is deprecated, please use " + newName + " instead.";
            if (version) {
              m += " Will be removed in " + version;
            }
            Util.warn(m);
          },
          deprecatedMethod: function(oldName, newName, args, version) {
            Util.deprecated(oldName, newName, version);
            if (typeof this[newName] === "function") {
              this[newName].apply(this, args);
            }
          },
          cleanupAttrs: function(el, attrs) {
            attrs.forEach(function(attr) {
              el.removeAttribute(attr);
            });
          },
          cleanupTags: function(el, tags) {
            if (tags.indexOf(el.nodeName.toLowerCase()) !== -1) {
              el.parentNode.removeChild(el);
            }
          },
          unwrapTags: function(el, tags) {
            if (tags.indexOf(el.nodeName.toLowerCase()) !== -1) {
              MediumEditor2.util.unwrap(el, document);
            }
          },
          // get the closest parent
          getClosestTag: function(el, tag) {
            return Util.traverseUp(el, function(element) {
              return element.nodeName.toLowerCase() === tag.toLowerCase();
            });
          },
          unwrap: function(el, doc) {
            var fragment = doc.createDocumentFragment(), nodes = Array.prototype.slice.call(el.childNodes);
            for (var i = 0; i < nodes.length; i++) {
              fragment.appendChild(nodes[i]);
            }
            if (fragment.childNodes.length) {
              el.parentNode.replaceChild(fragment, el);
            } else {
              el.parentNode.removeChild(el);
            }
          },
          guid: function() {
            function _s4() {
              return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
            }
            return _s4() + _s4() + "-" + _s4() + "-" + _s4() + "-" + _s4() + "-" + _s4() + _s4() + _s4();
          }
        };
        MediumEditor2.util = Util;
      })(window);
      (function() {
        "use strict";
        var Extension = function(options) {
          MediumEditor2.util.extend(this, options);
        };
        Extension.extend = function(protoProps) {
          var parent = this, child;
          if (protoProps && protoProps.hasOwnProperty("constructor")) {
            child = protoProps.constructor;
          } else {
            child = function() {
              return parent.apply(this, arguments);
            };
          }
          MediumEditor2.util.extend(child, parent);
          var Surrogate = function() {
            this.constructor = child;
          };
          Surrogate.prototype = parent.prototype;
          child.prototype = new Surrogate();
          if (protoProps) {
            MediumEditor2.util.extend(child.prototype, protoProps);
          }
          return child;
        };
        Extension.prototype = {
          /* init: [function]
           *
           * Called by MediumEditor during initialization.
           * The .base property will already have been set to
           * current instance of MediumEditor when this is called.
           * All helper methods will exist as well
           */
          init: function() {
          },
          /* base: [MediumEditor instance]
           *
           * If not overriden, this will be set to the current instance
           * of MediumEditor, before the init method is called
           */
          base: void 0,
          /* name: [string]
           *
           * 'name' of the extension, used for retrieving the extension.
           * If not set, MediumEditor will set this to be the key
           * used when passing the extension into MediumEditor via the
           * 'extensions' option
           */
          name: void 0,
          /* checkState: [function (node)]
           *
           * If implemented, this function will be called one or more times
           * the state of the editor & toolbar are updated.
           * When the state is updated, the editor does the following:
           *
           * 1) Find the parent node containing the current selection
           * 2) Call checkState on the extension, passing the node as an argument
           * 3) Get the parent node of the previous node
           * 4) Repeat steps #2 and #3 until we move outside the parent contenteditable
           */
          checkState: void 0,
          /* destroy: [function ()]
           *
           * This method should remove any created html, custom event handlers
           * or any other cleanup tasks that should be performed.
           * If implemented, this function will be called when MediumEditor's
           * destroy method has been called.
           */
          destroy: void 0,
          /* As alternatives to checkState, these functions provide a more structured
           * path to updating the state of an extension (usually a button) whenever
           * the state of the editor & toolbar are updated.
           */
          /* queryCommandState: [function ()]
           *
           * If implemented, this function will be called once on each extension
           * when the state of the editor/toolbar is being updated.
           *
           * If this function returns a non-null value, the extension will
           * be ignored as the code climbs the dom tree.
           *
           * If this function returns true, and the setActive() function is defined
           * setActive() will be called
           */
          queryCommandState: void 0,
          /* isActive: [function ()]
           *
           * If implemented, this function will be called when MediumEditor
           * has determined that this extension is 'active' for the current selection.
           * This may be called when the editor & toolbar are being updated,
           * but only if queryCommandState() or isAlreadyApplied() functions
           * are implemented, and when called, return true.
           */
          isActive: void 0,
          /* isAlreadyApplied: [function (node)]
           *
           * If implemented, this function is similar to checkState() in
           * that it will be called repeatedly as MediumEditor moves up
           * the DOM to update the editor & toolbar after a state change.
           *
           * NOTE: This function will NOT be called if checkState() has
           * been implemented. This function will NOT be called if
           * queryCommandState() is implemented and returns a non-null
           * value when called
           */
          isAlreadyApplied: void 0,
          /* setActive: [function ()]
           *
           * If implemented, this function is called when MediumEditor knows
           * that this extension is currently enabled.  Currently, this
           * function is called when updating the editor & toolbar, and
           * only if queryCommandState() or isAlreadyApplied(node) return
           * true when called
           */
          setActive: void 0,
          /* setInactive: [function ()]
           *
           * If implemented, this function is called when MediumEditor knows
           * that this extension is currently disabled.  Curently, this
           * is called at the beginning of each state change for
           * the editor & toolbar. After calling this, MediumEditor
           * will attempt to update the extension, either via checkState()
           * or the combination of queryCommandState(), isAlreadyApplied(node),
           * isActive(), and setActive()
           */
          setInactive: void 0,
          /* getInteractionElements: [function ()]
           *
           * If the extension renders any elements that the user can interact with,
           * this method should be implemented and return the root element or an array
           * containing all of the root elements. MediumEditor will call this function
           * during interaction to see if the user clicked on something outside of the editor.
           * The elements are used to check if the target element of a click or
           * other user event is a descendant of any extension elements.
           * This way, the editor can also count user interaction within editor elements as
           * interactions with the editor, and thus not trigger 'blur'
           */
          getInteractionElements: void 0,
          /************************ Helpers ************************
           * The following are helpers that are either set by MediumEditor
           * during initialization, or are helper methods which either
           * route calls to the MediumEditor instance or provide common
           * functionality for all extensions
           *********************************************************/
          /* window: [Window]
           *
           * If not overriden, this will be set to the window object
           * to be used by MediumEditor and its extensions.  This is
           * passed via the 'contentWindow' option to MediumEditor
           * and is the global 'window' object by default
           */
          "window": void 0,
          /* document: [Document]
           *
           * If not overriden, this will be set to the document object
           * to be used by MediumEditor and its extensions. This is
           * passed via the 'ownerDocument' optin to MediumEditor
           * and is the global 'document' object by default
           */
          "document": void 0,
          /* getEditorElements: [function ()]
           *
           * Helper function which returns an array containing
           * all the contenteditable elements for this instance
           * of MediumEditor
           */
          getEditorElements: function() {
            return this.base.elements;
          },
          /* getEditorId: [function ()]
           *
           * Helper function which returns a unique identifier
           * for this instance of MediumEditor
           */
          getEditorId: function() {
            return this.base.id;
          },
          /* getEditorOptions: [function (option)]
           *
           * Helper function which returns the value of an option
           * used to initialize this instance of MediumEditor
           */
          getEditorOption: function(option) {
            return this.base.options[option];
          }
        };
        [
          // general helpers
          "execAction",
          // event handling
          "on",
          "off",
          "subscribe",
          "trigger"
        ].forEach(function(helper) {
          Extension.prototype[helper] = function() {
            return this.base[helper].apply(this.base, arguments);
          };
        });
        MediumEditor2.Extension = Extension;
      })();
      (function() {
        "use strict";
        function filterOnlyParentElements(node2) {
          if (MediumEditor2.util.isBlockContainer(node2)) {
            return NodeFilter.FILTER_ACCEPT;
          } else {
            return NodeFilter.FILTER_SKIP;
          }
        }
        var Selection = {
          findMatchingSelectionParent: function(testElementFunction, contentWindow) {
            var selection = contentWindow.getSelection(), range, current;
            if (selection.rangeCount === 0) {
              return false;
            }
            range = selection.getRangeAt(0);
            current = range.commonAncestorContainer;
            return MediumEditor2.util.traverseUp(current, testElementFunction);
          },
          getSelectionElement: function(contentWindow) {
            return this.findMatchingSelectionParent(function(el) {
              return MediumEditor2.util.isMediumEditorElement(el);
            }, contentWindow);
          },
          // http://stackoverflow.com/questions/17678843/cant-restore-selection-after-html-modify-even-if-its-the-same-html
          // Tim Down
          exportSelection: function(root, doc) {
            if (!root) {
              return null;
            }
            var selectionState = null, selection = doc.getSelection();
            if (selection.rangeCount > 0) {
              var range = selection.getRangeAt(0), preSelectionRange = range.cloneRange(), start;
              preSelectionRange.selectNodeContents(root);
              preSelectionRange.setEnd(range.startContainer, range.startOffset);
              start = preSelectionRange.toString().length;
              selectionState = {
                start,
                end: start + range.toString().length
              };
              if (this.doesRangeStartWithImages(range, doc)) {
                selectionState.startsWithImage = true;
              }
              var trailingImageCount = this.getTrailingImageCount(root, selectionState, range.endContainer, range.endOffset);
              if (trailingImageCount) {
                selectionState.trailingImageCount = trailingImageCount;
              }
              if (start !== 0) {
                var emptyBlocksIndex = this.getIndexRelativeToAdjacentEmptyBlocks(doc, root, range.startContainer, range.startOffset);
                if (emptyBlocksIndex !== -1) {
                  selectionState.emptyBlocksIndex = emptyBlocksIndex;
                }
              }
            }
            return selectionState;
          },
          // http://stackoverflow.com/questions/17678843/cant-restore-selection-after-html-modify-even-if-its-the-same-html
          // Tim Down
          //
          // {object} selectionState - the selection to import
          // {DOMElement} root - the root element the selection is being restored inside of
          // {Document} doc - the document to use for managing selection
          // {boolean} [favorLaterSelectionAnchor] - defaults to false. If true, import the cursor immediately
          //      subsequent to an anchor tag if it would otherwise be placed right at the trailing edge inside the
          //      anchor. This cursor positioning, even though visually equivalent to the user, can affect behavior
          //      in MS IE.
          importSelection: function(selectionState, root, doc, favorLaterSelectionAnchor) {
            if (!selectionState || !root) {
              return;
            }
            var range = doc.createRange();
            range.setStart(root, 0);
            range.collapse(true);
            var node2 = root, nodeStack = [], charIndex = 0, foundStart = false, foundEnd = false, trailingImageCount = 0, stop = false, nextCharIndex, allowRangeToStartAtEndOfNode = false, lastTextNode = null;
            if (favorLaterSelectionAnchor || selectionState.startsWithImage || typeof selectionState.emptyBlocksIndex !== "undefined") {
              allowRangeToStartAtEndOfNode = true;
            }
            while (!stop && node2) {
              if (node2.nodeType > 3) {
                node2 = nodeStack.pop();
                continue;
              }
              if (node2.nodeType === 3 && !foundEnd) {
                nextCharIndex = charIndex + node2.length;
                if (!foundStart && selectionState.start >= charIndex && selectionState.start <= nextCharIndex) {
                  if (allowRangeToStartAtEndOfNode || selectionState.start < nextCharIndex) {
                    range.setStart(node2, selectionState.start - charIndex);
                    foundStart = true;
                  } else {
                    lastTextNode = node2;
                  }
                }
                if (foundStart && selectionState.end >= charIndex && selectionState.end <= nextCharIndex) {
                  if (!selectionState.trailingImageCount) {
                    range.setEnd(node2, selectionState.end - charIndex);
                    stop = true;
                  } else {
                    foundEnd = true;
                  }
                }
                charIndex = nextCharIndex;
              } else {
                if (selectionState.trailingImageCount && foundEnd) {
                  if (node2.nodeName.toLowerCase() === "img") {
                    trailingImageCount++;
                  }
                  if (trailingImageCount === selectionState.trailingImageCount) {
                    var endIndex = 0;
                    while (node2.parentNode.childNodes[endIndex] !== node2) {
                      endIndex++;
                    }
                    range.setEnd(node2.parentNode, endIndex + 1);
                    stop = true;
                  }
                }
                if (!stop && node2.nodeType === 1) {
                  var i = node2.childNodes.length - 1;
                  while (i >= 0) {
                    nodeStack.push(node2.childNodes[i]);
                    i -= 1;
                  }
                }
              }
              if (!stop) {
                node2 = nodeStack.pop();
              }
            }
            if (!foundStart && lastTextNode) {
              range.setStart(lastTextNode, lastTextNode.length);
              range.setEnd(lastTextNode, lastTextNode.length);
            }
            if (typeof selectionState.emptyBlocksIndex !== "undefined") {
              range = this.importSelectionMoveCursorPastBlocks(doc, root, selectionState.emptyBlocksIndex, range);
            }
            if (favorLaterSelectionAnchor) {
              range = this.importSelectionMoveCursorPastAnchor(selectionState, range);
            }
            this.selectRange(doc, range);
          },
          // Utility method called from importSelection only
          importSelectionMoveCursorPastAnchor: function(selectionState, range) {
            var nodeInsideAnchorTagFunction = function(node2) {
              return node2.nodeName.toLowerCase() === "a";
            };
            if (selectionState.start === selectionState.end && range.startContainer.nodeType === 3 && range.startOffset === range.startContainer.nodeValue.length && MediumEditor2.util.traverseUp(range.startContainer, nodeInsideAnchorTagFunction)) {
              var prevNode = range.startContainer, currentNode = range.startContainer.parentNode;
              while (currentNode !== null && currentNode.nodeName.toLowerCase() !== "a") {
                if (currentNode.childNodes[currentNode.childNodes.length - 1] !== prevNode) {
                  currentNode = null;
                } else {
                  prevNode = currentNode;
                  currentNode = currentNode.parentNode;
                }
              }
              if (currentNode !== null && currentNode.nodeName.toLowerCase() === "a") {
                var currentNodeIndex = null;
                for (var i = 0; currentNodeIndex === null && i < currentNode.parentNode.childNodes.length; i++) {
                  if (currentNode.parentNode.childNodes[i] === currentNode) {
                    currentNodeIndex = i;
                  }
                }
                range.setStart(currentNode.parentNode, currentNodeIndex + 1);
                range.collapse(true);
              }
            }
            return range;
          },
          // Uses the emptyBlocksIndex calculated by getIndexRelativeToAdjacentEmptyBlocks
          // to move the cursor back to the start of the correct paragraph
          importSelectionMoveCursorPastBlocks: function(doc, root, index, range) {
            var treeWalker = doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filterOnlyParentElements, false), startContainer = range.startContainer, startBlock, targetNode, currIndex = 0;
            index = index || 1;
            if (startContainer.nodeType === 3 && MediumEditor2.util.isBlockContainer(startContainer.previousSibling)) {
              startBlock = startContainer.previousSibling;
            } else {
              startBlock = MediumEditor2.util.getClosestBlockContainer(startContainer);
            }
            while (treeWalker.nextNode()) {
              if (!targetNode) {
                if (startBlock === treeWalker.currentNode) {
                  targetNode = treeWalker.currentNode;
                }
              } else {
                targetNode = treeWalker.currentNode;
                currIndex++;
                if (currIndex === index) {
                  break;
                }
                if (targetNode.textContent.length > 0) {
                  break;
                }
              }
            }
            if (!targetNode) {
              targetNode = startBlock;
            }
            range.setStart(MediumEditor2.util.getFirstSelectableLeafNode(targetNode), 0);
            return range;
          },
          // Returns -1 unless the cursor is at the beginning of a paragraph/block
          // If the paragraph/block is preceeded by empty paragraphs/block (with no text)
          // it will return the number of empty paragraphs before the cursor.
          // Otherwise, it will return 0, which indicates the cursor is at the beginning
          // of a paragraph/block, and not at the end of the paragraph/block before it
          getIndexRelativeToAdjacentEmptyBlocks: function(doc, root, cursorContainer, cursorOffset) {
            if (cursorContainer.textContent.length > 0 && cursorOffset > 0) {
              return -1;
            }
            var node2 = cursorContainer;
            if (node2.nodeType !== 3) {
              node2 = cursorContainer.childNodes[cursorOffset];
            }
            if (node2) {
              if (!MediumEditor2.util.isElementAtBeginningOfBlock(node2)) {
                return -1;
              }
              var previousSibling = MediumEditor2.util.findPreviousSibling(node2);
              if (!previousSibling) {
                return -1;
              } else if (previousSibling.nodeValue) {
                return -1;
              }
            }
            var closestBlock = MediumEditor2.util.getClosestBlockContainer(cursorContainer), treeWalker = doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filterOnlyParentElements, false), emptyBlocksCount = 0;
            while (treeWalker.nextNode()) {
              var blockIsEmpty = treeWalker.currentNode.textContent === "";
              if (blockIsEmpty || emptyBlocksCount > 0) {
                emptyBlocksCount += 1;
              }
              if (treeWalker.currentNode === closestBlock) {
                return emptyBlocksCount;
              }
              if (!blockIsEmpty) {
                emptyBlocksCount = 0;
              }
            }
            return emptyBlocksCount;
          },
          // Returns true if the selection range begins with an image tag
          // Returns false if the range starts with any non empty text nodes
          doesRangeStartWithImages: function(range, doc) {
            if (range.startOffset !== 0 || range.startContainer.nodeType !== 1) {
              return false;
            }
            if (range.startContainer.nodeName.toLowerCase() === "img") {
              return true;
            }
            var img = range.startContainer.querySelector("img");
            if (!img) {
              return false;
            }
            var treeWalker = doc.createTreeWalker(range.startContainer, NodeFilter.SHOW_ALL, null, false);
            while (treeWalker.nextNode()) {
              var next = treeWalker.currentNode;
              if (next === img) {
                break;
              }
              if (next.nodeValue) {
                return false;
              }
            }
            return true;
          },
          getTrailingImageCount: function(root, selectionState, endContainer, endOffset) {
            if (endOffset === 0 || endContainer.nodeType !== 1) {
              return 0;
            }
            if (endContainer.nodeName.toLowerCase() !== "img" && !endContainer.querySelector("img")) {
              return 0;
            }
            var lastNode = endContainer.childNodes[endOffset - 1];
            while (lastNode.hasChildNodes()) {
              lastNode = lastNode.lastChild;
            }
            var node2 = root, nodeStack = [], charIndex = 0, foundStart = false, foundEnd = false, stop = false, nextCharIndex, trailingImages = 0;
            while (!stop && node2) {
              if (node2.nodeType > 3) {
                node2 = nodeStack.pop();
                continue;
              }
              if (node2.nodeType === 3 && !foundEnd) {
                trailingImages = 0;
                nextCharIndex = charIndex + node2.length;
                if (!foundStart && selectionState.start >= charIndex && selectionState.start <= nextCharIndex) {
                  foundStart = true;
                }
                if (foundStart && selectionState.end >= charIndex && selectionState.end <= nextCharIndex) {
                  foundEnd = true;
                }
                charIndex = nextCharIndex;
              } else {
                if (node2.nodeName.toLowerCase() === "img") {
                  trailingImages++;
                }
                if (node2 === lastNode) {
                  stop = true;
                } else if (node2.nodeType === 1) {
                  var i = node2.childNodes.length - 1;
                  while (i >= 0) {
                    nodeStack.push(node2.childNodes[i]);
                    i -= 1;
                  }
                }
              }
              if (!stop) {
                node2 = nodeStack.pop();
              }
            }
            return trailingImages;
          },
          // determine if the current selection contains any 'content'
          // content being any non-white space text or an image
          selectionContainsContent: function(doc) {
            var sel = doc.getSelection();
            if (!sel || sel.isCollapsed || !sel.rangeCount) {
              return false;
            }
            if (sel.toString().trim() !== "") {
              return true;
            }
            var selectionNode = this.getSelectedParentElement(sel.getRangeAt(0));
            if (selectionNode) {
              if (selectionNode.nodeName.toLowerCase() === "img" || selectionNode.nodeType === 1 && selectionNode.querySelector("img")) {
                return true;
              }
            }
            return false;
          },
          selectionInContentEditableFalse: function(contentWindow) {
            var sawtrue, sawfalse = this.findMatchingSelectionParent(function(el) {
              var ce = el && el.getAttribute("contenteditable");
              if (ce === "true") {
                sawtrue = true;
              }
              return el.nodeName !== "#text" && ce === "false";
            }, contentWindow);
            return !sawtrue && sawfalse;
          },
          // http://stackoverflow.com/questions/4176923/html-of-selected-text
          // by Tim Down
          getSelectionHtml: function getSelectionHtml(doc) {
            var i, html = "", sel = doc.getSelection(), len, container;
            if (sel.rangeCount) {
              container = doc.createElement("div");
              for (i = 0, len = sel.rangeCount; i < len; i += 1) {
                container.appendChild(sel.getRangeAt(i).cloneContents());
              }
              html = container.innerHTML;
            }
            return html;
          },
          /**
           *  Find the caret position within an element irrespective of any inline tags it may contain.
           *
           *  @param {DOMElement} An element containing the cursor to find offsets relative to.
           *  @param {Range} A Range representing cursor position. Will window.getSelection if none is passed.
           *  @return {Object} 'left' and 'right' attributes contain offsets from begining and end of Element
           */
          getCaretOffsets: function getCaretOffsets(element, range) {
            var preCaretRange, postCaretRange;
            if (!range) {
              range = window.getSelection().getRangeAt(0);
            }
            preCaretRange = range.cloneRange();
            postCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            postCaretRange.selectNodeContents(element);
            postCaretRange.setStart(range.endContainer, range.endOffset);
            return {
              left: preCaretRange.toString().length,
              right: postCaretRange.toString().length
            };
          },
          // http://stackoverflow.com/questions/15867542/range-object-get-selection-parent-node-chrome-vs-firefox
          rangeSelectsSingleNode: function(range) {
            var startNode = range.startContainer;
            return startNode === range.endContainer && startNode.hasChildNodes() && range.endOffset === range.startOffset + 1;
          },
          getSelectedParentElement: function(range) {
            if (!range) {
              return null;
            }
            if (this.rangeSelectsSingleNode(range) && range.startContainer.childNodes[range.startOffset].nodeType !== 3) {
              return range.startContainer.childNodes[range.startOffset];
            }
            if (range.startContainer.nodeType === 3) {
              return range.startContainer.parentNode;
            }
            return range.startContainer;
          },
          getSelectedElements: function(doc) {
            var selection = doc.getSelection(), range, toRet, currNode;
            if (!selection.rangeCount || selection.isCollapsed || !selection.getRangeAt(0).commonAncestorContainer) {
              return [];
            }
            range = selection.getRangeAt(0);
            if (range.commonAncestorContainer.nodeType === 3) {
              toRet = [];
              currNode = range.commonAncestorContainer;
              while (currNode.parentNode && currNode.parentNode.childNodes.length === 1) {
                toRet.push(currNode.parentNode);
                currNode = currNode.parentNode;
              }
              return toRet;
            }
            return [].filter.call(range.commonAncestorContainer.getElementsByTagName("*"), function(el) {
              return typeof selection.containsNode === "function" ? selection.containsNode(el, true) : true;
            });
          },
          selectNode: function(node2, doc) {
            var range = doc.createRange();
            range.selectNodeContents(node2);
            this.selectRange(doc, range);
          },
          select: function(doc, startNode, startOffset, endNode, endOffset) {
            var range = doc.createRange();
            range.setStart(startNode, startOffset);
            if (endNode) {
              range.setEnd(endNode, endOffset);
            } else {
              range.collapse(true);
            }
            this.selectRange(doc, range);
            return range;
          },
          /**
           *  Clear the current highlighted selection and set the caret to the start or the end of that prior selection, defaults to end.
           *
           *  @param {DomDocument} doc            Current document
           *  @param {boolean} moveCursorToStart  A boolean representing whether or not to set the caret to the beginning of the prior selection.
           */
          clearSelection: function(doc, moveCursorToStart) {
            if (moveCursorToStart) {
              doc.getSelection().collapseToStart();
            } else {
              doc.getSelection().collapseToEnd();
            }
          },
          /**
           * Move cursor to the given node with the given offset.
           *
           * @param  {DomDocument} doc     Current document
           * @param  {DomElement}  node    Element where to jump
           * @param  {integer}     offset  Where in the element should we jump, 0 by default
           */
          moveCursor: function(doc, node2, offset) {
            this.select(doc, node2, offset);
          },
          getSelectionRange: function(ownerDocument) {
            var selection = ownerDocument.getSelection();
            if (selection.rangeCount === 0) {
              return null;
            }
            return selection.getRangeAt(0);
          },
          selectRange: function(ownerDocument, range) {
            var selection = ownerDocument.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
          },
          // http://stackoverflow.com/questions/1197401/how-can-i-get-the-element-the-caret-is-in-with-javascript-when-using-contentedi
          // by You
          getSelectionStart: function(ownerDocument) {
            var node2 = ownerDocument.getSelection().anchorNode, startNode = node2 && node2.nodeType === 3 ? node2.parentNode : node2;
            return startNode;
          }
        };
        MediumEditor2.selection = Selection;
      })();
      (function() {
        "use strict";
        function isElementDescendantOfExtension(extensions, element) {
          if (!extensions) {
            return false;
          }
          return extensions.some(function(extension) {
            if (typeof extension.getInteractionElements !== "function") {
              return false;
            }
            var extensionElements = extension.getInteractionElements();
            if (!extensionElements) {
              return false;
            }
            if (!Array.isArray(extensionElements)) {
              extensionElements = [extensionElements];
            }
            return extensionElements.some(function(el) {
              return MediumEditor2.util.isDescendant(el, element, true);
            });
          });
        }
        var Events = function(instance) {
          this.base = instance;
          this.options = this.base.options;
          this.events = [];
          this.disabledEvents = {};
          this.customEvents = {};
          this.listeners = {};
        };
        Events.prototype = {
          InputEventOnContenteditableSupported: !MediumEditor2.util.isIE && !MediumEditor2.util.isEdge,
          // Helpers for event handling
          attachDOMEvent: function(targets, event, listener, useCapture) {
            var win = this.base.options.contentWindow, doc = this.base.options.ownerDocument;
            targets = MediumEditor2.util.isElement(targets) || [win, doc].indexOf(targets) > -1 ? [targets] : targets;
            Array.prototype.forEach.call(targets, (function(target) {
              target.addEventListener(event, listener, useCapture);
              this.events.push([target, event, listener, useCapture]);
            }).bind(this));
          },
          detachDOMEvent: function(targets, event, listener, useCapture) {
            var index, e, win = this.base.options.contentWindow, doc = this.base.options.ownerDocument;
            if (targets) {
              targets = MediumEditor2.util.isElement(targets) || [win, doc].indexOf(targets) > -1 ? [targets] : targets;
              Array.prototype.forEach.call(targets, (function(target) {
                index = this.indexOfListener(target, event, listener, useCapture);
                if (index !== -1) {
                  e = this.events.splice(index, 1)[0];
                  e[0].removeEventListener(e[1], e[2], e[3]);
                }
              }).bind(this));
            }
          },
          indexOfListener: function(target, event, listener, useCapture) {
            var i, n, item;
            for (i = 0, n = this.events.length; i < n; i = i + 1) {
              item = this.events[i];
              if (item[0] === target && item[1] === event && item[2] === listener && item[3] === useCapture) {
                return i;
              }
            }
            return -1;
          },
          detachAllDOMEvents: function() {
            var e = this.events.pop();
            while (e) {
              e[0].removeEventListener(e[1], e[2], e[3]);
              e = this.events.pop();
            }
          },
          detachAllEventsFromElement: function(element) {
            var filtered = this.events.filter(function(e2) {
              return e2 && e2[0].getAttribute && e2[0].getAttribute("medium-editor-index") === element.getAttribute("medium-editor-index");
            });
            for (var i = 0, len = filtered.length; i < len; i++) {
              var e = filtered[i];
              this.detachDOMEvent(e[0], e[1], e[2], e[3]);
            }
          },
          // Attach all existing handlers to a new element
          attachAllEventsToElement: function(element) {
            if (this.listeners["editableInput"]) {
              this.contentCache[element.getAttribute("medium-editor-index")] = element.innerHTML;
            }
            if (this.eventsCache) {
              this.eventsCache.forEach(function(e) {
                this.attachDOMEvent(element, e["name"], e["handler"].bind(this));
              }, this);
            }
          },
          enableCustomEvent: function(event) {
            if (this.disabledEvents[event] !== void 0) {
              delete this.disabledEvents[event];
            }
          },
          disableCustomEvent: function(event) {
            this.disabledEvents[event] = true;
          },
          // custom events
          attachCustomEvent: function(event, listener) {
            this.setupListener(event);
            if (!this.customEvents[event]) {
              this.customEvents[event] = [];
            }
            this.customEvents[event].push(listener);
          },
          detachCustomEvent: function(event, listener) {
            var index = this.indexOfCustomListener(event, listener);
            if (index !== -1) {
              this.customEvents[event].splice(index, 1);
            }
          },
          indexOfCustomListener: function(event, listener) {
            if (!this.customEvents[event] || !this.customEvents[event].length) {
              return -1;
            }
            return this.customEvents[event].indexOf(listener);
          },
          detachAllCustomEvents: function() {
            this.customEvents = {};
          },
          triggerCustomEvent: function(name, data, editable) {
            if (this.customEvents[name] && !this.disabledEvents[name]) {
              this.customEvents[name].forEach(function(listener) {
                listener(data, editable);
              });
            }
          },
          // Cleaning up
          destroy: function() {
            this.detachAllDOMEvents();
            this.detachAllCustomEvents();
            this.detachExecCommand();
            if (this.base.elements) {
              this.base.elements.forEach(function(element) {
                element.removeAttribute("data-medium-focused");
              });
            }
          },
          // Listening to calls to document.execCommand
          // Attach a listener to be notified when document.execCommand is called
          attachToExecCommand: function() {
            if (this.execCommandListener) {
              return;
            }
            this.execCommandListener = (function(execInfo) {
              this.handleDocumentExecCommand(execInfo);
            }).bind(this);
            this.wrapExecCommand();
            this.options.ownerDocument.execCommand.listeners.push(this.execCommandListener);
          },
          // Remove our listener for calls to document.execCommand
          detachExecCommand: function() {
            var doc = this.options.ownerDocument;
            if (!this.execCommandListener || !doc.execCommand.listeners) {
              return;
            }
            var index = doc.execCommand.listeners.indexOf(this.execCommandListener);
            if (index !== -1) {
              doc.execCommand.listeners.splice(index, 1);
            }
            if (!doc.execCommand.listeners.length) {
              this.unwrapExecCommand();
            }
          },
          // Wrap document.execCommand in a custom method so we can listen to calls to it
          wrapExecCommand: function() {
            var doc = this.options.ownerDocument;
            if (doc.execCommand.listeners) {
              return;
            }
            var callListeners = function(args, result) {
              if (doc.execCommand.listeners) {
                doc.execCommand.listeners.forEach(function(listener) {
                  listener({
                    command: args[0],
                    value: args[2],
                    args,
                    result
                  });
                });
              }
            }, wrapper = function() {
              var result = doc.execCommand.orig.apply(this, arguments);
              if (!doc.execCommand.listeners) {
                return result;
              }
              var args = Array.prototype.slice.call(arguments);
              callListeners(args, result);
              return result;
            };
            wrapper.orig = doc.execCommand;
            wrapper.listeners = [];
            wrapper.callListeners = callListeners;
            doc.execCommand = wrapper;
          },
          // Revert document.execCommand back to its original self
          unwrapExecCommand: function() {
            var doc = this.options.ownerDocument;
            if (!doc.execCommand.orig) {
              return;
            }
            doc.execCommand = doc.execCommand.orig;
          },
          // Listening to browser events to emit events medium-editor cares about
          setupListener: function(name) {
            if (this.listeners[name]) {
              return;
            }
            switch (name) {
              case "externalInteraction":
                this.attachDOMEvent(this.options.ownerDocument.body, "mousedown", this.handleBodyMousedown.bind(this), true);
                this.attachDOMEvent(this.options.ownerDocument.body, "click", this.handleBodyClick.bind(this), true);
                this.attachDOMEvent(this.options.ownerDocument.body, "focus", this.handleBodyFocus.bind(this), true);
                break;
              case "blur":
                this.setupListener("externalInteraction");
                break;
              case "focus":
                this.setupListener("externalInteraction");
                break;
              case "editableInput":
                this.contentCache = {};
                this.base.elements.forEach(function(element) {
                  this.contentCache[element.getAttribute("medium-editor-index")] = element.innerHTML;
                }, this);
                if (this.InputEventOnContenteditableSupported) {
                  this.attachToEachElement("input", this.handleInput);
                }
                if (!this.InputEventOnContenteditableSupported) {
                  this.setupListener("editableKeypress");
                  this.keypressUpdateInput = true;
                  this.attachDOMEvent(document, "selectionchange", this.handleDocumentSelectionChange.bind(this));
                  this.attachToExecCommand();
                }
                break;
              case "editableClick":
                this.attachToEachElement("click", this.handleClick);
                break;
              case "editableBlur":
                this.attachToEachElement("blur", this.handleBlur);
                break;
              case "editableKeypress":
                this.attachToEachElement("keypress", this.handleKeypress);
                break;
              case "editableKeyup":
                this.attachToEachElement("keyup", this.handleKeyup);
                break;
              case "editableKeydown":
                this.attachToEachElement("keydown", this.handleKeydown);
                break;
              case "editableKeydownSpace":
                this.setupListener("editableKeydown");
                break;
              case "editableKeydownEnter":
                this.setupListener("editableKeydown");
                break;
              case "editableKeydownTab":
                this.setupListener("editableKeydown");
                break;
              case "editableKeydownDelete":
                this.setupListener("editableKeydown");
                break;
              case "editableMouseover":
                this.attachToEachElement("mouseover", this.handleMouseover);
                break;
              case "editableDrag":
                this.attachToEachElement("dragover", this.handleDragging);
                this.attachToEachElement("dragleave", this.handleDragging);
                break;
              case "editableDrop":
                this.attachToEachElement("drop", this.handleDrop);
                break;
              case "editablePaste":
                this.attachToEachElement("paste", this.handlePaste);
                break;
            }
            this.listeners[name] = true;
          },
          attachToEachElement: function(name, handler) {
            if (!this.eventsCache) {
              this.eventsCache = [];
            }
            this.base.elements.forEach(function(element) {
              this.attachDOMEvent(element, name, handler.bind(this));
            }, this);
            this.eventsCache.push({ "name": name, "handler": handler });
          },
          cleanupElement: function(element) {
            var index = element.getAttribute("medium-editor-index");
            if (index) {
              this.detachAllEventsFromElement(element);
              if (this.contentCache) {
                delete this.contentCache[index];
              }
            }
          },
          focusElement: function(element) {
            element.focus();
            this.updateFocus(element, { target: element, type: "focus" });
          },
          updateFocus: function(target, eventObj) {
            var hadFocus = this.base.getFocusedElement(), toFocus;
            if (hadFocus && eventObj.type === "click" && this.lastMousedownTarget && (MediumEditor2.util.isDescendant(hadFocus, this.lastMousedownTarget, true) || isElementDescendantOfExtension(this.base.extensions, this.lastMousedownTarget))) {
              toFocus = hadFocus;
            }
            if (!toFocus) {
              this.base.elements.some(function(element) {
                if (!toFocus && MediumEditor2.util.isDescendant(element, target, true)) {
                  toFocus = element;
                }
                return !!toFocus;
              }, this);
            }
            var externalEvent = !MediumEditor2.util.isDescendant(hadFocus, target, true) && !isElementDescendantOfExtension(this.base.extensions, target);
            if (toFocus !== hadFocus) {
              if (hadFocus && externalEvent) {
                hadFocus.removeAttribute("data-medium-focused");
                this.triggerCustomEvent("blur", eventObj, hadFocus);
              }
              if (toFocus) {
                toFocus.setAttribute("data-medium-focused", true);
                this.triggerCustomEvent("focus", eventObj, toFocus);
              }
            }
            if (externalEvent) {
              this.triggerCustomEvent("externalInteraction", eventObj);
            }
          },
          updateInput: function(target, eventObj) {
            if (!this.contentCache) {
              return;
            }
            var index = target.getAttribute("medium-editor-index"), html = target.innerHTML;
            if (html !== this.contentCache[index]) {
              this.triggerCustomEvent("editableInput", eventObj, target);
            }
            this.contentCache[index] = html;
          },
          handleDocumentSelectionChange: function(event) {
            if (event.currentTarget && event.currentTarget.activeElement) {
              var activeElement = event.currentTarget.activeElement, currentTarget;
              this.base.elements.some(function(element) {
                if (MediumEditor2.util.isDescendant(element, activeElement, true)) {
                  currentTarget = element;
                  return true;
                }
                return false;
              }, this);
              if (currentTarget) {
                this.updateInput(currentTarget, { target: activeElement, currentTarget });
              }
            }
          },
          handleDocumentExecCommand: function() {
            var target = this.base.getFocusedElement();
            if (target) {
              this.updateInput(target, { target, currentTarget: target });
            }
          },
          handleBodyClick: function(event) {
            this.updateFocus(event.target, event);
          },
          handleBodyFocus: function(event) {
            this.updateFocus(event.target, event);
          },
          handleBodyMousedown: function(event) {
            this.lastMousedownTarget = event.target;
          },
          handleInput: function(event) {
            this.updateInput(event.currentTarget, event);
          },
          handleClick: function(event) {
            this.triggerCustomEvent("editableClick", event, event.currentTarget);
          },
          handleBlur: function(event) {
            this.triggerCustomEvent("editableBlur", event, event.currentTarget);
          },
          handleKeypress: function(event) {
            this.triggerCustomEvent("editableKeypress", event, event.currentTarget);
            if (this.keypressUpdateInput) {
              var eventObj = { target: event.target, currentTarget: event.currentTarget };
              setTimeout((function() {
                this.updateInput(eventObj.currentTarget, eventObj);
              }).bind(this), 0);
            }
          },
          handleKeyup: function(event) {
            this.triggerCustomEvent("editableKeyup", event, event.currentTarget);
          },
          handleMouseover: function(event) {
            this.triggerCustomEvent("editableMouseover", event, event.currentTarget);
          },
          handleDragging: function(event) {
            this.triggerCustomEvent("editableDrag", event, event.currentTarget);
          },
          handleDrop: function(event) {
            this.triggerCustomEvent("editableDrop", event, event.currentTarget);
          },
          handlePaste: function(event) {
            this.triggerCustomEvent("editablePaste", event, event.currentTarget);
          },
          handleKeydown: function(event) {
            this.triggerCustomEvent("editableKeydown", event, event.currentTarget);
            if (MediumEditor2.util.isKey(event, MediumEditor2.util.keyCode.SPACE)) {
              return this.triggerCustomEvent("editableKeydownSpace", event, event.currentTarget);
            }
            if (MediumEditor2.util.isKey(event, MediumEditor2.util.keyCode.ENTER) || event.ctrlKey && MediumEditor2.util.isKey(event, MediumEditor2.util.keyCode.M)) {
              return this.triggerCustomEvent("editableKeydownEnter", event, event.currentTarget);
            }
            if (MediumEditor2.util.isKey(event, MediumEditor2.util.keyCode.TAB)) {
              return this.triggerCustomEvent("editableKeydownTab", event, event.currentTarget);
            }
            if (MediumEditor2.util.isKey(event, [MediumEditor2.util.keyCode.DELETE, MediumEditor2.util.keyCode.BACKSPACE])) {
              return this.triggerCustomEvent("editableKeydownDelete", event, event.currentTarget);
            }
          }
        };
        MediumEditor2.Events = Events;
      })();
      (function() {
        "use strict";
        var Button = MediumEditor2.Extension.extend({
          /* Button Options */
          /* action: [string]
           * The action argument to pass to MediumEditor.execAction()
           * when the button is clicked
           */
          action: void 0,
          /* aria: [string]
           * The value to add as the aria-label attribute of the button
           * element displayed in the toolbar.
           * This is also used as the tooltip for the button
           */
          aria: void 0,
          /* tagNames: [Array]
           * NOTE: This is not used if useQueryState is set to true.
           *
           * Array of element tag names that would indicate that this
           * button has already been applied. If this action has already
           * been applied, the button will be displayed as 'active' in the toolbar
           *
           * Example:
           * For 'bold', if the text is ever within a <b> or <strong>
           * tag that indicates the text is already bold. So the array
           * of tagNames for bold would be: ['b', 'strong']
           */
          tagNames: void 0,
          /* style: [Object]
           * NOTE: This is not used if useQueryState is set to true.
           *
           * A pair of css property & value(s) that indicate that this
           * button has already been applied. If this action has already
           * been applied, the button will be displayed as 'active' in the toolbar
           * Properties of the object:
           *   prop [String]: name of the css property
           *   value [String]: value(s) of the css property
           *                   multiple values can be separated by a '|'
           *
           * Example:
           * For 'bold', if the text is ever within an element with a 'font-weight'
           * style property set to '700' or 'bold', that indicates the text
           * is already bold.  So the style object for bold would be:
           * { prop: 'font-weight', value: '700|bold' }
           */
          style: void 0,
          /* useQueryState: [boolean]
           * Enables/disables whether this button should use the built-in
           * document.queryCommandState() method to determine whether
           * the action has already been applied.  If the action has already
           * been applied, the button will be displayed as 'active' in the toolbar
           *
           * Example:
           * For 'bold', if this is set to true, the code will call:
           * document.queryCommandState('bold') which will return true if the
           * browser thinks the text is already bold, and false otherwise
           */
          useQueryState: void 0,
          /* contentDefault: [string]
           * Default innerHTML to put inside the button
           */
          contentDefault: void 0,
          /* contentFA: [string]
           * The innerHTML to use for the content of the button
           * if the `buttonLabels` option for MediumEditor is set to 'fontawesome'
           */
          contentFA: void 0,
          /* classList: [Array]
           * An array of classNames (strings) to be added to the button
           */
          classList: void 0,
          /* attrs: [object]
           * A set of key-value pairs to add to the button as custom attributes
           */
          attrs: void 0,
          // The button constructor can optionally accept the name of a built-in button
          // (ie 'bold', 'italic', etc.)
          // When the name of a button is passed, it will initialize itself with the
          // configuration for that button
          constructor: function(options) {
            if (Button.isBuiltInButton(options)) {
              MediumEditor2.Extension.call(this, this.defaults[options]);
            } else {
              MediumEditor2.Extension.call(this, options);
            }
          },
          init: function() {
            MediumEditor2.Extension.prototype.init.apply(this, arguments);
            this.button = this.createButton();
            this.on(this.button, "click", this.handleClick.bind(this));
          },
          /* getButton: [function ()]
           *
           * If implemented, this function will be called when
           * the toolbar is being created.  The DOM Element returned
           * by this function will be appended to the toolbar along
           * with any other buttons.
           */
          getButton: function() {
            return this.button;
          },
          getAction: function() {
            return typeof this.action === "function" ? this.action(this.base.options) : this.action;
          },
          getAria: function() {
            return typeof this.aria === "function" ? this.aria(this.base.options) : this.aria;
          },
          getTagNames: function() {
            return typeof this.tagNames === "function" ? this.tagNames(this.base.options) : this.tagNames;
          },
          createButton: function() {
            var button = this.document.createElement("button"), content = this.contentDefault, ariaLabel = this.getAria(), buttonLabels = this.getEditorOption("buttonLabels");
            button.classList.add("medium-editor-action");
            button.classList.add("medium-editor-action-" + this.name);
            if (this.classList) {
              this.classList.forEach(function(className) {
                button.classList.add(className);
              });
            }
            button.setAttribute("data-action", this.getAction());
            if (ariaLabel) {
              button.setAttribute("title", ariaLabel);
              button.setAttribute("aria-label", ariaLabel);
            }
            if (this.attrs) {
              Object.keys(this.attrs).forEach(function(attr) {
                button.setAttribute(attr, this.attrs[attr]);
              }, this);
            }
            if (buttonLabels === "fontawesome" && this.contentFA) {
              content = this.contentFA;
            }
            button.innerHTML = content;
            return button;
          },
          handleClick: function(event) {
            event.preventDefault();
            event.stopPropagation();
            var action = this.getAction();
            if (action) {
              this.execAction(action);
            }
          },
          isActive: function() {
            return this.button.classList.contains(this.getEditorOption("activeButtonClass"));
          },
          setInactive: function() {
            this.button.classList.remove(this.getEditorOption("activeButtonClass"));
            delete this.knownState;
          },
          setActive: function() {
            this.button.classList.add(this.getEditorOption("activeButtonClass"));
            delete this.knownState;
          },
          queryCommandState: function() {
            var queryState = null;
            if (this.useQueryState) {
              queryState = this.base.queryCommandState(this.getAction());
            }
            return queryState;
          },
          isAlreadyApplied: function(node2) {
            var isMatch = false, tagNames = this.getTagNames(), styleVals, computedStyle;
            if (this.knownState === false || this.knownState === true) {
              return this.knownState;
            }
            if (tagNames && tagNames.length > 0) {
              isMatch = tagNames.indexOf(node2.nodeName.toLowerCase()) !== -1;
            }
            if (!isMatch && this.style) {
              styleVals = this.style.value.split("|");
              computedStyle = this.window.getComputedStyle(node2, null).getPropertyValue(this.style.prop);
              styleVals.forEach(function(val) {
                if (!this.knownState) {
                  isMatch = computedStyle.indexOf(val) !== -1;
                  if (isMatch || this.style.prop !== "text-decoration") {
                    this.knownState = isMatch;
                  }
                }
              }, this);
            }
            return isMatch;
          }
        });
        Button.isBuiltInButton = function(name) {
          return typeof name === "string" && MediumEditor2.extensions.button.prototype.defaults.hasOwnProperty(name);
        };
        MediumEditor2.extensions.button = Button;
      })();
      (function() {
        "use strict";
        MediumEditor2.extensions.button.prototype.defaults = {
          "bold": {
            name: "bold",
            action: "bold",
            aria: "bold",
            tagNames: ["b", "strong"],
            style: {
              prop: "font-weight",
              value: "700|bold"
            },
            useQueryState: true,
            contentDefault: "<b>B</b>",
            contentFA: '<i class="fa fa-bold"></i>'
          },
          "italic": {
            name: "italic",
            action: "italic",
            aria: "italic",
            tagNames: ["i", "em"],
            style: {
              prop: "font-style",
              value: "italic"
            },
            useQueryState: true,
            contentDefault: "<b><i>I</i></b>",
            contentFA: '<i class="fa fa-italic"></i>'
          },
          "underline": {
            name: "underline",
            action: "underline",
            aria: "underline",
            tagNames: ["u"],
            style: {
              prop: "text-decoration",
              value: "underline"
            },
            useQueryState: true,
            contentDefault: "<b><u>U</u></b>",
            contentFA: '<i class="fa fa-underline"></i>'
          },
          "strikethrough": {
            name: "strikethrough",
            action: "strikethrough",
            aria: "strike through",
            tagNames: ["strike"],
            style: {
              prop: "text-decoration",
              value: "line-through"
            },
            useQueryState: true,
            contentDefault: "<s>A</s>",
            contentFA: '<i class="fa fa-strikethrough"></i>'
          },
          "superscript": {
            name: "superscript",
            action: "superscript",
            aria: "superscript",
            tagNames: ["sup"],
            /* firefox doesn't behave the way we want it to, so we CAN'T use queryCommandState for superscript
               https://github.com/guardian/scribe/blob/master/BROWSERINCONSISTENCIES.md#documentquerycommandstate */
            // useQueryState: true
            contentDefault: "<b>x<sup>1</sup></b>",
            contentFA: '<i class="fa fa-superscript"></i>'
          },
          "subscript": {
            name: "subscript",
            action: "subscript",
            aria: "subscript",
            tagNames: ["sub"],
            /* firefox doesn't behave the way we want it to, so we CAN'T use queryCommandState for subscript
               https://github.com/guardian/scribe/blob/master/BROWSERINCONSISTENCIES.md#documentquerycommandstate */
            // useQueryState: true
            contentDefault: "<b>x<sub>1</sub></b>",
            contentFA: '<i class="fa fa-subscript"></i>'
          },
          "image": {
            name: "image",
            action: "image",
            aria: "image",
            tagNames: ["img"],
            contentDefault: "<b>image</b>",
            contentFA: '<i class="fa fa-picture-o"></i>'
          },
          "html": {
            name: "html",
            action: "html",
            aria: "evaluate html",
            tagNames: ["iframe", "object"],
            contentDefault: "<b>html</b>",
            contentFA: '<i class="fa fa-code"></i>'
          },
          "orderedlist": {
            name: "orderedlist",
            action: "insertorderedlist",
            aria: "ordered list",
            tagNames: ["ol"],
            useQueryState: true,
            contentDefault: "<b>1.</b>",
            contentFA: '<i class="fa fa-list-ol"></i>'
          },
          "unorderedlist": {
            name: "unorderedlist",
            action: "insertunorderedlist",
            aria: "unordered list",
            tagNames: ["ul"],
            useQueryState: true,
            contentDefault: "<b>&bull;</b>",
            contentFA: '<i class="fa fa-list-ul"></i>'
          },
          "indent": {
            name: "indent",
            action: "indent",
            aria: "indent",
            tagNames: [],
            contentDefault: "<b>&rarr;</b>",
            contentFA: '<i class="fa fa-indent"></i>'
          },
          "outdent": {
            name: "outdent",
            action: "outdent",
            aria: "outdent",
            tagNames: [],
            contentDefault: "<b>&larr;</b>",
            contentFA: '<i class="fa fa-outdent"></i>'
          },
          "justifyCenter": {
            name: "justifyCenter",
            action: "justifyCenter",
            aria: "center justify",
            tagNames: [],
            style: {
              prop: "text-align",
              value: "center"
            },
            contentDefault: "<b>C</b>",
            contentFA: '<i class="fa fa-align-center"></i>'
          },
          "justifyFull": {
            name: "justifyFull",
            action: "justifyFull",
            aria: "full justify",
            tagNames: [],
            style: {
              prop: "text-align",
              value: "justify"
            },
            contentDefault: "<b>J</b>",
            contentFA: '<i class="fa fa-align-justify"></i>'
          },
          "justifyLeft": {
            name: "justifyLeft",
            action: "justifyLeft",
            aria: "left justify",
            tagNames: [],
            style: {
              prop: "text-align",
              value: "left"
            },
            contentDefault: "<b>L</b>",
            contentFA: '<i class="fa fa-align-left"></i>'
          },
          "justifyRight": {
            name: "justifyRight",
            action: "justifyRight",
            aria: "right justify",
            tagNames: [],
            style: {
              prop: "text-align",
              value: "right"
            },
            contentDefault: "<b>R</b>",
            contentFA: '<i class="fa fa-align-right"></i>'
          },
          // Known inline elements that are not removed, or not removed consistantly across browsers:
          // <span>, <label>, <br>
          "removeFormat": {
            name: "removeFormat",
            aria: "remove formatting",
            action: "removeFormat",
            contentDefault: "<b>X</b>",
            contentFA: '<i class="fa fa-eraser"></i>'
          },
          /***** Buttons for appending block elements (append-<element> action) *****/
          "quote": {
            name: "quote",
            action: "append-blockquote",
            aria: "blockquote",
            tagNames: ["blockquote"],
            contentDefault: "<b>&ldquo;</b>",
            contentFA: '<i class="fa fa-quote-right"></i>'
          },
          "pre": {
            name: "pre",
            action: "append-pre",
            aria: "preformatted text",
            tagNames: ["pre"],
            contentDefault: "<b>0101</b>",
            contentFA: '<i class="fa fa-code fa-lg"></i>'
          },
          "h1": {
            name: "h1",
            action: "append-h1",
            aria: "header type one",
            tagNames: ["h1"],
            contentDefault: "<b>H1</b>",
            contentFA: '<i class="fa fa-header"><sup>1</sup>'
          },
          "h2": {
            name: "h2",
            action: "append-h2",
            aria: "header type two",
            tagNames: ["h2"],
            contentDefault: "<b>H2</b>",
            contentFA: '<i class="fa fa-header"><sup>2</sup>'
          },
          "h3": {
            name: "h3",
            action: "append-h3",
            aria: "header type three",
            tagNames: ["h3"],
            contentDefault: "<b>H3</b>",
            contentFA: '<i class="fa fa-header"><sup>3</sup>'
          },
          "h4": {
            name: "h4",
            action: "append-h4",
            aria: "header type four",
            tagNames: ["h4"],
            contentDefault: "<b>H4</b>",
            contentFA: '<i class="fa fa-header"><sup>4</sup>'
          },
          "h5": {
            name: "h5",
            action: "append-h5",
            aria: "header type five",
            tagNames: ["h5"],
            contentDefault: "<b>H5</b>",
            contentFA: '<i class="fa fa-header"><sup>5</sup>'
          },
          "h6": {
            name: "h6",
            action: "append-h6",
            aria: "header type six",
            tagNames: ["h6"],
            contentDefault: "<b>H6</b>",
            contentFA: '<i class="fa fa-header"><sup>6</sup>'
          }
        };
      })();
      (function() {
        "use strict";
        var FormExtension = MediumEditor2.extensions.button.extend({
          init: function() {
            MediumEditor2.extensions.button.prototype.init.apply(this, arguments);
          },
          // default labels for the form buttons
          formSaveLabel: "&#10003;",
          formCloseLabel: "&times;",
          /* activeClass: [string]
           * set class which added to shown form
           */
          activeClass: "medium-editor-toolbar-form-active",
          /* hasForm: [boolean]
           *
           * Setting this to true will cause getForm() to be called
           * when the toolbar is created, so the form can be appended
           * inside the toolbar container
           */
          hasForm: true,
          /* getForm: [function ()]
           *
           * When hasForm is true, this function must be implemented
           * and return a DOM Element which will be appended to
           * the toolbar container. The form should start hidden, and
           * the extension can choose when to hide/show it
           */
          getForm: function() {
          },
          /* isDisplayed: [function ()]
           *
           * This function should return true/false reflecting
           * whether the form is currently displayed
           */
          isDisplayed: function() {
            if (this.hasForm) {
              return this.getForm().classList.contains(this.activeClass);
            }
            return false;
          },
          /* hideForm: [function ()]
           *
           * This function should show the form element inside
           * the toolbar container
           */
          showForm: function() {
            if (this.hasForm) {
              this.getForm().classList.add(this.activeClass);
            }
          },
          /* hideForm: [function ()]
           *
           * This function should hide the form element inside
           * the toolbar container
           */
          hideForm: function() {
            if (this.hasForm) {
              this.getForm().classList.remove(this.activeClass);
            }
          },
          /************************ Helpers ************************
           * The following are helpers that are either set by MediumEditor
           * during initialization, or are helper methods which either
           * route calls to the MediumEditor instance or provide common
           * functionality for all form extensions
           *********************************************************/
          /* showToolbarDefaultActions: [function ()]
           *
           * Helper method which will turn back the toolbar after canceling
           * the customized form
           */
          showToolbarDefaultActions: function() {
            var toolbar = this.base.getExtensionByName("toolbar");
            if (toolbar) {
              toolbar.showToolbarDefaultActions();
            }
          },
          /* hideToolbarDefaultActions: [function ()]
           *
           * Helper function which will hide the default contents of the
           * toolbar, but leave the toolbar container in the same state
           * to allow a form to display its custom contents inside the toolbar
           */
          hideToolbarDefaultActions: function() {
            var toolbar = this.base.getExtensionByName("toolbar");
            if (toolbar) {
              toolbar.hideToolbarDefaultActions();
            }
          },
          /* setToolbarPosition: [function ()]
           *
           * Helper function which will update the size and position
           * of the toolbar based on the toolbar content and the current
           * position of the user's selection
           */
          setToolbarPosition: function() {
            var toolbar = this.base.getExtensionByName("toolbar");
            if (toolbar) {
              toolbar.setToolbarPosition();
            }
          }
        });
        MediumEditor2.extensions.form = FormExtension;
      })();
      (function() {
        "use strict";
        var AnchorForm = MediumEditor2.extensions.form.extend({
          /* Anchor Form Options */
          /* customClassOption: [string]  (previously options.anchorButton + options.anchorButtonClass)
           * Custom class name the user can optionally have added to their created links (ie 'button').
           * If passed as a non-empty string, a checkbox will be displayed allowing the user to choose
           * whether to have the class added to the created link or not.
           */
          customClassOption: null,
          /* customClassOptionText: [string]
           * text to be shown in the checkbox when the __customClassOption__ is being used.
           */
          customClassOptionText: "Button",
          /* linkValidation: [boolean]  (previously options.checkLinkFormat)
           * enables/disables check for common URL protocols on anchor links.
           */
          linkValidation: false,
          /* placeholderText: [string]  (previously options.anchorInputPlaceholder)
           * text to be shown as placeholder of the anchor input.
           */
          placeholderText: "Paste or type a link",
          /* targetCheckbox: [boolean]  (previously options.anchorTarget)
           * enables/disables displaying a "Open in new window" checkbox, which when checked
           * changes the `target` attribute of the created link.
           */
          targetCheckbox: false,
          /* targetCheckboxText: [string]  (previously options.anchorInputCheckboxLabel)
           * text to be shown in the checkbox enabled via the __targetCheckbox__ option.
           */
          targetCheckboxText: "Open in new window",
          // Options for the Button base class
          name: "anchor",
          action: "createLink",
          aria: "link",
          tagNames: ["a"],
          contentDefault: "<b>#</b>",
          contentFA: '<i class="fa fa-link"></i>',
          init: function() {
            MediumEditor2.extensions.form.prototype.init.apply(this, arguments);
            this.subscribe("editableKeydown", this.handleKeydown.bind(this));
          },
          // Called when the button the toolbar is clicked
          // Overrides ButtonExtension.handleClick
          handleClick: function(event) {
            event.preventDefault();
            event.stopPropagation();
            var range = MediumEditor2.selection.getSelectionRange(this.document);
            if (range.startContainer.nodeName.toLowerCase() === "a" || range.endContainer.nodeName.toLowerCase() === "a" || MediumEditor2.util.getClosestTag(MediumEditor2.selection.getSelectedParentElement(range), "a")) {
              return this.execAction("unlink");
            }
            if (!this.isDisplayed()) {
              this.showForm();
            }
            return false;
          },
          // Called when user hits the defined shortcut (CTRL / COMMAND + K)
          handleKeydown: function(event) {
            if (MediumEditor2.util.isKey(event, MediumEditor2.util.keyCode.K) && MediumEditor2.util.isMetaCtrlKey(event) && !event.shiftKey) {
              this.handleClick(event);
            }
          },
          // Called by medium-editor to append form to the toolbar
          getForm: function() {
            if (!this.form) {
              this.form = this.createForm();
            }
            return this.form;
          },
          getTemplate: function() {
            var template = [
              '<input type="text" class="medium-editor-toolbar-input" placeholder="',
              this.placeholderText,
              '">'
            ];
            template.push(
              '<a href="#" class="medium-editor-toolbar-save">',
              this.getEditorOption("buttonLabels") === "fontawesome" ? '<i class="fa fa-check"></i>' : this.formSaveLabel,
              "</a>"
            );
            template.push(
              '<a href="#" class="medium-editor-toolbar-close">',
              this.getEditorOption("buttonLabels") === "fontawesome" ? '<i class="fa fa-times"></i>' : this.formCloseLabel,
              "</a>"
            );
            if (this.targetCheckbox) {
              template.push(
                '<div class="medium-editor-toolbar-form-row">',
                '<input type="checkbox" class="medium-editor-toolbar-anchor-target" id="medium-editor-toolbar-anchor-target-field-' + this.getEditorId() + '">',
                '<label for="medium-editor-toolbar-anchor-target-field-' + this.getEditorId() + '">',
                this.targetCheckboxText,
                "</label>",
                "</div>"
              );
            }
            if (this.customClassOption) {
              template.push(
                '<div class="medium-editor-toolbar-form-row">',
                '<input type="checkbox" class="medium-editor-toolbar-anchor-button">',
                "<label>",
                this.customClassOptionText,
                "</label>",
                "</div>"
              );
            }
            return template.join("");
          },
          // Used by medium-editor when the default toolbar is to be displayed
          isDisplayed: function() {
            return MediumEditor2.extensions.form.prototype.isDisplayed.apply(this);
          },
          hideForm: function() {
            MediumEditor2.extensions.form.prototype.hideForm.apply(this);
            this.getInput().value = "";
          },
          showForm: function(opts) {
            var input = this.getInput(), targetCheckbox = this.getAnchorTargetCheckbox(), buttonCheckbox = this.getAnchorButtonCheckbox();
            opts = opts || { value: "" };
            if (typeof opts === "string") {
              opts = {
                value: opts
              };
            }
            this.base.saveSelection();
            this.hideToolbarDefaultActions();
            MediumEditor2.extensions.form.prototype.showForm.apply(this);
            this.setToolbarPosition();
            input.value = opts.value;
            input.focus();
            if (targetCheckbox) {
              targetCheckbox.checked = opts.target === "_blank";
            }
            if (buttonCheckbox) {
              var classList = opts.buttonClass ? opts.buttonClass.split(" ") : [];
              buttonCheckbox.checked = classList.indexOf(this.customClassOption) !== -1;
            }
          },
          // Called by core when tearing down medium-editor (destroy)
          destroy: function() {
            if (!this.form) {
              return false;
            }
            if (this.form.parentNode) {
              this.form.parentNode.removeChild(this.form);
            }
            delete this.form;
          },
          // core methods
          getFormOpts: function() {
            var targetCheckbox = this.getAnchorTargetCheckbox(), buttonCheckbox = this.getAnchorButtonCheckbox(), opts = {
              value: this.getInput().value.trim()
            };
            if (this.linkValidation) {
              opts.value = this.checkLinkFormat(opts.value);
            }
            opts.target = "_self";
            if (targetCheckbox && targetCheckbox.checked) {
              opts.target = "_blank";
            }
            if (buttonCheckbox && buttonCheckbox.checked) {
              opts.buttonClass = this.customClassOption;
            }
            return opts;
          },
          doFormSave: function() {
            var opts = this.getFormOpts();
            this.completeFormSave(opts);
          },
          completeFormSave: function(opts) {
            this.base.restoreSelection();
            this.execAction(this.action, opts);
            this.base.checkSelection();
          },
          ensureEncodedUri: function(str) {
            return str === decodeURI(str) ? encodeURI(str) : str;
          },
          ensureEncodedUriComponent: function(str) {
            return str === decodeURIComponent(str) ? encodeURIComponent(str) : str;
          },
          ensureEncodedParam: function(param) {
            var split = param.split("="), key = split[0], val = split[1];
            return key + (val === void 0 ? "" : "=" + this.ensureEncodedUriComponent(val));
          },
          ensureEncodedQuery: function(queryString) {
            return queryString.split("&").map(this.ensureEncodedParam.bind(this)).join("&");
          },
          checkLinkFormat: function(value) {
            var urlSchemeRegex = /^([a-z]+:)?\/\/|^(mailto|tel|maps):|^\#/i, hasScheme = urlSchemeRegex.test(value), scheme = "", telRegex = /^\+?\s?\(?(?:\d\s?\-?\)?){3,20}$/, urlParts = value.match(/^(.*?)(?:\?(.*?))?(?:#(.*))?$/), path = urlParts[1], query = urlParts[2], fragment = urlParts[3];
            if (telRegex.test(value)) {
              return "tel:" + value;
            }
            if (!hasScheme) {
              var host = path.split("/")[0];
              if (host.match(/.+(\.|:).+/) || host === "localhost") {
                scheme = "http://";
              }
            }
            return scheme + // Ensure path is encoded
            this.ensureEncodedUri(path) + // Ensure query is encoded
            (query === void 0 ? "" : "?" + this.ensureEncodedQuery(query)) + // Include fragment unencoded as encodeUriComponent is too
            // heavy handed for the many characters allowed in a fragment
            (fragment === void 0 ? "" : "#" + fragment);
          },
          doFormCancel: function() {
            this.base.restoreSelection();
            this.base.checkSelection();
          },
          // form creation and event handling
          attachFormEvents: function(form) {
            var close = form.querySelector(".medium-editor-toolbar-close"), save = form.querySelector(".medium-editor-toolbar-save"), input = form.querySelector(".medium-editor-toolbar-input");
            this.on(form, "click", this.handleFormClick.bind(this));
            this.on(input, "keyup", this.handleTextboxKeyup.bind(this));
            this.on(close, "click", this.handleCloseClick.bind(this));
            this.on(save, "click", this.handleSaveClick.bind(this), true);
          },
          createForm: function() {
            var doc = this.document, form = doc.createElement("div");
            form.className = "medium-editor-toolbar-form";
            form.id = "medium-editor-toolbar-form-anchor-" + this.getEditorId();
            form.innerHTML = this.getTemplate();
            this.attachFormEvents(form);
            return form;
          },
          getInput: function() {
            return this.getForm().querySelector("input.medium-editor-toolbar-input");
          },
          getAnchorTargetCheckbox: function() {
            return this.getForm().querySelector(".medium-editor-toolbar-anchor-target");
          },
          getAnchorButtonCheckbox: function() {
            return this.getForm().querySelector(".medium-editor-toolbar-anchor-button");
          },
          handleTextboxKeyup: function(event) {
            if (event.keyCode === MediumEditor2.util.keyCode.ENTER) {
              event.preventDefault();
              this.doFormSave();
              return;
            }
            if (event.keyCode === MediumEditor2.util.keyCode.ESCAPE) {
              event.preventDefault();
              this.doFormCancel();
            }
          },
          handleFormClick: function(event) {
            event.stopPropagation();
          },
          handleSaveClick: function(event) {
            event.preventDefault();
            this.doFormSave();
          },
          handleCloseClick: function(event) {
            event.preventDefault();
            this.doFormCancel();
          }
        });
        MediumEditor2.extensions.anchor = AnchorForm;
      })();
      (function() {
        "use strict";
        var AnchorPreview = MediumEditor2.Extension.extend({
          name: "anchor-preview",
          // Anchor Preview Options
          /* hideDelay: [number]  (previously options.anchorPreviewHideDelay)
           * time in milliseconds to show the anchor tag preview after the mouse has left the anchor tag.
           */
          hideDelay: 500,
          /* previewValueSelector: [string]
           * the default selector to locate where to put the activeAnchor value in the preview
           */
          previewValueSelector: "a",
          /* showWhenToolbarIsVisible: [boolean]
           * determines whether the anchor tag preview shows up when the toolbar is visible
           */
          showWhenToolbarIsVisible: false,
          /* showOnEmptyLinks: [boolean]
          * determines whether the anchor tag preview shows up on links with href="" or href="#something"
          */
          showOnEmptyLinks: true,
          init: function() {
            this.anchorPreview = this.createPreview();
            this.getEditorOption("elementsContainer").appendChild(this.anchorPreview);
            this.attachToEditables();
          },
          getInteractionElements: function() {
            return this.getPreviewElement();
          },
          // TODO: Remove this function in 6.0.0
          getPreviewElement: function() {
            return this.anchorPreview;
          },
          createPreview: function() {
            var el = this.document.createElement("div");
            el.id = "medium-editor-anchor-preview-" + this.getEditorId();
            el.className = "medium-editor-anchor-preview";
            el.innerHTML = this.getTemplate();
            this.on(el, "click", this.handleClick.bind(this));
            return el;
          },
          getTemplate: function() {
            return '<div class="medium-editor-toolbar-anchor-preview" id="medium-editor-toolbar-anchor-preview">    <a class="medium-editor-toolbar-anchor-preview-inner"></a></div>';
          },
          destroy: function() {
            if (this.anchorPreview) {
              if (this.anchorPreview.parentNode) {
                this.anchorPreview.parentNode.removeChild(this.anchorPreview);
              }
              delete this.anchorPreview;
            }
          },
          hidePreview: function() {
            if (this.anchorPreview) {
              this.anchorPreview.classList.remove("medium-editor-anchor-preview-active");
            }
            this.activeAnchor = null;
          },
          showPreview: function(anchorEl) {
            if (this.anchorPreview.classList.contains("medium-editor-anchor-preview-active") || anchorEl.getAttribute("data-disable-preview")) {
              return true;
            }
            if (this.previewValueSelector) {
              this.anchorPreview.querySelector(this.previewValueSelector).textContent = anchorEl.attributes.href.value;
              this.anchorPreview.querySelector(this.previewValueSelector).href = anchorEl.attributes.href.value;
            }
            this.anchorPreview.classList.add("medium-toolbar-arrow-over");
            this.anchorPreview.classList.remove("medium-toolbar-arrow-under");
            if (!this.anchorPreview.classList.contains("medium-editor-anchor-preview-active")) {
              this.anchorPreview.classList.add("medium-editor-anchor-preview-active");
            }
            this.activeAnchor = anchorEl;
            this.positionPreview();
            this.attachPreviewHandlers();
            return this;
          },
          positionPreview: function(activeAnchor) {
            activeAnchor = activeAnchor || this.activeAnchor;
            var containerWidth = this.window.innerWidth, buttonHeight = this.anchorPreview.offsetHeight, boundary = activeAnchor.getBoundingClientRect(), diffLeft = this.diffLeft, diffTop = this.diffTop, elementsContainer = this.getEditorOption("elementsContainer"), elementsContainerAbsolute = ["absolute", "fixed"].indexOf(window.getComputedStyle(elementsContainer).getPropertyValue("position")) > -1, relativeBoundary = {}, halfOffsetWidth, defaultLeft, middleBoundary, elementsContainerBoundary, top;
            halfOffsetWidth = this.anchorPreview.offsetWidth / 2;
            var toolbarExtension = this.base.getExtensionByName("toolbar");
            if (toolbarExtension) {
              diffLeft = toolbarExtension.diffLeft;
              diffTop = toolbarExtension.diffTop;
            }
            defaultLeft = diffLeft - halfOffsetWidth;
            if (elementsContainerAbsolute) {
              elementsContainerBoundary = elementsContainer.getBoundingClientRect();
              ["top", "left"].forEach(function(key) {
                relativeBoundary[key] = boundary[key] - elementsContainerBoundary[key];
              });
              relativeBoundary.width = boundary.width;
              relativeBoundary.height = boundary.height;
              boundary = relativeBoundary;
              containerWidth = elementsContainerBoundary.width;
              top = elementsContainer.scrollTop;
            } else {
              top = this.window.pageYOffset;
            }
            middleBoundary = boundary.left + boundary.width / 2;
            top += buttonHeight + boundary.top + boundary.height - diffTop - this.anchorPreview.offsetHeight;
            this.anchorPreview.style.top = Math.round(top) + "px";
            this.anchorPreview.style.right = "initial";
            if (middleBoundary < halfOffsetWidth) {
              this.anchorPreview.style.left = defaultLeft + halfOffsetWidth + "px";
              this.anchorPreview.style.right = "initial";
            } else if (containerWidth - middleBoundary < halfOffsetWidth) {
              this.anchorPreview.style.left = "auto";
              this.anchorPreview.style.right = 0;
            } else {
              this.anchorPreview.style.left = defaultLeft + middleBoundary + "px";
              this.anchorPreview.style.right = "initial";
            }
          },
          attachToEditables: function() {
            this.subscribe("editableMouseover", this.handleEditableMouseover.bind(this));
            this.subscribe("positionedToolbar", this.handlePositionedToolbar.bind(this));
          },
          handlePositionedToolbar: function() {
            if (!this.showWhenToolbarIsVisible) {
              this.hidePreview();
            }
          },
          handleClick: function(event) {
            var anchorExtension = this.base.getExtensionByName("anchor"), activeAnchor = this.activeAnchor;
            if (anchorExtension && activeAnchor) {
              event.preventDefault();
              this.base.selectElement(this.activeAnchor);
              this.base.delay((function() {
                if (activeAnchor) {
                  var opts = {
                    value: activeAnchor.attributes.href.value,
                    target: activeAnchor.getAttribute("target"),
                    buttonClass: activeAnchor.getAttribute("class")
                  };
                  anchorExtension.showForm(opts);
                  activeAnchor = null;
                }
              }).bind(this));
            }
            this.hidePreview();
          },
          handleAnchorMouseout: function() {
            this.anchorToPreview = null;
            this.off(this.activeAnchor, "mouseout", this.instanceHandleAnchorMouseout);
            this.instanceHandleAnchorMouseout = null;
          },
          handleEditableMouseover: function(event) {
            var target = MediumEditor2.util.getClosestTag(event.target, "a");
            if (false === target) {
              return;
            }
            if (!this.showOnEmptyLinks && (!/href=["']\S+["']/.test(target.outerHTML) || /href=["']#\S+["']/.test(target.outerHTML))) {
              return true;
            }
            var toolbar = this.base.getExtensionByName("toolbar");
            if (!this.showWhenToolbarIsVisible && toolbar && toolbar.isDisplayed && toolbar.isDisplayed()) {
              return true;
            }
            if (this.activeAnchor && this.activeAnchor !== target) {
              this.detachPreviewHandlers();
            }
            this.anchorToPreview = target;
            this.instanceHandleAnchorMouseout = this.handleAnchorMouseout.bind(this);
            this.on(this.anchorToPreview, "mouseout", this.instanceHandleAnchorMouseout);
            this.base.delay((function() {
              if (this.anchorToPreview) {
                this.showPreview(this.anchorToPreview);
              }
            }).bind(this));
          },
          handlePreviewMouseover: function() {
            this.lastOver = (/* @__PURE__ */ new Date()).getTime();
            this.hovering = true;
          },
          handlePreviewMouseout: function(event) {
            if (!event.relatedTarget || !/anchor-preview/.test(event.relatedTarget.className)) {
              this.hovering = false;
            }
          },
          updatePreview: function() {
            if (this.hovering) {
              return true;
            }
            var durr = (/* @__PURE__ */ new Date()).getTime() - this.lastOver;
            if (durr > this.hideDelay) {
              this.detachPreviewHandlers();
            }
          },
          detachPreviewHandlers: function() {
            clearInterval(this.intervalTimer);
            if (this.instanceHandlePreviewMouseover) {
              this.off(this.anchorPreview, "mouseover", this.instanceHandlePreviewMouseover);
              this.off(this.anchorPreview, "mouseout", this.instanceHandlePreviewMouseout);
              if (this.activeAnchor) {
                this.off(this.activeAnchor, "mouseover", this.instanceHandlePreviewMouseover);
                this.off(this.activeAnchor, "mouseout", this.instanceHandlePreviewMouseout);
              }
            }
            this.hidePreview();
            this.hovering = this.instanceHandlePreviewMouseover = this.instanceHandlePreviewMouseout = null;
          },
          // TODO: break up method and extract out handlers
          attachPreviewHandlers: function() {
            this.lastOver = (/* @__PURE__ */ new Date()).getTime();
            this.hovering = true;
            this.instanceHandlePreviewMouseover = this.handlePreviewMouseover.bind(this);
            this.instanceHandlePreviewMouseout = this.handlePreviewMouseout.bind(this);
            this.intervalTimer = setInterval(this.updatePreview.bind(this), 200);
            this.on(this.anchorPreview, "mouseover", this.instanceHandlePreviewMouseover);
            this.on(this.anchorPreview, "mouseout", this.instanceHandlePreviewMouseout);
            this.on(this.activeAnchor, "mouseover", this.instanceHandlePreviewMouseover);
            this.on(this.activeAnchor, "mouseout", this.instanceHandlePreviewMouseout);
          }
        });
        MediumEditor2.extensions.anchorPreview = AnchorPreview;
      })();
      (function() {
        "use strict";
        var WHITESPACE_CHARS, KNOWN_TLDS_FRAGMENT, LINK_REGEXP_TEXT, KNOWN_TLDS_REGEXP, LINK_REGEXP;
        WHITESPACE_CHARS = [
          " ",
          "	",
          "\n",
          "\r",
          " ",
          " ",
          " ",
          " ",
          " ",
          "\u2028",
          "\u2029"
        ];
        KNOWN_TLDS_FRAGMENT = "com|net|org|edu|gov|mil|aero|asia|biz|cat|coop|info|int|jobs|mobi|museum|name|post|pro|tel|travel|xxx|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cs|cu|cv|cx|cy|cz|dd|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|ja|sk|sl|sm|sn|so|sr|ss|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw";
        LINK_REGEXP_TEXT = "(((?:(https?://|ftps?://|nntp://)|www\\d{0,3}[.]|[a-z0-9.\\-]+[.](" + KNOWN_TLDS_FRAGMENT + ")\\/)\\S+(?:[^\\s`!\\[\\]{};:'\".,?«»“”‘’])))|(([a-z0-9\\-]+\\.)?[a-z0-9\\-]+\\.(" + KNOWN_TLDS_FRAGMENT + "))";
        KNOWN_TLDS_REGEXP = new RegExp("^(" + KNOWN_TLDS_FRAGMENT + ")$", "i");
        LINK_REGEXP = new RegExp(LINK_REGEXP_TEXT, "gi");
        function nodeIsNotInsideAnchorTag(node2) {
          return !MediumEditor2.util.getClosestTag(node2, "a");
        }
        var AutoLink = MediumEditor2.Extension.extend({
          init: function() {
            MediumEditor2.Extension.prototype.init.apply(this, arguments);
            this.disableEventHandling = false;
            this.subscribe("editableKeypress", this.onKeypress.bind(this));
            this.subscribe("editableBlur", this.onBlur.bind(this));
            this.document.execCommand("AutoUrlDetect", false, false);
          },
          isLastInstance: function() {
            var activeInstances = 0;
            for (var i = 0; i < this.window._mediumEditors.length; i++) {
              var editor = this.window._mediumEditors[i];
              if (editor !== null && editor.getExtensionByName("autoLink") !== void 0) {
                activeInstances++;
              }
            }
            return activeInstances === 1;
          },
          destroy: function() {
            if (this.document.queryCommandSupported("AutoUrlDetect") && this.isLastInstance()) {
              this.document.execCommand("AutoUrlDetect", false, true);
            }
          },
          onBlur: function(blurEvent, editable) {
            this.performLinking(editable);
          },
          onKeypress: function(keyPressEvent) {
            if (this.disableEventHandling) {
              return;
            }
            if (MediumEditor2.util.isKey(keyPressEvent, [MediumEditor2.util.keyCode.SPACE, MediumEditor2.util.keyCode.ENTER])) {
              clearTimeout(this.performLinkingTimeout);
              this.performLinkingTimeout = setTimeout((function() {
                try {
                  var sel = this.base.exportSelection();
                  if (this.performLinking(keyPressEvent.target)) {
                    this.base.importSelection(sel, true);
                  }
                } catch (e) {
                  if (window.console) {
                    window.console.error("Failed to perform linking", e);
                  }
                  this.disableEventHandling = true;
                }
              }).bind(this), 0);
            }
          },
          performLinking: function(contenteditable) {
            var blockElements = MediumEditor2.util.splitByBlockElements(contenteditable), documentModified = false;
            if (blockElements.length === 0) {
              blockElements = [contenteditable];
            }
            for (var i = 0; i < blockElements.length; i++) {
              documentModified = this.removeObsoleteAutoLinkSpans(blockElements[i]) || documentModified;
              documentModified = this.performLinkingWithinElement(blockElements[i]) || documentModified;
            }
            this.base.events.updateInput(contenteditable, { target: contenteditable, currentTarget: contenteditable });
            return documentModified;
          },
          removeObsoleteAutoLinkSpans: function(element) {
            if (!element || element.nodeType === 3) {
              return false;
            }
            var spans = element.querySelectorAll('span[data-auto-link="true"]'), documentModified = false;
            for (var i = 0; i < spans.length; i++) {
              var textContent = spans[i].textContent;
              if (textContent.indexOf("://") === -1) {
                textContent = MediumEditor2.util.ensureUrlHasProtocol(textContent);
              }
              if (spans[i].getAttribute("data-href") !== textContent && nodeIsNotInsideAnchorTag(spans[i])) {
                documentModified = true;
                var trimmedTextContent = textContent.replace(/\s+$/, "");
                if (spans[i].getAttribute("data-href") === trimmedTextContent) {
                  var charactersTrimmed = textContent.length - trimmedTextContent.length, subtree = MediumEditor2.util.splitOffDOMTree(spans[i], this.splitTextBeforeEnd(spans[i], charactersTrimmed));
                  spans[i].parentNode.insertBefore(subtree, spans[i].nextSibling);
                } else {
                  MediumEditor2.util.unwrap(spans[i], this.document);
                }
              }
            }
            return documentModified;
          },
          splitTextBeforeEnd: function(element, characterCount) {
            var treeWalker = this.document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false), lastChildNotExhausted = true;
            while (lastChildNotExhausted) {
              lastChildNotExhausted = treeWalker.lastChild() !== null;
            }
            var currentNode, currentNodeValue, previousNode;
            while (characterCount > 0 && previousNode !== null) {
              currentNode = treeWalker.currentNode;
              currentNodeValue = currentNode.nodeValue;
              if (currentNodeValue.length > characterCount) {
                previousNode = currentNode.splitText(currentNodeValue.length - characterCount);
                characterCount = 0;
              } else {
                previousNode = treeWalker.previousNode();
                characterCount -= currentNodeValue.length;
              }
            }
            return previousNode;
          },
          performLinkingWithinElement: function(element) {
            var matches = this.findLinkableText(element), linkCreated = false;
            for (var matchIndex = 0; matchIndex < matches.length; matchIndex++) {
              var matchingTextNodes = MediumEditor2.util.findOrCreateMatchingTextNodes(
                this.document,
                element,
                matches[matchIndex]
              );
              if (this.shouldNotLink(matchingTextNodes)) {
                continue;
              }
              this.createAutoLink(matchingTextNodes, matches[matchIndex].href);
            }
            return linkCreated;
          },
          shouldNotLink: function(textNodes) {
            var shouldNotLink = false;
            for (var i = 0; i < textNodes.length && shouldNotLink === false; i++) {
              shouldNotLink = !!MediumEditor2.util.traverseUp(textNodes[i], function(node2) {
                return node2.nodeName.toLowerCase() === "a" || node2.getAttribute && node2.getAttribute("data-auto-link") === "true";
              });
            }
            return shouldNotLink;
          },
          findLinkableText: function(contenteditable) {
            var textContent = contenteditable.textContent, match = null, matches = [];
            while ((match = LINK_REGEXP.exec(textContent)) !== null) {
              var matchOk = true, matchEnd = match.index + match[0].length;
              matchOk = (match.index === 0 || WHITESPACE_CHARS.indexOf(textContent[match.index - 1]) !== -1) && (matchEnd === textContent.length || WHITESPACE_CHARS.indexOf(textContent[matchEnd]) !== -1);
              matchOk = matchOk && (match[0].indexOf("/") !== -1 || KNOWN_TLDS_REGEXP.test(match[0].split(".").pop().split("?").shift()));
              if (matchOk) {
                matches.push({
                  href: match[0],
                  start: match.index,
                  end: matchEnd
                });
              }
            }
            return matches;
          },
          createAutoLink: function(textNodes, href) {
            href = MediumEditor2.util.ensureUrlHasProtocol(href);
            var anchor = MediumEditor2.util.createLink(this.document, textNodes, href, this.getEditorOption("targetBlank") ? "_blank" : null), span = this.document.createElement("span");
            span.setAttribute("data-auto-link", "true");
            span.setAttribute("data-href", href);
            anchor.insertBefore(span, anchor.firstChild);
            while (anchor.childNodes.length > 1) {
              span.appendChild(anchor.childNodes[1]);
            }
          }
        });
        MediumEditor2.extensions.autoLink = AutoLink;
      })();
      (function() {
        "use strict";
        var CLASS_DRAG_OVER = "medium-editor-dragover";
        function clearClassNames(element) {
          var editable = MediumEditor2.util.getContainerEditorElement(element), existing = Array.prototype.slice.call(editable.parentElement.querySelectorAll("." + CLASS_DRAG_OVER));
          existing.forEach(function(el) {
            el.classList.remove(CLASS_DRAG_OVER);
          });
        }
        var FileDragging = MediumEditor2.Extension.extend({
          name: "fileDragging",
          allowedTypes: ["image"],
          init: function() {
            MediumEditor2.Extension.prototype.init.apply(this, arguments);
            this.subscribe("editableDrag", this.handleDrag.bind(this));
            this.subscribe("editableDrop", this.handleDrop.bind(this));
          },
          handleDrag: function(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = "copy";
            var target = event.target.classList ? event.target : event.target.parentElement;
            clearClassNames(target);
            if (event.type === "dragover") {
              target.classList.add(CLASS_DRAG_OVER);
            }
          },
          handleDrop: function(event) {
            event.preventDefault();
            event.stopPropagation();
            this.base.selectElement(event.target);
            var selection = this.base.exportSelection();
            selection.start = selection.end;
            this.base.importSelection(selection);
            if (event.dataTransfer.files) {
              Array.prototype.slice.call(event.dataTransfer.files).forEach(function(file) {
                if (this.isAllowedFile(file)) {
                  if (file.type.match("image")) {
                    this.insertImageFile(file);
                  }
                }
              }, this);
            }
            clearClassNames(event.target);
          },
          isAllowedFile: function(file) {
            return this.allowedTypes.some(function(fileType) {
              return !!file.type.match(fileType);
            });
          },
          insertImageFile: function(file) {
            if (typeof FileReader !== "function") {
              return;
            }
            var fileReader = new FileReader();
            fileReader.readAsDataURL(file);
            fileReader.addEventListener("load", (function(e) {
              var addImageElement = this.document.createElement("img");
              addImageElement.src = e.target.result;
              MediumEditor2.util.insertHTMLCommand(this.document, addImageElement.outerHTML);
            }).bind(this));
          }
        });
        MediumEditor2.extensions.fileDragging = FileDragging;
      })();
      (function() {
        "use strict";
        var KeyboardCommands = MediumEditor2.Extension.extend({
          name: "keyboard-commands",
          /* KeyboardCommands Options */
          /* commands: [Array]
           * Array of objects describing each command and the combination of keys that will trigger it
           * Required for each object:
           *   command [String] (argument passed to editor.execAction())
           *   key [String] (keyboard character that triggers this command)
           *   meta [boolean] (whether the ctrl/meta key has to be active or inactive)
           *   shift [boolean] (whether the shift key has to be active or inactive)
           *   alt [boolean] (whether the alt key has to be active or inactive)
           */
          commands: [
            {
              command: "bold",
              key: "B",
              meta: true,
              shift: false,
              alt: false
            },
            {
              command: "italic",
              key: "I",
              meta: true,
              shift: false,
              alt: false
            },
            {
              command: "underline",
              key: "U",
              meta: true,
              shift: false,
              alt: false
            }
          ],
          init: function() {
            MediumEditor2.Extension.prototype.init.apply(this, arguments);
            this.subscribe("editableKeydown", this.handleKeydown.bind(this));
            this.keys = {};
            this.commands.forEach(function(command) {
              var keyCode = command.key.charCodeAt(0);
              if (!this.keys[keyCode]) {
                this.keys[keyCode] = [];
              }
              this.keys[keyCode].push(command);
            }, this);
          },
          handleKeydown: function(event) {
            var keyCode = MediumEditor2.util.getKeyCode(event);
            if (!this.keys[keyCode]) {
              return;
            }
            var isMeta = MediumEditor2.util.isMetaCtrlKey(event), isShift = !!event.shiftKey, isAlt = !!event.altKey;
            this.keys[keyCode].forEach(function(data) {
              if (data.meta === isMeta && data.shift === isShift && (data.alt === isAlt || void 0 === data.alt)) {
                event.preventDefault();
                event.stopPropagation();
                if (typeof data.command === "function") {
                  data.command.apply(this);
                } else if (false !== data.command) {
                  this.execAction(data.command);
                }
              }
            }, this);
          }
        });
        MediumEditor2.extensions.keyboardCommands = KeyboardCommands;
      })();
      (function() {
        "use strict";
        var FontNameForm = MediumEditor2.extensions.form.extend({
          name: "fontname",
          action: "fontName",
          aria: "change font name",
          contentDefault: "&#xB1;",
          // ±
          contentFA: '<i class="fa fa-font"></i>',
          fonts: ["", "Arial", "Verdana", "Times New Roman"],
          init: function() {
            MediumEditor2.extensions.form.prototype.init.apply(this, arguments);
          },
          // Called when the button the toolbar is clicked
          // Overrides ButtonExtension.handleClick
          handleClick: function(event) {
            event.preventDefault();
            event.stopPropagation();
            if (!this.isDisplayed()) {
              var fontName = this.document.queryCommandValue("fontName") + "";
              this.showForm(fontName);
            }
            return false;
          },
          // Called by medium-editor to append form to the toolbar
          getForm: function() {
            if (!this.form) {
              this.form = this.createForm();
            }
            return this.form;
          },
          // Used by medium-editor when the default toolbar is to be displayed
          isDisplayed: function() {
            return this.getForm().style.display === "block";
          },
          hideForm: function() {
            this.getForm().style.display = "none";
            this.getSelect().value = "";
          },
          showForm: function(fontName) {
            var select = this.getSelect();
            this.base.saveSelection();
            this.hideToolbarDefaultActions();
            this.getForm().style.display = "block";
            this.setToolbarPosition();
            select.value = fontName || "";
            select.focus();
          },
          // Called by core when tearing down medium-editor (destroy)
          destroy: function() {
            if (!this.form) {
              return false;
            }
            if (this.form.parentNode) {
              this.form.parentNode.removeChild(this.form);
            }
            delete this.form;
          },
          // core methods
          doFormSave: function() {
            this.base.restoreSelection();
            this.base.checkSelection();
          },
          doFormCancel: function() {
            this.base.restoreSelection();
            this.clearFontName();
            this.base.checkSelection();
          },
          // form creation and event handling
          createForm: function() {
            var doc = this.document, form = doc.createElement("div"), select = doc.createElement("select"), close = doc.createElement("a"), save = doc.createElement("a"), option;
            form.className = "medium-editor-toolbar-form";
            form.id = "medium-editor-toolbar-form-fontname-" + this.getEditorId();
            this.on(form, "click", this.handleFormClick.bind(this));
            for (var i = 0; i < this.fonts.length; i++) {
              option = doc.createElement("option");
              option.innerHTML = this.fonts[i];
              option.value = this.fonts[i];
              select.appendChild(option);
            }
            select.className = "medium-editor-toolbar-select";
            form.appendChild(select);
            this.on(select, "change", this.handleFontChange.bind(this));
            save.setAttribute("href", "#");
            save.className = "medium-editor-toobar-save";
            save.innerHTML = this.getEditorOption("buttonLabels") === "fontawesome" ? '<i class="fa fa-check"></i>' : "&#10003;";
            form.appendChild(save);
            this.on(save, "click", this.handleSaveClick.bind(this), true);
            close.setAttribute("href", "#");
            close.className = "medium-editor-toobar-close";
            close.innerHTML = this.getEditorOption("buttonLabels") === "fontawesome" ? '<i class="fa fa-times"></i>' : "&times;";
            form.appendChild(close);
            this.on(close, "click", this.handleCloseClick.bind(this));
            return form;
          },
          getSelect: function() {
            return this.getForm().querySelector("select.medium-editor-toolbar-select");
          },
          clearFontName: function() {
            MediumEditor2.selection.getSelectedElements(this.document).forEach(function(el) {
              if (el.nodeName.toLowerCase() === "font" && el.hasAttribute("face")) {
                el.removeAttribute("face");
              }
            });
          },
          handleFontChange: function() {
            var font = this.getSelect().value;
            if (font === "") {
              this.clearFontName();
            } else {
              this.execAction("fontName", { value: font });
            }
          },
          handleFormClick: function(event) {
            event.stopPropagation();
          },
          handleSaveClick: function(event) {
            event.preventDefault();
            this.doFormSave();
          },
          handleCloseClick: function(event) {
            event.preventDefault();
            this.doFormCancel();
          }
        });
        MediumEditor2.extensions.fontName = FontNameForm;
      })();
      (function() {
        "use strict";
        var FontSizeForm = MediumEditor2.extensions.form.extend({
          name: "fontsize",
          action: "fontSize",
          aria: "increase/decrease font size",
          contentDefault: "&#xB1;",
          // ±
          contentFA: '<i class="fa fa-text-height"></i>',
          init: function() {
            MediumEditor2.extensions.form.prototype.init.apply(this, arguments);
          },
          // Called when the button the toolbar is clicked
          // Overrides ButtonExtension.handleClick
          handleClick: function(event) {
            event.preventDefault();
            event.stopPropagation();
            if (!this.isDisplayed()) {
              var fontSize = this.document.queryCommandValue("fontSize") + "";
              this.showForm(fontSize);
            }
            return false;
          },
          // Called by medium-editor to append form to the toolbar
          getForm: function() {
            if (!this.form) {
              this.form = this.createForm();
            }
            return this.form;
          },
          // Used by medium-editor when the default toolbar is to be displayed
          isDisplayed: function() {
            return this.getForm().style.display === "block";
          },
          hideForm: function() {
            this.getForm().style.display = "none";
            this.getInput().value = "";
          },
          showForm: function(fontSize) {
            var input = this.getInput();
            this.base.saveSelection();
            this.hideToolbarDefaultActions();
            this.getForm().style.display = "block";
            this.setToolbarPosition();
            input.value = fontSize || "";
            input.focus();
          },
          // Called by core when tearing down medium-editor (destroy)
          destroy: function() {
            if (!this.form) {
              return false;
            }
            if (this.form.parentNode) {
              this.form.parentNode.removeChild(this.form);
            }
            delete this.form;
          },
          // core methods
          doFormSave: function() {
            this.base.restoreSelection();
            this.base.checkSelection();
          },
          doFormCancel: function() {
            this.base.restoreSelection();
            this.clearFontSize();
            this.base.checkSelection();
          },
          // form creation and event handling
          createForm: function() {
            var doc = this.document, form = doc.createElement("div"), input = doc.createElement("input"), close = doc.createElement("a"), save = doc.createElement("a");
            form.className = "medium-editor-toolbar-form";
            form.id = "medium-editor-toolbar-form-fontsize-" + this.getEditorId();
            this.on(form, "click", this.handleFormClick.bind(this));
            input.setAttribute("type", "range");
            input.setAttribute("min", "1");
            input.setAttribute("max", "7");
            input.className = "medium-editor-toolbar-input";
            form.appendChild(input);
            this.on(input, "change", this.handleSliderChange.bind(this));
            save.setAttribute("href", "#");
            save.className = "medium-editor-toobar-save";
            save.innerHTML = this.getEditorOption("buttonLabels") === "fontawesome" ? '<i class="fa fa-check"></i>' : "&#10003;";
            form.appendChild(save);
            this.on(save, "click", this.handleSaveClick.bind(this), true);
            close.setAttribute("href", "#");
            close.className = "medium-editor-toobar-close";
            close.innerHTML = this.getEditorOption("buttonLabels") === "fontawesome" ? '<i class="fa fa-times"></i>' : "&times;";
            form.appendChild(close);
            this.on(close, "click", this.handleCloseClick.bind(this));
            return form;
          },
          getInput: function() {
            return this.getForm().querySelector("input.medium-editor-toolbar-input");
          },
          clearFontSize: function() {
            MediumEditor2.selection.getSelectedElements(this.document).forEach(function(el) {
              if (el.nodeName.toLowerCase() === "font" && el.hasAttribute("size")) {
                el.removeAttribute("size");
              }
            });
          },
          handleSliderChange: function() {
            var size = this.getInput().value;
            if (size === "4") {
              this.clearFontSize();
            } else {
              this.execAction("fontSize", { value: size });
            }
          },
          handleFormClick: function(event) {
            event.stopPropagation();
          },
          handleSaveClick: function(event) {
            event.preventDefault();
            this.doFormSave();
          },
          handleCloseClick: function(event) {
            event.preventDefault();
            this.doFormCancel();
          }
        });
        MediumEditor2.extensions.fontSize = FontSizeForm;
      })();
      (function() {
        "use strict";
        var pasteBinDefaultContent = "%ME_PASTEBIN%", lastRange = null, keyboardPasteEditable = null, stopProp = function(event) {
          event.stopPropagation();
        };
        function createReplacements() {
          return [
            // Remove anything but the contents within the BODY element
            [new RegExp(/^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/g), ""],
            // cleanup comments added by Chrome when pasting html
            [new RegExp(/<!--StartFragment-->|<!--EndFragment-->/g), ""],
            // Trailing BR elements
            [new RegExp(/<br>$/i), ""],
            // replace two bogus tags that begin pastes from google docs
            [new RegExp(/<[^>]*docs-internal-guid[^>]*>/gi), ""],
            [new RegExp(/<\/b>(<br[^>]*>)?$/gi), ""],
            // un-html spaces and newlines inserted by OS X
            [new RegExp(/<span class="Apple-converted-space">\s+<\/span>/g), " "],
            [new RegExp(/<br class="Apple-interchange-newline">/g), "<br>"],
            // replace google docs italics+bold with a span to be replaced once the html is inserted
            [new RegExp(/<span[^>]*(font-style:italic;font-weight:(bold|700)|font-weight:(bold|700);font-style:italic)[^>]*>/gi), '<span class="replace-with italic bold">'],
            // replace google docs italics with a span to be replaced once the html is inserted
            [new RegExp(/<span[^>]*font-style:italic[^>]*>/gi), '<span class="replace-with italic">'],
            //[replace google docs bolds with a span to be replaced once the html is inserted
            [new RegExp(/<span[^>]*font-weight:(bold|700)[^>]*>/gi), '<span class="replace-with bold">'],
            // replace manually entered b/i/a tags with real ones
            [new RegExp(/&lt;(\/?)(i|b|a)&gt;/gi), "<$1$2>"],
            // replace manually a tags with real ones, converting smart-quotes from google docs
            [new RegExp(/&lt;a(?:(?!href).)+href=(?:&quot;|&rdquo;|&ldquo;|"|“|”)(((?!&quot;|&rdquo;|&ldquo;|"|“|”).)*)(?:&quot;|&rdquo;|&ldquo;|"|“|”)(?:(?!&gt;).)*&gt;/gi), '<a href="$1">'],
            // Newlines between paragraphs in html have no syntactic value,
            // but then have a tendency to accidentally become additional paragraphs down the line
            [new RegExp(/<\/p>\n+/gi), "</p>"],
            [new RegExp(/\n+<p/gi), "<p"],
            // Microsoft Word makes these odd tags, like <o:p></o:p>
            [new RegExp(/<\/?o:[a-z]*>/gi), ""],
            // Microsoft Word adds some special elements around list items
            [new RegExp(/<!\[if !supportLists\]>(((?!<!).)*)<!\[endif]\>/gi), "$1"]
          ];
        }
        function getClipboardContent(event, win, doc) {
          var dataTransfer = event.clipboardData || win.clipboardData || doc.dataTransfer, data = {};
          if (!dataTransfer) {
            return data;
          }
          if (dataTransfer.getData) {
            var legacyText = dataTransfer.getData("Text");
            if (legacyText && legacyText.length > 0) {
              data["text/plain"] = legacyText;
            }
          }
          if (dataTransfer.types) {
            for (var i = 0; i < dataTransfer.types.length; i++) {
              var contentType = dataTransfer.types[i];
              data[contentType] = dataTransfer.getData(contentType);
            }
          }
          return data;
        }
        var PasteHandler = MediumEditor2.Extension.extend({
          /* Paste Options */
          /* forcePlainText: [boolean]
           * Forces pasting as plain text.
           */
          forcePlainText: true,
          /* cleanPastedHTML: [boolean]
           * cleans pasted content from different sources, like google docs etc.
           */
          cleanPastedHTML: false,
          /* preCleanReplacements: [Array]
           * custom pairs (2 element arrays) of RegExp and replacement text to use during past when
           * __forcePlainText__ or __cleanPastedHTML__ are `true` OR when calling `cleanPaste(text)` helper method.
           * These replacements are executed before any medium editor defined replacements.
           */
          preCleanReplacements: [],
          /* cleanReplacements: [Array]
           * custom pairs (2 element arrays) of RegExp and replacement text to use during paste when
           * __forcePlainText__ or __cleanPastedHTML__ are `true` OR when calling `cleanPaste(text)` helper method.
           * These replacements are executed after any medium editor defined replacements.
           */
          cleanReplacements: [],
          /* cleanAttrs:: [Array]
           * list of element attributes to remove during paste when __cleanPastedHTML__ is `true` or when
           * calling `cleanPaste(text)` or `pasteHTML(html, options)` helper methods.
           */
          cleanAttrs: ["class", "style", "dir"],
          /* cleanTags: [Array]
           * list of element tag names to remove during paste when __cleanPastedHTML__ is `true` or when
           * calling `cleanPaste(text)` or `pasteHTML(html, options)` helper methods.
           */
          cleanTags: ["meta"],
          /* unwrapTags: [Array]
           * list of element tag names to unwrap (remove the element tag but retain its child elements)
           * during paste when __cleanPastedHTML__ is `true` or when
           * calling `cleanPaste(text)` or `pasteHTML(html, options)` helper methods.
           */
          unwrapTags: [],
          init: function() {
            MediumEditor2.Extension.prototype.init.apply(this, arguments);
            if (this.forcePlainText || this.cleanPastedHTML) {
              this.subscribe("editableKeydown", this.handleKeydown.bind(this));
              this.getEditorElements().forEach(function(element) {
                this.on(element, "paste", this.handlePaste.bind(this));
              }, this);
              this.subscribe("addElement", this.handleAddElement.bind(this));
            }
          },
          handleAddElement: function(event, editable) {
            this.on(editable, "paste", this.handlePaste.bind(this));
          },
          destroy: function() {
            if (this.forcePlainText || this.cleanPastedHTML) {
              this.removePasteBin();
            }
          },
          handlePaste: function(event, editable) {
            if (event.defaultPrevented) {
              return;
            }
            var clipboardContent = getClipboardContent(event, this.window, this.document), pastedHTML = clipboardContent["text/html"], pastedPlain = clipboardContent["text/plain"];
            if (this.window.clipboardData && event.clipboardData === void 0 && !pastedHTML) {
              pastedHTML = pastedPlain;
            }
            if (pastedHTML || pastedPlain) {
              event.preventDefault();
              this.doPaste(pastedHTML, pastedPlain, editable);
            }
          },
          doPaste: function(pastedHTML, pastedPlain, editable) {
            var paragraphs, html = "", p;
            if (this.cleanPastedHTML && pastedHTML) {
              return this.cleanPaste(pastedHTML);
            }
            if (!pastedPlain) {
              return;
            }
            if (!(this.getEditorOption("disableReturn") || editable && editable.getAttribute("data-disable-return"))) {
              paragraphs = pastedPlain.split(/[\r\n]+/g);
              if (paragraphs.length > 1) {
                for (p = 0; p < paragraphs.length; p += 1) {
                  if (paragraphs[p] !== "") {
                    html += "<p>" + MediumEditor2.util.htmlEntities(paragraphs[p]) + "</p>";
                  }
                }
              } else {
                html = MediumEditor2.util.htmlEntities(paragraphs[0]);
              }
            } else {
              html = MediumEditor2.util.htmlEntities(pastedPlain);
            }
            MediumEditor2.util.insertHTMLCommand(this.document, html);
          },
          handlePasteBinPaste: function(event) {
            if (event.defaultPrevented) {
              this.removePasteBin();
              return;
            }
            var clipboardContent = getClipboardContent(event, this.window, this.document), pastedHTML = clipboardContent["text/html"], pastedPlain = clipboardContent["text/plain"], editable = keyboardPasteEditable;
            if (!this.cleanPastedHTML || pastedHTML) {
              event.preventDefault();
              this.removePasteBin();
              this.doPaste(pastedHTML, pastedPlain, editable);
              this.trigger("editablePaste", { currentTarget: editable, target: editable }, editable);
              return;
            }
            setTimeout((function() {
              if (this.cleanPastedHTML) {
                pastedHTML = this.getPasteBinHtml();
              }
              this.removePasteBin();
              this.doPaste(pastedHTML, pastedPlain, editable);
              this.trigger("editablePaste", { currentTarget: editable, target: editable }, editable);
            }).bind(this), 0);
          },
          handleKeydown: function(event, editable) {
            if (!(MediumEditor2.util.isKey(event, MediumEditor2.util.keyCode.V) && MediumEditor2.util.isMetaCtrlKey(event))) {
              return;
            }
            event.stopImmediatePropagation();
            this.removePasteBin();
            this.createPasteBin(editable);
          },
          createPasteBin: function(editable) {
            var rects, range = MediumEditor2.selection.getSelectionRange(this.document), top = this.window.pageYOffset;
            keyboardPasteEditable = editable;
            if (range) {
              rects = range.getClientRects();
              if (rects.length) {
                top += rects[0].top;
              } else if (range.startContainer.getBoundingClientRect !== void 0) {
                top += range.startContainer.getBoundingClientRect().top;
              } else {
                top += range.getBoundingClientRect().top;
              }
            }
            lastRange = range;
            var pasteBinElm = this.document.createElement("div");
            pasteBinElm.id = this.pasteBinId = "medium-editor-pastebin-" + +Date.now();
            pasteBinElm.setAttribute("style", "border: 1px red solid; position: absolute; top: " + top + "px; width: 10px; height: 10px; overflow: hidden; opacity: 0");
            pasteBinElm.setAttribute("contentEditable", true);
            pasteBinElm.innerHTML = pasteBinDefaultContent;
            this.document.body.appendChild(pasteBinElm);
            this.on(pasteBinElm, "focus", stopProp);
            this.on(pasteBinElm, "focusin", stopProp);
            this.on(pasteBinElm, "focusout", stopProp);
            pasteBinElm.focus();
            MediumEditor2.selection.selectNode(pasteBinElm, this.document);
            if (!this.boundHandlePaste) {
              this.boundHandlePaste = this.handlePasteBinPaste.bind(this);
            }
            this.on(pasteBinElm, "paste", this.boundHandlePaste);
          },
          removePasteBin: function() {
            if (null !== lastRange) {
              MediumEditor2.selection.selectRange(this.document, lastRange);
              lastRange = null;
            }
            if (null !== keyboardPasteEditable) {
              keyboardPasteEditable = null;
            }
            var pasteBinElm = this.getPasteBin();
            if (!pasteBinElm) {
              return;
            }
            if (pasteBinElm) {
              this.off(pasteBinElm, "focus", stopProp);
              this.off(pasteBinElm, "focusin", stopProp);
              this.off(pasteBinElm, "focusout", stopProp);
              this.off(pasteBinElm, "paste", this.boundHandlePaste);
              pasteBinElm.parentElement.removeChild(pasteBinElm);
            }
          },
          getPasteBin: function() {
            return this.document.getElementById(this.pasteBinId);
          },
          getPasteBinHtml: function() {
            var pasteBinElm = this.getPasteBin();
            if (!pasteBinElm) {
              return false;
            }
            if (pasteBinElm.firstChild && pasteBinElm.firstChild.id === "mcepastebin") {
              return false;
            }
            var pasteBinHtml = pasteBinElm.innerHTML;
            if (!pasteBinHtml || pasteBinHtml === pasteBinDefaultContent) {
              return false;
            }
            return pasteBinHtml;
          },
          cleanPaste: function(text) {
            var i, elList, tmp, workEl, multiline = /<p|<br|<div/.test(text), replacements = [].concat(
              this.preCleanReplacements || [],
              createReplacements(),
              this.cleanReplacements || []
            );
            for (i = 0; i < replacements.length; i += 1) {
              text = text.replace(replacements[i][0], replacements[i][1]);
            }
            if (!multiline) {
              return this.pasteHTML(text);
            }
            tmp = this.document.createElement("div");
            tmp.innerHTML = "<p>" + text.split("<br><br>").join("</p><p>") + "</p>";
            elList = tmp.querySelectorAll("a,p,div,br");
            for (i = 0; i < elList.length; i += 1) {
              workEl = elList[i];
              workEl.innerHTML = workEl.innerHTML.replace(/\n/gi, " ");
              switch (workEl.nodeName.toLowerCase()) {
                case "p":
                case "div":
                  this.filterCommonBlocks(workEl);
                  break;
                case "br":
                  this.filterLineBreak(workEl);
                  break;
              }
            }
            this.pasteHTML(tmp.innerHTML);
          },
          pasteHTML: function(html, options) {
            options = MediumEditor2.util.defaults({}, options, {
              cleanAttrs: this.cleanAttrs,
              cleanTags: this.cleanTags,
              unwrapTags: this.unwrapTags
            });
            var elList, workEl, i, fragmentBody, pasteBlock = this.document.createDocumentFragment();
            pasteBlock.appendChild(this.document.createElement("body"));
            fragmentBody = pasteBlock.querySelector("body");
            fragmentBody.innerHTML = html;
            this.cleanupSpans(fragmentBody);
            elList = fragmentBody.querySelectorAll("*");
            for (i = 0; i < elList.length; i += 1) {
              workEl = elList[i];
              if ("a" === workEl.nodeName.toLowerCase() && this.getEditorOption("targetBlank")) {
                MediumEditor2.util.setTargetBlank(workEl);
              }
              MediumEditor2.util.cleanupAttrs(workEl, options.cleanAttrs);
              MediumEditor2.util.cleanupTags(workEl, options.cleanTags);
              MediumEditor2.util.unwrapTags(workEl, options.unwrapTags);
            }
            MediumEditor2.util.insertHTMLCommand(this.document, fragmentBody.innerHTML.replace(/&nbsp;/g, " "));
          },
          // TODO (6.0): Make this an internal helper instead of member of paste handler
          isCommonBlock: function(el) {
            return el && (el.nodeName.toLowerCase() === "p" || el.nodeName.toLowerCase() === "div");
          },
          // TODO (6.0): Make this an internal helper instead of member of paste handler
          filterCommonBlocks: function(el) {
            if (/^\s*$/.test(el.textContent) && el.parentNode) {
              el.parentNode.removeChild(el);
            }
          },
          // TODO (6.0): Make this an internal helper instead of member of paste handler
          filterLineBreak: function(el) {
            if (this.isCommonBlock(el.previousElementSibling)) {
              this.removeWithParent(el);
            } else if (this.isCommonBlock(el.parentNode) && (el.parentNode.firstChild === el || el.parentNode.lastChild === el)) {
              this.removeWithParent(el);
            } else if (el.parentNode && el.parentNode.childElementCount === 1 && el.parentNode.textContent === "") {
              this.removeWithParent(el);
            }
          },
          // TODO (6.0): Make this an internal helper instead of member of paste handler
          // remove an element, including its parent, if it is the only element within its parent
          removeWithParent: function(el) {
            if (el && el.parentNode) {
              if (el.parentNode.parentNode && el.parentNode.childElementCount === 1) {
                el.parentNode.parentNode.removeChild(el.parentNode);
              } else {
                el.parentNode.removeChild(el);
              }
            }
          },
          // TODO (6.0): Make this an internal helper instead of member of paste handler
          cleanupSpans: function(containerEl) {
            var i, el, newEl, spans = containerEl.querySelectorAll(".replace-with"), isCEF = function(el2) {
              return el2 && el2.nodeName !== "#text" && el2.getAttribute("contenteditable") === "false";
            };
            for (i = 0; i < spans.length; i += 1) {
              el = spans[i];
              newEl = this.document.createElement(el.classList.contains("bold") ? "b" : "i");
              if (el.classList.contains("bold") && el.classList.contains("italic")) {
                newEl.innerHTML = "<i>" + el.innerHTML + "</i>";
              } else {
                newEl.innerHTML = el.innerHTML;
              }
              el.parentNode.replaceChild(newEl, el);
            }
            spans = containerEl.querySelectorAll("span");
            for (i = 0; i < spans.length; i += 1) {
              el = spans[i];
              if (MediumEditor2.util.traverseUp(el, isCEF)) {
                return false;
              }
              MediumEditor2.util.unwrap(el, this.document);
            }
          }
        });
        MediumEditor2.extensions.paste = PasteHandler;
      })();
      (function() {
        "use strict";
        var Placeholder = MediumEditor2.Extension.extend({
          name: "placeholder",
          /* Placeholder Options */
          /* text: [string]
           * Text to display in the placeholder
           */
          text: "Type your text",
          /* hideOnClick: [boolean]
           * Should we hide the placeholder on click (true) or when user starts typing (false)
           */
          hideOnClick: true,
          init: function() {
            MediumEditor2.Extension.prototype.init.apply(this, arguments);
            this.initPlaceholders();
            this.attachEventHandlers();
          },
          initPlaceholders: function() {
            this.getEditorElements().forEach(this.initElement, this);
          },
          handleAddElement: function(event, editable) {
            this.initElement(editable);
          },
          initElement: function(el) {
            if (!el.getAttribute("data-placeholder")) {
              el.setAttribute("data-placeholder", this.text);
            }
            this.updatePlaceholder(el);
          },
          destroy: function() {
            this.getEditorElements().forEach(this.cleanupElement, this);
          },
          handleRemoveElement: function(event, editable) {
            this.cleanupElement(editable);
          },
          cleanupElement: function(el) {
            if (el.getAttribute("data-placeholder") === this.text) {
              el.removeAttribute("data-placeholder");
            }
          },
          showPlaceholder: function(el) {
            if (el) {
              if (MediumEditor2.util.isFF && el.childNodes.length === 0) {
                el.classList.add("medium-editor-placeholder-relative");
                el.classList.remove("medium-editor-placeholder");
              } else {
                el.classList.add("medium-editor-placeholder");
                el.classList.remove("medium-editor-placeholder-relative");
              }
            }
          },
          hidePlaceholder: function(el) {
            if (el) {
              el.classList.remove("medium-editor-placeholder");
              el.classList.remove("medium-editor-placeholder-relative");
            }
          },
          updatePlaceholder: function(el, dontShow) {
            if (el.querySelector("img, blockquote, ul, ol, table") || el.textContent.replace(/^\s+|\s+$/g, "") !== "") {
              return this.hidePlaceholder(el);
            }
            if (!dontShow) {
              this.showPlaceholder(el);
            }
          },
          attachEventHandlers: function() {
            if (this.hideOnClick) {
              this.subscribe("focus", this.handleFocus.bind(this));
            }
            this.subscribe("editableInput", this.handleInput.bind(this));
            this.subscribe("blur", this.handleBlur.bind(this));
            this.subscribe("addElement", this.handleAddElement.bind(this));
            this.subscribe("removeElement", this.handleRemoveElement.bind(this));
          },
          handleInput: function(event, element) {
            var dontShow = this.hideOnClick && element === this.base.getFocusedElement();
            this.updatePlaceholder(element, dontShow);
          },
          handleFocus: function(event, element) {
            this.hidePlaceholder(element);
          },
          handleBlur: function(event, element) {
            this.updatePlaceholder(element);
          }
        });
        MediumEditor2.extensions.placeholder = Placeholder;
      })();
      (function() {
        "use strict";
        var Toolbar = MediumEditor2.Extension.extend({
          name: "toolbar",
          /* Toolbar Options */
          /* align: ['left'|'center'|'right']
           * When the __static__ option is true, this aligns the static toolbar
           * relative to the medium-editor element.
           */
          align: "center",
          /* allowMultiParagraphSelection: [boolean]
           * enables/disables whether the toolbar should be displayed when
           * selecting multiple paragraphs/block elements
           */
          allowMultiParagraphSelection: true,
          /* buttons: [Array]
           * the names of the set of buttons to display on the toolbar.
           */
          buttons: ["bold", "italic", "underline", "anchor", "h2", "h3", "quote"],
          /* diffLeft: [Number]
           * value in pixels to be added to the X axis positioning of the toolbar.
           */
          diffLeft: 0,
          /* diffTop: [Number]
           * value in pixels to be added to the Y axis positioning of the toolbar.
           */
          diffTop: -10,
          /* firstButtonClass: [string]
           * CSS class added to the first button in the toolbar.
           */
          firstButtonClass: "medium-editor-button-first",
          /* lastButtonClass: [string]
           * CSS class added to the last button in the toolbar.
           */
          lastButtonClass: "medium-editor-button-last",
          /* standardizeSelectionStart: [boolean]
           * enables/disables standardizing how the beginning of a range is decided
           * between browsers whenever the selected text is analyzed for updating toolbar buttons status.
           */
          standardizeSelectionStart: false,
          /* static: [boolean]
           * enable/disable the toolbar always displaying in the same location
           * relative to the medium-editor element.
           */
          static: false,
          /* sticky: [boolean]
           * When the __static__ option is true, this enables/disables the toolbar
           * "sticking" to the viewport and staying visible on the screen while
           * the page scrolls.
           */
          sticky: false,
          /* stickyTopOffset: [Number]
           * Value in pixel of the top offset above the toolbar
           */
          stickyTopOffset: 0,
          /* updateOnEmptySelection: [boolean]
           * When the __static__ option is true, this enables/disables updating
           * the state of the toolbar buttons even when the selection is collapsed
           * (there is no selection, just a cursor).
           */
          updateOnEmptySelection: false,
          /* relativeContainer: [node]
           * appending the toolbar to a given node instead of body
           */
          relativeContainer: null,
          init: function() {
            MediumEditor2.Extension.prototype.init.apply(this, arguments);
            this.initThrottledMethods();
            if (!this.relativeContainer) {
              this.getEditorOption("elementsContainer").appendChild(this.getToolbarElement());
            } else {
              this.relativeContainer.appendChild(this.getToolbarElement());
            }
          },
          // Helper method to execute method for every extension, but ignoring the toolbar extension
          forEachExtension: function(iterator, context) {
            return this.base.extensions.forEach(function(command) {
              if (command === this) {
                return;
              }
              return iterator.apply(context || this, arguments);
            }, this);
          },
          // Toolbar creation/deletion
          createToolbar: function() {
            var toolbar = this.document.createElement("div");
            toolbar.id = "medium-editor-toolbar-" + this.getEditorId();
            toolbar.className = "medium-editor-toolbar";
            if (this.static) {
              toolbar.className += " static-toolbar";
            } else if (this.relativeContainer) {
              toolbar.className += " medium-editor-relative-toolbar";
            } else {
              toolbar.className += " medium-editor-stalker-toolbar";
            }
            toolbar.appendChild(this.createToolbarButtons());
            this.forEachExtension(function(extension) {
              if (extension.hasForm) {
                toolbar.appendChild(extension.getForm());
              }
            });
            this.attachEventHandlers();
            return toolbar;
          },
          createToolbarButtons: function() {
            var ul = this.document.createElement("ul"), li, btn, buttons, extension, buttonName, buttonOpts;
            ul.id = "medium-editor-toolbar-actions" + this.getEditorId();
            ul.className = "medium-editor-toolbar-actions";
            ul.style.display = "block";
            this.buttons.forEach(function(button) {
              if (typeof button === "string") {
                buttonName = button;
                buttonOpts = null;
              } else {
                buttonName = button.name;
                buttonOpts = button;
              }
              extension = this.base.addBuiltInExtension(buttonName, buttonOpts);
              if (extension && typeof extension.getButton === "function") {
                btn = extension.getButton(this.base);
                li = this.document.createElement("li");
                if (MediumEditor2.util.isElement(btn)) {
                  li.appendChild(btn);
                } else {
                  li.innerHTML = btn;
                }
                ul.appendChild(li);
              }
            }, this);
            buttons = ul.querySelectorAll("button");
            if (buttons.length > 0) {
              buttons[0].classList.add(this.firstButtonClass);
              buttons[buttons.length - 1].classList.add(this.lastButtonClass);
            }
            return ul;
          },
          destroy: function() {
            if (this.toolbar) {
              if (this.toolbar.parentNode) {
                this.toolbar.parentNode.removeChild(this.toolbar);
              }
              delete this.toolbar;
            }
          },
          // Toolbar accessors
          getInteractionElements: function() {
            return this.getToolbarElement();
          },
          getToolbarElement: function() {
            if (!this.toolbar) {
              this.toolbar = this.createToolbar();
            }
            return this.toolbar;
          },
          getToolbarActionsElement: function() {
            return this.getToolbarElement().querySelector(".medium-editor-toolbar-actions");
          },
          // Toolbar event handlers
          initThrottledMethods: function() {
            this.throttledPositionToolbar = MediumEditor2.util.throttle((function() {
              if (this.base.isActive) {
                this.positionToolbarIfShown();
              }
            }).bind(this));
          },
          attachEventHandlers: function() {
            this.subscribe("blur", this.handleBlur.bind(this));
            this.subscribe("focus", this.handleFocus.bind(this));
            this.subscribe("editableClick", this.handleEditableClick.bind(this));
            this.subscribe("editableKeyup", this.handleEditableKeyup.bind(this));
            this.on(this.document.documentElement, "mouseup", this.handleDocumentMouseup.bind(this));
            if (this.static && this.sticky) {
              this.on(this.window, "scroll", this.handleWindowScroll.bind(this), true);
            }
            this.on(this.window, "resize", this.handleWindowResize.bind(this));
          },
          handleWindowScroll: function() {
            this.positionToolbarIfShown();
          },
          handleWindowResize: function() {
            this.throttledPositionToolbar();
          },
          handleDocumentMouseup: function(event) {
            if (event && event.target && MediumEditor2.util.isDescendant(this.getToolbarElement(), event.target)) {
              return false;
            }
            this.checkState();
          },
          handleEditableClick: function() {
            setTimeout((function() {
              this.checkState();
            }).bind(this), 0);
          },
          handleEditableKeyup: function() {
            this.checkState();
          },
          handleBlur: function() {
            clearTimeout(this.hideTimeout);
            clearTimeout(this.delayShowTimeout);
            this.hideTimeout = setTimeout((function() {
              this.hideToolbar();
            }).bind(this), 1);
          },
          handleFocus: function() {
            this.checkState();
          },
          // Hiding/showing toolbar
          isDisplayed: function() {
            return this.getToolbarElement().classList.contains("medium-editor-toolbar-active");
          },
          showToolbar: function() {
            clearTimeout(this.hideTimeout);
            if (!this.isDisplayed()) {
              this.getToolbarElement().classList.add("medium-editor-toolbar-active");
              this.trigger("showToolbar", {}, this.base.getFocusedElement());
            }
          },
          hideToolbar: function() {
            if (this.isDisplayed()) {
              this.getToolbarElement().classList.remove("medium-editor-toolbar-active");
              this.trigger("hideToolbar", {}, this.base.getFocusedElement());
            }
          },
          isToolbarDefaultActionsDisplayed: function() {
            return this.getToolbarActionsElement().style.display === "block";
          },
          hideToolbarDefaultActions: function() {
            if (this.isToolbarDefaultActionsDisplayed()) {
              this.getToolbarActionsElement().style.display = "none";
            }
          },
          showToolbarDefaultActions: function() {
            this.hideExtensionForms();
            if (!this.isToolbarDefaultActionsDisplayed()) {
              this.getToolbarActionsElement().style.display = "block";
            }
            this.delayShowTimeout = this.base.delay((function() {
              this.showToolbar();
            }).bind(this));
          },
          hideExtensionForms: function() {
            this.forEachExtension(function(extension) {
              if (extension.hasForm && extension.isDisplayed()) {
                extension.hideForm();
              }
            });
          },
          // Responding to changes in user selection
          // Checks for existance of multiple block elements in the current selection
          multipleBlockElementsSelected: function() {
            var regexEmptyHTMLTags = /<[^\/>][^>]*><\/[^>]+>/gim, regexBlockElements = new RegExp("<(" + MediumEditor2.util.blockContainerElementNames.join("|") + ")[^>]*>", "g"), selectionHTML = MediumEditor2.selection.getSelectionHtml(this.document).replace(regexEmptyHTMLTags, ""), hasMultiParagraphs = selectionHTML.match(regexBlockElements);
            return !!hasMultiParagraphs && hasMultiParagraphs.length > 1;
          },
          modifySelection: function() {
            var selection = this.window.getSelection(), selectionRange = selection.getRangeAt(0);
            if (this.standardizeSelectionStart && selectionRange.startContainer.nodeValue && selectionRange.startOffset === selectionRange.startContainer.nodeValue.length) {
              var adjacentNode = MediumEditor2.util.findAdjacentTextNodeWithContent(MediumEditor2.selection.getSelectionElement(this.window), selectionRange.startContainer, this.document);
              if (adjacentNode) {
                var offset = 0;
                while (adjacentNode.nodeValue.substr(offset, 1).trim().length === 0) {
                  offset = offset + 1;
                }
                selectionRange = MediumEditor2.selection.select(
                  this.document,
                  adjacentNode,
                  offset,
                  selectionRange.endContainer,
                  selectionRange.endOffset
                );
              }
            }
          },
          checkState: function() {
            if (this.base.preventSelectionUpdates) {
              return;
            }
            if (!this.base.getFocusedElement() || MediumEditor2.selection.selectionInContentEditableFalse(this.window)) {
              return this.hideToolbar();
            }
            var selectionElement = MediumEditor2.selection.getSelectionElement(this.window);
            if (!selectionElement || this.getEditorElements().indexOf(selectionElement) === -1 || selectionElement.getAttribute("data-disable-toolbar")) {
              return this.hideToolbar();
            }
            if (this.updateOnEmptySelection && this.static) {
              return this.showAndUpdateToolbar();
            }
            if (!MediumEditor2.selection.selectionContainsContent(this.document) || this.allowMultiParagraphSelection === false && this.multipleBlockElementsSelected()) {
              return this.hideToolbar();
            }
            this.showAndUpdateToolbar();
          },
          // Updating the toolbar
          showAndUpdateToolbar: function() {
            this.modifySelection();
            this.setToolbarButtonStates();
            this.trigger("positionToolbar", {}, this.base.getFocusedElement());
            this.showToolbarDefaultActions();
            this.setToolbarPosition();
          },
          setToolbarButtonStates: function() {
            this.forEachExtension(function(extension) {
              if (typeof extension.isActive === "function" && typeof extension.setInactive === "function") {
                extension.setInactive();
              }
            });
            this.checkActiveButtons();
          },
          checkActiveButtons: function() {
            var manualStateChecks = [], queryState = null, selectionRange = MediumEditor2.selection.getSelectionRange(this.document), parentNode, updateExtensionState = function(extension) {
              if (typeof extension.checkState === "function") {
                extension.checkState(parentNode);
              } else if (typeof extension.isActive === "function" && typeof extension.isAlreadyApplied === "function" && typeof extension.setActive === "function") {
                if (!extension.isActive() && extension.isAlreadyApplied(parentNode)) {
                  extension.setActive();
                }
              }
            };
            if (!selectionRange) {
              return;
            }
            this.forEachExtension(function(extension) {
              if (typeof extension.queryCommandState === "function") {
                queryState = extension.queryCommandState();
                if (queryState !== null) {
                  if (queryState && typeof extension.setActive === "function") {
                    extension.setActive();
                  }
                  return;
                }
              }
              manualStateChecks.push(extension);
            });
            parentNode = MediumEditor2.selection.getSelectedParentElement(selectionRange);
            if (!this.getEditorElements().some(function(element) {
              return MediumEditor2.util.isDescendant(element, parentNode, true);
            })) {
              return;
            }
            while (parentNode) {
              manualStateChecks.forEach(updateExtensionState);
              if (MediumEditor2.util.isMediumEditorElement(parentNode)) {
                break;
              }
              parentNode = parentNode.parentNode;
            }
          },
          // Positioning toolbar
          positionToolbarIfShown: function() {
            if (this.isDisplayed()) {
              this.setToolbarPosition();
            }
          },
          setToolbarPosition: function() {
            var container = this.base.getFocusedElement(), selection = this.window.getSelection();
            if (!container) {
              return this;
            }
            if (this.static || !selection.isCollapsed) {
              this.showToolbar();
              if (!this.relativeContainer) {
                if (this.static) {
                  this.positionStaticToolbar(container);
                } else {
                  this.positionToolbar(selection);
                }
              }
              this.trigger("positionedToolbar", {}, this.base.getFocusedElement());
            }
          },
          positionStaticToolbar: function(container) {
            this.getToolbarElement().style.left = "0";
            var scrollTop = this.document.documentElement && this.document.documentElement.scrollTop || this.document.body.scrollTop, windowWidth = this.window.innerWidth, toolbarElement = this.getToolbarElement(), containerRect = container.getBoundingClientRect(), containerTop = containerRect.top + scrollTop, containerCenter = containerRect.left + containerRect.width / 2, toolbarHeight = toolbarElement.offsetHeight, toolbarWidth = toolbarElement.offsetWidth, halfOffsetWidth = toolbarWidth / 2, targetLeft;
            if (this.sticky) {
              if (scrollTop > containerTop + container.offsetHeight - toolbarHeight - this.stickyTopOffset) {
                toolbarElement.style.top = containerTop + container.offsetHeight - toolbarHeight + "px";
                toolbarElement.classList.remove("medium-editor-sticky-toolbar");
              } else if (scrollTop > containerTop - toolbarHeight - this.stickyTopOffset) {
                toolbarElement.classList.add("medium-editor-sticky-toolbar");
                toolbarElement.style.top = this.stickyTopOffset + "px";
              } else {
                toolbarElement.classList.remove("medium-editor-sticky-toolbar");
                toolbarElement.style.top = containerTop - toolbarHeight + "px";
              }
            } else {
              toolbarElement.style.top = containerTop - toolbarHeight + "px";
            }
            switch (this.align) {
              case "left":
                targetLeft = containerRect.left;
                break;
              case "right":
                targetLeft = containerRect.right - toolbarWidth;
                break;
              case "center":
                targetLeft = containerCenter - halfOffsetWidth;
                break;
            }
            if (targetLeft < 0) {
              targetLeft = 0;
            } else if (targetLeft + toolbarWidth > windowWidth) {
              targetLeft = windowWidth - Math.ceil(toolbarWidth) - 1;
            }
            toolbarElement.style.left = targetLeft + "px";
          },
          positionToolbar: function(selection) {
            this.getToolbarElement().style.left = "0";
            this.getToolbarElement().style.right = "initial";
            var range = selection.getRangeAt(0), boundary = range.getBoundingClientRect();
            if (!boundary || boundary.height === 0 && boundary.width === 0 && range.startContainer === range.endContainer) {
              if (range.startContainer.nodeType === 1 && range.startContainer.querySelector("img")) {
                boundary = range.startContainer.querySelector("img").getBoundingClientRect();
              } else {
                boundary = range.startContainer.getBoundingClientRect();
              }
            }
            var containerWidth = this.window.innerWidth, toolbarElement = this.getToolbarElement(), toolbarHeight = toolbarElement.offsetHeight, toolbarWidth = toolbarElement.offsetWidth, halfOffsetWidth = toolbarWidth / 2, buttonHeight = 50, defaultLeft = this.diffLeft - halfOffsetWidth, elementsContainer = this.getEditorOption("elementsContainer"), elementsContainerAbsolute = ["absolute", "fixed"].indexOf(window.getComputedStyle(elementsContainer).getPropertyValue("position")) > -1, positions = {}, relativeBoundary = {}, middleBoundary, elementsContainerBoundary;
            if (elementsContainerAbsolute) {
              elementsContainerBoundary = elementsContainer.getBoundingClientRect();
              ["top", "left"].forEach(function(key) {
                relativeBoundary[key] = boundary[key] - elementsContainerBoundary[key];
              });
              relativeBoundary.width = boundary.width;
              relativeBoundary.height = boundary.height;
              boundary = relativeBoundary;
              containerWidth = elementsContainerBoundary.width;
              positions.top = elementsContainer.scrollTop;
            } else {
              positions.top = this.window.pageYOffset;
            }
            middleBoundary = boundary.left + boundary.width / 2;
            positions.top += boundary.top - toolbarHeight;
            if (boundary.top < buttonHeight) {
              toolbarElement.classList.add("medium-toolbar-arrow-over");
              toolbarElement.classList.remove("medium-toolbar-arrow-under");
              positions.top += buttonHeight + boundary.height - this.diffTop;
            } else {
              toolbarElement.classList.add("medium-toolbar-arrow-under");
              toolbarElement.classList.remove("medium-toolbar-arrow-over");
              positions.top += this.diffTop;
            }
            if (middleBoundary < halfOffsetWidth) {
              positions.left = defaultLeft + halfOffsetWidth;
              positions.right = "initial";
            } else if (containerWidth - middleBoundary < halfOffsetWidth) {
              positions.left = "auto";
              positions.right = 0;
            } else {
              positions.left = defaultLeft + middleBoundary;
              positions.right = "initial";
            }
            ["top", "left", "right"].forEach(function(key) {
              toolbarElement.style[key] = positions[key] + (isNaN(positions[key]) ? "" : "px");
            });
          }
        });
        MediumEditor2.extensions.toolbar = Toolbar;
      })();
      (function() {
        "use strict";
        var ImageDragging = MediumEditor2.Extension.extend({
          init: function() {
            MediumEditor2.Extension.prototype.init.apply(this, arguments);
            this.subscribe("editableDrag", this.handleDrag.bind(this));
            this.subscribe("editableDrop", this.handleDrop.bind(this));
          },
          handleDrag: function(event) {
            var className = "medium-editor-dragover";
            event.preventDefault();
            event.dataTransfer.dropEffect = "copy";
            if (event.type === "dragover") {
              event.target.classList.add(className);
            } else if (event.type === "dragleave") {
              event.target.classList.remove(className);
            }
          },
          handleDrop: function(event) {
            var className = "medium-editor-dragover", files;
            event.preventDefault();
            event.stopPropagation();
            if (event.dataTransfer.files) {
              files = Array.prototype.slice.call(event.dataTransfer.files, 0);
              files.some((function(file) {
                if (file.type.match("image")) {
                  var fileReader, id;
                  fileReader = new FileReader();
                  fileReader.readAsDataURL(file);
                  id = "medium-img-" + +/* @__PURE__ */ new Date();
                  MediumEditor2.util.insertHTMLCommand(this.document, '<img class="medium-editor-image-loading" id="' + id + '" />');
                  fileReader.onload = (function() {
                    var img = this.document.getElementById(id);
                    if (img) {
                      img.removeAttribute("id");
                      img.removeAttribute("class");
                      img.src = fileReader.result;
                    }
                  }).bind(this);
                }
              }).bind(this));
            }
            event.target.classList.remove(className);
          }
        });
        MediumEditor2.extensions.imageDragging = ImageDragging;
      })();
      (function() {
        "use strict";
        function handleDisableExtraSpaces(event) {
          var node2 = MediumEditor2.selection.getSelectionStart(this.options.ownerDocument), textContent = node2.textContent, caretPositions = MediumEditor2.selection.getCaretOffsets(node2);
          if (textContent[caretPositions.left - 1] === void 0 || textContent[caretPositions.left - 1].trim() === "" || textContent[caretPositions.left] !== void 0 && textContent[caretPositions.left].trim() === "") {
            event.preventDefault();
          }
        }
        function handleDisabledEnterKeydown(event, element) {
          if (this.options.disableReturn || element.getAttribute("data-disable-return")) {
            event.preventDefault();
          } else if (this.options.disableDoubleReturn || element.getAttribute("data-disable-double-return")) {
            var node2 = MediumEditor2.selection.getSelectionStart(this.options.ownerDocument);
            if (node2 && node2.textContent.trim() === "" && node2.nodeName.toLowerCase() !== "li" || node2.previousElementSibling && node2.previousElementSibling.nodeName.toLowerCase() !== "br" && node2.previousElementSibling.textContent.trim() === "") {
              event.preventDefault();
            }
          }
        }
        function handleTabKeydown(event) {
          var node2 = MediumEditor2.selection.getSelectionStart(this.options.ownerDocument), tag = node2 && node2.nodeName.toLowerCase();
          if (tag === "pre") {
            event.preventDefault();
            MediumEditor2.util.insertHTMLCommand(this.options.ownerDocument, "    ");
          }
          if (MediumEditor2.util.isListItem(node2)) {
            event.preventDefault();
            if (event.shiftKey) {
              this.options.ownerDocument.execCommand("outdent", false, null);
            } else {
              this.options.ownerDocument.execCommand("indent", false, null);
            }
          }
        }
        function handleBlockDeleteKeydowns(event) {
          var p, node2 = MediumEditor2.selection.getSelectionStart(this.options.ownerDocument), tagName = node2.nodeName.toLowerCase(), isEmpty = /^(\s+|<br\/?>)?$/i, isHeader = /h\d/i;
          if (MediumEditor2.util.isKey(event, [MediumEditor2.util.keyCode.BACKSPACE, MediumEditor2.util.keyCode.ENTER]) && // has a preceeding sibling
          node2.previousElementSibling && // in a header
          isHeader.test(tagName) && // at the very end of the block
          MediumEditor2.selection.getCaretOffsets(node2).left === 0) {
            if (MediumEditor2.util.isKey(event, MediumEditor2.util.keyCode.BACKSPACE) && isEmpty.test(node2.previousElementSibling.innerHTML)) {
              node2.previousElementSibling.parentNode.removeChild(node2.previousElementSibling);
              event.preventDefault();
            } else if (!this.options.disableDoubleReturn && MediumEditor2.util.isKey(event, MediumEditor2.util.keyCode.ENTER)) {
              p = this.options.ownerDocument.createElement("p");
              p.innerHTML = "<br>";
              node2.previousElementSibling.parentNode.insertBefore(p, node2);
              event.preventDefault();
            }
          } else if (MediumEditor2.util.isKey(event, MediumEditor2.util.keyCode.DELETE) && // between two sibling elements
          node2.nextElementSibling && node2.previousElementSibling && // not in a header
          !isHeader.test(tagName) && // in an empty tag
          isEmpty.test(node2.innerHTML) && // when the next tag *is* a header
          isHeader.test(node2.nextElementSibling.nodeName.toLowerCase())) {
            MediumEditor2.selection.moveCursor(this.options.ownerDocument, node2.nextElementSibling);
            node2.previousElementSibling.parentNode.removeChild(node2);
            event.preventDefault();
          } else if (MediumEditor2.util.isKey(event, MediumEditor2.util.keyCode.BACKSPACE) && tagName === "li" && // hitting backspace inside an empty li
          isEmpty.test(node2.innerHTML) && // is first element (no preceeding siblings)
          !node2.previousElementSibling && // parent also does not have a sibling
          !node2.parentElement.previousElementSibling && // is not the only li in a list
          node2.nextElementSibling && node2.nextElementSibling.nodeName.toLowerCase() === "li") {
            p = this.options.ownerDocument.createElement("p");
            p.innerHTML = "<br>";
            node2.parentElement.parentElement.insertBefore(p, node2.parentElement);
            MediumEditor2.selection.moveCursor(this.options.ownerDocument, p);
            node2.parentElement.removeChild(node2);
            event.preventDefault();
          } else if (MediumEditor2.util.isKey(event, MediumEditor2.util.keyCode.BACKSPACE) && MediumEditor2.util.getClosestTag(node2, "blockquote") !== false && MediumEditor2.selection.getCaretOffsets(node2).left === 0) {
            event.preventDefault();
            MediumEditor2.util.execFormatBlock(this.options.ownerDocument, "p");
          } else if (MediumEditor2.util.isKey(event, MediumEditor2.util.keyCode.ENTER) && MediumEditor2.util.getClosestTag(node2, "blockquote") !== false && MediumEditor2.selection.getCaretOffsets(node2).right === 0) {
            p = this.options.ownerDocument.createElement("p");
            p.innerHTML = "<br>";
            node2.parentElement.insertBefore(p, node2.nextSibling);
            MediumEditor2.selection.moveCursor(this.options.ownerDocument, p);
            event.preventDefault();
          } else if (MediumEditor2.util.isKey(event, MediumEditor2.util.keyCode.BACKSPACE) && MediumEditor2.util.isMediumEditorElement(node2.parentElement) && !node2.previousElementSibling && node2.nextElementSibling && isEmpty.test(node2.innerHTML)) {
            event.preventDefault();
            MediumEditor2.selection.moveCursor(this.options.ownerDocument, node2.nextSibling);
            node2.parentElement.removeChild(node2);
          }
        }
        function handleKeyup(event) {
          var node2 = MediumEditor2.selection.getSelectionStart(this.options.ownerDocument), tagName;
          if (!node2) {
            return;
          }
          if (MediumEditor2.util.isMediumEditorElement(node2) && node2.children.length === 0 && !MediumEditor2.util.isBlockContainer(node2)) {
            this.options.ownerDocument.execCommand("formatBlock", false, "p");
          }
          if (MediumEditor2.util.isKey(event, MediumEditor2.util.keyCode.ENTER) && !MediumEditor2.util.isListItem(node2) && !MediumEditor2.util.isBlockContainer(node2)) {
            tagName = node2.nodeName.toLowerCase();
            if (tagName === "a") {
              this.options.ownerDocument.execCommand("unlink", false, null);
            } else if (!event.shiftKey && !event.ctrlKey) {
              this.options.ownerDocument.execCommand("formatBlock", false, "p");
            }
          }
        }
        function handleEditableInput(event, editable) {
          var textarea = editable.parentNode.querySelector('textarea[medium-editor-textarea-id="' + editable.getAttribute("medium-editor-textarea-id") + '"]');
          if (textarea) {
            textarea.value = editable.innerHTML.trim();
          }
        }
        function addToEditors(win) {
          if (!win._mediumEditors) {
            win._mediumEditors = [null];
          }
          if (!this.id) {
            this.id = win._mediumEditors.length;
          }
          win._mediumEditors[this.id] = this;
        }
        function removeFromEditors(win) {
          if (!win._mediumEditors || !win._mediumEditors[this.id]) {
            return;
          }
          win._mediumEditors[this.id] = null;
        }
        function createElementsArray(selector, doc, filterEditorElements) {
          var elements = [];
          if (!selector) {
            selector = [];
          }
          if (typeof selector === "string") {
            selector = doc.querySelectorAll(selector);
          }
          if (MediumEditor2.util.isElement(selector)) {
            selector = [selector];
          }
          if (filterEditorElements) {
            for (var i = 0; i < selector.length; i++) {
              var el = selector[i];
              if (MediumEditor2.util.isElement(el) && !el.getAttribute("data-medium-editor-element") && !el.getAttribute("medium-editor-textarea-id")) {
                elements.push(el);
              }
            }
          } else {
            elements = Array.prototype.slice.apply(selector);
          }
          return elements;
        }
        function cleanupTextareaElement(element) {
          var textarea = element.parentNode.querySelector('textarea[medium-editor-textarea-id="' + element.getAttribute("medium-editor-textarea-id") + '"]');
          if (textarea) {
            textarea.classList.remove("medium-editor-hidden");
            textarea.removeAttribute("medium-editor-textarea-id");
          }
          if (element.parentNode) {
            element.parentNode.removeChild(element);
          }
        }
        function setExtensionDefaults(extension, defaults) {
          Object.keys(defaults).forEach(function(prop) {
            if (extension[prop] === void 0) {
              extension[prop] = defaults[prop];
            }
          });
          return extension;
        }
        function initExtension(extension, name, instance) {
          var extensionDefaults = {
            "window": instance.options.contentWindow,
            "document": instance.options.ownerDocument,
            "base": instance
          };
          extension = setExtensionDefaults(extension, extensionDefaults);
          if (typeof extension.init === "function") {
            extension.init();
          }
          if (!extension.name) {
            extension.name = name;
          }
          return extension;
        }
        function isToolbarEnabled() {
          if (this.elements.every(function(element) {
            return !!element.getAttribute("data-disable-toolbar");
          })) {
            return false;
          }
          return this.options.toolbar !== false;
        }
        function isAnchorPreviewEnabled() {
          if (!isToolbarEnabled.call(this)) {
            return false;
          }
          return this.options.anchorPreview !== false;
        }
        function isPlaceholderEnabled() {
          return this.options.placeholder !== false;
        }
        function isAutoLinkEnabled() {
          return this.options.autoLink !== false;
        }
        function isImageDraggingEnabled() {
          return this.options.imageDragging !== false;
        }
        function isKeyboardCommandsEnabled() {
          return this.options.keyboardCommands !== false;
        }
        function shouldUseFileDraggingExtension() {
          return !this.options.extensions["imageDragging"];
        }
        function createContentEditable(textarea) {
          var div = this.options.ownerDocument.createElement("div"), now = Date.now(), uniqueId = "medium-editor-" + now, atts = textarea.attributes;
          while (this.options.ownerDocument.getElementById(uniqueId)) {
            now++;
            uniqueId = "medium-editor-" + now;
          }
          div.className = textarea.className;
          div.id = uniqueId;
          div.innerHTML = textarea.value;
          textarea.setAttribute("medium-editor-textarea-id", uniqueId);
          for (var i = 0, n = atts.length; i < n; i++) {
            if (!div.hasAttribute(atts[i].nodeName)) {
              div.setAttribute(atts[i].nodeName, atts[i].value);
            }
          }
          if (textarea.form) {
            this.on(textarea.form, "reset", (function(event) {
              if (!event.defaultPrevented) {
                this.resetContent(this.options.ownerDocument.getElementById(uniqueId));
              }
            }).bind(this));
          }
          textarea.classList.add("medium-editor-hidden");
          textarea.parentNode.insertBefore(
            div,
            textarea
          );
          return div;
        }
        function initElement(element, editorId) {
          if (!element.getAttribute("data-medium-editor-element")) {
            if (element.nodeName.toLowerCase() === "textarea") {
              element = createContentEditable.call(this, element);
              if (!this.instanceHandleEditableInput) {
                this.instanceHandleEditableInput = handleEditableInput.bind(this);
                this.subscribe("editableInput", this.instanceHandleEditableInput);
              }
            }
            if (!this.options.disableEditing && !element.getAttribute("data-disable-editing")) {
              element.setAttribute("contentEditable", true);
              element.setAttribute("spellcheck", this.options.spellcheck);
            }
            if (!this.instanceHandleEditableKeydownEnter) {
              if (element.getAttribute("data-disable-return") || element.getAttribute("data-disable-double-return")) {
                this.instanceHandleEditableKeydownEnter = handleDisabledEnterKeydown.bind(this);
                this.subscribe("editableKeydownEnter", this.instanceHandleEditableKeydownEnter);
              }
            }
            if (!this.options.disableReturn && !element.getAttribute("data-disable-return")) {
              this.on(element, "keyup", handleKeyup.bind(this));
            }
            var elementId = MediumEditor2.util.guid();
            element.setAttribute("data-medium-editor-element", true);
            element.classList.add("medium-editor-element");
            element.setAttribute("role", "textbox");
            element.setAttribute("aria-multiline", true);
            element.setAttribute("data-medium-editor-editor-index", editorId);
            element.setAttribute("medium-editor-index", elementId);
            initialContent[elementId] = element.innerHTML;
            this.events.attachAllEventsToElement(element);
          }
          return element;
        }
        function attachHandlers() {
          this.subscribe("editableKeydownTab", handleTabKeydown.bind(this));
          this.subscribe("editableKeydownDelete", handleBlockDeleteKeydowns.bind(this));
          this.subscribe("editableKeydownEnter", handleBlockDeleteKeydowns.bind(this));
          if (this.options.disableExtraSpaces) {
            this.subscribe("editableKeydownSpace", handleDisableExtraSpaces.bind(this));
          }
          if (!this.instanceHandleEditableKeydownEnter) {
            if (this.options.disableReturn || this.options.disableDoubleReturn) {
              this.instanceHandleEditableKeydownEnter = handleDisabledEnterKeydown.bind(this);
              this.subscribe("editableKeydownEnter", this.instanceHandleEditableKeydownEnter);
            }
          }
        }
        function initExtensions() {
          this.extensions = [];
          Object.keys(this.options.extensions).forEach(function(name) {
            if (name !== "toolbar" && this.options.extensions[name]) {
              this.extensions.push(initExtension(this.options.extensions[name], name, this));
            }
          }, this);
          if (shouldUseFileDraggingExtension.call(this)) {
            var opts = this.options.fileDragging;
            if (!opts) {
              opts = {};
              if (!isImageDraggingEnabled.call(this)) {
                opts.allowedTypes = [];
              }
            }
            this.addBuiltInExtension("fileDragging", opts);
          }
          var builtIns = {
            paste: true,
            "anchor-preview": isAnchorPreviewEnabled.call(this),
            autoLink: isAutoLinkEnabled.call(this),
            keyboardCommands: isKeyboardCommandsEnabled.call(this),
            placeholder: isPlaceholderEnabled.call(this)
          };
          Object.keys(builtIns).forEach(function(name) {
            if (builtIns[name]) {
              this.addBuiltInExtension(name);
            }
          }, this);
          var toolbarExtension = this.options.extensions["toolbar"];
          if (!toolbarExtension && isToolbarEnabled.call(this)) {
            var toolbarOptions = MediumEditor2.util.extend({}, this.options.toolbar, {
              allowMultiParagraphSelection: this.options.allowMultiParagraphSelection
              // deprecated
            });
            toolbarExtension = new MediumEditor2.extensions.toolbar(toolbarOptions);
          }
          if (toolbarExtension) {
            this.extensions.push(initExtension(toolbarExtension, "toolbar", this));
          }
        }
        function mergeOptions(defaults, options) {
          var deprecatedProperties = [
            ["allowMultiParagraphSelection", "toolbar.allowMultiParagraphSelection"]
          ];
          if (options) {
            deprecatedProperties.forEach(function(pair) {
              if (options.hasOwnProperty(pair[0]) && options[pair[0]] !== void 0) {
                MediumEditor2.util.deprecated(pair[0], pair[1], "v6.0.0");
              }
            });
          }
          return MediumEditor2.util.defaults({}, options, defaults);
        }
        function execActionInternal(action, opts) {
          var appendAction = /^append-(.+)$/gi, justifyAction = /justify([A-Za-z]*)$/g, match, cmdValueArgument;
          match = appendAction.exec(action);
          if (match) {
            return MediumEditor2.util.execFormatBlock(this.options.ownerDocument, match[1]);
          }
          if (action === "fontSize") {
            if (opts.size) {
              MediumEditor2.util.deprecated(".size option for fontSize command", ".value", "6.0.0");
            }
            cmdValueArgument = opts.value || opts.size;
            return this.options.ownerDocument.execCommand("fontSize", false, cmdValueArgument);
          }
          if (action === "fontName") {
            if (opts.name) {
              MediumEditor2.util.deprecated(".name option for fontName command", ".value", "6.0.0");
            }
            cmdValueArgument = opts.value || opts.name;
            return this.options.ownerDocument.execCommand("fontName", false, cmdValueArgument);
          }
          if (action === "createLink") {
            return this.createLink(opts);
          }
          if (action === "image") {
            var src = this.options.contentWindow.getSelection().toString().trim();
            return this.options.ownerDocument.execCommand("insertImage", false, src);
          }
          if (action === "html") {
            var html = this.options.contentWindow.getSelection().toString().trim();
            return MediumEditor2.util.insertHTMLCommand(this.options.ownerDocument, html);
          }
          if (justifyAction.exec(action)) {
            var result = this.options.ownerDocument.execCommand(action, false, null), parentNode = MediumEditor2.selection.getSelectedParentElement(MediumEditor2.selection.getSelectionRange(this.options.ownerDocument));
            if (parentNode) {
              cleanupJustifyDivFragments.call(this, MediumEditor2.util.getTopBlockContainer(parentNode));
            }
            return result;
          }
          cmdValueArgument = opts && opts.value;
          return this.options.ownerDocument.execCommand(action, false, cmdValueArgument);
        }
        function cleanupJustifyDivFragments(blockContainer) {
          if (!blockContainer) {
            return;
          }
          var textAlign, childDivs = Array.prototype.slice.call(blockContainer.childNodes).filter(function(element) {
            var isDiv = element.nodeName.toLowerCase() === "div";
            if (isDiv && !textAlign) {
              textAlign = element.style.textAlign;
            }
            return isDiv;
          });
          if (childDivs.length) {
            this.saveSelection();
            childDivs.forEach(function(div) {
              if (div.style.textAlign === textAlign) {
                var lastChild = div.lastChild;
                if (lastChild) {
                  MediumEditor2.util.unwrap(div, this.options.ownerDocument);
                  var br = this.options.ownerDocument.createElement("BR");
                  lastChild.parentNode.insertBefore(br, lastChild.nextSibling);
                }
              }
            }, this);
            blockContainer.style.textAlign = textAlign;
            this.restoreSelection();
          }
        }
        var initialContent = {};
        MediumEditor2.prototype = {
          // NOT DOCUMENTED - exposed for backwards compatability
          init: function(elements, options) {
            this.options = mergeOptions.call(this, this.defaults, options);
            this.origElements = elements;
            if (!this.options.elementsContainer) {
              this.options.elementsContainer = this.options.ownerDocument.body;
            }
            return this.setup();
          },
          setup: function() {
            if (this.isActive) {
              return;
            }
            addToEditors.call(this, this.options.contentWindow);
            this.events = new MediumEditor2.Events(this);
            this.elements = [];
            this.addElements(this.origElements);
            if (this.elements.length === 0) {
              return;
            }
            this.isActive = true;
            initExtensions.call(this);
            attachHandlers.call(this);
          },
          destroy: function() {
            if (!this.isActive) {
              return;
            }
            this.isActive = false;
            this.extensions.forEach(function(extension) {
              if (typeof extension.destroy === "function") {
                extension.destroy();
              }
            }, this);
            this.events.destroy();
            this.elements.forEach(function(element) {
              if (this.options.spellcheck) {
                element.innerHTML = element.innerHTML;
              }
              element.removeAttribute("contentEditable");
              element.removeAttribute("spellcheck");
              element.removeAttribute("data-medium-editor-element");
              element.classList.remove("medium-editor-element");
              element.removeAttribute("role");
              element.removeAttribute("aria-multiline");
              element.removeAttribute("medium-editor-index");
              element.removeAttribute("data-medium-editor-editor-index");
              if (element.getAttribute("medium-editor-textarea-id")) {
                cleanupTextareaElement(element);
              }
            }, this);
            this.elements = [];
            this.instanceHandleEditableKeydownEnter = null;
            this.instanceHandleEditableInput = null;
            removeFromEditors.call(this, this.options.contentWindow);
          },
          on: function(target, event, listener, useCapture) {
            this.events.attachDOMEvent(target, event, listener, useCapture);
            return this;
          },
          off: function(target, event, listener, useCapture) {
            this.events.detachDOMEvent(target, event, listener, useCapture);
            return this;
          },
          subscribe: function(event, listener) {
            this.events.attachCustomEvent(event, listener);
            return this;
          },
          unsubscribe: function(event, listener) {
            this.events.detachCustomEvent(event, listener);
            return this;
          },
          trigger: function(name, data, editable) {
            this.events.triggerCustomEvent(name, data, editable);
            return this;
          },
          delay: function(fn) {
            var self2 = this;
            return setTimeout(function() {
              if (self2.isActive) {
                fn();
              }
            }, this.options.delay);
          },
          serialize: function() {
            var i, elementid, content = {}, len = this.elements.length;
            for (i = 0; i < len; i += 1) {
              elementid = this.elements[i].id !== "" ? this.elements[i].id : "element-" + i;
              content[elementid] = {
                value: this.elements[i].innerHTML.trim()
              };
            }
            return content;
          },
          getExtensionByName: function(name) {
            var extension;
            if (this.extensions && this.extensions.length) {
              this.extensions.some(function(ext) {
                if (ext.name === name) {
                  extension = ext;
                  return true;
                }
                return false;
              });
            }
            return extension;
          },
          /**
           * NOT DOCUMENTED - exposed as a helper for other extensions to use
           */
          addBuiltInExtension: function(name, opts) {
            var extension = this.getExtensionByName(name), merged;
            if (extension) {
              return extension;
            }
            switch (name) {
              case "anchor":
                merged = MediumEditor2.util.extend({}, this.options.anchor, opts);
                extension = new MediumEditor2.extensions.anchor(merged);
                break;
              case "anchor-preview":
                extension = new MediumEditor2.extensions.anchorPreview(this.options.anchorPreview);
                break;
              case "autoLink":
                extension = new MediumEditor2.extensions.autoLink();
                break;
              case "fileDragging":
                extension = new MediumEditor2.extensions.fileDragging(opts);
                break;
              case "fontname":
                extension = new MediumEditor2.extensions.fontName(this.options.fontName);
                break;
              case "fontsize":
                extension = new MediumEditor2.extensions.fontSize(opts);
                break;
              case "keyboardCommands":
                extension = new MediumEditor2.extensions.keyboardCommands(this.options.keyboardCommands);
                break;
              case "paste":
                extension = new MediumEditor2.extensions.paste(this.options.paste);
                break;
              case "placeholder":
                extension = new MediumEditor2.extensions.placeholder(this.options.placeholder);
                break;
              default:
                if (MediumEditor2.extensions.button.isBuiltInButton(name)) {
                  if (opts) {
                    merged = MediumEditor2.util.defaults({}, opts, MediumEditor2.extensions.button.prototype.defaults[name]);
                    extension = new MediumEditor2.extensions.button(merged);
                  } else {
                    extension = new MediumEditor2.extensions.button(name);
                  }
                }
            }
            if (extension) {
              this.extensions.push(initExtension(extension, name, this));
            }
            return extension;
          },
          stopSelectionUpdates: function() {
            this.preventSelectionUpdates = true;
          },
          startSelectionUpdates: function() {
            this.preventSelectionUpdates = false;
          },
          checkSelection: function() {
            var toolbar = this.getExtensionByName("toolbar");
            if (toolbar) {
              toolbar.checkState();
            }
            return this;
          },
          // Wrapper around document.queryCommandState for checking whether an action has already
          // been applied to the current selection
          queryCommandState: function(action) {
            var fullAction = /^full-(.+)$/gi, match, queryState = null;
            match = fullAction.exec(action);
            if (match) {
              action = match[1];
            }
            try {
              queryState = this.options.ownerDocument.queryCommandState(action);
            } catch (exc) {
              queryState = null;
            }
            return queryState;
          },
          execAction: function(action, opts) {
            var fullAction = /^full-(.+)$/gi, match, result;
            match = fullAction.exec(action);
            if (match) {
              this.saveSelection();
              this.selectAllContents();
              result = execActionInternal.call(this, match[1], opts);
              this.restoreSelection();
            } else {
              result = execActionInternal.call(this, action, opts);
            }
            if (action === "insertunorderedlist" || action === "insertorderedlist") {
              MediumEditor2.util.cleanListDOM(this.options.ownerDocument, this.getSelectedParentElement());
            }
            this.checkSelection();
            return result;
          },
          getSelectedParentElement: function(range) {
            if (range === void 0) {
              range = this.options.contentWindow.getSelection().getRangeAt(0);
            }
            return MediumEditor2.selection.getSelectedParentElement(range);
          },
          selectAllContents: function() {
            var currNode = MediumEditor2.selection.getSelectionElement(this.options.contentWindow);
            if (currNode) {
              while (currNode.children.length === 1) {
                currNode = currNode.children[0];
              }
              this.selectElement(currNode);
            }
          },
          selectElement: function(element) {
            MediumEditor2.selection.selectNode(element, this.options.ownerDocument);
            var selElement = MediumEditor2.selection.getSelectionElement(this.options.contentWindow);
            if (selElement) {
              this.events.focusElement(selElement);
            }
          },
          getFocusedElement: function() {
            var focused;
            this.elements.some(function(element) {
              if (!focused && element.getAttribute("data-medium-focused")) {
                focused = element;
              }
              return !!focused;
            }, this);
            return focused;
          },
          // Export the state of the selection in respect to one of this
          // instance of MediumEditor's elements
          exportSelection: function() {
            var selectionElement = MediumEditor2.selection.getSelectionElement(this.options.contentWindow), editableElementIndex = this.elements.indexOf(selectionElement), selectionState = null;
            if (editableElementIndex >= 0) {
              selectionState = MediumEditor2.selection.exportSelection(selectionElement, this.options.ownerDocument);
            }
            if (selectionState !== null && editableElementIndex !== 0) {
              selectionState.editableElementIndex = editableElementIndex;
            }
            return selectionState;
          },
          saveSelection: function() {
            this.selectionState = this.exportSelection();
          },
          // Restore a selection based on a selectionState returned by a call
          // to MediumEditor.exportSelection
          importSelection: function(selectionState, favorLaterSelectionAnchor) {
            if (!selectionState) {
              return;
            }
            var editableElement = this.elements[selectionState.editableElementIndex || 0];
            MediumEditor2.selection.importSelection(selectionState, editableElement, this.options.ownerDocument, favorLaterSelectionAnchor);
          },
          restoreSelection: function() {
            this.importSelection(this.selectionState);
          },
          createLink: function(opts) {
            var currentEditor = MediumEditor2.selection.getSelectionElement(this.options.contentWindow), customEvent = {}, targetUrl;
            if (this.elements.indexOf(currentEditor) === -1) {
              return;
            }
            try {
              this.events.disableCustomEvent("editableInput");
              if (opts.url) {
                MediumEditor2.util.deprecated(".url option for createLink", ".value", "6.0.0");
              }
              targetUrl = opts.url || opts.value;
              if (targetUrl && targetUrl.trim().length > 0) {
                var currentSelection = this.options.contentWindow.getSelection();
                if (currentSelection) {
                  var currRange = currentSelection.getRangeAt(0), commonAncestorContainer = currRange.commonAncestorContainer, exportedSelection, startContainerParentElement, endContainerParentElement, textNodes;
                  if (currRange.endContainer.nodeType === 3 && currRange.startContainer.nodeType !== 3 && currRange.startOffset === 0 && currRange.startContainer.firstChild === currRange.endContainer) {
                    commonAncestorContainer = currRange.endContainer;
                  }
                  startContainerParentElement = MediumEditor2.util.getClosestBlockContainer(currRange.startContainer);
                  endContainerParentElement = MediumEditor2.util.getClosestBlockContainer(currRange.endContainer);
                  if (commonAncestorContainer.nodeType !== 3 && commonAncestorContainer.textContent.length !== 0 && startContainerParentElement === endContainerParentElement) {
                    var parentElement = startContainerParentElement || currentEditor, fragment = this.options.ownerDocument.createDocumentFragment();
                    this.execAction("unlink");
                    exportedSelection = this.exportSelection();
                    fragment.appendChild(parentElement.cloneNode(true));
                    if (currentEditor === parentElement) {
                      MediumEditor2.selection.select(
                        this.options.ownerDocument,
                        parentElement.firstChild,
                        0,
                        parentElement.lastChild,
                        parentElement.lastChild.nodeType === 3 ? parentElement.lastChild.nodeValue.length : parentElement.lastChild.childNodes.length
                      );
                    } else {
                      MediumEditor2.selection.select(
                        this.options.ownerDocument,
                        parentElement,
                        0,
                        parentElement,
                        parentElement.childNodes.length
                      );
                    }
                    var modifiedExportedSelection = this.exportSelection();
                    textNodes = MediumEditor2.util.findOrCreateMatchingTextNodes(
                      this.options.ownerDocument,
                      fragment,
                      {
                        start: exportedSelection.start - modifiedExportedSelection.start,
                        end: exportedSelection.end - modifiedExportedSelection.start,
                        editableElementIndex: exportedSelection.editableElementIndex
                      }
                    );
                    if (textNodes.length === 0) {
                      fragment = this.options.ownerDocument.createDocumentFragment();
                      fragment.appendChild(commonAncestorContainer.cloneNode(true));
                      textNodes = [fragment.firstChild.firstChild, fragment.firstChild.lastChild];
                    }
                    MediumEditor2.util.createLink(this.options.ownerDocument, textNodes, targetUrl.trim());
                    var leadingWhitespacesCount = (fragment.firstChild.innerHTML.match(/^\s+/) || [""])[0].length;
                    MediumEditor2.util.insertHTMLCommand(this.options.ownerDocument, fragment.firstChild.innerHTML.replace(/^\s+/, ""));
                    exportedSelection.start -= leadingWhitespacesCount;
                    exportedSelection.end -= leadingWhitespacesCount;
                    this.importSelection(exportedSelection);
                  } else {
                    this.options.ownerDocument.execCommand("createLink", false, targetUrl);
                  }
                  if (this.options.targetBlank || opts.target === "_blank") {
                    MediumEditor2.util.setTargetBlank(MediumEditor2.selection.getSelectionStart(this.options.ownerDocument), targetUrl);
                  } else {
                    MediumEditor2.util.removeTargetBlank(MediumEditor2.selection.getSelectionStart(this.options.ownerDocument), targetUrl);
                  }
                  if (opts.buttonClass) {
                    MediumEditor2.util.addClassToAnchors(MediumEditor2.selection.getSelectionStart(this.options.ownerDocument), opts.buttonClass);
                  }
                }
              }
              if (this.options.targetBlank || opts.target === "_blank" || opts.buttonClass) {
                customEvent = this.options.ownerDocument.createEvent("HTMLEvents");
                customEvent.initEvent("input", true, true, this.options.contentWindow);
                for (var i = 0, len = this.elements.length; i < len; i += 1) {
                  this.elements[i].dispatchEvent(customEvent);
                }
              }
            } finally {
              this.events.enableCustomEvent("editableInput");
            }
            this.events.triggerCustomEvent("editableInput", customEvent, currentEditor);
          },
          cleanPaste: function(text) {
            this.getExtensionByName("paste").cleanPaste(text);
          },
          pasteHTML: function(html, options) {
            this.getExtensionByName("paste").pasteHTML(html, options);
          },
          setContent: function(html, index) {
            index = index || 0;
            if (this.elements[index]) {
              var target = this.elements[index];
              target.innerHTML = html;
              this.checkContentChanged(target);
            }
          },
          getContent: function(index) {
            index = index || 0;
            if (this.elements[index]) {
              return this.elements[index].innerHTML.trim();
            }
            return null;
          },
          checkContentChanged: function(editable) {
            editable = editable || MediumEditor2.selection.getSelectionElement(this.options.contentWindow);
            this.events.updateInput(editable, { target: editable, currentTarget: editable });
          },
          resetContent: function(element) {
            if (element) {
              var index = this.elements.indexOf(element);
              if (index !== -1) {
                this.setContent(initialContent[element.getAttribute("medium-editor-index")], index);
              }
              return;
            }
            this.elements.forEach(function(el, idx) {
              this.setContent(initialContent[el.getAttribute("medium-editor-index")], idx);
            }, this);
          },
          addElements: function(selector) {
            var elements = createElementsArray(selector, this.options.ownerDocument, true);
            if (elements.length === 0) {
              return false;
            }
            elements.forEach(function(element) {
              element = initElement.call(this, element, this.id);
              this.elements.push(element);
              this.trigger("addElement", { target: element, currentTarget: element }, element);
            }, this);
          },
          removeElements: function(selector) {
            var elements = createElementsArray(selector, this.options.ownerDocument), toRemove = elements.map(function(el) {
              if (el.getAttribute("medium-editor-textarea-id") && el.parentNode) {
                return el.parentNode.querySelector('div[medium-editor-textarea-id="' + el.getAttribute("medium-editor-textarea-id") + '"]');
              } else {
                return el;
              }
            });
            this.elements = this.elements.filter(function(element) {
              if (toRemove.indexOf(element) !== -1) {
                this.events.cleanupElement(element);
                if (element.getAttribute("medium-editor-textarea-id")) {
                  cleanupTextareaElement(element);
                }
                this.trigger("removeElement", { target: element, currentTarget: element }, element);
                return false;
              }
              return true;
            }, this);
          }
        };
        MediumEditor2.getEditorFromElement = function(element) {
          var index = element.getAttribute("data-medium-editor-editor-index"), win = element && element.ownerDocument && (element.ownerDocument.defaultView || element.ownerDocument.parentWindow);
          if (win && win._mediumEditors && win._mediumEditors[index]) {
            return win._mediumEditors[index];
          }
          return null;
        };
      })();
      (function() {
        MediumEditor2.prototype.defaults = {
          activeButtonClass: "medium-editor-button-active",
          buttonLabels: false,
          delay: 0,
          disableReturn: false,
          disableDoubleReturn: false,
          disableExtraSpaces: false,
          disableEditing: false,
          autoLink: false,
          elementsContainer: false,
          contentWindow: window,
          ownerDocument: document,
          targetBlank: false,
          extensions: {},
          spellcheck: true
        };
      })();
      MediumEditor2.parseVersionString = function(release) {
        var split = release.split("-"), version = split[0].split("."), preRelease = split.length > 1 ? split[1] : "";
        return {
          major: parseInt(version[0], 10),
          minor: parseInt(version[1], 10),
          revision: parseInt(version[2], 10),
          preRelease,
          toString: function() {
            return [version[0], version[1], version[2]].join(".") + (preRelease ? "-" + preRelease : "");
          }
        };
      };
      MediumEditor2.version = MediumEditor2.parseVersionString.call(this, {
        // grunt-bump looks for this:
        "version": "5.23.3"
      }.version);
      return MediumEditor2;
    }());
  }
});

// node_modules/rangy/lib/rangy-core.js
var require_rangy_core = __commonJS({
  "node_modules/rangy/lib/rangy-core.js"(exports, module) {
    (function(factory, root) {
      if (typeof define == "function" && define.amd) {
        define(factory);
      } else if (typeof module != "undefined" && typeof exports == "object") {
        module.exports = factory();
      } else {
        root.rangy = factory();
      }
    })(function() {
      var OBJECT = "object", FUNCTION = "function", UNDEFINED = "undefined";
      var domRangeProperties = [
        "startContainer",
        "startOffset",
        "endContainer",
        "endOffset",
        "collapsed",
        "commonAncestorContainer"
      ];
      var domRangeMethods = [
        "setStart",
        "setStartBefore",
        "setStartAfter",
        "setEnd",
        "setEndBefore",
        "setEndAfter",
        "collapse",
        "selectNode",
        "selectNodeContents",
        "compareBoundaryPoints",
        "deleteContents",
        "extractContents",
        "cloneContents",
        "insertNode",
        "surroundContents",
        "cloneRange",
        "toString",
        "detach"
      ];
      var textRangeProperties = ["boundingHeight", "boundingLeft", "boundingTop", "boundingWidth", "htmlText", "text"];
      var textRangeMethods = [
        "collapse",
        "compareEndPoints",
        "duplicate",
        "moveToElementText",
        "parentElement",
        "select",
        "setEndPoint",
        "getBoundingClientRect"
      ];
      function isHostMethod(o, p) {
        var t = typeof o[p];
        return t == FUNCTION || !!(t == OBJECT && o[p]) || t == "unknown";
      }
      function isHostObject(o, p) {
        return !!(typeof o[p] == OBJECT && o[p]);
      }
      function isHostProperty(o, p) {
        return typeof o[p] != UNDEFINED;
      }
      function createMultiplePropertyTest(testFunc) {
        return function(o, props) {
          var i = props.length;
          while (i--) {
            if (!testFunc(o, props[i])) {
              return false;
            }
          }
          return true;
        };
      }
      var areHostMethods = createMultiplePropertyTest(isHostMethod);
      var areHostObjects = createMultiplePropertyTest(isHostObject);
      var areHostProperties = createMultiplePropertyTest(isHostProperty);
      function isTextRange(range) {
        return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);
      }
      function getBody(doc) {
        return isHostObject(doc, "body") ? doc.body : doc.getElementsByTagName("body")[0];
      }
      var forEach = [].forEach ? function(arr, func) {
        arr.forEach(func);
      } : function(arr, func) {
        for (var i = 0, len = arr.length; i < len; ++i) {
          func(arr[i], i);
        }
      };
      var modules = {};
      var isBrowser = typeof window != UNDEFINED && typeof document != UNDEFINED;
      var util = {
        isHostMethod,
        isHostObject,
        isHostProperty,
        areHostMethods,
        areHostObjects,
        areHostProperties,
        isTextRange,
        getBody,
        forEach
      };
      var api = {
        version: "1.3.2",
        initialized: false,
        isBrowser,
        supported: true,
        util,
        features: {},
        modules,
        config: {
          alertOnFail: false,
          alertOnWarn: false,
          preferTextRange: false,
          autoInitialize: typeof rangyAutoInitialize == UNDEFINED ? true : rangyAutoInitialize
        }
      };
      function consoleLog(msg) {
        if (typeof console != UNDEFINED && isHostMethod(console, "log")) {
          console.log(msg);
        }
      }
      function alertOrLog(msg, shouldAlert) {
        if (isBrowser && shouldAlert) {
          alert(msg);
        } else {
          consoleLog(msg);
        }
      }
      function fail(reason) {
        api.initialized = true;
        api.supported = false;
        alertOrLog("Rangy is not supported in this environment. Reason: " + reason, api.config.alertOnFail);
      }
      api.fail = fail;
      function warn(msg) {
        alertOrLog("Rangy warning: " + msg, api.config.alertOnWarn);
      }
      api.warn = warn;
      var extend;
      if ({}.hasOwnProperty) {
        util.extend = extend = function(obj, props, deep) {
          var o, p;
          for (var i in props) {
            if (i === "__proto__" || i === "constructor" || i === "prototype") {
              continue;
            }
            if (props.hasOwnProperty(i)) {
              o = obj[i];
              p = props[i];
              if (deep && o !== null && typeof o == "object" && p !== null && typeof p == "object") {
                extend(o, p, true);
              }
              obj[i] = p;
            }
          }
          if (props.hasOwnProperty("toString")) {
            obj.toString = props.toString;
          }
          return obj;
        };
        util.createOptions = function(optionsParam, defaults) {
          var options = {};
          extend(options, defaults);
          if (optionsParam) {
            extend(options, optionsParam);
          }
          return options;
        };
      } else {
        fail("hasOwnProperty not supported");
      }
      if (!isBrowser) {
        fail("Rangy can only run in a browser");
      }
      (function() {
        var toArray;
        if (isBrowser) {
          var el = document.createElement("div");
          el.appendChild(document.createElement("span"));
          var slice = [].slice;
          try {
            if (slice.call(el.childNodes, 0)[0].nodeType == 1) {
              toArray = function(arrayLike) {
                return slice.call(arrayLike, 0);
              };
            }
          } catch (e) {
          }
        }
        if (!toArray) {
          toArray = function(arrayLike) {
            var arr = [];
            for (var i = 0, len = arrayLike.length; i < len; ++i) {
              arr[i] = arrayLike[i];
            }
            return arr;
          };
        }
        util.toArray = toArray;
      })();
      var addListener;
      if (isBrowser) {
        if (isHostMethod(document, "addEventListener")) {
          addListener = function(obj, eventType, listener) {
            obj.addEventListener(eventType, listener, false);
          };
        } else if (isHostMethod(document, "attachEvent")) {
          addListener = function(obj, eventType, listener) {
            obj.attachEvent("on" + eventType, listener);
          };
        } else {
          fail("Document does not have required addEventListener or attachEvent method");
        }
        util.addListener = addListener;
      }
      var initListeners = [];
      function getErrorDesc(ex) {
        return ex.message || ex.description || String(ex);
      }
      function init() {
        if (!isBrowser || api.initialized) {
          return;
        }
        var testRange;
        var implementsDomRange = false, implementsTextRange = false;
        if (isHostMethod(document, "createRange")) {
          testRange = document.createRange();
          if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {
            implementsDomRange = true;
          }
        }
        var body = getBody(document);
        if (!body || body.nodeName.toLowerCase() != "body") {
          fail("No body element found");
          return;
        }
        if (body && isHostMethod(body, "createTextRange")) {
          testRange = body.createTextRange();
          if (isTextRange(testRange)) {
            implementsTextRange = true;
          }
        }
        if (!implementsDomRange && !implementsTextRange) {
          fail("Neither Range nor TextRange are available");
          return;
        }
        api.initialized = true;
        api.features = {
          implementsDomRange,
          implementsTextRange
        };
        var module2, errorMessage;
        for (var moduleName in modules) {
          if ((module2 = modules[moduleName]) instanceof Module) {
            module2.init(module2, api);
          }
        }
        for (var i = 0, len = initListeners.length; i < len; ++i) {
          try {
            initListeners[i](api);
          } catch (ex) {
            errorMessage = "Rangy init listener threw an exception. Continuing. Detail: " + getErrorDesc(ex);
            consoleLog(errorMessage);
          }
        }
      }
      function deprecationNotice(deprecated, replacement, module2) {
        if (module2) {
          deprecated += " in module " + module2.name;
        }
        api.warn("DEPRECATED: " + deprecated + " is deprecated. Please use " + replacement + " instead.");
      }
      function createAliasForDeprecatedMethod(owner, deprecated, replacement, module2) {
        owner[deprecated] = function() {
          deprecationNotice(deprecated, replacement, module2);
          return owner[replacement].apply(owner, util.toArray(arguments));
        };
      }
      util.deprecationNotice = deprecationNotice;
      util.createAliasForDeprecatedMethod = createAliasForDeprecatedMethod;
      api.init = init;
      api.addInitListener = function(listener) {
        if (api.initialized) {
          listener(api);
        } else {
          initListeners.push(listener);
        }
      };
      var shimListeners = [];
      api.addShimListener = function(listener) {
        shimListeners.push(listener);
      };
      function shim(win) {
        win = win || window;
        init();
        for (var i = 0, len = shimListeners.length; i < len; ++i) {
          shimListeners[i](win);
        }
      }
      if (isBrowser) {
        api.shim = api.createMissingNativeApi = shim;
        createAliasForDeprecatedMethod(api, "createMissingNativeApi", "shim");
      }
      function Module(name, dependencies, initializer) {
        this.name = name;
        this.dependencies = dependencies;
        this.initialized = false;
        this.supported = false;
        this.initializer = initializer;
      }
      Module.prototype = {
        init: function() {
          var requiredModuleNames = this.dependencies || [];
          for (var i = 0, len = requiredModuleNames.length, requiredModule, moduleName; i < len; ++i) {
            moduleName = requiredModuleNames[i];
            requiredModule = modules[moduleName];
            if (!requiredModule || !(requiredModule instanceof Module)) {
              throw new Error("required module '" + moduleName + "' not found");
            }
            requiredModule.init();
            if (!requiredModule.supported) {
              throw new Error("required module '" + moduleName + "' not supported");
            }
          }
          this.initializer(this);
        },
        fail: function(reason) {
          this.initialized = true;
          this.supported = false;
          throw new Error(reason);
        },
        warn: function(msg) {
          api.warn("Module " + this.name + ": " + msg);
        },
        deprecationNotice: function(deprecated, replacement) {
          api.warn("DEPRECATED: " + deprecated + " in module " + this.name + " is deprecated. Please use " + replacement + " instead");
        },
        createError: function(msg) {
          return new Error("Error in Rangy " + this.name + " module: " + msg);
        }
      };
      function createModule(name, dependencies, initFunc) {
        var newModule = new Module(name, dependencies, function(module2) {
          if (!module2.initialized) {
            module2.initialized = true;
            try {
              initFunc(api, module2);
              module2.supported = true;
            } catch (ex) {
              var errorMessage = "Module '" + name + "' failed to load: " + getErrorDesc(ex);
              consoleLog(errorMessage);
              if (ex.stack) {
                consoleLog(ex.stack);
              }
            }
          }
        });
        modules[name] = newModule;
        return newModule;
      }
      api.createModule = function(name) {
        var initFunc, dependencies;
        if (arguments.length == 2) {
          initFunc = arguments[1];
          dependencies = [];
        } else {
          initFunc = arguments[2];
          dependencies = arguments[1];
        }
        var module2 = createModule(name, dependencies, initFunc);
        if (api.initialized && api.supported) {
          module2.init();
        }
      };
      api.createCoreModule = function(name, dependencies, initFunc) {
        createModule(name, dependencies, initFunc);
      };
      function RangePrototype() {
      }
      api.RangePrototype = RangePrototype;
      api.rangePrototype = new RangePrototype();
      function SelectionPrototype() {
      }
      api.selectionPrototype = new SelectionPrototype();
      api.createCoreModule("DomUtil", [], function(api2, module2) {
        var UNDEF = "undefined";
        var util2 = api2.util;
        var getBody2 = util2.getBody;
        if (!util2.areHostMethods(document, ["createDocumentFragment", "createElement", "createTextNode"])) {
          module2.fail("document missing a Node creation method");
        }
        if (!util2.isHostMethod(document, "getElementsByTagName")) {
          module2.fail("document missing getElementsByTagName method");
        }
        var el = document.createElement("div");
        if (!util2.areHostMethods(el, ["insertBefore", "appendChild", "cloneNode"])) {
          module2.fail("Incomplete Element implementation");
        }
        if (!util2.isHostProperty(el, "innerHTML")) {
          module2.fail("Element is missing innerHTML property");
        }
        var textNode = document.createTextNode("test");
        if (!util2.areHostMethods(textNode, ["splitText", "deleteData", "insertData", "appendData", "cloneNode"])) {
          module2.fail("Incomplete Text Node implementation");
        }
        var arrayContains = (
          /*Array.prototype.indexOf ?
          function(arr, val) {
              return arr.indexOf(val) > -1;
          }:*/
          function(arr, val) {
            var i = arr.length;
            while (i--) {
              if (arr[i] === val) {
                return true;
              }
            }
            return false;
          }
        );
        function isHtmlNamespace(node2) {
          var ns;
          return typeof node2.namespaceURI == UNDEF || ((ns = node2.namespaceURI) === null || ns == "http://www.w3.org/1999/xhtml");
        }
        function parentElement(node2) {
          var parent = node2.parentNode;
          return parent.nodeType == 1 ? parent : null;
        }
        function getNodeIndex(node2) {
          var i = 0;
          while (node2 = node2.previousSibling) {
            ++i;
          }
          return i;
        }
        function getNodeLength(node2) {
          switch (node2.nodeType) {
            case 7:
            case 10:
              return 0;
            case 3:
            case 8:
              return node2.length;
            default:
              return node2.childNodes.length;
          }
        }
        function getCommonAncestor(node1, node2) {
          var ancestors = [], n;
          for (n = node1; n; n = n.parentNode) {
            ancestors.push(n);
          }
          for (n = node2; n; n = n.parentNode) {
            if (arrayContains(ancestors, n)) {
              return n;
            }
          }
          return null;
        }
        function isAncestorOf(ancestor, descendant, selfIsAncestor) {
          var n = selfIsAncestor ? descendant : descendant.parentNode;
          while (n) {
            if (n === ancestor) {
              return true;
            } else {
              n = n.parentNode;
            }
          }
          return false;
        }
        function isOrIsAncestorOf(ancestor, descendant) {
          return isAncestorOf(ancestor, descendant, true);
        }
        function getClosestAncestorIn(node2, ancestor, selfIsAncestor) {
          var p, n = selfIsAncestor ? node2 : node2.parentNode;
          while (n) {
            p = n.parentNode;
            if (p === ancestor) {
              return n;
            }
            n = p;
          }
          return null;
        }
        function isCharacterDataNode(node2) {
          var t = node2.nodeType;
          return t == 3 || t == 4 || t == 8;
        }
        function isTextOrCommentNode(node2) {
          if (!node2) {
            return false;
          }
          var t = node2.nodeType;
          return t == 3 || t == 8;
        }
        function insertAfter(node2, precedingNode) {
          var nextNode = precedingNode.nextSibling, parent = precedingNode.parentNode;
          if (nextNode) {
            parent.insertBefore(node2, nextNode);
          } else {
            parent.appendChild(node2);
          }
          return node2;
        }
        function splitDataNode(node2, index, positionsToPreserve) {
          var newNode = node2.cloneNode(false);
          newNode.deleteData(0, index);
          node2.deleteData(index, node2.length - index);
          insertAfter(newNode, node2);
          if (positionsToPreserve) {
            for (var i = 0, position; position = positionsToPreserve[i++]; ) {
              if (position.node == node2 && position.offset > index) {
                position.node = newNode;
                position.offset -= index;
              } else if (position.node == node2.parentNode && position.offset > getNodeIndex(node2)) {
                ++position.offset;
              }
            }
          }
          return newNode;
        }
        function getDocument(node2) {
          if (node2.nodeType == 9) {
            return node2;
          } else if (typeof node2.ownerDocument != UNDEF) {
            return node2.ownerDocument;
          } else if (typeof node2.document != UNDEF) {
            return node2.document;
          } else if (node2.parentNode) {
            return getDocument(node2.parentNode);
          } else {
            throw module2.createError("getDocument: no document found for node");
          }
        }
        function getWindow(node2) {
          var doc = getDocument(node2);
          if (typeof doc.defaultView != UNDEF) {
            return doc.defaultView;
          } else if (typeof doc.parentWindow != UNDEF) {
            return doc.parentWindow;
          } else {
            throw module2.createError("Cannot get a window object for node");
          }
        }
        function getIframeDocument(iframeEl) {
          if (typeof iframeEl.contentDocument != UNDEF) {
            return iframeEl.contentDocument;
          } else if (typeof iframeEl.contentWindow != UNDEF) {
            return iframeEl.contentWindow.document;
          } else {
            throw module2.createError("getIframeDocument: No Document object found for iframe element");
          }
        }
        function getIframeWindow(iframeEl) {
          if (typeof iframeEl.contentWindow != UNDEF) {
            return iframeEl.contentWindow;
          } else if (typeof iframeEl.contentDocument != UNDEF) {
            return iframeEl.contentDocument.defaultView;
          } else {
            throw module2.createError("getIframeWindow: No Window object found for iframe element");
          }
        }
        function isWindow(obj) {
          return obj && util2.isHostMethod(obj, "setTimeout") && util2.isHostObject(obj, "document");
        }
        function getContentDocument(obj, module3, methodName) {
          var doc;
          if (!obj) {
            doc = document;
          } else if (util2.isHostProperty(obj, "nodeType")) {
            doc = obj.nodeType == 1 && obj.tagName.toLowerCase() == "iframe" ? getIframeDocument(obj) : getDocument(obj);
          } else if (isWindow(obj)) {
            doc = obj.document;
          }
          if (!doc) {
            throw module3.createError(methodName + "(): Parameter must be a Window object or DOM node");
          }
          return doc;
        }
        function getRootContainer(node2) {
          var parent;
          while (parent = node2.parentNode) {
            node2 = parent;
          }
          return node2;
        }
        function comparePoints(nodeA, offsetA, nodeB, offsetB) {
          var nodeC, root, childA, childB, n;
          if (nodeA == nodeB) {
            return offsetA === offsetB ? 0 : offsetA < offsetB ? -1 : 1;
          } else if (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) {
            return offsetA <= getNodeIndex(nodeC) ? -1 : 1;
          } else if (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) {
            return getNodeIndex(nodeC) < offsetB ? -1 : 1;
          } else {
            root = getCommonAncestor(nodeA, nodeB);
            if (!root) {
              throw new Error("comparePoints error: nodes have no common ancestor");
            }
            childA = nodeA === root ? root : getClosestAncestorIn(nodeA, root, true);
            childB = nodeB === root ? root : getClosestAncestorIn(nodeB, root, true);
            if (childA === childB) {
              throw module2.createError("comparePoints got to case 4 and childA and childB are the same!");
            } else {
              n = root.firstChild;
              while (n) {
                if (n === childA) {
                  return -1;
                } else if (n === childB) {
                  return 1;
                }
                n = n.nextSibling;
              }
            }
          }
        }
        var crashyTextNodes = false;
        function isBrokenNode(node2) {
          var n;
          try {
            n = node2.parentNode;
            return false;
          } catch (e) {
            return true;
          }
        }
        (function() {
          var el2 = document.createElement("b");
          el2.innerHTML = "1";
          var textNode2 = el2.firstChild;
          el2.innerHTML = "<br />";
          crashyTextNodes = isBrokenNode(textNode2);
          api2.features.crashyTextNodes = crashyTextNodes;
        })();
        function inspectNode(node2) {
          if (!node2) {
            return "[No node]";
          }
          if (crashyTextNodes && isBrokenNode(node2)) {
            return "[Broken node]";
          }
          if (isCharacterDataNode(node2)) {
            return '"' + node2.data + '"';
          }
          if (node2.nodeType == 1) {
            var idAttr = node2.id ? ' id="' + node2.id + '"' : "";
            return "<" + node2.nodeName + idAttr + ">[index:" + getNodeIndex(node2) + ",length:" + node2.childNodes.length + "][" + (node2.innerHTML || "[innerHTML not supported]").slice(0, 25) + "]";
          }
          return node2.nodeName;
        }
        function fragmentFromNodeChildren(node2) {
          var fragment = getDocument(node2).createDocumentFragment(), child;
          while (child = node2.firstChild) {
            fragment.appendChild(child);
          }
          return fragment;
        }
        var getComputedStyleProperty;
        if (typeof window.getComputedStyle != UNDEF) {
          getComputedStyleProperty = function(el2, propName) {
            return getWindow(el2).getComputedStyle(el2, null)[propName];
          };
        } else if (typeof document.documentElement.currentStyle != UNDEF) {
          getComputedStyleProperty = function(el2, propName) {
            return el2.currentStyle ? el2.currentStyle[propName] : "";
          };
        } else {
          module2.fail("No means of obtaining computed style properties found");
        }
        function createTestElement(doc, html, contentEditable) {
          var body = getBody2(doc);
          var el2 = doc.createElement("div");
          el2.contentEditable = "" + !!contentEditable;
          if (html) {
            el2.innerHTML = html;
          }
          var bodyFirstChild = body.firstChild;
          if (bodyFirstChild) {
            body.insertBefore(el2, bodyFirstChild);
          } else {
            body.appendChild(el2);
          }
          return el2;
        }
        function removeNode(node2) {
          return node2.parentNode.removeChild(node2);
        }
        function NodeIterator(root) {
          this.root = root;
          this._next = root;
        }
        NodeIterator.prototype = {
          _current: null,
          hasNext: function() {
            return !!this._next;
          },
          next: function() {
            var n = this._current = this._next;
            var child, next;
            if (this._current) {
              child = n.firstChild;
              if (child) {
                this._next = child;
              } else {
                next = null;
                while (n !== this.root && !(next = n.nextSibling)) {
                  n = n.parentNode;
                }
                this._next = next;
              }
            }
            return this._current;
          },
          detach: function() {
            this._current = this._next = this.root = null;
          }
        };
        function createIterator(root) {
          return new NodeIterator(root);
        }
        function DomPosition(node2, offset) {
          this.node = node2;
          this.offset = offset;
        }
        DomPosition.prototype = {
          equals: function(pos) {
            return !!pos && this.node === pos.node && this.offset == pos.offset;
          },
          inspect: function() {
            return "[DomPosition(" + inspectNode(this.node) + ":" + this.offset + ")]";
          },
          toString: function() {
            return this.inspect();
          }
        };
        function DOMException2(codeName) {
          this.code = this[codeName];
          this.codeName = codeName;
          this.message = "DOMException: " + this.codeName;
        }
        DOMException2.prototype = {
          INDEX_SIZE_ERR: 1,
          HIERARCHY_REQUEST_ERR: 3,
          WRONG_DOCUMENT_ERR: 4,
          NO_MODIFICATION_ALLOWED_ERR: 7,
          NOT_FOUND_ERR: 8,
          NOT_SUPPORTED_ERR: 9,
          INVALID_STATE_ERR: 11,
          INVALID_NODE_TYPE_ERR: 24
        };
        DOMException2.prototype.toString = function() {
          return this.message;
        };
        api2.dom = {
          arrayContains,
          isHtmlNamespace,
          parentElement,
          getNodeIndex,
          getNodeLength,
          getCommonAncestor,
          isAncestorOf,
          isOrIsAncestorOf,
          getClosestAncestorIn,
          isCharacterDataNode,
          isTextOrCommentNode,
          insertAfter,
          splitDataNode,
          getDocument,
          getWindow,
          getIframeWindow,
          getIframeDocument,
          getBody: getBody2,
          isWindow,
          getContentDocument,
          getRootContainer,
          comparePoints,
          isBrokenNode,
          inspectNode,
          getComputedStyleProperty,
          createTestElement,
          removeNode,
          fragmentFromNodeChildren,
          createIterator,
          DomPosition
        };
        api2.DOMException = DOMException2;
      });
      api.createCoreModule("DomRange", ["DomUtil"], function(api2, module2) {
        var dom = api2.dom;
        var util2 = api2.util;
        var DomPosition = dom.DomPosition;
        var DOMException2 = api2.DOMException;
        var isCharacterDataNode = dom.isCharacterDataNode;
        var getNodeIndex = dom.getNodeIndex;
        var isOrIsAncestorOf = dom.isOrIsAncestorOf;
        var getDocument = dom.getDocument;
        var comparePoints = dom.comparePoints;
        var splitDataNode = dom.splitDataNode;
        var getClosestAncestorIn = dom.getClosestAncestorIn;
        var getNodeLength = dom.getNodeLength;
        var arrayContains = dom.arrayContains;
        var getRootContainer = dom.getRootContainer;
        var crashyTextNodes = api2.features.crashyTextNodes;
        var removeNode = dom.removeNode;
        function isNonTextPartiallySelected(node2, range) {
          return node2.nodeType != 3 && (isOrIsAncestorOf(node2, range.startContainer) || isOrIsAncestorOf(node2, range.endContainer));
        }
        function getRangeDocument(range) {
          return range.document || getDocument(range.startContainer);
        }
        function getRangeRoot(range) {
          return getRootContainer(range.startContainer);
        }
        function getBoundaryBeforeNode(node2) {
          return new DomPosition(node2.parentNode, getNodeIndex(node2));
        }
        function getBoundaryAfterNode(node2) {
          return new DomPosition(node2.parentNode, getNodeIndex(node2) + 1);
        }
        function insertNodeAtPosition(node2, n, o) {
          var firstNodeInserted = node2.nodeType == 11 ? node2.firstChild : node2;
          if (isCharacterDataNode(n)) {
            if (o == n.length) {
              dom.insertAfter(node2, n);
            } else {
              n.parentNode.insertBefore(node2, o == 0 ? n : splitDataNode(n, o));
            }
          } else if (o >= n.childNodes.length) {
            n.appendChild(node2);
          } else {
            n.insertBefore(node2, n.childNodes[o]);
          }
          return firstNodeInserted;
        }
        function rangesIntersect(rangeA, rangeB, touchingIsIntersecting) {
          assertRangeValid(rangeA);
          assertRangeValid(rangeB);
          if (getRangeDocument(rangeB) != getRangeDocument(rangeA)) {
            throw new DOMException2("WRONG_DOCUMENT_ERR");
          }
          var startComparison = comparePoints(rangeA.startContainer, rangeA.startOffset, rangeB.endContainer, rangeB.endOffset), endComparison = comparePoints(rangeA.endContainer, rangeA.endOffset, rangeB.startContainer, rangeB.startOffset);
          return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
        }
        function cloneSubtree(iterator) {
          var partiallySelected;
          for (var node2, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node2 = iterator.next(); ) {
            partiallySelected = iterator.isPartiallySelectedSubtree();
            node2 = node2.cloneNode(!partiallySelected);
            if (partiallySelected) {
              subIterator = iterator.getSubtreeIterator();
              node2.appendChild(cloneSubtree(subIterator));
              subIterator.detach();
            }
            if (node2.nodeType == 10) {
              throw new DOMException2("HIERARCHY_REQUEST_ERR");
            }
            frag.appendChild(node2);
          }
          return frag;
        }
        function iterateSubtree(rangeIterator, func, iteratorState) {
          var it, n;
          iteratorState = iteratorState || { stop: false };
          for (var node2, subRangeIterator; node2 = rangeIterator.next(); ) {
            if (rangeIterator.isPartiallySelectedSubtree()) {
              if (func(node2) === false) {
                iteratorState.stop = true;
                return;
              } else {
                subRangeIterator = rangeIterator.getSubtreeIterator();
                iterateSubtree(subRangeIterator, func, iteratorState);
                subRangeIterator.detach();
                if (iteratorState.stop) {
                  return;
                }
              }
            } else {
              it = dom.createIterator(node2);
              while (n = it.next()) {
                if (func(n) === false) {
                  iteratorState.stop = true;
                  return;
                }
              }
            }
          }
        }
        function deleteSubtree(iterator) {
          var subIterator;
          while (iterator.next()) {
            if (iterator.isPartiallySelectedSubtree()) {
              subIterator = iterator.getSubtreeIterator();
              deleteSubtree(subIterator);
              subIterator.detach();
            } else {
              iterator.remove();
            }
          }
        }
        function extractSubtree(iterator) {
          for (var node2, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node2 = iterator.next(); ) {
            if (iterator.isPartiallySelectedSubtree()) {
              node2 = node2.cloneNode(false);
              subIterator = iterator.getSubtreeIterator();
              node2.appendChild(extractSubtree(subIterator));
              subIterator.detach();
            } else {
              iterator.remove();
            }
            if (node2.nodeType == 10) {
              throw new DOMException2("HIERARCHY_REQUEST_ERR");
            }
            frag.appendChild(node2);
          }
          return frag;
        }
        function getNodesInRange(range, nodeTypes, filter) {
          var filterNodeTypes = !!(nodeTypes && nodeTypes.length), regex;
          var filterExists = !!filter;
          if (filterNodeTypes) {
            regex = new RegExp("^(" + nodeTypes.join("|") + ")$");
          }
          var nodes = [];
          iterateSubtree(new RangeIterator(range, false), function(node2) {
            if (filterNodeTypes && !regex.test(node2.nodeType)) {
              return;
            }
            if (filterExists && !filter(node2)) {
              return;
            }
            var sc = range.startContainer;
            if (node2 == sc && isCharacterDataNode(sc) && range.startOffset == sc.length) {
              return;
            }
            var ec = range.endContainer;
            if (node2 == ec && isCharacterDataNode(ec) && range.endOffset == 0) {
              return;
            }
            nodes.push(node2);
          });
          return nodes;
        }
        function inspect(range) {
          var name = typeof range.getName == "undefined" ? "Range" : range.getName();
          return "[" + name + "(" + dom.inspectNode(range.startContainer) + ":" + range.startOffset + ", " + dom.inspectNode(range.endContainer) + ":" + range.endOffset + ")]";
        }
        function RangeIterator(range, clonePartiallySelectedTextNodes) {
          this.range = range;
          this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;
          if (!range.collapsed) {
            this.sc = range.startContainer;
            this.so = range.startOffset;
            this.ec = range.endContainer;
            this.eo = range.endOffset;
            var root = range.commonAncestorContainer;
            if (this.sc === this.ec && isCharacterDataNode(this.sc)) {
              this.isSingleCharacterDataNode = true;
              this._first = this._last = this._next = this.sc;
            } else {
              this._first = this._next = this.sc === root && !isCharacterDataNode(this.sc) ? this.sc.childNodes[this.so] : getClosestAncestorIn(this.sc, root, true);
              this._last = this.ec === root && !isCharacterDataNode(this.ec) ? this.ec.childNodes[this.eo - 1] : getClosestAncestorIn(this.ec, root, true);
            }
          }
        }
        RangeIterator.prototype = {
          _current: null,
          _next: null,
          _first: null,
          _last: null,
          isSingleCharacterDataNode: false,
          reset: function() {
            this._current = null;
            this._next = this._first;
          },
          hasNext: function() {
            return !!this._next;
          },
          next: function() {
            var current = this._current = this._next;
            if (current) {
              this._next = current !== this._last ? current.nextSibling : null;
              if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {
                if (current === this.ec) {
                  (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);
                }
                if (this._current === this.sc) {
                  (current = current.cloneNode(true)).deleteData(0, this.so);
                }
              }
            }
            return current;
          },
          remove: function() {
            var current = this._current, start, end;
            if (isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {
              start = current === this.sc ? this.so : 0;
              end = current === this.ec ? this.eo : current.length;
              if (start != end) {
                current.deleteData(start, end - start);
              }
            } else {
              if (current.parentNode) {
                removeNode(current);
              } else {
              }
            }
          },
          // Checks if the current node is partially selected
          isPartiallySelectedSubtree: function() {
            var current = this._current;
            return isNonTextPartiallySelected(current, this.range);
          },
          getSubtreeIterator: function() {
            var subRange;
            if (this.isSingleCharacterDataNode) {
              subRange = this.range.cloneRange();
              subRange.collapse(false);
            } else {
              subRange = new Range(getRangeDocument(this.range));
              var current = this._current;
              var startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);
              if (isOrIsAncestorOf(current, this.sc)) {
                startContainer = this.sc;
                startOffset = this.so;
              }
              if (isOrIsAncestorOf(current, this.ec)) {
                endContainer = this.ec;
                endOffset = this.eo;
              }
              updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);
            }
            return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);
          },
          detach: function() {
            this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;
          }
        };
        var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];
        var rootContainerNodeTypes = [2, 9, 11];
        var readonlyNodeTypes = [5, 6, 10, 12];
        var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];
        var surroundNodeTypes = [1, 3, 4, 5, 7, 8];
        function createAncestorFinder(nodeTypes) {
          return function(node2, selfIsAncestor) {
            var t, n = selfIsAncestor ? node2 : node2.parentNode;
            while (n) {
              t = n.nodeType;
              if (arrayContains(nodeTypes, t)) {
                return n;
              }
              n = n.parentNode;
            }
            return null;
          };
        }
        var getDocumentOrFragmentContainer = createAncestorFinder([9, 11]);
        var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);
        var getDocTypeNotationEntityAncestor = createAncestorFinder([6, 10, 12]);
        var getElementAncestor = createAncestorFinder([1]);
        function assertNoDocTypeNotationEntityAncestor(node2, allowSelf) {
          if (getDocTypeNotationEntityAncestor(node2, allowSelf)) {
            throw new DOMException2("INVALID_NODE_TYPE_ERR");
          }
        }
        function assertValidNodeType(node2, invalidTypes) {
          if (!arrayContains(invalidTypes, node2.nodeType)) {
            throw new DOMException2("INVALID_NODE_TYPE_ERR");
          }
        }
        function assertValidOffset(node2, offset) {
          if (offset < 0 || offset > (isCharacterDataNode(node2) ? node2.length : node2.childNodes.length)) {
            throw new DOMException2("INDEX_SIZE_ERR");
          }
        }
        function assertSameDocumentOrFragment(node1, node2) {
          if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {
            throw new DOMException2("WRONG_DOCUMENT_ERR");
          }
        }
        function assertNodeNotReadOnly(node2) {
          if (getReadonlyAncestor(node2, true)) {
            throw new DOMException2("NO_MODIFICATION_ALLOWED_ERR");
          }
        }
        function assertNode(node2, codeName) {
          if (!node2) {
            throw new DOMException2(codeName);
          }
        }
        function isValidOffset(node2, offset) {
          return offset <= (isCharacterDataNode(node2) ? node2.length : node2.childNodes.length);
        }
        function isRangeValid(range) {
          return !!range.startContainer && !!range.endContainer && !(crashyTextNodes && (dom.isBrokenNode(range.startContainer) || dom.isBrokenNode(range.endContainer))) && getRootContainer(range.startContainer) == getRootContainer(range.endContainer) && isValidOffset(range.startContainer, range.startOffset) && isValidOffset(range.endContainer, range.endOffset);
        }
        function assertRangeValid(range) {
          if (!isRangeValid(range)) {
            throw new Error("Range error: Range is not valid. This usually happens after DOM mutation. Range: (" + range.inspect() + ")");
          }
        }
        var styleEl = document.createElement("style");
        var htmlParsingConforms = false;
        try {
          styleEl.innerHTML = "<b>x</b>";
          htmlParsingConforms = styleEl.firstChild.nodeType == 3;
        } catch (e) {
        }
        api2.features.htmlParsingConforms = htmlParsingConforms;
        var createContextualFragment = htmlParsingConforms ? (
          // Implementation as per HTML parsing spec, trusting in the browser's implementation of innerHTML. See
          // discussion and base code for this implementation at issue 67.
          // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface
          // Thanks to Aleks Williams.
          function(fragmentStr) {
            var node2 = this.startContainer;
            var doc = getDocument(node2);
            if (!node2) {
              throw new DOMException2("INVALID_STATE_ERR");
            }
            var el = null;
            if (node2.nodeType == 1) {
              el = node2;
            } else if (isCharacterDataNode(node2)) {
              el = dom.parentElement(node2);
            }
            if (el === null || el.nodeName == "HTML" && dom.isHtmlNamespace(getDocument(el).documentElement) && dom.isHtmlNamespace(el)) {
              el = doc.createElement("body");
            } else {
              el = el.cloneNode(false);
            }
            el.innerHTML = fragmentStr;
            return dom.fragmentFromNodeChildren(el);
          }
        ) : (
          // In this case, innerHTML cannot be trusted, so fall back to a simpler, non-conformant implementation that
          // previous versions of Rangy used (with the exception of using a body element rather than a div)
          function(fragmentStr) {
            var doc = getRangeDocument(this);
            var el = doc.createElement("body");
            el.innerHTML = fragmentStr;
            return dom.fragmentFromNodeChildren(el);
          }
        );
        function splitRangeBoundaries(range, positionsToPreserve) {
          assertRangeValid(range);
          var sc = range.startContainer, so = range.startOffset, ec = range.endContainer, eo = range.endOffset;
          var startEndSame = sc === ec;
          if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {
            splitDataNode(ec, eo, positionsToPreserve);
          }
          if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {
            sc = splitDataNode(sc, so, positionsToPreserve);
            if (startEndSame) {
              eo -= so;
              ec = sc;
            } else if (ec == sc.parentNode && eo >= getNodeIndex(sc)) {
              eo++;
            }
            so = 0;
          }
          range.setStartAndEnd(sc, so, ec, eo);
        }
        function rangeToHtml(range) {
          assertRangeValid(range);
          var container = range.commonAncestorContainer.parentNode.cloneNode(false);
          container.appendChild(range.cloneContents());
          return container.innerHTML;
        }
        var rangeProperties = [
          "startContainer",
          "startOffset",
          "endContainer",
          "endOffset",
          "collapsed",
          "commonAncestorContainer"
        ];
        var s2s = 0, s2e = 1, e2e = 2, e2s = 3;
        var n_b = 0, n_a = 1, n_b_a = 2, n_i = 3;
        util2.extend(api2.rangePrototype, {
          compareBoundaryPoints: function(how, range) {
            assertRangeValid(this);
            assertSameDocumentOrFragment(this.startContainer, range.startContainer);
            var nodeA, offsetA, nodeB, offsetB;
            var prefixA = how == e2s || how == s2s ? "start" : "end";
            var prefixB = how == s2e || how == s2s ? "start" : "end";
            nodeA = this[prefixA + "Container"];
            offsetA = this[prefixA + "Offset"];
            nodeB = range[prefixB + "Container"];
            offsetB = range[prefixB + "Offset"];
            return comparePoints(nodeA, offsetA, nodeB, offsetB);
          },
          insertNode: function(node2) {
            assertRangeValid(this);
            assertValidNodeType(node2, insertableNodeTypes);
            assertNodeNotReadOnly(this.startContainer);
            if (isOrIsAncestorOf(node2, this.startContainer)) {
              throw new DOMException2("HIERARCHY_REQUEST_ERR");
            }
            var firstNodeInserted = insertNodeAtPosition(node2, this.startContainer, this.startOffset);
            this.setStartBefore(firstNodeInserted);
          },
          cloneContents: function() {
            assertRangeValid(this);
            var clone, frag;
            if (this.collapsed) {
              return getRangeDocument(this).createDocumentFragment();
            } else {
              if (this.startContainer === this.endContainer && isCharacterDataNode(this.startContainer)) {
                clone = this.startContainer.cloneNode(true);
                clone.data = clone.data.slice(this.startOffset, this.endOffset);
                frag = getRangeDocument(this).createDocumentFragment();
                frag.appendChild(clone);
                return frag;
              } else {
                var iterator = new RangeIterator(this, true);
                clone = cloneSubtree(iterator);
                iterator.detach();
              }
              return clone;
            }
          },
          canSurroundContents: function() {
            assertRangeValid(this);
            assertNodeNotReadOnly(this.startContainer);
            assertNodeNotReadOnly(this.endContainer);
            var iterator = new RangeIterator(this, true);
            var boundariesInvalid = iterator._first && isNonTextPartiallySelected(iterator._first, this) || iterator._last && isNonTextPartiallySelected(iterator._last, this);
            iterator.detach();
            return !boundariesInvalid;
          },
          surroundContents: function(node2) {
            assertValidNodeType(node2, surroundNodeTypes);
            if (!this.canSurroundContents()) {
              throw new DOMException2("INVALID_STATE_ERR");
            }
            var content = this.extractContents();
            if (node2.hasChildNodes()) {
              while (node2.lastChild) {
                node2.removeChild(node2.lastChild);
              }
            }
            insertNodeAtPosition(node2, this.startContainer, this.startOffset);
            node2.appendChild(content);
            this.selectNode(node2);
          },
          cloneRange: function() {
            assertRangeValid(this);
            var range = new Range(getRangeDocument(this));
            var i = rangeProperties.length, prop;
            while (i--) {
              prop = rangeProperties[i];
              range[prop] = this[prop];
            }
            return range;
          },
          toString: function() {
            assertRangeValid(this);
            var sc = this.startContainer;
            if (sc === this.endContainer && isCharacterDataNode(sc)) {
              return sc.nodeType == 3 || sc.nodeType == 4 ? sc.data.slice(this.startOffset, this.endOffset) : "";
            } else {
              var textParts = [], iterator = new RangeIterator(this, true);
              iterateSubtree(iterator, function(node2) {
                if (node2.nodeType == 3 || node2.nodeType == 4) {
                  textParts.push(node2.data);
                }
              });
              iterator.detach();
              return textParts.join("");
            }
          },
          // The methods below are all non-standard. The following batch were introduced by Mozilla but have since
          // been removed from Mozilla.
          compareNode: function(node2) {
            assertRangeValid(this);
            var parent = node2.parentNode;
            var nodeIndex = getNodeIndex(node2);
            if (!parent) {
              throw new DOMException2("NOT_FOUND_ERR");
            }
            var startComparison = this.comparePoint(parent, nodeIndex), endComparison = this.comparePoint(parent, nodeIndex + 1);
            if (startComparison < 0) {
              return endComparison > 0 ? n_b_a : n_b;
            } else {
              return endComparison > 0 ? n_a : n_i;
            }
          },
          comparePoint: function(node2, offset) {
            assertRangeValid(this);
            assertNode(node2, "HIERARCHY_REQUEST_ERR");
            assertSameDocumentOrFragment(node2, this.startContainer);
            if (comparePoints(node2, offset, this.startContainer, this.startOffset) < 0) {
              return -1;
            } else if (comparePoints(node2, offset, this.endContainer, this.endOffset) > 0) {
              return 1;
            }
            return 0;
          },
          createContextualFragment,
          toHtml: function() {
            return rangeToHtml(this);
          },
          // touchingIsIntersecting determines whether this method considers a node that borders a range intersects
          // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)
          intersectsNode: function(node2, touchingIsIntersecting) {
            assertRangeValid(this);
            if (getRootContainer(node2) != getRangeRoot(this)) {
              return false;
            }
            var parent = node2.parentNode, offset = getNodeIndex(node2);
            if (!parent) {
              return true;
            }
            var startComparison = comparePoints(parent, offset, this.endContainer, this.endOffset), endComparison = comparePoints(parent, offset + 1, this.startContainer, this.startOffset);
            return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
          },
          isPointInRange: function(node2, offset) {
            assertRangeValid(this);
            assertNode(node2, "HIERARCHY_REQUEST_ERR");
            assertSameDocumentOrFragment(node2, this.startContainer);
            return comparePoints(node2, offset, this.startContainer, this.startOffset) >= 0 && comparePoints(node2, offset, this.endContainer, this.endOffset) <= 0;
          },
          // The methods below are non-standard and invented by me.
          // Sharing a boundary start-to-end or end-to-start does not count as intersection.
          intersectsRange: function(range) {
            return rangesIntersect(this, range, false);
          },
          // Sharing a boundary start-to-end or end-to-start does count as intersection.
          intersectsOrTouchesRange: function(range) {
            return rangesIntersect(this, range, true);
          },
          intersection: function(range) {
            if (this.intersectsRange(range)) {
              var startComparison = comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset), endComparison = comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);
              var intersectionRange = this.cloneRange();
              if (startComparison == -1) {
                intersectionRange.setStart(range.startContainer, range.startOffset);
              }
              if (endComparison == 1) {
                intersectionRange.setEnd(range.endContainer, range.endOffset);
              }
              return intersectionRange;
            }
            return null;
          },
          union: function(range) {
            if (this.intersectsOrTouchesRange(range)) {
              var unionRange = this.cloneRange();
              if (comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {
                unionRange.setStart(range.startContainer, range.startOffset);
              }
              if (comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {
                unionRange.setEnd(range.endContainer, range.endOffset);
              }
              return unionRange;
            } else {
              throw new DOMException2("Ranges do not intersect");
            }
          },
          containsNode: function(node2, allowPartial) {
            if (allowPartial) {
              return this.intersectsNode(node2, false);
            } else {
              return this.compareNode(node2) == n_i;
            }
          },
          containsNodeContents: function(node2) {
            return this.comparePoint(node2, 0) >= 0 && this.comparePoint(node2, getNodeLength(node2)) <= 0;
          },
          containsRange: function(range) {
            var intersection = this.intersection(range);
            return intersection !== null && range.equals(intersection);
          },
          containsNodeText: function(node2) {
            var nodeRange = this.cloneRange();
            nodeRange.selectNode(node2);
            var textNodes = nodeRange.getNodes([3]);
            if (textNodes.length > 0) {
              nodeRange.setStart(textNodes[0], 0);
              var lastTextNode = textNodes.pop();
              nodeRange.setEnd(lastTextNode, lastTextNode.length);
              return this.containsRange(nodeRange);
            } else {
              return this.containsNodeContents(node2);
            }
          },
          getNodes: function(nodeTypes, filter) {
            assertRangeValid(this);
            return getNodesInRange(this, nodeTypes, filter);
          },
          getDocument: function() {
            return getRangeDocument(this);
          },
          collapseBefore: function(node2) {
            this.setEndBefore(node2);
            this.collapse(false);
          },
          collapseAfter: function(node2) {
            this.setStartAfter(node2);
            this.collapse(true);
          },
          getBookmark: function(containerNode) {
            var doc = getRangeDocument(this);
            var preSelectionRange = api2.createRange(doc);
            containerNode = containerNode || dom.getBody(doc);
            preSelectionRange.selectNodeContents(containerNode);
            var range = this.intersection(preSelectionRange);
            var start = 0, end = 0;
            if (range) {
              preSelectionRange.setEnd(range.startContainer, range.startOffset);
              start = preSelectionRange.toString().length;
              end = start + range.toString().length;
            }
            return {
              start,
              end,
              containerNode
            };
          },
          moveToBookmark: function(bookmark) {
            var containerNode = bookmark.containerNode;
            var charIndex = 0;
            this.setStart(containerNode, 0);
            this.collapse(true);
            var nodeStack = [containerNode], node2, foundStart = false, stop = false;
            var nextCharIndex, i, childNodes;
            while (!stop && (node2 = nodeStack.pop())) {
              if (node2.nodeType == 3) {
                nextCharIndex = charIndex + node2.length;
                if (!foundStart && bookmark.start >= charIndex && bookmark.start <= nextCharIndex) {
                  this.setStart(node2, bookmark.start - charIndex);
                  foundStart = true;
                }
                if (foundStart && bookmark.end >= charIndex && bookmark.end <= nextCharIndex) {
                  this.setEnd(node2, bookmark.end - charIndex);
                  stop = true;
                }
                charIndex = nextCharIndex;
              } else {
                childNodes = node2.childNodes;
                i = childNodes.length;
                while (i--) {
                  nodeStack.push(childNodes[i]);
                }
              }
            }
          },
          getName: function() {
            return "DomRange";
          },
          equals: function(range) {
            return Range.rangesEqual(this, range);
          },
          isValid: function() {
            return isRangeValid(this);
          },
          inspect: function() {
            return inspect(this);
          },
          detach: function() {
          }
        });
        function copyComparisonConstantsToObject(obj) {
          obj.START_TO_START = s2s;
          obj.START_TO_END = s2e;
          obj.END_TO_END = e2e;
          obj.END_TO_START = e2s;
          obj.NODE_BEFORE = n_b;
          obj.NODE_AFTER = n_a;
          obj.NODE_BEFORE_AND_AFTER = n_b_a;
          obj.NODE_INSIDE = n_i;
        }
        function copyComparisonConstants(constructor) {
          copyComparisonConstantsToObject(constructor);
          copyComparisonConstantsToObject(constructor.prototype);
        }
        function createRangeContentRemover(remover, boundaryUpdater) {
          return function() {
            assertRangeValid(this);
            var sc = this.startContainer, so = this.startOffset, root = this.commonAncestorContainer;
            var iterator = new RangeIterator(this, true);
            var node2, boundary;
            if (sc !== root) {
              node2 = getClosestAncestorIn(sc, root, true);
              boundary = getBoundaryAfterNode(node2);
              sc = boundary.node;
              so = boundary.offset;
            }
            iterateSubtree(iterator, assertNodeNotReadOnly);
            iterator.reset();
            var returnValue = remover(iterator);
            iterator.detach();
            boundaryUpdater(this, sc, so, sc, so);
            return returnValue;
          };
        }
        function createPrototypeRange(constructor, boundaryUpdater) {
          function createBeforeAfterNodeSetter(isBefore, isStart) {
            return function(node2) {
              assertValidNodeType(node2, beforeAfterNodeTypes);
              assertValidNodeType(getRootContainer(node2), rootContainerNodeTypes);
              var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node2);
              (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);
            };
          }
          function setRangeStart(range, node2, offset) {
            var ec = range.endContainer, eo = range.endOffset;
            if (node2 !== range.startContainer || offset !== range.startOffset) {
              if (getRootContainer(node2) != getRootContainer(ec) || comparePoints(node2, offset, ec, eo) == 1) {
                ec = node2;
                eo = offset;
              }
              boundaryUpdater(range, node2, offset, ec, eo);
            }
          }
          function setRangeEnd(range, node2, offset) {
            var sc = range.startContainer, so = range.startOffset;
            if (node2 !== range.endContainer || offset !== range.endOffset) {
              if (getRootContainer(node2) != getRootContainer(sc) || comparePoints(node2, offset, sc, so) == -1) {
                sc = node2;
                so = offset;
              }
              boundaryUpdater(range, sc, so, node2, offset);
            }
          }
          var F = function() {
          };
          F.prototype = api2.rangePrototype;
          constructor.prototype = new F();
          util2.extend(constructor.prototype, {
            setStart: function(node2, offset) {
              assertNoDocTypeNotationEntityAncestor(node2, true);
              assertValidOffset(node2, offset);
              setRangeStart(this, node2, offset);
            },
            setEnd: function(node2, offset) {
              assertNoDocTypeNotationEntityAncestor(node2, true);
              assertValidOffset(node2, offset);
              setRangeEnd(this, node2, offset);
            },
            /**
             * Convenience method to set a range's start and end boundaries. Overloaded as follows:
             * - Two parameters (node, offset) creates a collapsed range at that position
             * - Three parameters (node, startOffset, endOffset) creates a range contained with node starting at
             *   startOffset and ending at endOffset
             * - Four parameters (startNode, startOffset, endNode, endOffset) creates a range starting at startOffset in
             *   startNode and ending at endOffset in endNode
             */
            setStartAndEnd: function() {
              var args = arguments;
              var sc = args[0], so = args[1], ec = sc, eo = so;
              switch (args.length) {
                case 3:
                  eo = args[2];
                  break;
                case 4:
                  ec = args[2];
                  eo = args[3];
                  break;
              }
              assertNoDocTypeNotationEntityAncestor(sc, true);
              assertValidOffset(sc, so);
              assertNoDocTypeNotationEntityAncestor(ec, true);
              assertValidOffset(ec, eo);
              boundaryUpdater(this, sc, so, ec, eo);
            },
            setBoundary: function(node2, offset, isStart) {
              this["set" + (isStart ? "Start" : "End")](node2, offset);
            },
            setStartBefore: createBeforeAfterNodeSetter(true, true),
            setStartAfter: createBeforeAfterNodeSetter(false, true),
            setEndBefore: createBeforeAfterNodeSetter(true, false),
            setEndAfter: createBeforeAfterNodeSetter(false, false),
            collapse: function(isStart) {
              assertRangeValid(this);
              if (isStart) {
                boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);
              } else {
                boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);
              }
            },
            selectNodeContents: function(node2) {
              assertNoDocTypeNotationEntityAncestor(node2, true);
              boundaryUpdater(this, node2, 0, node2, getNodeLength(node2));
            },
            selectNode: function(node2) {
              assertNoDocTypeNotationEntityAncestor(node2, false);
              assertValidNodeType(node2, beforeAfterNodeTypes);
              var start = getBoundaryBeforeNode(node2), end = getBoundaryAfterNode(node2);
              boundaryUpdater(this, start.node, start.offset, end.node, end.offset);
            },
            extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),
            deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),
            canSurroundContents: function() {
              assertRangeValid(this);
              assertNodeNotReadOnly(this.startContainer);
              assertNodeNotReadOnly(this.endContainer);
              var iterator = new RangeIterator(this, true);
              var boundariesInvalid = iterator._first && isNonTextPartiallySelected(iterator._first, this) || iterator._last && isNonTextPartiallySelected(iterator._last, this);
              iterator.detach();
              return !boundariesInvalid;
            },
            splitBoundaries: function() {
              splitRangeBoundaries(this);
            },
            splitBoundariesPreservingPositions: function(positionsToPreserve) {
              splitRangeBoundaries(this, positionsToPreserve);
            },
            normalizeBoundaries: function() {
              assertRangeValid(this);
              var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;
              var mergeForward = function(node2) {
                var sibling2 = node2.nextSibling;
                if (sibling2 && sibling2.nodeType == node2.nodeType) {
                  ec = node2;
                  eo = node2.length;
                  node2.appendData(sibling2.data);
                  removeNode(sibling2);
                }
              };
              var mergeBackward = function(node2) {
                var sibling2 = node2.previousSibling;
                if (sibling2 && sibling2.nodeType == node2.nodeType) {
                  sc = node2;
                  var nodeLength = node2.length;
                  so = sibling2.length;
                  node2.insertData(0, sibling2.data);
                  removeNode(sibling2);
                  if (sc == ec) {
                    eo += so;
                    ec = sc;
                  } else if (ec == node2.parentNode) {
                    var nodeIndex = getNodeIndex(node2);
                    if (eo == nodeIndex) {
                      ec = node2;
                      eo = nodeLength;
                    } else if (eo > nodeIndex) {
                      eo--;
                    }
                  }
                }
              };
              var normalizeStart = true;
              var sibling;
              if (isCharacterDataNode(ec)) {
                if (eo == ec.length) {
                  mergeForward(ec);
                } else if (eo == 0) {
                  sibling = ec.previousSibling;
                  if (sibling && sibling.nodeType == ec.nodeType) {
                    eo = sibling.length;
                    if (sc == ec) {
                      normalizeStart = false;
                    }
                    sibling.appendData(ec.data);
                    removeNode(ec);
                    ec = sibling;
                  }
                }
              } else {
                if (eo > 0) {
                  var endNode = ec.childNodes[eo - 1];
                  if (endNode && isCharacterDataNode(endNode)) {
                    mergeForward(endNode);
                  }
                }
                normalizeStart = !this.collapsed;
              }
              if (normalizeStart) {
                if (isCharacterDataNode(sc)) {
                  if (so == 0) {
                    mergeBackward(sc);
                  } else if (so == sc.length) {
                    sibling = sc.nextSibling;
                    if (sibling && sibling.nodeType == sc.nodeType) {
                      if (ec == sibling) {
                        ec = sc;
                        eo += sc.length;
                      }
                      sc.appendData(sibling.data);
                      removeNode(sibling);
                    }
                  }
                } else {
                  if (so < sc.childNodes.length) {
                    var startNode = sc.childNodes[so];
                    if (startNode && isCharacterDataNode(startNode)) {
                      mergeBackward(startNode);
                    }
                  }
                }
              } else {
                sc = ec;
                so = eo;
              }
              boundaryUpdater(this, sc, so, ec, eo);
            },
            collapseToPoint: function(node2, offset) {
              assertNoDocTypeNotationEntityAncestor(node2, true);
              assertValidOffset(node2, offset);
              this.setStartAndEnd(node2, offset);
            },
            parentElement: function() {
              assertRangeValid(this);
              var parentNode = this.commonAncestorContainer;
              return parentNode ? getElementAncestor(this.commonAncestorContainer, true) : null;
            }
          });
          copyComparisonConstants(constructor);
        }
        function updateCollapsedAndCommonAncestor(range) {
          range.collapsed = range.startContainer === range.endContainer && range.startOffset === range.endOffset;
          range.commonAncestorContainer = range.collapsed ? range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);
        }
        function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {
          range.startContainer = startContainer;
          range.startOffset = startOffset;
          range.endContainer = endContainer;
          range.endOffset = endOffset;
          range.document = dom.getDocument(startContainer);
          updateCollapsedAndCommonAncestor(range);
        }
        function Range(doc) {
          updateBoundaries(this, doc, 0, doc, 0);
        }
        createPrototypeRange(Range, updateBoundaries);
        util2.extend(Range, {
          rangeProperties,
          RangeIterator,
          copyComparisonConstants,
          createPrototypeRange,
          inspect,
          toHtml: rangeToHtml,
          getRangeDocument,
          rangesEqual: function(r1, r2) {
            return r1.startContainer === r2.startContainer && r1.startOffset === r2.startOffset && r1.endContainer === r2.endContainer && r1.endOffset === r2.endOffset;
          }
        });
        api2.DomRange = Range;
      });
      api.createCoreModule("WrappedRange", ["DomRange"], function(api2, module2) {
        var WrappedRange, WrappedTextRange;
        var dom = api2.dom;
        var util2 = api2.util;
        var DomPosition = dom.DomPosition;
        var DomRange = api2.DomRange;
        var getBody2 = dom.getBody;
        var getContentDocument = dom.getContentDocument;
        var isCharacterDataNode = dom.isCharacterDataNode;
        if (api2.features.implementsDomRange) {
          (function() {
            var rangeProto;
            var rangeProperties = DomRange.rangeProperties;
            function updateRangeProperties(range3) {
              var i = rangeProperties.length, prop;
              while (i--) {
                prop = rangeProperties[i];
                range3[prop] = range3.nativeRange[prop];
              }
              range3.collapsed = range3.startContainer === range3.endContainer && range3.startOffset === range3.endOffset;
            }
            function updateNativeRange(range3, startContainer, startOffset, endContainer, endOffset) {
              var startMoved = range3.startContainer !== startContainer || range3.startOffset != startOffset;
              var endMoved = range3.endContainer !== endContainer || range3.endOffset != endOffset;
              var nativeRangeDifferent = !range3.equals(range3.nativeRange);
              if (startMoved || endMoved || nativeRangeDifferent) {
                range3.setEnd(endContainer, endOffset);
                range3.setStart(startContainer, startOffset);
              }
            }
            var createBeforeAfterNodeSetter;
            WrappedRange = function(range3) {
              if (!range3) {
                throw module2.createError("WrappedRange: Range must be specified");
              }
              this.nativeRange = range3;
              updateRangeProperties(this);
            };
            DomRange.createPrototypeRange(WrappedRange, updateNativeRange);
            rangeProto = WrappedRange.prototype;
            rangeProto.selectNode = function(node2) {
              this.nativeRange.selectNode(node2);
              updateRangeProperties(this);
            };
            rangeProto.cloneContents = function() {
              return this.nativeRange.cloneContents();
            };
            rangeProto.surroundContents = function(node2) {
              this.nativeRange.surroundContents(node2);
              updateRangeProperties(this);
            };
            rangeProto.collapse = function(isStart) {
              this.nativeRange.collapse(isStart);
              updateRangeProperties(this);
            };
            rangeProto.cloneRange = function() {
              return new WrappedRange(this.nativeRange.cloneRange());
            };
            rangeProto.refresh = function() {
              updateRangeProperties(this);
            };
            rangeProto.toString = function() {
              return this.nativeRange.toString();
            };
            var testTextNode = document.createTextNode("test");
            getBody2(document).appendChild(testTextNode);
            var range = document.createRange();
            range.setStart(testTextNode, 0);
            range.setEnd(testTextNode, 0);
            try {
              range.setStart(testTextNode, 1);
              rangeProto.setStart = function(node2, offset) {
                this.nativeRange.setStart(node2, offset);
                updateRangeProperties(this);
              };
              rangeProto.setEnd = function(node2, offset) {
                this.nativeRange.setEnd(node2, offset);
                updateRangeProperties(this);
              };
              createBeforeAfterNodeSetter = function(name) {
                return function(node2) {
                  this.nativeRange[name](node2);
                  updateRangeProperties(this);
                };
              };
            } catch (ex) {
              rangeProto.setStart = function(node2, offset) {
                try {
                  this.nativeRange.setStart(node2, offset);
                } catch (ex2) {
                  this.nativeRange.setEnd(node2, offset);
                  this.nativeRange.setStart(node2, offset);
                }
                updateRangeProperties(this);
              };
              rangeProto.setEnd = function(node2, offset) {
                try {
                  this.nativeRange.setEnd(node2, offset);
                } catch (ex2) {
                  this.nativeRange.setStart(node2, offset);
                  this.nativeRange.setEnd(node2, offset);
                }
                updateRangeProperties(this);
              };
              createBeforeAfterNodeSetter = function(name, oppositeName) {
                return function(node2) {
                  try {
                    this.nativeRange[name](node2);
                  } catch (ex2) {
                    this.nativeRange[oppositeName](node2);
                    this.nativeRange[name](node2);
                  }
                  updateRangeProperties(this);
                };
              };
            }
            rangeProto.setStartBefore = createBeforeAfterNodeSetter("setStartBefore", "setEndBefore");
            rangeProto.setStartAfter = createBeforeAfterNodeSetter("setStartAfter", "setEndAfter");
            rangeProto.setEndBefore = createBeforeAfterNodeSetter("setEndBefore", "setStartBefore");
            rangeProto.setEndAfter = createBeforeAfterNodeSetter("setEndAfter", "setStartAfter");
            rangeProto.selectNodeContents = function(node2) {
              this.setStartAndEnd(node2, 0, dom.getNodeLength(node2));
            };
            range.selectNodeContents(testTextNode);
            range.setEnd(testTextNode, 3);
            var range2 = document.createRange();
            range2.selectNodeContents(testTextNode);
            range2.setEnd(testTextNode, 4);
            range2.setStart(testTextNode, 2);
            if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 && range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {
              rangeProto.compareBoundaryPoints = function(type3, range3) {
                range3 = range3.nativeRange || range3;
                if (type3 == range3.START_TO_END) {
                  type3 = range3.END_TO_START;
                } else if (type3 == range3.END_TO_START) {
                  type3 = range3.START_TO_END;
                }
                return this.nativeRange.compareBoundaryPoints(type3, range3);
              };
            } else {
              rangeProto.compareBoundaryPoints = function(type3, range3) {
                return this.nativeRange.compareBoundaryPoints(type3, range3.nativeRange || range3);
              };
            }
            var el = document.createElement("div");
            el.innerHTML = "123";
            var textNode = el.firstChild;
            var body = getBody2(document);
            body.appendChild(el);
            range.setStart(textNode, 1);
            range.setEnd(textNode, 2);
            range.deleteContents();
            if (textNode.data == "13") {
              rangeProto.deleteContents = function() {
                this.nativeRange.deleteContents();
                updateRangeProperties(this);
              };
              rangeProto.extractContents = function() {
                var frag = this.nativeRange.extractContents();
                updateRangeProperties(this);
                return frag;
              };
            } else {
            }
            body.removeChild(el);
            body = null;
            if (util2.isHostMethod(range, "createContextualFragment")) {
              rangeProto.createContextualFragment = function(fragmentStr) {
                return this.nativeRange.createContextualFragment(fragmentStr);
              };
            }
            getBody2(document).removeChild(testTextNode);
            rangeProto.getName = function() {
              return "WrappedRange";
            };
            api2.WrappedRange = WrappedRange;
            api2.createNativeRange = function(doc) {
              doc = getContentDocument(doc, module2, "createNativeRange");
              return doc.createRange();
            };
          })();
        }
        if (api2.features.implementsTextRange) {
          var getTextRangeContainerElement = function(textRange) {
            var parentEl = textRange.parentElement();
            var range = textRange.duplicate();
            range.collapse(true);
            var startEl = range.parentElement();
            range = textRange.duplicate();
            range.collapse(false);
            var endEl = range.parentElement();
            var startEndContainer = startEl == endEl ? startEl : dom.getCommonAncestor(startEl, endEl);
            return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);
          };
          var textRangeIsCollapsed = function(textRange) {
            return textRange.compareEndPoints("StartToEnd", textRange) == 0;
          };
          var getTextRangeBoundaryPosition = function(textRange, wholeRangeContainerElement, isStart, isCollapsed, startInfo) {
            var workingRange = textRange.duplicate();
            workingRange.collapse(isStart);
            var containerElement = workingRange.parentElement();
            if (!dom.isOrIsAncestorOf(wholeRangeContainerElement, containerElement)) {
              containerElement = wholeRangeContainerElement;
            }
            if (!containerElement.canHaveHTML) {
              var pos = new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));
              return {
                boundaryPosition: pos,
                nodeInfo: {
                  nodeIndex: pos.offset,
                  containerElement: pos.node
                }
              };
            }
            var workingNode = dom.getDocument(containerElement).createElement("span");
            if (workingNode.parentNode) {
              dom.removeNode(workingNode);
            }
            var comparison, workingComparisonType = isStart ? "StartToStart" : "StartToEnd";
            var previousNode, nextNode, boundaryPosition, boundaryNode;
            var start = startInfo && startInfo.containerElement == containerElement ? startInfo.nodeIndex : 0;
            var childNodeCount = containerElement.childNodes.length;
            var end = childNodeCount;
            var nodeIndex = end;
            while (true) {
              if (nodeIndex == childNodeCount) {
                containerElement.appendChild(workingNode);
              } else {
                containerElement.insertBefore(workingNode, containerElement.childNodes[nodeIndex]);
              }
              workingRange.moveToElementText(workingNode);
              comparison = workingRange.compareEndPoints(workingComparisonType, textRange);
              if (comparison == 0 || start == end) {
                break;
              } else if (comparison == -1) {
                if (end == start + 1) {
                  break;
                } else {
                  start = nodeIndex;
                }
              } else {
                end = end == start + 1 ? start : nodeIndex;
              }
              nodeIndex = Math.floor((start + end) / 2);
              containerElement.removeChild(workingNode);
            }
            boundaryNode = workingNode.nextSibling;
            if (comparison == -1 && boundaryNode && isCharacterDataNode(boundaryNode)) {
              workingRange.setEndPoint(isStart ? "EndToStart" : "EndToEnd", textRange);
              var offset;
              if (/[\r\n]/.test(boundaryNode.data)) {
                var tempRange = workingRange.duplicate();
                var rangeLength = tempRange.text.replace(/\r\n/g, "\r").length;
                offset = tempRange.moveStart("character", rangeLength);
                while ((comparison = tempRange.compareEndPoints("StartToEnd", tempRange)) == -1) {
                  offset++;
                  tempRange.moveStart("character", 1);
                }
              } else {
                offset = workingRange.text.length;
              }
              boundaryPosition = new DomPosition(boundaryNode, offset);
            } else {
              previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;
              nextNode = (isCollapsed || isStart) && workingNode.nextSibling;
              if (nextNode && isCharacterDataNode(nextNode)) {
                boundaryPosition = new DomPosition(nextNode, 0);
              } else if (previousNode && isCharacterDataNode(previousNode)) {
                boundaryPosition = new DomPosition(previousNode, previousNode.data.length);
              } else {
                boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));
              }
            }
            dom.removeNode(workingNode);
            return {
              boundaryPosition,
              nodeInfo: {
                nodeIndex,
                containerElement
              }
            };
          };
          var createBoundaryTextRange = function(boundaryPosition, isStart) {
            var boundaryNode, boundaryParent, boundaryOffset = boundaryPosition.offset;
            var doc = dom.getDocument(boundaryPosition.node);
            var workingNode, childNodes, workingRange = getBody2(doc).createTextRange();
            var nodeIsDataNode = isCharacterDataNode(boundaryPosition.node);
            if (nodeIsDataNode) {
              boundaryNode = boundaryPosition.node;
              boundaryParent = boundaryNode.parentNode;
            } else {
              childNodes = boundaryPosition.node.childNodes;
              boundaryNode = boundaryOffset < childNodes.length ? childNodes[boundaryOffset] : null;
              boundaryParent = boundaryPosition.node;
            }
            workingNode = doc.createElement("span");
            workingNode.innerHTML = "&#feff;";
            if (boundaryNode) {
              boundaryParent.insertBefore(workingNode, boundaryNode);
            } else {
              boundaryParent.appendChild(workingNode);
            }
            workingRange.moveToElementText(workingNode);
            workingRange.collapse(!isStart);
            boundaryParent.removeChild(workingNode);
            if (nodeIsDataNode) {
              workingRange[isStart ? "moveStart" : "moveEnd"]("character", boundaryOffset);
            }
            return workingRange;
          };
          WrappedTextRange = function(textRange) {
            this.textRange = textRange;
            this.refresh();
          };
          WrappedTextRange.prototype = new DomRange(document);
          WrappedTextRange.prototype.refresh = function() {
            var start, end, startBoundary;
            var rangeContainerElement = getTextRangeContainerElement(this.textRange);
            if (textRangeIsCollapsed(this.textRange)) {
              end = start = getTextRangeBoundaryPosition(
                this.textRange,
                rangeContainerElement,
                true,
                true
              ).boundaryPosition;
            } else {
              startBoundary = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);
              start = startBoundary.boundaryPosition;
              end = getTextRangeBoundaryPosition(
                this.textRange,
                rangeContainerElement,
                false,
                false,
                startBoundary.nodeInfo
              ).boundaryPosition;
            }
            this.setStart(start.node, start.offset);
            this.setEnd(end.node, end.offset);
          };
          WrappedTextRange.prototype.getName = function() {
            return "WrappedTextRange";
          };
          DomRange.copyComparisonConstants(WrappedTextRange);
          var rangeToTextRange = function(range) {
            if (range.collapsed) {
              return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
            } else {
              var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
              var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);
              var textRange = getBody2(DomRange.getRangeDocument(range)).createTextRange();
              textRange.setEndPoint("StartToStart", startRange);
              textRange.setEndPoint("EndToEnd", endRange);
              return textRange;
            }
          };
          WrappedTextRange.rangeToTextRange = rangeToTextRange;
          WrappedTextRange.prototype.toTextRange = function() {
            return rangeToTextRange(this);
          };
          api2.WrappedTextRange = WrappedTextRange;
          if (!api2.features.implementsDomRange || api2.config.preferTextRange) {
            var globalObj = function(f) {
              return f("return this;")();
            }(Function);
            if (typeof globalObj.Range == "undefined") {
              globalObj.Range = WrappedTextRange;
            }
            api2.createNativeRange = function(doc) {
              doc = getContentDocument(doc, module2, "createNativeRange");
              return getBody2(doc).createTextRange();
            };
            api2.WrappedRange = WrappedTextRange;
          }
        }
        api2.createRange = function(doc) {
          doc = getContentDocument(doc, module2, "createRange");
          return new api2.WrappedRange(api2.createNativeRange(doc));
        };
        api2.createRangyRange = function(doc) {
          doc = getContentDocument(doc, module2, "createRangyRange");
          return new DomRange(doc);
        };
        util2.createAliasForDeprecatedMethod(api2, "createIframeRange", "createRange");
        util2.createAliasForDeprecatedMethod(api2, "createIframeRangyRange", "createRangyRange");
        api2.addShimListener(function(win) {
          var doc = win.document;
          if (typeof doc.createRange == "undefined") {
            doc.createRange = function() {
              return api2.createRange(doc);
            };
          }
          doc = win = null;
        });
      });
      api.createCoreModule("WrappedSelection", ["DomRange", "WrappedRange"], function(api2, module2) {
        api2.config.checkSelectionRanges = true;
        var BOOLEAN = "boolean";
        var NUMBER = "number";
        var dom = api2.dom;
        var util2 = api2.util;
        var isHostMethod2 = util2.isHostMethod;
        var DomRange = api2.DomRange;
        var WrappedRange = api2.WrappedRange;
        var DOMException2 = api2.DOMException;
        var DomPosition = dom.DomPosition;
        var getNativeSelection;
        var selectionIsCollapsed;
        var features = api2.features;
        var CONTROL = "Control";
        var getDocument = dom.getDocument;
        var getBody2 = dom.getBody;
        var rangesEqual = DomRange.rangesEqual;
        function isDirectionBackward(dir) {
          return typeof dir == "string" ? /^backward(s)?$/i.test(dir) : !!dir;
        }
        function getWindow(win, methodName) {
          if (!win) {
            return window;
          } else if (dom.isWindow(win)) {
            return win;
          } else if (win instanceof WrappedSelection) {
            return win.win;
          } else {
            var doc = dom.getContentDocument(win, module2, methodName);
            return dom.getWindow(doc);
          }
        }
        function getWinSelection(winParam) {
          return getWindow(winParam, "getWinSelection").getSelection();
        }
        function getDocSelection(winParam) {
          return getWindow(winParam, "getDocSelection").document.selection;
        }
        function winSelectionIsBackward(sel) {
          var backward = false;
          if (sel.anchorNode) {
            backward = dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1;
          }
          return backward;
        }
        var implementsWinGetSelection = isHostMethod2(window, "getSelection"), implementsDocSelection = util2.isHostObject(document, "selection");
        features.implementsWinGetSelection = implementsWinGetSelection;
        features.implementsDocSelection = implementsDocSelection;
        var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api2.config.preferTextRange);
        if (useDocumentSelection) {
          getNativeSelection = getDocSelection;
          api2.isSelectionValid = function(winParam) {
            var doc = getWindow(winParam, "isSelectionValid").document, nativeSel = doc.selection;
            return nativeSel.type != "None" || getDocument(nativeSel.createRange().parentElement()) == doc;
          };
        } else if (implementsWinGetSelection) {
          getNativeSelection = getWinSelection;
          api2.isSelectionValid = function() {
            return true;
          };
        } else {
          module2.fail("Neither document.selection or window.getSelection() detected.");
          return false;
        }
        api2.getNativeSelection = getNativeSelection;
        var testSelection = getNativeSelection();
        if (!testSelection) {
          module2.fail("Native selection was null (possibly issue 138?)");
          return false;
        }
        var testRange = api2.createNativeRange(document);
        var body = getBody2(document);
        var selectionHasAnchorAndFocus = util2.areHostProperties(
          testSelection,
          ["anchorNode", "focusNode", "anchorOffset", "focusOffset"]
        );
        features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;
        var selectionHasExtend = isHostMethod2(testSelection, "extend");
        features.selectionHasExtend = selectionHasExtend;
        var selectionHasSetBaseAndExtent = isHostMethod2(testSelection, "setBaseAndExtent");
        features.selectionHasSetBaseAndExtent = selectionHasSetBaseAndExtent;
        var selectionHasRangeCount = typeof testSelection.rangeCount == NUMBER;
        features.selectionHasRangeCount = selectionHasRangeCount;
        var selectionSupportsMultipleRanges = false;
        var collapsedNonEditableSelectionsSupported = true;
        var addRangeBackwardToNative = selectionHasExtend ? function(nativeSelection, range) {
          var doc = DomRange.getRangeDocument(range);
          var endRange = api2.createRange(doc);
          endRange.collapseToPoint(range.endContainer, range.endOffset);
          nativeSelection.addRange(getNativeRange(endRange));
          nativeSelection.extend(range.startContainer, range.startOffset);
        } : null;
        if (util2.areHostMethods(testSelection, ["addRange", "getRangeAt", "removeAllRanges"]) && typeof testSelection.rangeCount == NUMBER && features.implementsDomRange) {
          (function() {
            var sel = window.getSelection();
            if (sel) {
              var originalSelectionRangeCount = sel.rangeCount;
              var selectionHasMultipleRanges = originalSelectionRangeCount > 1;
              var originalSelectionRanges = [];
              var originalSelectionBackward = winSelectionIsBackward(sel);
              for (var i = 0; i < originalSelectionRangeCount; ++i) {
                originalSelectionRanges[i] = sel.getRangeAt(i);
              }
              var testEl = dom.createTestElement(document, "", false);
              var textNode = testEl.appendChild(document.createTextNode("   "));
              var r1 = document.createRange();
              r1.setStart(textNode, 1);
              r1.collapse(true);
              sel.removeAllRanges();
              sel.addRange(r1);
              collapsedNonEditableSelectionsSupported = sel.rangeCount == 1;
              sel.removeAllRanges();
              if (!selectionHasMultipleRanges) {
                var chromeMatch = window.navigator.appVersion.match(/Chrome\/(.*?) /);
                if (chromeMatch && parseInt(chromeMatch[1]) >= 36) {
                  selectionSupportsMultipleRanges = false;
                } else {
                  var r2 = r1.cloneRange();
                  r1.setStart(textNode, 0);
                  r2.setEnd(textNode, 3);
                  r2.setStart(textNode, 2);
                  sel.addRange(r1);
                  sel.addRange(r2);
                  selectionSupportsMultipleRanges = sel.rangeCount == 2;
                }
              }
              dom.removeNode(testEl);
              sel.removeAllRanges();
              for (i = 0; i < originalSelectionRangeCount; ++i) {
                if (i == 0 && originalSelectionBackward) {
                  if (addRangeBackwardToNative) {
                    addRangeBackwardToNative(sel, originalSelectionRanges[i]);
                  } else {
                    api2.warn("Rangy initialization: original selection was backwards but selection has been restored forwards because the browser does not support Selection.extend");
                    sel.addRange(originalSelectionRanges[i]);
                  }
                } else {
                  sel.addRange(originalSelectionRanges[i]);
                }
              }
            }
          })();
        }
        features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;
        features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;
        var implementsControlRange = false, testControlRange;
        if (body && isHostMethod2(body, "createControlRange")) {
          testControlRange = body.createControlRange();
          if (util2.areHostProperties(testControlRange, ["item", "add"])) {
            implementsControlRange = true;
          }
        }
        features.implementsControlRange = implementsControlRange;
        if (selectionHasAnchorAndFocus) {
          selectionIsCollapsed = function(sel) {
            return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;
          };
        } else {
          selectionIsCollapsed = function(sel) {
            return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;
          };
        }
        function updateAnchorAndFocusFromRange(sel, range, backward) {
          var anchorPrefix = backward ? "end" : "start", focusPrefix = backward ? "start" : "end";
          sel.anchorNode = range[anchorPrefix + "Container"];
          sel.anchorOffset = range[anchorPrefix + "Offset"];
          sel.focusNode = range[focusPrefix + "Container"];
          sel.focusOffset = range[focusPrefix + "Offset"];
        }
        function updateAnchorAndFocusFromNativeSelection(sel) {
          var nativeSel = sel.nativeSelection;
          sel.anchorNode = nativeSel.anchorNode;
          sel.anchorOffset = nativeSel.anchorOffset;
          sel.focusNode = nativeSel.focusNode;
          sel.focusOffset = nativeSel.focusOffset;
        }
        function updateEmptySelection(sel) {
          sel.anchorNode = sel.focusNode = null;
          sel.anchorOffset = sel.focusOffset = 0;
          sel.rangeCount = 0;
          sel.isCollapsed = true;
          sel._ranges.length = 0;
          updateType(sel);
        }
        function updateType(sel) {
          sel.type = sel.rangeCount == 0 ? "None" : selectionIsCollapsed(sel) ? "Caret" : "Range";
        }
        function getNativeRange(range) {
          var nativeRange;
          if (range instanceof DomRange) {
            nativeRange = api2.createNativeRange(range.getDocument());
            nativeRange.setEnd(range.endContainer, range.endOffset);
            nativeRange.setStart(range.startContainer, range.startOffset);
          } else if (range instanceof WrappedRange) {
            nativeRange = range.nativeRange;
          } else if (features.implementsDomRange && range instanceof dom.getWindow(range.startContainer).Range) {
            nativeRange = range;
          }
          return nativeRange;
        }
        function rangeContainsSingleElement(rangeNodes) {
          if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {
            return false;
          }
          for (var i = 1, len = rangeNodes.length; i < len; ++i) {
            if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {
              return false;
            }
          }
          return true;
        }
        function getSingleElementFromRange(range) {
          var nodes = range.getNodes();
          if (!rangeContainsSingleElement(nodes)) {
            throw module2.createError("getSingleElementFromRange: range " + range.inspect() + " did not consist of a single element");
          }
          return nodes[0];
        }
        function isTextRange2(range) {
          return !!range && typeof range.text != "undefined";
        }
        function updateFromTextRange(sel, range) {
          var wrappedRange = new WrappedRange(range);
          sel._ranges = [wrappedRange];
          updateAnchorAndFocusFromRange(sel, wrappedRange, false);
          sel.rangeCount = 1;
          sel.isCollapsed = wrappedRange.collapsed;
          updateType(sel);
        }
        function updateControlSelection(sel) {
          sel._ranges.length = 0;
          if (sel.docSelection.type == "None") {
            updateEmptySelection(sel);
          } else {
            var controlRange = sel.docSelection.createRange();
            if (isTextRange2(controlRange)) {
              updateFromTextRange(sel, controlRange);
            } else {
              sel.rangeCount = controlRange.length;
              var range, doc = getDocument(controlRange.item(0));
              for (var i = 0; i < sel.rangeCount; ++i) {
                range = api2.createRange(doc);
                range.selectNode(controlRange.item(i));
                sel._ranges.push(range);
              }
              sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;
              updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);
              updateType(sel);
            }
          }
        }
        function addRangeToControlSelection(sel, range) {
          var controlRange = sel.docSelection.createRange();
          var rangeElement = getSingleElementFromRange(range);
          var doc = getDocument(controlRange.item(0));
          var newControlRange = getBody2(doc).createControlRange();
          for (var i = 0, len = controlRange.length; i < len; ++i) {
            newControlRange.add(controlRange.item(i));
          }
          try {
            newControlRange.add(rangeElement);
          } catch (ex) {
            throw module2.createError("addRange(): Element within the specified Range could not be added to control selection (does it have layout?)");
          }
          newControlRange.select();
          updateControlSelection(sel);
        }
        var getSelectionRangeAt;
        if (isHostMethod2(testSelection, "getRangeAt")) {
          getSelectionRangeAt = function(sel, index) {
            try {
              return sel.getRangeAt(index);
            } catch (ex) {
              return null;
            }
          };
        } else if (selectionHasAnchorAndFocus) {
          getSelectionRangeAt = function(sel) {
            var doc = getDocument(sel.anchorNode);
            var range = api2.createRange(doc);
            range.setStartAndEnd(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);
            if (range.collapsed !== this.isCollapsed) {
              range.setStartAndEnd(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset);
            }
            return range;
          };
        }
        function WrappedSelection(selection, docSelection, win) {
          this.nativeSelection = selection;
          this.docSelection = docSelection;
          this._ranges = [];
          this.win = win;
          this.refresh();
        }
        WrappedSelection.prototype = api2.selectionPrototype;
        function deleteProperties(sel) {
          sel.win = sel.anchorNode = sel.focusNode = sel._ranges = null;
          sel.rangeCount = sel.anchorOffset = sel.focusOffset = 0;
          sel.detached = true;
          updateType(sel);
        }
        var cachedRangySelections = [];
        function actOnCachedSelection(win, action) {
          var i = cachedRangySelections.length, cached, sel;
          while (i--) {
            cached = cachedRangySelections[i];
            sel = cached.selection;
            if (action == "deleteAll") {
              deleteProperties(sel);
            } else if (cached.win == win) {
              if (action == "delete") {
                cachedRangySelections.splice(i, 1);
                return true;
              } else {
                return sel;
              }
            }
          }
          if (action == "deleteAll") {
            cachedRangySelections.length = 0;
          }
          return null;
        }
        var getSelection = function(win) {
          if (win && win instanceof WrappedSelection) {
            win.refresh();
            return win;
          }
          win = getWindow(win, "getNativeSelection");
          var sel = actOnCachedSelection(win);
          var nativeSel = getNativeSelection(win), docSel = implementsDocSelection ? getDocSelection(win) : null;
          if (sel) {
            sel.nativeSelection = nativeSel;
            sel.docSelection = docSel;
            sel.refresh();
          } else {
            sel = new WrappedSelection(nativeSel, docSel, win);
            cachedRangySelections.push({ win, selection: sel });
          }
          return sel;
        };
        api2.getSelection = getSelection;
        util2.createAliasForDeprecatedMethod(api2, "getIframeSelection", "getSelection");
        var selProto = WrappedSelection.prototype;
        function createControlSelection(sel, ranges) {
          var doc = getDocument(ranges[0].startContainer);
          var controlRange = getBody2(doc).createControlRange();
          for (var i = 0, el, len = ranges.length; i < len; ++i) {
            el = getSingleElementFromRange(ranges[i]);
            try {
              controlRange.add(el);
            } catch (ex) {
              throw module2.createError("setRanges(): Element within one of the specified Ranges could not be added to control selection (does it have layout?)");
            }
          }
          controlRange.select();
          updateControlSelection(sel);
        }
        if (!useDocumentSelection && selectionHasAnchorAndFocus && util2.areHostMethods(testSelection, ["removeAllRanges", "addRange"])) {
          selProto.removeAllRanges = function() {
            this.nativeSelection.removeAllRanges();
            updateEmptySelection(this);
          };
          var addRangeBackward = function(sel, range) {
            addRangeBackwardToNative(sel.nativeSelection, range);
            sel.refresh();
          };
          if (selectionHasRangeCount) {
            selProto.addRange = function(range, direction) {
              if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
                addRangeToControlSelection(this, range);
              } else {
                if (isDirectionBackward(direction) && selectionHasExtend) {
                  addRangeBackward(this, range);
                } else {
                  var previousRangeCount;
                  if (selectionSupportsMultipleRanges) {
                    previousRangeCount = this.rangeCount;
                  } else {
                    this.removeAllRanges();
                    previousRangeCount = 0;
                  }
                  var clonedNativeRange = getNativeRange(range).cloneRange();
                  try {
                    this.nativeSelection.addRange(clonedNativeRange);
                  } catch (ex) {
                  }
                  this.rangeCount = this.nativeSelection.rangeCount;
                  if (this.rangeCount == previousRangeCount + 1) {
                    if (api2.config.checkSelectionRanges) {
                      var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);
                      if (nativeRange && !rangesEqual(nativeRange, range)) {
                        range = new WrappedRange(nativeRange);
                      }
                    }
                    this._ranges[this.rangeCount - 1] = range;
                    updateAnchorAndFocusFromRange(this, range, selectionIsBackward(this.nativeSelection));
                    this.isCollapsed = selectionIsCollapsed(this);
                    updateType(this);
                  } else {
                    this.refresh();
                  }
                }
              }
            };
          } else {
            selProto.addRange = function(range, direction) {
              if (isDirectionBackward(direction) && selectionHasExtend) {
                addRangeBackward(this, range);
              } else {
                this.nativeSelection.addRange(getNativeRange(range));
                this.refresh();
              }
            };
          }
          selProto.setRanges = function(ranges) {
            if (implementsControlRange && implementsDocSelection && ranges.length > 1) {
              createControlSelection(this, ranges);
            } else {
              this.removeAllRanges();
              for (var i = 0, len = ranges.length; i < len; ++i) {
                this.addRange(ranges[i]);
              }
            }
          };
        } else if (isHostMethod2(testSelection, "empty") && isHostMethod2(testRange, "select") && implementsControlRange && useDocumentSelection) {
          selProto.removeAllRanges = function() {
            try {
              this.docSelection.empty();
              if (this.docSelection.type != "None") {
                var doc;
                if (this.anchorNode) {
                  doc = getDocument(this.anchorNode);
                } else if (this.docSelection.type == CONTROL) {
                  var controlRange = this.docSelection.createRange();
                  if (controlRange.length) {
                    doc = getDocument(controlRange.item(0));
                  }
                }
                if (doc) {
                  var textRange = getBody2(doc).createTextRange();
                  textRange.select();
                  this.docSelection.empty();
                }
              }
            } catch (ex) {
            }
            updateEmptySelection(this);
          };
          selProto.addRange = function(range) {
            if (this.docSelection.type == CONTROL) {
              addRangeToControlSelection(this, range);
            } else {
              api2.WrappedTextRange.rangeToTextRange(range).select();
              this._ranges[0] = range;
              this.rangeCount = 1;
              this.isCollapsed = this._ranges[0].collapsed;
              updateAnchorAndFocusFromRange(this, range, false);
              updateType(this);
            }
          };
          selProto.setRanges = function(ranges) {
            this.removeAllRanges();
            var rangeCount = ranges.length;
            if (rangeCount > 1) {
              createControlSelection(this, ranges);
            } else if (rangeCount) {
              this.addRange(ranges[0]);
            }
          };
        } else {
          module2.fail("No means of selecting a Range or TextRange was found");
          return false;
        }
        selProto.getRangeAt = function(index) {
          if (index < 0 || index >= this.rangeCount) {
            throw new DOMException2("INDEX_SIZE_ERR");
          } else {
            return this._ranges[index].cloneRange();
          }
        };
        var refreshSelection;
        if (useDocumentSelection) {
          refreshSelection = function(sel) {
            var range;
            if (api2.isSelectionValid(sel.win)) {
              range = sel.docSelection.createRange();
            } else {
              range = getBody2(sel.win.document).createTextRange();
              range.collapse(true);
            }
            if (sel.docSelection.type == CONTROL) {
              updateControlSelection(sel);
            } else if (isTextRange2(range)) {
              updateFromTextRange(sel, range);
            } else {
              updateEmptySelection(sel);
            }
          };
        } else if (isHostMethod2(testSelection, "getRangeAt") && typeof testSelection.rangeCount == NUMBER) {
          refreshSelection = function(sel) {
            if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {
              updateControlSelection(sel);
            } else {
              sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;
              if (sel.rangeCount) {
                for (var i = 0, len = sel.rangeCount; i < len; ++i) {
                  sel._ranges[i] = new api2.WrappedRange(sel.nativeSelection.getRangeAt(i));
                }
                updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackward(sel.nativeSelection));
                sel.isCollapsed = selectionIsCollapsed(sel);
                updateType(sel);
              } else {
                updateEmptySelection(sel);
              }
            }
          };
        } else if (selectionHasAnchorAndFocus && typeof testSelection.isCollapsed == BOOLEAN && typeof testRange.collapsed == BOOLEAN && features.implementsDomRange) {
          refreshSelection = function(sel) {
            var range, nativeSel = sel.nativeSelection;
            if (nativeSel.anchorNode) {
              range = getSelectionRangeAt(nativeSel, 0);
              sel._ranges = [range];
              sel.rangeCount = 1;
              updateAnchorAndFocusFromNativeSelection(sel);
              sel.isCollapsed = selectionIsCollapsed(sel);
              updateType(sel);
            } else {
              updateEmptySelection(sel);
            }
          };
        } else {
          module2.fail("No means of obtaining a Range or TextRange from the user's selection was found");
          return false;
        }
        selProto.refresh = function(checkForChanges) {
          var oldRanges = checkForChanges ? this._ranges.slice(0) : null;
          var oldAnchorNode = this.anchorNode, oldAnchorOffset = this.anchorOffset;
          refreshSelection(this);
          if (checkForChanges) {
            var i = oldRanges.length;
            if (i != this._ranges.length) {
              return true;
            }
            if (this.anchorNode != oldAnchorNode || this.anchorOffset != oldAnchorOffset) {
              return true;
            }
            while (i--) {
              if (!rangesEqual(oldRanges[i], this._ranges[i])) {
                return true;
              }
            }
            return false;
          }
        };
        var removeRangeManually = function(sel, range) {
          var ranges = sel.getAllRanges();
          sel.removeAllRanges();
          for (var i = 0, len = ranges.length; i < len; ++i) {
            if (!rangesEqual(range, ranges[i])) {
              sel.addRange(ranges[i]);
            }
          }
          if (!sel.rangeCount) {
            updateEmptySelection(sel);
          }
        };
        if (implementsControlRange && implementsDocSelection) {
          selProto.removeRange = function(range) {
            if (this.docSelection.type == CONTROL) {
              var controlRange = this.docSelection.createRange();
              var rangeElement = getSingleElementFromRange(range);
              var doc = getDocument(controlRange.item(0));
              var newControlRange = getBody2(doc).createControlRange();
              var el, removed = false;
              for (var i = 0, len = controlRange.length; i < len; ++i) {
                el = controlRange.item(i);
                if (el !== rangeElement || removed) {
                  newControlRange.add(controlRange.item(i));
                } else {
                  removed = true;
                }
              }
              newControlRange.select();
              updateControlSelection(this);
            } else {
              removeRangeManually(this, range);
            }
          };
        } else {
          selProto.removeRange = function(range) {
            removeRangeManually(this, range);
          };
        }
        var selectionIsBackward;
        if (!useDocumentSelection && selectionHasAnchorAndFocus && features.implementsDomRange) {
          selectionIsBackward = winSelectionIsBackward;
          selProto.isBackward = function() {
            return selectionIsBackward(this);
          };
        } else {
          selectionIsBackward = selProto.isBackward = function() {
            return false;
          };
        }
        selProto.isBackwards = selProto.isBackward;
        selProto.toString = function() {
          var rangeTexts = [];
          for (var i = 0, len = this.rangeCount; i < len; ++i) {
            rangeTexts[i] = "" + this._ranges[i];
          }
          return rangeTexts.join("");
        };
        function assertNodeInSameDocument(sel, node2) {
          if (sel.win.document != getDocument(node2)) {
            throw new DOMException2("WRONG_DOCUMENT_ERR");
          }
        }
        function assertValidOffset(node2, offset) {
          if (offset < 0 || offset > (dom.isCharacterDataNode(node2) ? node2.length : node2.childNodes.length)) {
            throw new DOMException2("INDEX_SIZE_ERR");
          }
        }
        selProto.collapse = function(node2, offset) {
          assertNodeInSameDocument(this, node2);
          var range = api2.createRange(node2);
          range.collapseToPoint(node2, offset);
          this.setSingleRange(range);
          this.isCollapsed = true;
        };
        selProto.collapseToStart = function() {
          if (this.rangeCount) {
            var range = this._ranges[0];
            this.collapse(range.startContainer, range.startOffset);
          } else {
            throw new DOMException2("INVALID_STATE_ERR");
          }
        };
        selProto.collapseToEnd = function() {
          if (this.rangeCount) {
            var range = this._ranges[this.rangeCount - 1];
            this.collapse(range.endContainer, range.endOffset);
          } else {
            throw new DOMException2("INVALID_STATE_ERR");
          }
        };
        selProto.selectAllChildren = function(node2) {
          assertNodeInSameDocument(this, node2);
          var range = api2.createRange(node2);
          range.selectNodeContents(node2);
          this.setSingleRange(range);
        };
        if (selectionHasSetBaseAndExtent) {
          selProto.setBaseAndExtent = function(anchorNode, anchorOffset, focusNode, focusOffset) {
            this.nativeSelection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
            this.refresh();
          };
        } else if (selectionHasExtend) {
          selProto.setBaseAndExtent = function(anchorNode, anchorOffset, focusNode, focusOffset) {
            assertValidOffset(anchorNode, anchorOffset);
            assertValidOffset(focusNode, focusOffset);
            assertNodeInSameDocument(this, anchorNode);
            assertNodeInSameDocument(this, focusNode);
            var range = api2.createRange(node);
            var isBackwards = dom.comparePoints(anchorNode, anchorOffset, focusNode, focusOffset) == -1;
            if (isBackwards) {
              range.setStartAndEnd(focusNode, focusOffset, anchorNode, anchorOffset);
            } else {
              range.setStartAndEnd(anchorNode, anchorOffset, focusNode, focusOffset);
            }
            this.setSingleRange(range, isBackwards);
          };
        }
        selProto.deleteFromDocument = function() {
          if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
            var controlRange = this.docSelection.createRange();
            var element;
            while (controlRange.length) {
              element = controlRange.item(0);
              controlRange.remove(element);
              dom.removeNode(element);
            }
            this.refresh();
          } else if (this.rangeCount) {
            var ranges = this.getAllRanges();
            if (ranges.length) {
              this.removeAllRanges();
              for (var i = 0, len = ranges.length; i < len; ++i) {
                ranges[i].deleteContents();
              }
              this.addRange(ranges[len - 1]);
            }
          }
        };
        selProto.eachRange = function(func, returnValue) {
          for (var i = 0, len = this._ranges.length; i < len; ++i) {
            if (func(this.getRangeAt(i))) {
              return returnValue;
            }
          }
        };
        selProto.getAllRanges = function() {
          var ranges = [];
          this.eachRange(function(range) {
            ranges.push(range);
          });
          return ranges;
        };
        selProto.setSingleRange = function(range, direction) {
          this.removeAllRanges();
          this.addRange(range, direction);
        };
        selProto.callMethodOnEachRange = function(methodName, params) {
          var results = [];
          this.eachRange(function(range) {
            results.push(range[methodName].apply(range, params || []));
          });
          return results;
        };
        function createStartOrEndSetter(isStart) {
          return function(node2, offset) {
            var range;
            if (this.rangeCount) {
              range = this.getRangeAt(0);
              range["set" + (isStart ? "Start" : "End")](node2, offset);
            } else {
              range = api2.createRange(this.win.document);
              range.setStartAndEnd(node2, offset);
            }
            this.setSingleRange(range, this.isBackward());
          };
        }
        selProto.setStart = createStartOrEndSetter(true);
        selProto.setEnd = createStartOrEndSetter(false);
        api2.rangePrototype.select = function(direction) {
          getSelection(this.getDocument()).setSingleRange(this, direction);
        };
        selProto.changeEachRange = function(func) {
          var ranges = [];
          var backward = this.isBackward();
          this.eachRange(function(range) {
            func(range);
            ranges.push(range);
          });
          this.removeAllRanges();
          if (backward && ranges.length == 1) {
            this.addRange(ranges[0], "backward");
          } else {
            this.setRanges(ranges);
          }
        };
        selProto.containsNode = function(node2, allowPartial) {
          return this.eachRange(function(range) {
            return range.containsNode(node2, allowPartial);
          }, true) || false;
        };
        selProto.getBookmark = function(containerNode) {
          return {
            backward: this.isBackward(),
            rangeBookmarks: this.callMethodOnEachRange("getBookmark", [containerNode])
          };
        };
        selProto.moveToBookmark = function(bookmark) {
          var selRanges = [];
          for (var i = 0, rangeBookmark, range; rangeBookmark = bookmark.rangeBookmarks[i++]; ) {
            range = api2.createRange(this.win);
            range.moveToBookmark(rangeBookmark);
            selRanges.push(range);
          }
          if (bookmark.backward) {
            this.setSingleRange(selRanges[0], "backward");
          } else {
            this.setRanges(selRanges);
          }
        };
        selProto.saveRanges = function() {
          return {
            backward: this.isBackward(),
            ranges: this.callMethodOnEachRange("cloneRange")
          };
        };
        selProto.restoreRanges = function(selRanges) {
          this.removeAllRanges();
          for (var i = 0, range; range = selRanges.ranges[i]; ++i) {
            this.addRange(range, selRanges.backward && i == 0);
          }
        };
        selProto.toHtml = function() {
          var rangeHtmls = [];
          this.eachRange(function(range) {
            rangeHtmls.push(DomRange.toHtml(range));
          });
          return rangeHtmls.join("");
        };
        if (features.implementsTextRange) {
          selProto.getNativeTextRange = function() {
            var sel, textRange;
            if (sel = this.docSelection) {
              var range = sel.createRange();
              if (isTextRange2(range)) {
                return range;
              } else {
                throw module2.createError("getNativeTextRange: selection is a control selection");
              }
            } else if (this.rangeCount > 0) {
              return api2.WrappedTextRange.rangeToTextRange(this.getRangeAt(0));
            } else {
              throw module2.createError("getNativeTextRange: selection contains no range");
            }
          };
        }
        function inspect(sel) {
          var rangeInspects = [];
          var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);
          var focus = new DomPosition(sel.focusNode, sel.focusOffset);
          var name = typeof sel.getName == "function" ? sel.getName() : "Selection";
          if (typeof sel.rangeCount != "undefined") {
            for (var i = 0, len = sel.rangeCount; i < len; ++i) {
              rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));
            }
          }
          return "[" + name + "(Ranges: " + rangeInspects.join(", ") + ")(anchor: " + anchor.inspect() + ", focus: " + focus.inspect() + "]";
        }
        selProto.getName = function() {
          return "WrappedSelection";
        };
        selProto.inspect = function() {
          return inspect(this);
        };
        selProto.detach = function() {
          actOnCachedSelection(this.win, "delete");
          deleteProperties(this);
        };
        WrappedSelection.detachAll = function() {
          actOnCachedSelection(null, "deleteAll");
        };
        WrappedSelection.inspect = inspect;
        WrappedSelection.isDirectionBackward = isDirectionBackward;
        api2.Selection = WrappedSelection;
        api2.selectionPrototype = selProto;
        api2.addShimListener(function(win) {
          if (typeof win.getSelection == "undefined") {
            win.getSelection = function() {
              return getSelection(win);
            };
          }
          win = null;
        });
      });
      var docReady = false;
      var loadHandler = function(e) {
        if (!docReady) {
          docReady = true;
          if (!api.initialized && api.config.autoInitialize) {
            init();
          }
        }
      };
      if (isBrowser) {
        if (document.readyState == "complete") {
          loadHandler();
        } else {
          if (isHostMethod(document, "addEventListener")) {
            document.addEventListener("DOMContentLoaded", loadHandler, false);
          }
          addListener(window, "load", loadHandler);
        }
      }
      return api;
    }, exports);
  }
});

// node_modules/rangy/lib/rangy-classapplier.js
var require_rangy_classapplier = __commonJS({
  "node_modules/rangy/lib/rangy-classapplier.js"(exports, module) {
    (function(factory, root) {
      if (typeof define == "function" && define.amd) {
        define(["./rangy-core"], factory);
      } else if (typeof module != "undefined" && typeof exports == "object") {
        module.exports = factory(require_rangy_core());
      } else {
        factory(root.rangy);
      }
    })(function(rangy2) {
      rangy2.createModule("ClassApplier", ["WrappedSelection"], function(api, module2) {
        var dom = api.dom;
        var DomPosition = dom.DomPosition;
        var contains = dom.arrayContains;
        var util = api.util;
        var forEach = util.forEach;
        var defaultTagName = "span";
        var createElementNSSupported = util.isHostMethod(document, "createElementNS");
        function each(obj, func) {
          for (var i in obj) {
            if (obj.hasOwnProperty(i)) {
              if (func(i, obj[i]) === false) {
                return false;
              }
            }
          }
          return true;
        }
        function trim(str) {
          return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        }
        function classNameContainsClass(fullClassName, className) {
          return !!fullClassName && new RegExp("(?:^|\\s)" + className + "(?:\\s|$)").test(fullClassName);
        }
        function hasClass(el, className) {
          if (typeof el.classList == "object") {
            return el.classList.contains(className);
          } else {
            var classNameSupported = typeof el.className == "string";
            var elClass = classNameSupported ? el.className : el.getAttribute("class");
            return classNameContainsClass(elClass, className);
          }
        }
        function addClass(el, className) {
          if (typeof el.classList == "object") {
            el.classList.add(className);
          } else {
            var classNameSupported = typeof el.className == "string";
            var elClass = classNameSupported ? el.className : el.getAttribute("class");
            if (elClass) {
              if (!classNameContainsClass(elClass, className)) {
                elClass += " " + className;
              }
            } else {
              elClass = className;
            }
            if (classNameSupported) {
              el.className = elClass;
            } else {
              el.setAttribute("class", elClass);
            }
          }
        }
        var removeClass = /* @__PURE__ */ function() {
          function replacer(matched, whiteSpaceBefore, whiteSpaceAfter) {
            return whiteSpaceBefore && whiteSpaceAfter ? " " : "";
          }
          return function(el, className) {
            if (typeof el.classList == "object") {
              el.classList.remove(className);
            } else {
              var classNameSupported = typeof el.className == "string";
              var elClass = classNameSupported ? el.className : el.getAttribute("class");
              elClass = elClass.replace(new RegExp("(^|\\s)" + className + "(\\s|$)"), replacer);
              if (classNameSupported) {
                el.className = elClass;
              } else {
                el.setAttribute("class", elClass);
              }
            }
          };
        }();
        function getClass(el) {
          var classNameSupported = typeof el.className == "string";
          return classNameSupported ? el.className : el.getAttribute("class");
        }
        function sortClassName(className) {
          return className && className.split(/\s+/).sort().join(" ");
        }
        function getSortedClassName(el) {
          return sortClassName(getClass(el));
        }
        function haveSameClasses(el1, el2) {
          return getSortedClassName(el1) == getSortedClassName(el2);
        }
        function hasAllClasses(el, className) {
          var classes = className.split(/\s+/);
          for (var i = 0, len = classes.length; i < len; ++i) {
            if (!hasClass(el, trim(classes[i]))) {
              return false;
            }
          }
          return true;
        }
        function canTextBeStyled(textNode) {
          var parent = textNode.parentNode;
          return parent && parent.nodeType == 1 && !/^(textarea|style|script|select|iframe)$/i.test(parent.nodeName);
        }
        function movePosition(position, oldParent, oldIndex, newParent, newIndex) {
          var posNode = position.node, posOffset = position.offset;
          var newNode = posNode, newOffset = posOffset;
          if (posNode == newParent && posOffset > newIndex) {
            ++newOffset;
          }
          if (posNode == oldParent && (posOffset == oldIndex || posOffset == oldIndex + 1)) {
            newNode = newParent;
            newOffset += newIndex - oldIndex;
          }
          if (posNode == oldParent && posOffset > oldIndex + 1) {
            --newOffset;
          }
          position.node = newNode;
          position.offset = newOffset;
        }
        function movePositionWhenRemovingNode(position, parentNode, index) {
          if (position.node == parentNode && position.offset > index) {
            --position.offset;
          }
        }
        function movePreservingPositions(node2, newParent, newIndex, positionsToPreserve) {
          if (newIndex == -1) {
            newIndex = newParent.childNodes.length;
          }
          var oldParent = node2.parentNode;
          var oldIndex = dom.getNodeIndex(node2);
          forEach(positionsToPreserve, function(position) {
            movePosition(position, oldParent, oldIndex, newParent, newIndex);
          });
          if (newParent.childNodes.length == newIndex) {
            newParent.appendChild(node2);
          } else {
            newParent.insertBefore(node2, newParent.childNodes[newIndex]);
          }
        }
        function removePreservingPositions(node2, positionsToPreserve) {
          var oldParent = node2.parentNode;
          var oldIndex = dom.getNodeIndex(node2);
          forEach(positionsToPreserve, function(position) {
            movePositionWhenRemovingNode(position, oldParent, oldIndex);
          });
          dom.removeNode(node2);
        }
        function moveChildrenPreservingPositions(node2, newParent, newIndex, removeNode, positionsToPreserve) {
          var child, children = [];
          while (child = node2.firstChild) {
            movePreservingPositions(child, newParent, newIndex++, positionsToPreserve);
            children.push(child);
          }
          if (removeNode) {
            removePreservingPositions(node2, positionsToPreserve);
          }
          return children;
        }
        function replaceWithOwnChildrenPreservingPositions(element, positionsToPreserve) {
          return moveChildrenPreservingPositions(element, element.parentNode, dom.getNodeIndex(element), true, positionsToPreserve);
        }
        function rangeSelectsAnyText(range, textNode) {
          var textNodeRange = range.cloneRange();
          textNodeRange.selectNodeContents(textNode);
          var intersectionRange = textNodeRange.intersection(range);
          var text = intersectionRange ? intersectionRange.toString() : "";
          return text != "";
        }
        function getEffectiveTextNodes(range) {
          var nodes = range.getNodes([3]);
          var start = 0, node2;
          while ((node2 = nodes[start]) && !rangeSelectsAnyText(range, node2)) {
            ++start;
          }
          var end = nodes.length - 1;
          while ((node2 = nodes[end]) && !rangeSelectsAnyText(range, node2)) {
            --end;
          }
          return nodes.slice(start, end + 1);
        }
        function elementsHaveSameNonClassAttributes(el1, el2) {
          if (el1.attributes.length != el2.attributes.length) return false;
          for (var i = 0, len = el1.attributes.length, attr1, attr2, name; i < len; ++i) {
            attr1 = el1.attributes[i];
            name = attr1.name;
            if (name != "class") {
              attr2 = el2.attributes.getNamedItem(name);
              if (attr1 === null != (attr2 === null)) return false;
              if (attr1.specified != attr2.specified) return false;
              if (attr1.specified && attr1.nodeValue !== attr2.nodeValue) return false;
            }
          }
          return true;
        }
        function elementHasNonClassAttributes(el, exceptions) {
          for (var i = 0, len = el.attributes.length, attrName; i < len; ++i) {
            attrName = el.attributes[i].name;
            if (!(exceptions && contains(exceptions, attrName)) && el.attributes[i].specified && attrName != "class") {
              return true;
            }
          }
          return false;
        }
        var getComputedStyleProperty = dom.getComputedStyleProperty;
        var isEditableElement = function() {
          var testEl = document.createElement("div");
          return typeof testEl.isContentEditable == "boolean" ? function(node2) {
            return node2 && node2.nodeType == 1 && node2.isContentEditable;
          } : function(node2) {
            if (!node2 || node2.nodeType != 1 || node2.contentEditable == "false") {
              return false;
            }
            return node2.contentEditable == "true" || isEditableElement(node2.parentNode);
          };
        }();
        function isEditingHost(node2) {
          var parent;
          return node2 && node2.nodeType == 1 && ((parent = node2.parentNode) && parent.nodeType == 9 && parent.designMode == "on" || isEditableElement(node2) && !isEditableElement(node2.parentNode));
        }
        function isEditable(node2) {
          return (isEditableElement(node2) || node2.nodeType != 1 && isEditableElement(node2.parentNode)) && !isEditingHost(node2);
        }
        var inlineDisplayRegex = /^inline(-block|-table)?$/i;
        function isNonInlineElement(node2) {
          return node2 && node2.nodeType == 1 && !inlineDisplayRegex.test(getComputedStyleProperty(node2, "display"));
        }
        var htmlNonWhiteSpaceRegex = /[^\r\n\t\f \u200B]/;
        function isUnrenderedWhiteSpaceNode(node2) {
          if (node2.data.length == 0) {
            return true;
          }
          if (htmlNonWhiteSpaceRegex.test(node2.data)) {
            return false;
          }
          var cssWhiteSpace = getComputedStyleProperty(node2.parentNode, "whiteSpace");
          switch (cssWhiteSpace) {
            case "pre":
            case "pre-wrap":
            case "-moz-pre-wrap":
              return false;
            case "pre-line":
              if (/[\r\n]/.test(node2.data)) {
                return false;
              }
          }
          return isNonInlineElement(node2.previousSibling) || isNonInlineElement(node2.nextSibling);
        }
        function getRangeBoundaries(ranges) {
          var positions = [], i, range;
          for (i = 0; range = ranges[i++]; ) {
            positions.push(
              new DomPosition(range.startContainer, range.startOffset),
              new DomPosition(range.endContainer, range.endOffset)
            );
          }
          return positions;
        }
        function updateRangesFromBoundaries(ranges, positions) {
          for (var i = 0, range, start, end, len = ranges.length; i < len; ++i) {
            range = ranges[i];
            start = positions[i * 2];
            end = positions[i * 2 + 1];
            range.setStartAndEnd(start.node, start.offset, end.node, end.offset);
          }
        }
        function isSplitPoint(node2, offset) {
          if (dom.isCharacterDataNode(node2)) {
            if (offset == 0) {
              return !!node2.previousSibling;
            } else if (offset == node2.length) {
              return !!node2.nextSibling;
            } else {
              return true;
            }
          }
          return offset > 0 && offset < node2.childNodes.length;
        }
        function splitNodeAt(node2, descendantNode, descendantOffset, positionsToPreserve) {
          var newNode, parentNode;
          var splitAtStart = descendantOffset == 0;
          if (dom.isAncestorOf(descendantNode, node2)) {
            return node2;
          }
          if (dom.isCharacterDataNode(descendantNode)) {
            var descendantIndex = dom.getNodeIndex(descendantNode);
            if (descendantOffset == 0) {
              descendantOffset = descendantIndex;
            } else if (descendantOffset == descendantNode.length) {
              descendantOffset = descendantIndex + 1;
            } else {
              throw module2.createError("splitNodeAt() should not be called with offset in the middle of a data node (" + descendantOffset + " in " + descendantNode.data);
            }
            descendantNode = descendantNode.parentNode;
          }
          if (isSplitPoint(descendantNode, descendantOffset)) {
            newNode = descendantNode.cloneNode(false);
            parentNode = descendantNode.parentNode;
            if (newNode.id) {
              newNode.removeAttribute("id");
            }
            var child, newChildIndex = 0;
            while (child = descendantNode.childNodes[descendantOffset]) {
              movePreservingPositions(child, newNode, newChildIndex++, positionsToPreserve);
            }
            movePreservingPositions(newNode, parentNode, dom.getNodeIndex(descendantNode) + 1, positionsToPreserve);
            return descendantNode == node2 ? newNode : splitNodeAt(node2, parentNode, dom.getNodeIndex(newNode), positionsToPreserve);
          } else if (node2 != descendantNode) {
            newNode = descendantNode.parentNode;
            var newNodeIndex = dom.getNodeIndex(descendantNode);
            if (!splitAtStart) {
              newNodeIndex++;
            }
            return splitNodeAt(node2, newNode, newNodeIndex, positionsToPreserve);
          }
          return node2;
        }
        function areElementsMergeable(el1, el2) {
          return el1.namespaceURI == el2.namespaceURI && el1.tagName.toLowerCase() == el2.tagName.toLowerCase() && haveSameClasses(el1, el2) && elementsHaveSameNonClassAttributes(el1, el2) && getComputedStyleProperty(el1, "display") == "inline" && getComputedStyleProperty(el2, "display") == "inline";
        }
        function createAdjacentMergeableTextNodeGetter(forward) {
          var siblingPropName = forward ? "nextSibling" : "previousSibling";
          return function(textNode, checkParentElement) {
            var el = textNode.parentNode;
            var adjacentNode = textNode[siblingPropName];
            if (adjacentNode) {
              if (adjacentNode && adjacentNode.nodeType == 3) {
                return adjacentNode;
              }
            } else if (checkParentElement) {
              adjacentNode = el[siblingPropName];
              if (adjacentNode && adjacentNode.nodeType == 1 && areElementsMergeable(el, adjacentNode)) {
                var adjacentNodeChild = adjacentNode[forward ? "firstChild" : "lastChild"];
                if (adjacentNodeChild && adjacentNodeChild.nodeType == 3) {
                  return adjacentNodeChild;
                }
              }
            }
            return null;
          };
        }
        var getPreviousMergeableTextNode = createAdjacentMergeableTextNodeGetter(false), getNextMergeableTextNode = createAdjacentMergeableTextNodeGetter(true);
        function Merge(firstNode) {
          this.isElementMerge = firstNode.nodeType == 1;
          this.textNodes = [];
          var firstTextNode = this.isElementMerge ? firstNode.lastChild : firstNode;
          if (firstTextNode) {
            this.textNodes[0] = firstTextNode;
          }
        }
        Merge.prototype = {
          doMerge: function(positionsToPreserve) {
            var textNodes = this.textNodes;
            var firstTextNode = textNodes[0];
            if (textNodes.length > 1) {
              var firstTextNodeIndex = dom.getNodeIndex(firstTextNode);
              var textParts = [], combinedTextLength = 0, textNode, parent;
              forEach(textNodes, function(textNode2, i) {
                parent = textNode2.parentNode;
                if (i > 0) {
                  parent.removeChild(textNode2);
                  if (!parent.hasChildNodes()) {
                    dom.removeNode(parent);
                  }
                  if (positionsToPreserve) {
                    forEach(positionsToPreserve, function(position) {
                      if (position.node == textNode2) {
                        position.node = firstTextNode;
                        position.offset += combinedTextLength;
                      }
                      if (position.node == parent && position.offset > firstTextNodeIndex) {
                        --position.offset;
                        if (position.offset == firstTextNodeIndex + 1 && i < textNodes.length - 1) {
                          position.node = firstTextNode;
                          position.offset = combinedTextLength;
                        }
                      }
                    });
                  }
                }
                textParts[i] = textNode2.data;
                combinedTextLength += textNode2.data.length;
              });
              firstTextNode.data = textParts.join("");
            }
            return firstTextNode.data;
          },
          getLength: function() {
            var i = this.textNodes.length, len = 0;
            while (i--) {
              len += this.textNodes[i].length;
            }
            return len;
          },
          toString: function() {
            var textParts = [];
            forEach(this.textNodes, function(textNode, i) {
              textParts[i] = "'" + textNode.data + "'";
            });
            return "[Merge(" + textParts.join(",") + ")]";
          }
        };
        var optionProperties = [
          "elementTagName",
          "ignoreWhiteSpace",
          "applyToEditableOnly",
          "useExistingElements",
          "removeEmptyElements",
          "onElementCreate"
        ];
        var attrNamesForProperties = {};
        function ClassApplier(className, options, tagNames) {
          var normalize, i, len, propName, applier = this;
          applier.cssClass = applier.className = className;
          var elementPropertiesFromOptions = null, elementAttributes = {};
          if (typeof options == "object" && options !== null) {
            if (typeof options.elementTagName !== "undefined") {
              options.elementTagName = options.elementTagName.toLowerCase();
            }
            tagNames = options.tagNames;
            elementPropertiesFromOptions = options.elementProperties;
            elementAttributes = options.elementAttributes;
            for (i = 0; propName = optionProperties[i++]; ) {
              if (options.hasOwnProperty(propName)) {
                applier[propName] = options[propName];
              }
            }
            normalize = options.normalize;
          } else {
            normalize = options;
          }
          applier.normalize = typeof normalize == "undefined" ? true : normalize;
          applier.attrExceptions = [];
          var el = document.createElement(applier.elementTagName);
          applier.elementProperties = applier.copyPropertiesToElement(elementPropertiesFromOptions, el, true);
          each(elementAttributes, function(attrName, attrValue) {
            applier.attrExceptions.push(attrName);
            elementAttributes[attrName] = "" + attrValue;
          });
          applier.elementAttributes = elementAttributes;
          applier.elementSortedClassName = applier.elementProperties.hasOwnProperty("className") ? sortClassName(applier.elementProperties.className + " " + className) : className;
          applier.applyToAnyTagName = false;
          var type3 = typeof tagNames;
          if (type3 == "string") {
            if (tagNames == "*") {
              applier.applyToAnyTagName = true;
            } else {
              applier.tagNames = trim(tagNames.toLowerCase()).split(/\s*,\s*/);
            }
          } else if (type3 == "object" && typeof tagNames.length == "number") {
            applier.tagNames = [];
            for (i = 0, len = tagNames.length; i < len; ++i) {
              if (tagNames[i] == "*") {
                applier.applyToAnyTagName = true;
              } else {
                applier.tagNames.push(tagNames[i].toLowerCase());
              }
            }
          } else {
            applier.tagNames = [applier.elementTagName];
          }
        }
        ClassApplier.prototype = {
          elementTagName: defaultTagName,
          elementProperties: {},
          elementAttributes: {},
          ignoreWhiteSpace: true,
          applyToEditableOnly: false,
          useExistingElements: true,
          removeEmptyElements: true,
          onElementCreate: null,
          copyPropertiesToElement: function(props, el, createCopy) {
            var s, elStyle, elProps = {}, elPropsStyle, propValue, elPropValue, attrName;
            for (var p in props) {
              if (props.hasOwnProperty(p)) {
                propValue = props[p];
                elPropValue = el[p];
                if (p == "className") {
                  addClass(el, propValue);
                  addClass(el, this.className);
                  el[p] = sortClassName(el[p]);
                  if (createCopy) {
                    elProps[p] = propValue;
                  }
                } else if (p == "style") {
                  elStyle = elPropValue;
                  if (createCopy) {
                    elProps[p] = elPropsStyle = {};
                  }
                  for (s in props[p]) {
                    if (props[p].hasOwnProperty(s)) {
                      elStyle[s] = propValue[s];
                      if (createCopy) {
                        elPropsStyle[s] = elStyle[s];
                      }
                    }
                  }
                  this.attrExceptions.push(p);
                } else {
                  el[p] = propValue;
                  if (createCopy) {
                    elProps[p] = el[p];
                    attrName = attrNamesForProperties.hasOwnProperty(p) ? attrNamesForProperties[p] : p;
                    this.attrExceptions.push(attrName);
                  }
                }
              }
            }
            return createCopy ? elProps : "";
          },
          copyAttributesToElement: function(attrs, el) {
            for (var attrName in attrs) {
              if (attrs.hasOwnProperty(attrName) && !/^class(?:Name)?$/i.test(attrName)) {
                el.setAttribute(attrName, attrs[attrName]);
              }
            }
          },
          appliesToElement: function(el) {
            return contains(this.tagNames, el.tagName.toLowerCase());
          },
          getEmptyElements: function(range) {
            var applier = this;
            return range.getNodes([1], function(el) {
              return applier.appliesToElement(el) && !el.hasChildNodes();
            });
          },
          hasClass: function(node2) {
            return node2.nodeType == 1 && (this.applyToAnyTagName || this.appliesToElement(node2)) && hasClass(node2, this.className);
          },
          getSelfOrAncestorWithClass: function(node2) {
            while (node2) {
              if (this.hasClass(node2)) {
                return node2;
              }
              node2 = node2.parentNode;
            }
            return null;
          },
          isModifiable: function(node2) {
            return !this.applyToEditableOnly || isEditable(node2);
          },
          // White space adjacent to an unwrappable node can be ignored for wrapping
          isIgnorableWhiteSpaceNode: function(node2) {
            return this.ignoreWhiteSpace && node2 && node2.nodeType == 3 && isUnrenderedWhiteSpaceNode(node2);
          },
          // Normalizes nodes after applying a class to a Range.
          postApply: function(textNodes, range, positionsToPreserve, isUndo) {
            var firstNode = textNodes[0], lastNode = textNodes[textNodes.length - 1];
            var merges = [], currentMerge;
            var rangeStartNode = firstNode, rangeEndNode = lastNode;
            var rangeStartOffset = 0, rangeEndOffset = lastNode.length;
            var precedingTextNode;
            forEach(textNodes, function(textNode) {
              precedingTextNode = getPreviousMergeableTextNode(textNode, !isUndo);
              if (precedingTextNode) {
                if (!currentMerge) {
                  currentMerge = new Merge(precedingTextNode);
                  merges.push(currentMerge);
                }
                currentMerge.textNodes.push(textNode);
                if (textNode === firstNode) {
                  rangeStartNode = currentMerge.textNodes[0];
                  rangeStartOffset = rangeStartNode.length;
                }
                if (textNode === lastNode) {
                  rangeEndNode = currentMerge.textNodes[0];
                  rangeEndOffset = currentMerge.getLength();
                }
              } else {
                currentMerge = null;
              }
            });
            var nextTextNode = getNextMergeableTextNode(lastNode, !isUndo);
            if (nextTextNode) {
              if (!currentMerge) {
                currentMerge = new Merge(lastNode);
                merges.push(currentMerge);
              }
              currentMerge.textNodes.push(nextTextNode);
            }
            if (merges.length) {
              for (var i = 0, len = merges.length; i < len; ++i) {
                merges[i].doMerge(positionsToPreserve);
              }
              range.setStartAndEnd(rangeStartNode, rangeStartOffset, rangeEndNode, rangeEndOffset);
            }
          },
          createContainer: function(parentNode) {
            var doc = dom.getDocument(parentNode);
            var namespace;
            var el = createElementNSSupported && !dom.isHtmlNamespace(parentNode) && (namespace = parentNode.namespaceURI) ? doc.createElementNS(parentNode.namespaceURI, this.elementTagName) : doc.createElement(this.elementTagName);
            this.copyPropertiesToElement(this.elementProperties, el, false);
            this.copyAttributesToElement(this.elementAttributes, el);
            addClass(el, this.className);
            if (this.onElementCreate) {
              this.onElementCreate(el, this);
            }
            return el;
          },
          elementHasProperties: function(el, props) {
            var applier = this;
            return each(props, function(p, propValue) {
              if (p == "className") {
                return hasAllClasses(el, propValue);
              } else if (typeof propValue == "object") {
                if (!applier.elementHasProperties(el[p], propValue)) {
                  return false;
                }
              } else if (el[p] !== propValue) {
                return false;
              }
            });
          },
          elementHasAttributes: function(el, attrs) {
            return each(attrs, function(name, value) {
              if (el.getAttribute(name) !== value) {
                return false;
              }
            });
          },
          applyToTextNode: function(textNode, positionsToPreserve) {
            if (canTextBeStyled(textNode)) {
              var parent = textNode.parentNode;
              if (parent.childNodes.length == 1 && this.useExistingElements && this.appliesToElement(parent) && this.elementHasProperties(parent, this.elementProperties) && this.elementHasAttributes(parent, this.elementAttributes)) {
                addClass(parent, this.className);
              } else {
                var textNodeParent = textNode.parentNode;
                var el = this.createContainer(textNodeParent);
                textNodeParent.insertBefore(el, textNode);
                el.appendChild(textNode);
              }
            }
          },
          isRemovable: function(el) {
            return el.tagName.toLowerCase() == this.elementTagName && getSortedClassName(el) == this.elementSortedClassName && this.elementHasProperties(el, this.elementProperties) && !elementHasNonClassAttributes(el, this.attrExceptions) && this.elementHasAttributes(el, this.elementAttributes) && this.isModifiable(el);
          },
          isEmptyContainer: function(el) {
            var childNodeCount = el.childNodes.length;
            return el.nodeType == 1 && this.isRemovable(el) && (childNodeCount == 0 || childNodeCount == 1 && this.isEmptyContainer(el.firstChild));
          },
          removeEmptyContainers: function(range) {
            var applier = this;
            var nodesToRemove = range.getNodes([1], function(el) {
              return applier.isEmptyContainer(el);
            });
            var rangesToPreserve = [range];
            var positionsToPreserve = getRangeBoundaries(rangesToPreserve);
            forEach(nodesToRemove, function(node2) {
              removePreservingPositions(node2, positionsToPreserve);
            });
            updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);
          },
          undoToTextNode: function(textNode, range, ancestorWithClass, positionsToPreserve) {
            if (!range.containsNode(ancestorWithClass)) {
              var ancestorRange = range.cloneRange();
              ancestorRange.selectNode(ancestorWithClass);
              if (ancestorRange.isPointInRange(range.endContainer, range.endOffset)) {
                splitNodeAt(ancestorWithClass, range.endContainer, range.endOffset, positionsToPreserve);
                range.setEndAfter(ancestorWithClass);
              }
              if (ancestorRange.isPointInRange(range.startContainer, range.startOffset)) {
                ancestorWithClass = splitNodeAt(ancestorWithClass, range.startContainer, range.startOffset, positionsToPreserve);
              }
            }
            if (this.isRemovable(ancestorWithClass)) {
              replaceWithOwnChildrenPreservingPositions(ancestorWithClass, positionsToPreserve);
            } else {
              removeClass(ancestorWithClass, this.className);
            }
          },
          splitAncestorWithClass: function(container, offset, positionsToPreserve) {
            var ancestorWithClass = this.getSelfOrAncestorWithClass(container);
            if (ancestorWithClass) {
              splitNodeAt(ancestorWithClass, container, offset, positionsToPreserve);
            }
          },
          undoToAncestor: function(ancestorWithClass, positionsToPreserve) {
            if (this.isRemovable(ancestorWithClass)) {
              replaceWithOwnChildrenPreservingPositions(ancestorWithClass, positionsToPreserve);
            } else {
              removeClass(ancestorWithClass, this.className);
            }
          },
          applyToRange: function(range, rangesToPreserve) {
            var applier = this;
            rangesToPreserve = rangesToPreserve || [];
            var positionsToPreserve = getRangeBoundaries(rangesToPreserve || []);
            range.splitBoundariesPreservingPositions(positionsToPreserve);
            if (applier.removeEmptyElements) {
              applier.removeEmptyContainers(range);
            }
            var textNodes = getEffectiveTextNodes(range);
            if (textNodes.length) {
              forEach(textNodes, function(textNode) {
                if (!applier.isIgnorableWhiteSpaceNode(textNode) && !applier.getSelfOrAncestorWithClass(textNode) && applier.isModifiable(textNode)) {
                  applier.applyToTextNode(textNode, positionsToPreserve);
                }
              });
              var lastTextNode = textNodes[textNodes.length - 1];
              range.setStartAndEnd(textNodes[0], 0, lastTextNode, lastTextNode.length);
              if (applier.normalize) {
                applier.postApply(textNodes, range, positionsToPreserve, false);
              }
              updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);
            }
            var emptyElements = applier.getEmptyElements(range);
            forEach(emptyElements, function(el) {
              addClass(el, applier.className);
            });
          },
          applyToRanges: function(ranges) {
            var i = ranges.length;
            while (i--) {
              this.applyToRange(ranges[i], ranges);
            }
            return ranges;
          },
          applyToSelection: function(win) {
            var sel = api.getSelection(win);
            sel.setRanges(this.applyToRanges(sel.getAllRanges()));
          },
          undoToRange: function(range, rangesToPreserve) {
            var applier = this;
            rangesToPreserve = rangesToPreserve || [];
            var positionsToPreserve = getRangeBoundaries(rangesToPreserve);
            range.splitBoundariesPreservingPositions(positionsToPreserve);
            if (applier.removeEmptyElements) {
              applier.removeEmptyContainers(range, positionsToPreserve);
            }
            var textNodes = getEffectiveTextNodes(range);
            var textNode, ancestorWithClass;
            var lastTextNode = textNodes[textNodes.length - 1];
            if (textNodes.length) {
              applier.splitAncestorWithClass(range.endContainer, range.endOffset, positionsToPreserve);
              applier.splitAncestorWithClass(range.startContainer, range.startOffset, positionsToPreserve);
              for (var i = 0, len = textNodes.length; i < len; ++i) {
                textNode = textNodes[i];
                ancestorWithClass = applier.getSelfOrAncestorWithClass(textNode);
                if (ancestorWithClass && applier.isModifiable(textNode)) {
                  applier.undoToAncestor(ancestorWithClass, positionsToPreserve);
                }
              }
              range.setStartAndEnd(textNodes[0], 0, lastTextNode, lastTextNode.length);
              if (applier.normalize) {
                applier.postApply(textNodes, range, positionsToPreserve, true);
              }
              updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);
            }
            var emptyElements = applier.getEmptyElements(range);
            forEach(emptyElements, function(el) {
              removeClass(el, applier.className);
            });
          },
          undoToRanges: function(ranges) {
            var i = ranges.length;
            while (i--) {
              this.undoToRange(ranges[i], ranges);
            }
            return ranges;
          },
          undoToSelection: function(win) {
            var sel = api.getSelection(win);
            var ranges = api.getSelection(win).getAllRanges();
            this.undoToRanges(ranges);
            sel.setRanges(ranges);
          },
          isAppliedToRange: function(range) {
            if (range.collapsed || range.toString() == "") {
              return !!this.getSelfOrAncestorWithClass(range.commonAncestorContainer);
            } else {
              var textNodes = range.getNodes([3]);
              if (textNodes.length)
                for (var i = 0, textNode; textNode = textNodes[i++]; ) {
                  if (!this.isIgnorableWhiteSpaceNode(textNode) && rangeSelectsAnyText(range, textNode) && this.isModifiable(textNode) && !this.getSelfOrAncestorWithClass(textNode)) {
                    return false;
                  }
                }
              return true;
            }
          },
          isAppliedToRanges: function(ranges) {
            var i = ranges.length;
            if (i == 0) {
              return false;
            }
            while (i--) {
              if (!this.isAppliedToRange(ranges[i])) {
                return false;
              }
            }
            return true;
          },
          isAppliedToSelection: function(win) {
            var sel = api.getSelection(win);
            return this.isAppliedToRanges(sel.getAllRanges());
          },
          toggleRange: function(range) {
            if (this.isAppliedToRange(range)) {
              this.undoToRange(range);
            } else {
              this.applyToRange(range);
            }
          },
          toggleSelection: function(win) {
            if (this.isAppliedToSelection(win)) {
              this.undoToSelection(win);
            } else {
              this.applyToSelection(win);
            }
          },
          getElementsWithClassIntersectingRange: function(range) {
            var elements = [];
            var applier = this;
            range.getNodes([3], function(textNode) {
              var el = applier.getSelfOrAncestorWithClass(textNode);
              if (el && !contains(elements, el)) {
                elements.push(el);
              }
            });
            return elements;
          },
          detach: function() {
          }
        };
        function createClassApplier(className, options, tagNames) {
          return new ClassApplier(className, options, tagNames);
        }
        ClassApplier.util = {
          hasClass,
          addClass,
          removeClass,
          getClass,
          hasSameClasses: haveSameClasses,
          hasAllClasses,
          replaceWithOwnChildren: replaceWithOwnChildrenPreservingPositions,
          elementsHaveSameNonClassAttributes,
          elementHasNonClassAttributes,
          splitNodeAt,
          isEditableElement,
          isEditingHost,
          isEditable
        };
        api.CssClassApplier = api.ClassApplier = ClassApplier;
        api.createClassApplier = createClassApplier;
        util.createAliasForDeprecatedMethod(api, "createCssClassApplier", "createClassApplier", module2);
      });
      return rangy2;
    }, exports);
  }
});

// node_modules/@logicflow/extension/es/bpmn/constant.js
var StartEventConfig = {
  width: 40,
  height: 40
};
var EndEventConfig = {
  width: 40,
  height: 40
};
var ExclusiveGatewayConfig = {
  width: 40,
  height: 40
};
var ServiceTaskConfig = {
  width: 100,
  height: 80
};
var UserTaskConfig = {
  width: 100,
  height: 80
};
var theme = {
  rect: {
    radius: 5,
    stroke: "rgb(24, 125, 255)"
  },
  circle: {
    r: 18,
    stroke: "rgb(24, 125, 255)"
  },
  polygon: {
    stroke: "rgb(24, 125, 255)"
  },
  polyline: {
    stroke: "rgb(24, 125, 255)",
    hoverStroke: "rgb(24, 125, 255)",
    selectedStroke: "rgb(24, 125, 255)"
  },
  edgeText: {
    textWidth: 100,
    overflowMode: "default",
    fontSize: 12,
    background: {
      fill: "white",
      height: 14,
      stroke: "transparent",
      radius: 3
    }
  }
};

// node_modules/@logicflow/extension/es/bpmn/getBpmnId.js
var IDS = (
  /** @class */
  function() {
    function IDS2() {
      globalThis._ids = this;
      this._ids = /* @__PURE__ */ new Set();
    }
    IDS2.prototype.generateId = function() {
      return "xxxxxxx".replace(/[x]/g, function(c) {
        var r = Math.random() * 16 | 0;
        var v = c === "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    };
    IDS2.prototype.next = function() {
      var id = this.generateId();
      while (this._ids.has(id)) {
        id = this.generateId();
      }
      this._ids.add(id);
      return id;
    };
    return IDS2;
  }()
);
var ids = (globalThis === null || globalThis === void 0 ? void 0 : globalThis._ids) || new IDS();
function getBpmnId() {
  return ids.next();
}

// node_modules/@logicflow/extension/es/bpmn/events/StartEvent.js
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var StartEventModel = (
  /** @class */
  function(_super) {
    __extends(StartEventModel2, _super);
    function StartEventModel2(data, graphModel) {
      if (!data.id) {
        data.id = "Event_".concat(getBpmnId());
      }
      if (!data.text) {
        data.text = "";
      }
      if (data.text && typeof data.text === "string") {
        data.text = {
          value: data.text,
          x: data.x,
          y: data.y + 40
        };
      }
      return _super.call(this, data, graphModel) || this;
    }
    StartEventModel2.prototype.setAttributes = function() {
      this.r = 18;
    };
    StartEventModel2.prototype.getConnectedTargetRules = function() {
      var rules = _super.prototype.getConnectedTargetRules.call(this);
      var notAsTarget = {
        message: "起始节点不能作为边的终点",
        validate: function() {
          return false;
        }
      };
      rules.push(notAsTarget);
      return rules;
    };
    StartEventModel2.extendKey = "StartEventModel";
    return StartEventModel2;
  }(CircleNodeModel)
);
var StartEventView = (
  /** @class */
  function(_super) {
    __extends(StartEventView2, _super);
    function StartEventView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    StartEventView2.extendKey = "StartEventNode";
    return StartEventView2;
  }(CircleNode)
);
var StartEvent = {
  type: "bpmn:startEvent",
  view: StartEventView,
  model: StartEventModel
};

// node_modules/@logicflow/extension/es/bpmn/events/EndEvent.js
var __extends2 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var EndEventModel = (
  /** @class */
  function(_super) {
    __extends2(EndEventModel2, _super);
    function EndEventModel2(data, graphModel) {
      if (!data.id) {
        data.id = "Event_".concat(getBpmnId());
      }
      if (!data.text) {
        data.text = "";
      }
      if (data.text && typeof data.text === "string") {
        data.text = {
          value: data.text,
          x: data.x,
          y: data.y + 40
        };
      }
      return _super.call(this, data, graphModel) || this;
    }
    EndEventModel2.prototype.setAttributes = function() {
      this.r = 18;
    };
    EndEventModel2.prototype.getConnectedSourceRules = function() {
      var rules = _super.prototype.getConnectedSourceRules.call(this);
      var notAsSource = {
        message: "结束节点不能作为边的起点",
        validate: function() {
          return false;
        }
      };
      rules.push(notAsSource);
      return rules;
    };
    EndEventModel2.extendKey = "EndEventModel";
    return EndEventModel2;
  }(CircleNodeModel)
);
var EndEventView = (
  /** @class */
  function(_super) {
    __extends2(EndEventView2, _super);
    function EndEventView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    EndEventView2.prototype.getAnchorStyle = function() {
      return {
        visibility: "hidden"
      };
    };
    EndEventView2.prototype.getShape = function() {
      var model = this.props.model;
      var style2 = model.getNodeStyle();
      var _a = model, x2 = _a.x, y = _a.y, r = _a.r;
      var outCircle = _super.prototype.getShape.call(this);
      return g("g", {}, outCircle, g("circle", __assign(__assign({}, style2), { cx: x2, cy: y, r: r - 5 })));
    };
    EndEventView2.extendKey = "EndEventView";
    return EndEventView2;
  }(CircleNode)
);
var EndEvent = {
  type: "bpmn:endEvent",
  view: EndEventView,
  model: EndEventModel
};

// node_modules/@logicflow/extension/es/bpmn/flow/SequenceFlow.js
var __extends3 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var SequenceFlowModel = (
  /** @class */
  function(_super) {
    __extends3(SequenceFlowModel2, _super);
    function SequenceFlowModel2(data, graphModel) {
      if (!data.id) {
        data.id = "Flow_".concat(getBpmnId());
      }
      return _super.call(this, data, graphModel) || this;
    }
    SequenceFlowModel2.extendKey = "SequenceFlowModel";
    return SequenceFlowModel2;
  }(PolylineEdgeModel)
);
var SequenceFlowView = (
  /** @class */
  function(_super) {
    __extends3(SequenceFlowView2, _super);
    function SequenceFlowView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SequenceFlowView2.extendKey = "SequenceFlowEdge";
    return SequenceFlowView2;
  }(PolylineEdge)
);
var SequenceFlow = {
  type: "bpmn:sequenceFlow",
  view: SequenceFlowView,
  model: SequenceFlowModel
};

// node_modules/@logicflow/extension/es/bpmn/gateways/ExclusiveGateway.js
var __extends4 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var ExclusiveGatewayModel = (
  /** @class */
  function(_super) {
    __extends4(ExclusiveGatewayModel2, _super);
    function ExclusiveGatewayModel2(data, graphModel) {
      var _this = this;
      if (!data.id) {
        data.id = "Gateway_".concat(getBpmnId());
      }
      if (!data.text) {
        data.text = "";
      }
      if (data.text && typeof data.text === "string") {
        data.text = {
          value: data.text,
          x: data.x,
          y: data.y + 40
        };
      }
      _this = _super.call(this, data, graphModel) || this;
      _this.points = [
        [25, 0],
        [50, 25],
        [25, 50],
        [0, 25]
      ];
      return _this;
    }
    ExclusiveGatewayModel2.extendKey = "ExclusiveGatewayModel";
    return ExclusiveGatewayModel2;
  }(PolygonNodeModel)
);
var ExclusiveGatewayView = (
  /** @class */
  function(_super) {
    __extends4(ExclusiveGatewayView2, _super);
    function ExclusiveGatewayView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ExclusiveGatewayView2.prototype.getShape = function() {
      var model = this.props.model;
      var _a = model, x2 = _a.x, y = _a.y, width = _a.width, height = _a.height, points = _a.points;
      var style2 = model.getNodeStyle();
      return g(
        "g",
        {
          transform: "matrix(1 0 0 1 ".concat(x2 - width / 2, " ").concat(y - height / 2, ")")
        },
        // @ts-ignore TODO: 确认 h('polygon') 报错的问题
        g("polygon", __assign2(__assign2({}, style2), { x: x2, y, points })),
        g("path", __assign2({ d: "m 16,15 7.42857142857143,9.714285714285715 -7.42857142857143,9.714285714285715 3.428571428571429,0 5.714285714285715,-7.464228571428572 5.714285714285715,7.464228571428572 3.428571428571429,0 -7.42857142857143,-9.714285714285715 7.42857142857143,-9.714285714285715 -3.428571428571429,0 -5.714285714285715,7.464228571428572 -5.714285714285715,-7.464228571428572 -3.428571428571429,0 z" }, style2))
      );
    };
    ExclusiveGatewayView2.extendKey = "ExclusiveGatewayNode";
    return ExclusiveGatewayView2;
  }(PolygonNode)
);
var ExclusiveGateway = {
  type: "bpmn:exclusiveGateway",
  view: ExclusiveGatewayView,
  model: ExclusiveGatewayModel
};

// node_modules/@logicflow/extension/es/bpmn/tasks/ServiceTask.js
var __extends5 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign3 = function() {
  __assign3 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
var ServiceTaskModel = (
  /** @class */
  function(_super) {
    __extends5(ServiceTaskModel2, _super);
    function ServiceTaskModel2(data, graphModel) {
      if (!data.id) {
        data.id = "Activity_".concat(getBpmnId());
      }
      return _super.call(this, data, graphModel) || this;
    }
    ServiceTaskModel2.extendKey = "ServiceTaskModel";
    return ServiceTaskModel2;
  }(RectNodeModel)
);
var ServiceTaskView = (
  /** @class */
  function(_super) {
    __extends5(ServiceTaskView2, _super);
    function ServiceTaskView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ServiceTaskView2.prototype.getLabelShape = function() {
      var model = this.props.model;
      var x2 = model.x, y = model.y, width = model.width, height = model.height;
      var style2 = model.getNodeStyle();
      return g("svg", {
        x: x2 - width / 2 + 5,
        y: y - height / 2 + 5,
        width: 30,
        height: 30,
        viewBox: "0 0 1274 1024"
      }, g("path", {
        fill: style2.stroke,
        d: "M882.527918 434.149934c-2.234901-5.303796-7.311523-8.853645-13.059434-9.138124l-61.390185-3.009544c-6.635117-20.973684-15.521508-41.175795-26.513864-60.282968l42.051745-47.743374c4.308119-4.889357 4.955872-12.004405 1.602498-17.59268-46.384423-77.30362-103.969956-101.422947-106.400309-102.410438-5.332449-2.170432-11.432377-1.090844-15.693424 2.77009L654.674467 240.664222c-17.004279-8.654101-35.092239-15.756869-53.995775-21.210068l-3.26537-66.490344c-0.280386-5.747911-3.833305-10.824533-9.134031-13.059434-1.683339-0.709151-30.193673-12.391215-76.866668-12.051477-46.672996-0.339738-75.18333 11.342326-76.866668 12.051477-5.300726 2.234901-8.853645 7.311523-9.134031 13.059434l-3.26537 66.490344c-18.903535 5.453199-36.991496 12.555967-53.995775 21.210068l-48.450479-43.922349c-4.261047-3.860934-10.360975-4.940522-15.693424-2.77009-2.430352 0.98749-60.015885 25.106818-106.400309 102.410438-3.353374 5.588275-2.705622 12.703323 1.602498 17.59268l42.051745 47.743374c-10.992355 19.107173-19.878746 39.309284-26.513864 60.282968l-61.390185 3.009544c-5.747911 0.284479-10.824533 3.834328-13.059434 9.138124-1.01512 2.415003-24.687262 60.190871-2.822278 147.651828 1.583055 6.324032 7.072069 10.893094 13.57518 11.308557 5.892197 0.37146 11.751648 0.523933 17.419741 0.667196 14.498202 0.372483 28.193109 0.723477 40.908712 4.63353 4.212952 1.294482 6.435573 8.270361 9.349949 18.763342 1.287319 4.640694 2.617617 9.43693 4.484128 14.010085 1.794879 4.393054 3.75758 8.570189 5.66093 12.607132 1.302669 2.765997 2.529613 5.380544 3.689019 8.018627 2.986007 6.803963 2.682086 9.773598 2.578732 10.349719-3.061732 3.672646-6.391571 7.238868-9.91379 11.015891-1.810229 1.943258-3.680832 3.949962-5.523807 5.980201l-22.560832 24.8909c-3.865028 4.261047-4.940522 10.365068-2.774183 15.693424 0.991584 2.426259 25.102724 60.011792 102.414531 106.400309 5.588275 3.353374 12.703323 2.701528 17.591657-1.603521l23.476691-20.682042c2.346441-2.061962 4.64888-4.336772 6.875594-6.534833 9.05319-8.93858 14.018272-12.95608 17.73185-11.576663 3.305279 1.222851 6.907317 3.166109 10.720156 5.228071 3.325745 1.794879 6.764054 3.650133 10.465352 5.288446 6.016017 2.662643 12.120039 4.688789 18.019399 6.65149 6.827499 2.266623 13.279445 4.409426 18.819624 7.275707 1.518586 0.782829 1.926886 0.994654 2.358721 7.830339 0.726547 11.496845 1.25048 23.276123 1.753947 34.672684 0.264013 5.900384 0.528026 11.803837 0.815575 17.700127 0.284479 5.743818 3.833305 10.82044 9.138124 13.05534 1.654686 0.698918 29.371958 12.063757 74.869175 12.063757 0.328481 0 3.65832 0 3.986801 0 45.497217 0 73.214489-11.364839 74.869175-12.063757 5.304819-2.234901 8.853645-7.311523 9.138124-13.05534 0.287549-5.89629 0.551562-11.799744 0.815575-17.700127 0.503467-11.396561 1.027399-23.175839 1.753947-34.672684 0.431835-6.835685 0.840134-7.04751 2.358721-7.830339 5.54018-2.866281 11.992125-5.009084 18.819624-7.275707 5.89936-1.962701 12.003382-3.988848 18.019399-6.65149 3.701299-1.638313 7.139607-3.493567 10.465352-5.288446 3.812839-2.061962 7.414877-4.00522 10.720156-5.228071 3.713578-1.379417 8.67866 2.638083 17.73185 11.576663 2.226714 2.198062 4.529153 4.472871 6.875594 6.534833l23.476691 20.682042c4.888334 4.305049 12.003382 4.956895 17.591657 1.603521 77.311807-46.388517 101.422947-103.97405 102.414531-106.400309 2.166339-5.328355 1.090844-11.432377-2.774183-15.693424l-22.560832-24.8909c-1.842974-2.030239-3.713578-4.036943-5.523807-5.980201-3.52222-3.777023-6.852058-7.343245-9.91379-11.015891-0.103354-0.576121-0.407276-3.545756 2.578732-10.349719 1.159406-2.638083 2.38635-5.252631 3.689019-8.018627 1.90335-4.036943 3.866051-8.214079 5.66093-12.607132 1.866511-4.573155 3.196809-9.369392 4.484128-14.010085 2.914376-10.492982 5.136997-17.46886 9.349949-18.763342 12.715603-3.910053 26.41051-4.261047 40.908712-4.63353 5.668093-0.143263 11.527544-0.295735 17.419741-0.667196 6.503111-0.415462 11.992125-4.984524 13.57518-11.308557C907.21518 494.340805 883.543038 436.564937 882.527918 434.149934zM643.49894 643.761929c-35.280528 35.280528-82.191954 54.711066-132.086317 54.711066s-96.806813-19.430538-132.086317-54.711066c-35.280528-35.279504-54.711066-82.191954-54.711066-132.086317 0-49.894364 19.430538-96.80272 54.711066-132.082224 35.283598-35.284621 82.191954-54.711066 132.086317-54.711066s96.80579 19.426445 132.086317 54.711066c35.279504 35.279504 54.711066 82.187861 54.711066 132.082224C698.210006 561.569976 678.782537 608.482425 643.49894 643.761929z"
      }));
    };
    ServiceTaskView2.prototype.getShape = function() {
      var model = this.props.model;
      var x2 = model.x, y = model.y, width = model.width, height = model.height, radius = model.radius;
      var style2 = model.getNodeStyle();
      return g("g", {}, [
        g("rect", __assign3({ x: x2 - width / 2, y: y - height / 2, rx: radius, ry: radius, width, height }, style2)),
        this.getLabelShape()
      ]);
    };
    ServiceTaskView2.extendKey = "ServiceTaskNode";
    return ServiceTaskView2;
  }(RectNode)
);
var ServiceTask = {
  type: "bpmn:serviceTask",
  view: ServiceTaskView,
  model: ServiceTaskModel
};

// node_modules/@logicflow/extension/es/bpmn/tasks/UserTask.js
var __extends6 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign4 = function() {
  __assign4 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign4.apply(this, arguments);
};
var UserTaskModel = (
  /** @class */
  function(_super) {
    __extends6(UserTaskModel2, _super);
    function UserTaskModel2(data, graphModel) {
      if (!data.id) {
        data.id = "Activity_".concat(getBpmnId());
      }
      return _super.call(this, data, graphModel) || this;
    }
    UserTaskModel2.extendKey = "UserTaskModel";
    return UserTaskModel2;
  }(RectNodeModel)
);
var UserTaskView = (
  /** @class */
  function(_super) {
    __extends6(UserTaskView2, _super);
    function UserTaskView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    UserTaskView2.prototype.getLabelShape = function() {
      var model = this.props.model;
      var x2 = model.x, y = model.y, width = model.width, height = model.height;
      var style2 = model.getNodeStyle();
      return g("svg", {
        x: x2 - width / 2 + 5,
        y: y - height / 2 + 5,
        width: 25,
        height: 25,
        viewBox: "0 0 1274 1024"
      }, g("path", {
        fill: style2.stroke,
        d: "M655.807326 287.35973m-223.989415 0a218.879 218.879 0 1 0 447.978829 0 218.879 218.879 0 1 0-447.978829 0ZM1039.955839 895.482975c-0.490184-212.177424-172.287821-384.030443-384.148513-384.030443-211.862739 0-383.660376 171.85302-384.15056 384.030443L1039.955839 895.482975z"
      }));
    };
    UserTaskView2.prototype.getShape = function() {
      var model = this.props.model;
      var x2 = model.x, y = model.y, width = model.width, height = model.height, radius = model.radius;
      var style2 = model.getNodeStyle();
      return g("g", {}, [
        g("rect", __assign4(__assign4({}, style2), { x: x2 - width / 2, y: y - height / 2, rx: radius, ry: radius, width, height })),
        this.getLabelShape()
      ]);
    };
    UserTaskView2.extendKey = "UserTaskNode";
    return UserTaskView2;
  }(RectNode)
);
var UserTask = {
  type: "bpmn:userTask",
  view: UserTaskView,
  model: UserTaskModel
};

// node_modules/@logicflow/extension/es/bpmn/index.js
var BpmnElement = {
  pluginName: "bpmnElement",
  install: function(lf) {
    lf.setTheme(theme);
    lf.register(StartEvent);
    lf.register(EndEvent);
    lf.register(ExclusiveGateway);
    lf.register(UserTask);
    lf.register(ServiceTask);
    if (!lf.options.customBpmnEdge) {
      lf.register(SequenceFlow);
      lf.setDefaultEdgeType("bpmn:sequenceFlow");
    }
  }
};

// node_modules/@logicflow/extension/es/bpmn-adapter/bpmnIds.js
var IDs = (
  /** @class */
  function() {
    function IDs3() {
      globalThis._ids = this;
      this._ids = /* @__PURE__ */ new Set();
    }
    IDs3.prototype.generateId = function() {
      return "xxxxxxx".replace(/[x]/g, function(c) {
        var r = Math.random() * 16 | 0;
        var v = c === "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    };
    IDs3.prototype.next = function() {
      var id = this.generateId();
      while (this._ids.has(id)) {
        id = this.generateId();
      }
      this._ids.add(id);
      return id;
    };
    return IDs3;
  }()
);
var ids2 = (globalThis === null || globalThis === void 0 ? void 0 : globalThis._ids) || new IDs();
function getBpmnId2() {
  return ids2.next();
}

// node_modules/@logicflow/extension/es/bpmn-adapter/json2xml.js
function type(obj) {
  return Object.prototype.toString.call(obj);
}
function addSpace(depth) {
  return "  ".repeat(depth);
}
function handleAttributes(o) {
  var t = o;
  if (type(o) === "[object Object]") {
    t = {};
    Object.keys(o).forEach(function(k) {
      var tk = k;
      if (k.charAt(0) === "-") {
        tk = k.substring(1);
      }
      t[tk] = handleAttributes(o[k]);
    });
  } else if (Array.isArray(o)) {
    t = [];
    o.forEach(function(item, index) {
      t[index] = handleAttributes(item);
    });
  }
  return t;
}
function getAttributes(obj) {
  var tmp = obj;
  try {
    if (typeof tmp !== "string") {
      tmp = JSON.parse(obj);
    }
  } catch (error) {
    tmp = JSON.stringify(handleAttributes(obj)).replace(/"/g, "'");
  }
  return tmp;
}
var tn = "	\n";
function toXml(obj, name, depth) {
  var frontSpace = addSpace(depth);
  if (obj !== 0 && obj !== false && !obj) {
    return tn + frontSpace + "<".concat(name, " />");
  }
  var str = "";
  if (name === "#text") {
    return tn + frontSpace + obj;
  } else if (name === "#cdata-section") {
    return tn + frontSpace + "<![CDATA[" + obj + "]]>";
  } else if (name === "#comment") {
    return tn + frontSpace + "<!--" + obj + "-->";
  }
  if ("".concat(name).charAt(0) === "-") {
    return " " + name.substring(1) + '="' + getAttributes(obj) + '"';
  } else {
    if (Array.isArray(obj)) {
      obj.forEach(function(item) {
        str += toXml(item, name, depth + 1);
      });
    } else if (type(obj) === "[object Object]") {
      var keys = Object.keys(obj);
      var attributes_1 = "";
      var children_1 = "";
      str += (depth === 0 ? "" : tn + frontSpace) + "<" + name;
      keys.forEach(function(k) {
        k.charAt(0) === "-" ? attributes_1 += toXml(obj[k], k, depth + 1) : children_1 += toXml(obj[k], k, depth + 1);
      });
      str += attributes_1 + (children_1 !== "" ? ">".concat(children_1).concat(tn + frontSpace, "</").concat(name, ">") : " />");
    } else {
      str += tn + frontSpace + "<".concat(name, ">").concat(obj.toString(), "</").concat(name, ">");
    }
  }
  return str;
}
function lfJson2Xml(o) {
  var xmlStr = "";
  for (var m in o) {
    xmlStr += toXml(o[m], m, 0);
  }
  return xmlStr;
}

// node_modules/@logicflow/extension/es/bpmn-adapter/xml2json.js
var XML = function() {
};
XML.ObjTree = function() {
  return this;
};
XML.ObjTree.VERSION = "0.23";
XML.ObjTree.prototype.xmlDecl = '<?xml version="1.0" encoding="UTF-8" ?>\n';
XML.ObjTree.prototype.attr_prefix = "-";
XML.ObjTree.prototype.parseXML = function(xml) {
  var root;
  if (window.DOMParser) {
    var xmldom = new DOMParser();
    var dom = xmldom.parseFromString(xml, "application/xml");
    if (!dom)
      return;
    root = dom.documentElement;
  } else if (window.ActiveXObject) {
    xmldom = new ActiveXObject("Microsoft.XMLDOM");
    xmldom.async = false;
    xmldom.loadXML(xml);
    root = xmldom.documentElement;
  }
  if (!root)
    return;
  return this.parseDOM(root);
};
XML.ObjTree.prototype.parseHTTP = function(url, options, callback) {
  var myOpt = {};
  for (var key in options) {
    myOpt[key] = options[key];
  }
  if (!myOpt.method) {
    if (typeof myOpt.postBody == "undefined" && typeof myOpt.postbody == "undefined" && typeof myOpt.parameters == "undefined") {
      myOpt.method = "get";
    } else {
      myOpt.method = "post";
    }
  }
  if (callback) {
    myOpt.asynchronous = true;
    var __this = this;
    var __func = callback;
    var __save = myOpt.onComplete;
    myOpt.onComplete = function(trans2) {
      var tree;
      if (trans2 && trans2.responseXML && trans2.responseXML.documentElement) {
        tree = __this.parseDOM(trans2.responseXML.documentElement);
      }
      __func(tree, trans2);
      if (__save)
        __save(trans2);
    };
  } else {
    myOpt.asynchronous = false;
  }
  var trans;
  if (typeof HTTP != "undefined" && HTTP.Request) {
    myOpt.uri = url;
    var req = new HTTP.Request(myOpt);
    if (req)
      trans = req.transport;
  } else if (typeof Ajax != "undefined" && Ajax.Request) {
    var req = new Ajax.Request(url, myOpt);
    if (req)
      trans = req.transport;
  }
  if (callback)
    return trans;
  if (trans && trans.responseXML && trans.responseXML.documentElement) {
    return this.parseDOM(trans.responseXML.documentElement);
  }
};
XML.ObjTree.prototype.parseDOM = function(root) {
  if (!root)
    return;
  this.__force_array = {};
  if (this.force_array) {
    for (var i = 0; i < this.force_array.length; i++) {
      this.__force_array[this.force_array[i]] = 1;
    }
  }
  var json = this.parseElement(root);
  if (this.__force_array[root.nodeName]) {
    json = [json];
  }
  if (root.nodeType != 11) {
    var tmp = {};
    tmp[root.nodeName] = json;
    json = tmp;
  }
  return json;
};
XML.ObjTree.prototype.parseElement = function(elem) {
  if (elem.nodeType == 7) {
    return;
  }
  if (elem.nodeType == 3 || elem.nodeType == 4 || elem.nodeType == 8) {
    var bool = elem.nodeValue.match(/[^\x00-\x20]/);
    if (bool == null)
      return;
    return elem.nodeValue;
  }
  var retVal = null;
  var cnt = {};
  if (elem.attributes && elem.attributes.length) {
    retVal = {};
    for (var i = 0; i < elem.attributes.length; i++) {
      var key = elem.attributes[i].nodeName;
      if (typeof key != "string")
        continue;
      var val = elem.attributes[i].nodeValue;
      try {
        val = JSON.parse(elem.attributes[i].nodeValue.replace(/'/g, '"'));
      } catch (error) {
        val = elem.attributes[i].nodeValue;
      }
      if (!val)
        continue;
      key = this.attr_prefix + key;
      if (typeof cnt[key] == "undefined")
        cnt[key] = 0;
      cnt[key]++;
      this.addNode(retVal, key, cnt[key], val);
    }
  }
  if (elem.childNodes && elem.childNodes.length) {
    var textOnly = true;
    if (retVal)
      textOnly = false;
    for (var i = 0; i < elem.childNodes.length && textOnly; i++) {
      var nType = elem.childNodes[i].nodeType;
      if (nType == 3 || nType == 4 || nType == 8)
        continue;
      textOnly = false;
    }
    if (textOnly) {
      if (!retVal)
        retVal = "";
      for (var i = 0; i < elem.childNodes.length; i++) {
        retVal += elem.childNodes[i].nodeValue;
      }
    } else {
      if (!retVal)
        retVal = {};
      for (var i = 0; i < elem.childNodes.length; i++) {
        var key = elem.childNodes[i].nodeName;
        if (typeof key != "string")
          continue;
        var val = this.parseElement(elem.childNodes[i]);
        if (!val)
          continue;
        if (typeof cnt[key] == "undefined")
          cnt[key] = 0;
        cnt[key]++;
        this.addNode(retVal, key, cnt[key], val);
      }
    }
  } else {
    retVal === null && (retVal = {});
  }
  return retVal;
};
XML.ObjTree.prototype.addNode = function(hash, key, counts, val) {
  if (this.__force_array[key]) {
    if (counts == 1)
      hash[key] = [];
    hash[key][hash[key].length] = val;
  } else if (counts == 1) {
    hash[key] = val;
  } else if (counts == 2) {
    hash[key] = [hash[key], val];
  } else {
    hash[key][hash[key].length] = val;
  }
};
XML.ObjTree.prototype.writeXML = function(tree) {
  var xml = this.hash_to_xml(null, tree);
  return this.xmlDecl + xml;
};
XML.ObjTree.prototype.hash_to_xml = function(name, tree) {
  var elem = [];
  var attr = [];
  for (var key in tree) {
    if (!tree.hasOwnProperty(key))
      continue;
    var val = tree[key];
    if (key.charAt(0) != this.attr_prefix) {
      if (typeof val == "undefined" || val == null) {
        elem[elem.length] = "<" + key + " />";
      } else if (typeof val == "object" && val.constructor == Array) {
        elem[elem.length] = this.array_to_xml(key, val);
      } else if (typeof val == "object") {
        elem[elem.length] = this.hash_to_xml(key, val);
      } else {
        elem[elem.length] = this.scalar_to_xml(key, val);
      }
    } else {
      attr[attr.length] = " " + key.substring(1) + '="' + this.xml_escape(val) + '"';
    }
  }
  var jattr = attr.join("");
  var jelem = elem.join("");
  if (typeof name == "undefined" || name == null) {
  } else if (elem.length > 0) {
    if (jelem.match(/\n/)) {
      jelem = "<" + name + jattr + ">\n" + jelem + "</" + name + ">\n";
    } else {
      jelem = "<" + name + jattr + ">" + jelem + "</" + name + ">\n";
    }
  } else {
    jelem = "<" + name + jattr + " />\n";
  }
  return jelem;
};
XML.ObjTree.prototype.array_to_xml = function(name, array) {
  var out = [];
  for (var i = 0; i < array.length; i++) {
    var val = array[i];
    if (typeof val == "undefined" || val == null) {
      out[out.length] = "<" + name + " />";
    } else if (typeof val == "object" && val.constructor == Array) {
      out[out.length] = this.array_to_xml(name, val);
    } else if (typeof val == "object") {
      out[out.length] = this.hash_to_xml(name, val);
    } else {
      out[out.length] = this.scalar_to_xml(name, val);
    }
  }
  return out.join("");
};
XML.ObjTree.prototype.scalar_to_xml = function(name, text) {
  if (name == "#text") {
    return this.xml_escape(text);
  } else {
    return "<" + name + ">" + this.xml_escape(text) + "</" + name + ">\n";
  }
};
XML.ObjTree.prototype.xml_escape = function(text) {
  return text.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">").replace(/"/g, '"');
};
var lfXml2Json = function(xmlData) {
  return new XML.ObjTree().parseXML(xmlData);
};

// node_modules/@logicflow/extension/es/bpmn-adapter/index.js
var __extends7 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign5 = function() {
  __assign5 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign5.apply(this, arguments);
};
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var BpmnElements;
(function(BpmnElements3) {
  BpmnElements3["START"] = "bpmn:startEvent";
  BpmnElements3["END"] = "bpmn:endEvent";
  BpmnElements3["GATEWAY"] = "bpmn:exclusiveGateway";
  BpmnElements3["USER"] = "bpmn:userTask";
  BpmnElements3["SYSTEM"] = "bpmn:serviceTask";
  BpmnElements3["FLOW"] = "bpmn:sequenceFlow";
})(BpmnElements || (BpmnElements = {}));
var defaultAttrs = [
  "-name",
  "-id",
  "bpmn:incoming",
  "bpmn:outgoing",
  "-sourceRef",
  "-targetRef"
];
var defaultRetainedFields = [
  "properties",
  "startPoint",
  "endPoint",
  "pointsList"
];
function toXmlJson(retainedFields) {
  var fields = retainedFields ? defaultRetainedFields.concat(retainedFields) : defaultRetainedFields;
  return function(json) {
    function ToXmlJson(obj) {
      var xmlJson = {};
      if (typeof obj === "string") {
        return obj;
      }
      if (Array.isArray(obj)) {
        return obj.map(function(j) {
          return ToXmlJson(j);
        });
      }
      Object.entries(obj).forEach(function(_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        if (typeof value !== "object") {
          if (key.indexOf("-") === 0 || ["#text", "#cdata-section", "#comment"].includes(key)) {
            xmlJson[key] = value;
          } else {
            xmlJson["-".concat(key)] = value;
          }
        } else if (fields.includes(key)) {
          xmlJson["-".concat(key)] = ToXmlJson(value);
        } else {
          xmlJson[key] = ToXmlJson(value);
        }
      });
      return xmlJson;
    }
    return ToXmlJson(json);
  };
}
function toNormalJson(xmlJson) {
  var json = {};
  Object.entries(xmlJson).forEach(function(_a) {
    var _b = __read(_a, 2), key = _b[0], value = _b[1];
    if (key.indexOf("-") === 0) {
      json[key.substring(1)] = handleAttributes(value);
    } else if (typeof value === "string") {
      json[key] = value;
    } else if (Object.prototype.toString.call(value) === "[object Object]") {
      json[key] = toNormalJson(value);
    } else if (Array.isArray(value)) {
      json[key] = value.map(function(v) {
        return toNormalJson(v);
      });
    } else {
      json[key] = value;
    }
  });
  return json;
}
function convertLf2ProcessData(bpmnProcessData, data, retainedFields) {
  var nodeMap = /* @__PURE__ */ new Map();
  data.nodes.forEach(function(node2) {
    var _a;
    var processNode = {
      "-id": node2.id
      // 如果是xml的属性，json中属性用'-'开头
    };
    if ((_a = node2.text) === null || _a === void 0 ? void 0 : _a.value) {
      processNode["-name"] = node2.text.value;
    }
    if (node2.properties) {
      var properties = toXmlJson(retainedFields)(node2.properties);
      Object.assign(processNode, properties);
    }
    nodeMap.set(node2.id, processNode);
    if (!bpmnProcessData[node2.type]) {
      bpmnProcessData[node2.type] = processNode;
    } else if (Array.isArray(bpmnProcessData[node2.type])) {
      bpmnProcessData[node2.type].push(processNode);
    } else {
      bpmnProcessData[node2.type] = [bpmnProcessData[node2.type], processNode];
    }
  });
  var sequenceFlow = data.edges.map(function(edge) {
    var _a, _b;
    var targetNode = nodeMap.get(edge.targetNodeId);
    if (!targetNode["bpmn:incoming"]) {
      targetNode["bpmn:incoming"] = edge.id;
    } else if (Array.isArray(targetNode["bpmn:incoming"])) {
      targetNode["bpmn:incoming"].push(edge.id);
    } else {
      targetNode["bpmn:incoming"] = [targetNode["bpmn:incoming"], edge.id];
    }
    var edgeConfig = {
      "-id": edge.id,
      "-sourceRef": edge.sourceNodeId,
      "-targetRef": edge.targetNodeId
    };
    if ((_a = edge.text) === null || _a === void 0 ? void 0 : _a.value) {
      edgeConfig["-name"] = (_b = edge.text) === null || _b === void 0 ? void 0 : _b.value;
    }
    if (edge.properties) {
      var properties = toXmlJson(retainedFields)(edge.properties);
      Object.assign(edgeConfig, properties);
    }
    return edgeConfig;
  });
  data.edges.forEach(function(edge) {
    var sourceNode = nodeMap.get(edge.sourceNodeId);
    if (!sourceNode["bpmn:outgoing"]) {
      sourceNode["bpmn:outgoing"] = edge.id;
    } else if (Array.isArray(sourceNode["bpmn:outgoing"])) {
      sourceNode["bpmn:outgoing"].push(edge.id);
    } else {
      sourceNode["bpmn:outgoing"] = [sourceNode["bpmn:outgoing"], edge.id];
    }
  });
  bpmnProcessData[BpmnElements.FLOW] = sequenceFlow;
}
function convertLf2DiagramData(bpmnDiagramData, data) {
  bpmnDiagramData["bpmndi:BPMNEdge"] = data.edges.map(function(edge) {
    var _a;
    var edgeId = edge.id;
    var pointsList = edge.pointsList.map(function(_a2) {
      var x2 = _a2.x, y = _a2.y;
      return {
        "-x": x2,
        "-y": y
      };
    });
    var diagramData = {
      "-id": "".concat(edgeId, "_di"),
      "-bpmnElement": edgeId,
      "di:waypoint": pointsList
    };
    if ((_a = edge.text) === null || _a === void 0 ? void 0 : _a.value) {
      diagramData["bpmndi:BPMNLabel"] = {
        "dc:Bounds": {
          "-x": edge.text.x - edge.text.value.length * 10 / 2,
          "-y": edge.text.y - 7,
          "-width": edge.text.value.length * 10,
          "-height": 14
        }
      };
    }
    return diagramData;
  });
  bpmnDiagramData["bpmndi:BPMNShape"] = data.nodes.map(function(node2) {
    var _a;
    var nodeId = node2.id;
    var width = 100;
    var height = 80;
    var x2 = node2.x, y = node2.y;
    var shapeConfig = BpmnAdapter.shapeConfigMap.get(node2.type);
    if (shapeConfig) {
      width = shapeConfig.width;
      height = shapeConfig.height;
    }
    x2 -= width / 2;
    y -= height / 2;
    var diagramData = {
      "-id": "".concat(nodeId, "_di"),
      "-bpmnElement": nodeId,
      "dc:Bounds": {
        "-x": x2,
        "-y": y,
        "-width": width,
        "-height": height
      }
    };
    if ((_a = node2.text) === null || _a === void 0 ? void 0 : _a.value) {
      diagramData["bpmndi:BPMNLabel"] = {
        "dc:Bounds": {
          "-x": node2.text.x - node2.text.value.length * 10 / 2,
          "-y": node2.text.y - 7,
          "-width": node2.text.value.length * 10,
          "-height": 14
        }
      };
    }
    return diagramData;
  });
}
function convertBpmn2LfData(bpmnData) {
  var nodes = [];
  var edges = [];
  var definitions = bpmnData["bpmn:definitions"];
  if (definitions) {
    var process_1 = definitions["bpmn:process"];
    Object.keys(process_1).forEach(function(key) {
      if (key.indexOf("bpmn:") === 0) {
        var value = process_1[key];
        if (key === BpmnElements.FLOW) {
          var bpmnEdges = definitions["bpmndi:BPMNDiagram"]["bpmndi:BPMNPlane"]["bpmndi:BPMNEdge"];
          edges = getLfEdges(value, bpmnEdges);
        } else {
          var shapes = definitions["bpmndi:BPMNDiagram"]["bpmndi:BPMNPlane"]["bpmndi:BPMNShape"];
          nodes = nodes.concat(getLfNodes(value, shapes, key));
        }
      }
    });
  }
  return {
    nodes,
    edges
  };
}
function getLfNodes(value, shapes, key) {
  var nodes = [];
  if (Array.isArray(value)) {
    value.forEach(function(val) {
      var shapeValue2;
      if (Array.isArray(shapes)) {
        shapeValue2 = shapes.find(function(shape) {
          return shape["-bpmnElement"] === val["-id"];
        });
      } else {
        shapeValue2 = shapes;
      }
      var node3 = getNodeConfig(shapeValue2, key, val);
      nodes.push(node3);
    });
  } else {
    var shapeValue = void 0;
    if (Array.isArray(shapes)) {
      shapeValue = shapes.find(function(shape) {
        return shape["-bpmnElement"] === value["-id"];
      });
    } else {
      shapeValue = shapes;
    }
    var node2 = getNodeConfig(shapeValue, key, value);
    nodes.push(node2);
  }
  return nodes;
}
function getNodeConfig(shapeValue, type3, processValue) {
  var x2 = Number(shapeValue["dc:Bounds"]["-x"]);
  var y = Number(shapeValue["dc:Bounds"]["-y"]);
  var name = processValue["-name"];
  var shapeConfig = BpmnAdapter.shapeConfigMap.get(type3);
  if (shapeConfig) {
    x2 += shapeConfig.width / 2;
    y += shapeConfig.height / 2;
  }
  var properties;
  Object.entries(processValue).forEach(function(_a) {
    var _b = __read(_a, 2), key = _b[0], value = _b[1];
    if (defaultAttrs.indexOf(key) === -1) {
      if (!properties)
        properties = {};
      properties[key] = value;
    }
  });
  if (properties) {
    properties = toNormalJson(properties);
  }
  var text;
  if (name) {
    text = {
      x: x2,
      y,
      value: name
    };
    if (shapeValue["bpmndi:BPMNLabel"] && shapeValue["bpmndi:BPMNLabel"]["dc:Bounds"]) {
      var textBounds = shapeValue["bpmndi:BPMNLabel"]["dc:Bounds"];
      text.x = Number(textBounds["-x"]) + Number(textBounds["-width"]) / 2;
      text.y = Number(textBounds["-y"]) + Number(textBounds["-height"]) / 2;
    }
  }
  var nodeConfig = {
    id: shapeValue["-bpmnElement"],
    type: type3,
    x: x2,
    y,
    properties
  };
  if (text) {
    nodeConfig.text = text;
  }
  return nodeConfig;
}
function getLfEdges(value, bpmnEdges) {
  var edges = [];
  if (Array.isArray(value)) {
    value.forEach(function(val) {
      var edgeValue2;
      if (Array.isArray(bpmnEdges)) {
        edgeValue2 = bpmnEdges.find(function(edge) {
          return edge["-bpmnElement"] === val["-id"];
        });
      } else {
        edgeValue2 = bpmnEdges;
      }
      edges.push(getEdgeConfig(edgeValue2, val));
    });
  } else {
    var edgeValue = void 0;
    if (Array.isArray(bpmnEdges)) {
      edgeValue = bpmnEdges.find(function(edge) {
        return edge["-bpmnElement"] === value["-id"];
      });
    } else {
      edgeValue = bpmnEdges;
    }
    edges.push(getEdgeConfig(edgeValue, value));
  }
  return edges;
}
function getEdgeConfig(edgeValue, processValue) {
  var text;
  var textVal = processValue["-name"] ? "".concat(processValue["-name"]) : "";
  if (textVal) {
    var textBounds = edgeValue["bpmndi:BPMNLabel"]["dc:Bounds"];
    var textLength_1 = 0;
    textVal.split("\n").forEach(function(textSpan) {
      if (textLength_1 < textSpan.length) {
        textLength_1 = textSpan.length;
      }
    });
    text = {
      value: textVal,
      x: Number(textBounds["-x"]) + textLength_1 * 10 / 2,
      y: Number(textBounds["-y"]) + 7
    };
  }
  var properties;
  Object.entries(processValue).forEach(function(_a) {
    var _b = __read(_a, 2), key = _b[0], value = _b[1];
    if (defaultAttrs.indexOf(key) === -1) {
      if (!properties)
        properties = {};
      properties[key] = value;
    }
  });
  if (properties) {
    properties = toNormalJson(properties);
  }
  var edge = {
    id: processValue["-id"],
    type: BpmnElements.FLOW,
    pointsList: edgeValue["di:waypoint"].map(function(point) {
      return {
        x: Number(point["-x"]),
        y: Number(point["-y"])
      };
    }),
    sourceNodeId: processValue["-sourceRef"],
    targetNodeId: processValue["-targetRef"],
    properties
  };
  if (text) {
    edge.text = text;
  }
  return edge;
}
var BpmnAdapter = (
  /** @class */
  function() {
    function BpmnAdapter2(_a) {
      var lf = _a.lf;
      var _this = this;
      this.adapterOut = function(data, retainedFields) {
        var bpmnProcessData = __assign5({}, _this.processAttributes);
        convertLf2ProcessData(bpmnProcessData, data, retainedFields);
        var bpmnDiagramData = {
          "-id": "BPMNPlane_1",
          "-bpmnElement": bpmnProcessData["-id"]
        };
        convertLf2DiagramData(bpmnDiagramData, data);
        var definitions = _this.definitionAttributes;
        definitions["bpmn:process"] = bpmnProcessData;
        definitions["bpmndi:BPMNDiagram"] = {
          "-id": "BPMNDiagram_1",
          "bpmndi:BPMNPlane": bpmnDiagramData
        };
        var bpmnData = {
          "bpmn:definitions": definitions
        };
        return bpmnData;
      };
      this.adapterIn = function(bpmnData) {
        if (bpmnData) {
          return convertBpmn2LfData(bpmnData);
        }
      };
      lf.adapterIn = function(data) {
        return _this.adapterIn(data);
      };
      lf.adapterOut = function(data, retainedFields) {
        return _this.adapterOut(data, retainedFields);
      };
      this.processAttributes = {
        "-isExecutable": "true",
        "-id": "Process_".concat(getBpmnId2())
      };
      this.definitionAttributes = {
        "-id": "Definitions_".concat(getBpmnId2()),
        "-xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
        "-xmlns:bpmn": "http://www.omg.org/spec/BPMN/20100524/MODEL",
        "-xmlns:bpmndi": "http://www.omg.org/spec/BPMN/20100524/DI",
        "-xmlns:dc": "http://www.omg.org/spec/DD/20100524/DC",
        "-xmlns:di": "http://www.omg.org/spec/DD/20100524/DI",
        "-targetNamespace": "http://logic-flow.org",
        "-exporter": "logicflow",
        "-exporterVersion": "1.2.0"
      };
    }
    BpmnAdapter2.prototype.setCustomShape = function(key, val) {
      BpmnAdapter2.shapeConfigMap.set(key, val);
    };
    BpmnAdapter2.pluginName = "bpmn-adapter";
    BpmnAdapter2.shapeConfigMap = /* @__PURE__ */ new Map();
    return BpmnAdapter2;
  }()
);
BpmnAdapter.shapeConfigMap.set(BpmnElements.START, {
  width: StartEventConfig.width,
  height: StartEventConfig.height
});
BpmnAdapter.shapeConfigMap.set(BpmnElements.END, {
  width: EndEventConfig.width,
  height: EndEventConfig.height
});
BpmnAdapter.shapeConfigMap.set(BpmnElements.GATEWAY, {
  width: ExclusiveGatewayConfig.width,
  height: ExclusiveGatewayConfig.height
});
BpmnAdapter.shapeConfigMap.set(BpmnElements.SYSTEM, {
  width: ServiceTaskConfig.width,
  height: ServiceTaskConfig.height
});
BpmnAdapter.shapeConfigMap.set(BpmnElements.USER, {
  width: UserTaskConfig.width,
  height: UserTaskConfig.height
});
var BpmnXmlAdapter = (
  /** @class */
  function(_super) {
    __extends7(BpmnXmlAdapter2, _super);
    function BpmnXmlAdapter2(data) {
      var _this = _super.call(this, data) || this;
      _this.adapterXmlIn = function(bpmnData) {
        var json = lfXml2Json(bpmnData);
        return _this.adapterIn(json);
      };
      _this.adapterXmlOut = function(data2, retainedFields) {
        var outData = _this.adapterOut(data2, retainedFields);
        return lfJson2Xml(outData);
      };
      var lf = data.lf;
      lf.adapterIn = _this.adapterXmlIn;
      lf.adapterOut = _this.adapterXmlOut;
      return _this;
    }
    BpmnXmlAdapter2.pluginName = "bpmnXmlAdapter";
    return BpmnXmlAdapter2;
  }(BpmnAdapter)
);

// node_modules/@logicflow/extension/es/bpmn-elements/utils.js
var utils_exports = {};
__export(utils_exports, {
  genBpmnId: () => genBpmnId,
  groupRule: () => groupRule
});
function groupRule() {
  var rule = {
    message: "分组外的节点不允许连接分组内的",
    validate: function(_sourceNode, _targetNode) {
      var isSourceNodeInsideTheGroup = !!_sourceNode.properties.parent;
      var isTargetNodeInsideTheGroup = !!_targetNode.properties.parent;
      return !(!isSourceNodeInsideTheGroup && isTargetNodeInsideTheGroup);
    }
  };
  this.targetRules.push(rule);
}
var IDs2 = (
  /** @class */
  function() {
    function IDs3() {
      globalThis._ids = this;
      this._ids = /* @__PURE__ */ new Set();
    }
    IDs3.prototype.generateId = function() {
      var id = "xxxxxxx".replace(/[x]/g, function(c) {
        var r = Math.random() * 16 | 0;
        var v = c === "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
      return id;
    };
    IDs3.prototype.next = function() {
      var id = this.generateId();
      while (this._ids.has(id)) {
        id = this.generateId();
      }
      this._ids.add(id);
      return id;
    };
    return IDs3;
  }()
);
var ids3 = (globalThis === null || globalThis === void 0 ? void 0 : globalThis._ids) || new IDs2();
function genBpmnId() {
  return ids3.next();
}

// node_modules/@logicflow/extension/es/bpmn-elements/presets/Event/EndEventFactory.js
var __extends8 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign6 = function() {
  __assign6 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign6.apply(this, arguments);
};
var __read2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function EndEventFactory(lf) {
  var _a = __read2(lf.useDefinition(), 1), definition = _a[0];
  var view = (
    /** @class */
    function(_super) {
      __extends8(view2, _super);
      function view2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      view2.prototype.getAnchorStyle = function() {
        return {
          visibility: "hidden"
        };
      };
      view2.prototype.getShape = function() {
        var _a2;
        var model2 = this.props.model;
        var style2 = model2.getNodeStyle();
        var _b = model2, x2 = _b.x, y = _b.y, r = _b.r, width = _b.width, height = _b.height, properties = _b.properties;
        var outCircle = _super.prototype.getShape.call(this);
        var definitionType = properties.definitionType;
        var icon = (((_a2 = definition.endEvent) === null || _a2 === void 0 ? void 0 : _a2.get(definitionType)) || {}).icon;
        var i = Array.isArray(icon) ? g.apply(void 0, __spreadArray([
          "g",
          {
            transform: "matrix(1 0 0 1 ".concat(x2 - width / 2, " ").concat(y - height / 2, ")")
          }
        ], __read2(icon), false)) : g("path", {
          transform: "matrix(1 0 0 1 ".concat(x2 - width / 2, " ").concat(y - height / 2, ")"),
          d: icon,
          style: "fill: black; stroke-linecap: round; stroke-linejoin: round; stroke: white; stroke-width: 1px;"
        });
        return g("g", {}, outCircle, g("circle", __assign6(__assign6({}, style2), { strokeWidth: 2, cx: x2, cy: y, r: r - 2 })), i);
      };
      return view2;
    }(CircleNode)
  );
  var model = (
    /** @class */
    function(_super) {
      __extends8(model2, _super);
      function model2(data, graphModel) {
        var _this = this;
        var _a2, _b, _c;
        if (!data.id) {
          data.id = "Event_".concat(genBpmnId());
        }
        if (!data.text) {
          data.text = "";
        }
        if (data.text && typeof data.text === "string") {
          data.text = {
            value: data.text,
            x: data.x,
            y: data.y + 40
          };
        }
        var _d = (((_a2 = definition.endEvent) === null || _a2 === void 0 ? void 0 : _a2.get((_b = data.properties) === null || _b === void 0 ? void 0 : _b.definitionType)) || {}).properties, properties = _d === void 0 ? {} : _d;
        data.properties = __assign6(__assign6({}, properties), data.properties);
        ((_c = data.properties) === null || _c === void 0 ? void 0 : _c.definitionType) && (data.properties.definitionId = "Definition_".concat(genBpmnId()));
        _this = _super.call(this, data, graphModel) || this;
        groupRule.call(_this);
        return _this;
      }
      model2.prototype.setAttributes = function() {
        this.r = 18;
      };
      model2.prototype.getConnectedSourceRules = function() {
        var _this = this;
        var rules = _super.prototype.getConnectedSourceRules.call(this);
        var notAsSource = {
          message: "结束节点不能作为边的起点",
          validate: function(source, _target) {
            console.log("_target", _target);
            return source !== _this;
          }
        };
        rules.push(notAsSource);
        return rules;
      };
      return model2;
    }(CircleNodeModel)
  );
  return {
    type: "bpmn:endEvent",
    view,
    model
  };
}

// node_modules/@logicflow/extension/es/bpmn-elements/presets/Event/IntermediateCatchEvent.js
var __extends9 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign7 = function() {
  __assign7 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign7.apply(this, arguments);
};
var __read3 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function IntermediateCatchEventFactory(lf) {
  var _a = __read3(lf.useDefinition(), 1), definition = _a[0];
  var view = (
    /** @class */
    function(_super) {
      __extends9(view2, _super);
      function view2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      view2.prototype.getAnchorStyle = function() {
        return {
          visibility: "hidden"
        };
      };
      view2.prototype.getShape = function() {
        var _a2;
        var model2 = this.props.model;
        var style2 = model2.getNodeStyle();
        var _b = model2, x2 = _b.x, y = _b.y, r = _b.r, width = _b.width, height = _b.height, properties = _b.properties;
        var definitionType = properties.definitionType;
        var icon = (((_a2 = definition.intermediateCatchEvent) === null || _a2 === void 0 ? void 0 : _a2.get(definitionType)) || {}).icon;
        var i = Array.isArray(icon) ? g.apply(void 0, __spreadArray2([
          "g",
          {
            transform: "matrix(1 0 0 1 ".concat(x2 - width / 2, " ").concat(y - height / 2, ")")
          }
        ], __read3(icon), false)) : g("path", {
          transform: "matrix(1 0 0 1 ".concat(x2 - width / 2, " ").concat(y - height / 2, ")"),
          d: icon
        });
        return g("g", {}, g("circle", __assign7(__assign7({}, style2), { cx: x2, cy: y, r, strokeWidth: 1.5 })), g("circle", __assign7(__assign7({}, style2), { cx: x2, cy: y, r: r - 3, strokeWidth: 1.5 })), i);
      };
      return view2;
    }(CircleNode)
  );
  var model = (
    /** @class */
    function(_super) {
      __extends9(model2, _super);
      function model2(data, graphModel) {
        var _this = this;
        var _a2, _b, _c;
        if (!data.id) {
          data.id = "Event_".concat(genBpmnId());
        }
        if (!data.text) {
          data.text = "";
        }
        if (data.text && typeof data.text === "string") {
          data.text = {
            value: data.text,
            x: data.x,
            y: data.y + 40
          };
        }
        var _d = (((_a2 = definition.intermediateCatchEvent) === null || _a2 === void 0 ? void 0 : _a2.get((_b = data.properties) === null || _b === void 0 ? void 0 : _b.definitionType)) || {}).properties, properties = _d === void 0 ? {} : _d;
        data.properties = __assign7(__assign7({}, properties), data.properties);
        ((_c = data.properties) === null || _c === void 0 ? void 0 : _c.definitionType) && (data.properties.definitionId = "Definition_".concat(genBpmnId()));
        _this = _super.call(this, data, graphModel) || this;
        groupRule.call(_this);
        return _this;
      }
      model2.prototype.setAttributes = function() {
        this.r = 18;
      };
      return model2;
    }(CircleNodeModel)
  );
  return {
    type: "bpmn:intermediateCatchEvent",
    view,
    model
  };
}

// node_modules/@logicflow/extension/es/bpmn-elements/presets/Event/StartEventFactory.js
var __extends10 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign8 = function() {
  __assign8 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign8.apply(this, arguments);
};
var __read4 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray3 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function StartEventFactory(lf) {
  var _a = __read4(lf.useDefinition(), 1), definition = _a[0];
  var view = (
    /** @class */
    function(_super) {
      __extends10(view2, _super);
      function view2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      view2.prototype.getAnchorStyle = function() {
        return {
          visibility: "hidden"
        };
      };
      view2.prototype.getShape = function() {
        var _a2;
        var model2 = this.props.model;
        var style2 = model2.getNodeStyle();
        var _b = model2, x2 = _b.x, y = _b.y, r = _b.r, width = _b.width, height = _b.height, properties = _b.properties;
        var definitionType = properties.definitionType, isInterrupting = properties.isInterrupting;
        var icon = (((_a2 = definition.startEvent) === null || _a2 === void 0 ? void 0 : _a2.get(definitionType)) || {}).icon;
        var i = Array.isArray(icon) ? g.apply(void 0, __spreadArray3([
          "g",
          {
            transform: "matrix(1 0 0 1 ".concat(x2 - width / 2, " ").concat(y - height / 2, ")")
          }
        ], __read4(icon), false)) : g("path", {
          transform: "matrix(1 0 0 1 ".concat(x2 - width / 2, " ").concat(y - height / 2, ")"),
          d: icon,
          style: "fill: white; stroke-linecap: round; stroke-linejoin: round; stroke: rgb(34, 36, 42); stroke-width: 1px;"
        });
        return g("g", {}, g("circle", __assign8(__assign8({}, style2), { cx: x2, cy: y, r, strokeDasharray: isInterrupting ? "5,5" : "", strokeWidth: 2 })), i);
      };
      return view2;
    }(CircleNode)
  );
  var model = (
    /** @class */
    function(_super) {
      __extends10(model2, _super);
      function model2(data, graphModel) {
        var _a2, _b, _c;
        if (!data.id) {
          data.id = "Event_".concat(genBpmnId());
        }
        if (!data.text) {
          data.text = "";
        }
        if (data.text && typeof data.text === "string") {
          data.text = {
            value: data.text,
            x: data.x,
            y: data.y + 40
          };
        }
        var _d = (((_a2 = definition.startEvent) === null || _a2 === void 0 ? void 0 : _a2.get((_b = data.properties) === null || _b === void 0 ? void 0 : _b.definitionType)) || {}).properties, properties = _d === void 0 ? {} : _d;
        data.properties = __assign8(__assign8({}, properties), data.properties);
        ((_c = data.properties) === null || _c === void 0 ? void 0 : _c.definitionType) && (data.properties.definitionId = "Definition_".concat(genBpmnId()));
        return _super.call(this, data, graphModel) || this;
      }
      model2.prototype.setAttributes = function() {
        this.r = 18;
      };
      model2.prototype.getConnectedTargetRules = function() {
        var _this = this;
        var rules = _super.prototype.getConnectedTargetRules.call(this);
        var notAsSource = {
          message: "起始节点不能作为边的终点",
          validate: function(_source, target) {
            if (target === _this) {
              return false;
            }
            return true;
          }
        };
        rules.push(notAsSource);
        return rules;
      };
      return model2;
    }(CircleNodeModel)
  );
  return {
    type: "bpmn:startEvent",
    view,
    model
  };
}

// node_modules/@logicflow/extension/es/bpmn-elements/presets/Event/boundaryEventFactory.js
var __extends11 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign9 = function() {
  __assign9 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign9.apply(this, arguments);
};
var __read5 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray4 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function BoundaryEventFactory(lf) {
  var _a = __read5(lf.useDefinition(), 1), definition = _a[0];
  var view = (
    /** @class */
    function(_super) {
      __extends11(view2, _super);
      function view2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      view2.prototype.getAnchorStyle = function() {
        return {
          visibility: "hidden"
        };
      };
      view2.prototype.getShape = function() {
        var _a2;
        var model2 = this.props.model;
        var style2 = model2.getNodeStyle();
        var _b = model2, x2 = _b.x, y = _b.y, r = _b.r, width = _b.width, height = _b.height, properties = _b.properties;
        var definitionType = properties.definitionType, cancelActivity = properties.cancelActivity;
        var icon = (((_a2 = definition.boundaryEvent) === null || _a2 === void 0 ? void 0 : _a2.get(definitionType)) || {}).icon;
        var i = Array.isArray(icon) ? g.apply(void 0, __spreadArray4([
          "g",
          {
            transform: "matrix(1 0 0 1 ".concat(x2 - width / 2, " ").concat(y - height / 2, ")")
          }
        ], __read5(icon), false)) : g("path", {
          transform: "matrix(1 0 0 1 ".concat(x2 - width / 2, " ").concat(y - height / 2, ")"),
          d: icon
        });
        return g("g", {}, g("circle", __assign9(__assign9({}, style2), { cx: x2, cy: y, r, strokeDasharray: cancelActivity ? "" : "5,5", strokeWidth: 1.5 })), g("circle", __assign9(__assign9({}, style2), { cx: x2, cy: y, r: r - 3, strokeDasharray: cancelActivity ? "" : "5,5", strokeWidth: 1.5 })), i);
      };
      return view2;
    }(CircleNode)
  );
  var model = (
    /** @class */
    function(_super) {
      __extends11(model2, _super);
      function model2(data, graphModel) {
        var _this = this;
        var _a2, _b, _c;
        if (!data.id) {
          data.id = "Event_".concat(genBpmnId());
        }
        if (!data.text) {
          data.text = "";
        }
        if (data.text && typeof data.text === "string") {
          data.text = {
            value: data.text,
            x: data.x,
            y: data.y + 40
          };
        }
        var _d = (((_a2 = definition.boundaryEvent) === null || _a2 === void 0 ? void 0 : _a2.get((_b = data.properties) === null || _b === void 0 ? void 0 : _b.definitionType)) || {}).properties, properties = _d === void 0 ? {} : _d;
        data.properties = __assign9(__assign9({ attachedToRef: "", cancelActivity: true }, properties), data.properties);
        ((_c = data.properties) === null || _c === void 0 ? void 0 : _c.definitionType) && (data.properties.definitionId = "Definition_".concat(genBpmnId()));
        _this = _super.call(this, data, graphModel) || this;
        groupRule.call(_this);
        return _this;
      }
      model2.prototype.initNodeData = function(data) {
        _super.prototype.initNodeData.call(this, data);
        this.r = 20;
        this.autoToFront = false;
        this.zIndex = 99999;
      };
      model2.prototype.setAttributes = function() {
        this.r = 18;
      };
      return model2;
    }(CircleNodeModel)
  );
  return {
    type: "bpmn:boundaryEvent",
    view,
    model
  };
}

// node_modules/@logicflow/extension/es/bpmn-elements/presets/Event/IntermediateThrowEvent.js
var __extends12 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign10 = function() {
  __assign10 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign10.apply(this, arguments);
};
var __read6 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray5 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function IntermediateThrowEventFactory(lf) {
  var _a = __read6(lf.useDefinition(), 1), definition = _a[0];
  var view = (
    /** @class */
    function(_super) {
      __extends12(view2, _super);
      function view2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      view2.prototype.getAnchorStyle = function() {
        return {
          visibility: "hidden"
        };
      };
      view2.prototype.getShape = function() {
        var _a2;
        var model2 = this.props.model;
        var style2 = model2.getNodeStyle();
        var _b = model2, x2 = _b.x, y = _b.y, r = _b.r, width = _b.width, height = _b.height, properties = _b.properties;
        var definitionType = properties.definitionType;
        var icon = (((_a2 = definition.intermediateThrowEvent) === null || _a2 === void 0 ? void 0 : _a2.get(definitionType)) || {}).icon;
        var i = Array.isArray(icon) ? g.apply(void 0, __spreadArray5([
          "g",
          {
            transform: "matrix(1 0 0 1 ".concat(x2 - width / 2, " ").concat(y - height / 2, ")")
          }
        ], __read6(icon), false)) : g("path", {
          transform: "matrix(1 0 0 1 ".concat(x2 - width / 2, " ").concat(y - height / 2, ")"),
          d: icon,
          style: "fill: black"
        });
        return g("g", {}, g("circle", __assign10(__assign10({}, style2), { cx: x2, cy: y, r, strokeWidth: 1.5 })), g("circle", __assign10(__assign10({}, style2), { cx: x2, cy: y, r: r - 3, strokeWidth: 1.5 })), i);
      };
      return view2;
    }(CircleNode)
  );
  var model = (
    /** @class */
    function(_super) {
      __extends12(model2, _super);
      function model2(data, graphModel) {
        var _this = this;
        var _a2, _b, _c;
        if (!data.id) {
          data.id = "Event_".concat(genBpmnId());
        }
        if (!data.text) {
          data.text = "";
        }
        if (data.text && typeof data.text === "string") {
          data.text = {
            value: data.text,
            x: data.x,
            y: data.y + 40
          };
        }
        var _d = (((_a2 = definition.intermediateThrowEvent) === null || _a2 === void 0 ? void 0 : _a2.get((_b = data.properties) === null || _b === void 0 ? void 0 : _b.definitionType)) || {}).properties, properties = _d === void 0 ? {} : _d;
        data.properties = __assign10(__assign10({}, properties), data.properties);
        ((_c = data.properties) === null || _c === void 0 ? void 0 : _c.definitionType) && (data.properties.definitionId = "Definition_".concat(genBpmnId()));
        _this = _super.call(this, data, graphModel) || this;
        groupRule.call(_this);
        return _this;
      }
      model2.prototype.setAttributes = function() {
        this.r = 18;
      };
      return model2;
    }(CircleNodeModel)
  );
  return {
    type: "bpmn:intermediateThrowEvent",
    view,
    model
  };
}

// node_modules/@logicflow/extension/es/bpmn-elements/presets/Event/index.js
function registerEventNodes(lf) {
  lf.register(StartEventFactory(lf));
  lf.register(EndEventFactory(lf));
  lf.register(IntermediateCatchEventFactory(lf));
  lf.register(IntermediateThrowEventFactory(lf));
  lf.register(BoundaryEventFactory(lf));
}

// node_modules/@logicflow/extension/es/bpmn-elements/presets/icons.js
var icons_exports = {};
__export(icons_exports, {
  compensationIcon: () => compensationIcon,
  conditionalIcon: () => conditionalIcon,
  errorIcon: () => errorIcon,
  escalationIcon: () => escalationIcon,
  exclusiveIcon: () => exclusiveIcon,
  inclusiveIcon: () => inclusiveIcon,
  linkIcon: () => linkIcon,
  loopMarker: () => loopMarker,
  manualTaskIcon: () => manualTaskIcon,
  messageIcon: () => messageIcon,
  parallelIcon: () => parallelIcon,
  parallelMarker: () => parallelMarker,
  scriptTaskIcon: () => scriptTaskIcon,
  sequentialMarker: () => sequentialMarker,
  serviceTaskIcon: () => serviceTaskIcon,
  signalIcon: () => signalIcon,
  style: () => style,
  terminateIcon: () => terminateIcon,
  timerIcon: () => timerIcon,
  userTaskIcon: () => userTaskIcon
});
var messageIcon = "m 8.459999999999999,11.34 l 0,12.6 l 18.900000000000002,0 l 0,-12.6 z l 9.450000000000001,5.4 l 9.450000000000001,-5.4";
var timerIcon = [
  g("circle", {
    cx: 18,
    cy: 18,
    r: 11,
    style: "stroke-linecap: round;stroke-linejoin: round;stroke: rgb(34, 36, 42);stroke-width: 2px;fill: white"
  }),
  g("path", {
    d: "M 18,18 l 2.25,-7.5 m -2.25,7.5 l 5.25,1.5",
    style: "fill: none; stroke-linecap: round; stroke-linejoin: round; stroke: rgb(34, 36, 42); stroke-width: 2px;"
  }),
  g("path", {
    d: "M 18,18 m 0,7.5 l -0,2.25",
    transform: "rotate(0,18,18)",
    style: "fill: none; stroke-linecap: round; stroke-linejoin: round; stroke: rgb(34, 36, 42); stroke-width: 1px;"
  }),
  g("path", {
    d: "M 18,18 m 0,7.5 l -0,2.25",
    transform: "rotate(30,18,18)",
    style: "fill: none; stroke-linecap: round; stroke-linejoin: round; stroke: rgb(34, 36, 42); stroke-width: 1px;"
  }),
  g("path", {
    d: "M 18,18 m 0,7.5 l -0,2.25",
    transform: "rotate(60,18,18)",
    style: "fill: none; stroke-linecap: round; stroke-linejoin: round; stroke: rgb(34, 36, 42); stroke-width: 1px;"
  }),
  g("path", {
    d: "M 18,18 m 0,7.5 l -0,2.25",
    transform: "rotate(90,18,18)",
    style: "fill: none; stroke-linecap: round; stroke-linejoin: round; stroke: rgb(34, 36, 42); stroke-width: 1px;"
  }),
  g("path", {
    d: "M 18,18 m 0,7.5 l -0,2.25",
    transform: "rotate(120,18,18)",
    style: "fill: none; stroke-linecap: round; stroke-linejoin: round; stroke: rgb(34, 36, 42); stroke-width: 1px;"
  }),
  g("path", {
    d: "M 18,18 m 0,7.5 l -0,2.25",
    transform: "rotate(150,18,18)",
    style: "fill: none; stroke-linecap: round; stroke-linejoin: round; stroke: rgb(34, 36, 42); stroke-width: 1px;"
  }),
  g("path", {
    d: "M 18,18 m 0,7.5 l -0,2.25",
    transform: "rotate(180,18,18)",
    style: "fill: none; stroke-linecap: round; stroke-linejoin: round; stroke: rgb(34, 36, 42); stroke-width: 1px;"
  }),
  g("path", {
    d: "M 18,18 m 0,7.5 l -0,2.25",
    transform: "rotate(210,18,18)",
    style: "fill: none; stroke-linecap: round; stroke-linejoin: round; stroke: rgb(34, 36, 42); stroke-width: 1px;"
  }),
  g("path", {
    d: "M 18,18 m 0,7.5 l -0,2.25",
    transform: "rotate(240,18,18)",
    style: "fill: none; stroke-linecap: round; stroke-linejoin: round; stroke: rgb(34, 36, 42); stroke-width: 1px;"
  }),
  g("path", {
    d: "M 18,18 m 0,7.5 l -0,2.25",
    transform: "rotate(270,18,18)",
    style: "fill: none; stroke-linecap: round; stroke-linejoin: round; stroke: rgb(34, 36, 42); stroke-width: 1px;"
  }),
  g("path", {
    d: "M 18,18 m 0,7.5 l -0,2.25",
    transform: "rotate(300,18,18)",
    style: "fill: none; stroke-linecap: round; stroke-linejoin: round; stroke: rgb(34, 36, 42); stroke-width: 1px;"
  }),
  g("path", {
    d: "M 18,18 m 0,7.5 l -0,2.25",
    transform: "rotate(330,18,18)",
    style: "fill: none; stroke-linecap: round; stroke-linejoin: round; stroke: rgb(34, 36, 42); stroke-width: 1px;"
  })
];
var errorIcon = "m 7.2,25.991999999999997 0.09350000000000001,-0.025300000000000003 7.3392,-9.610700000000001 7.667000000000001,8.9661 4.7003,-18.2204 -5.8707,11.6501 -7.299600000000001,-9.585400000000002 z";
var escalationIcon = "M 18,7.2 l 8,20 l -8,-7 l -8,7 Z";
var compensationIcon = "m 7.92,18 9,-6.5 0,13 z m 9.3,-0.4 8.7,-6.1 0,13 -8.7,-6.1 z";
var conditionalIcon = "M 10.5,8.5 l 14.5,0 l 0,18 l -14.5,0 Z M 12.5,11.5 l 10.5,0 M 12.5,14.5 l 10.5,0 M 12.5,17.5 l 10.5,0 M 12.5,20.5 l 10.5,0 M 12.5,23.5 l 10.5,0 M 12.5,26.5 l 10.5,0 ";
var linkIcon = "m 20.52,9.468 0,4.4375 -13.5,0 0,6.75 13.5,0 0,4.4375 9.84375,-7.8125 -9.84375,-7.8125 z";
var signalIcon = "M 18,7.2 l 9,16.2 l -18,0 Z";
var terminateIcon = [
  g("circle", {
    cx: 18,
    cy: 18,
    r: 10,
    style: "stroke-linecap: round; stroke-linejoin: round; stroke: rgb(34, 36, 42); stroke-width: 4px; fill: rgb(34, 36, 42);"
  })
];
var exclusiveIcon = "m 16,15 7.42857142857143,9.714285714285715 -7.42857142857143,9.714285714285715 3.428571428571429,0 5.714285714285715,-7.464228571428572 5.714285714285715,7.464228571428572 3.428571428571429,0 -7.42857142857143,-9.714285714285715 7.42857142857143,-9.714285714285715 -3.428571428571429,0 -5.714285714285715,7.464228571428572 -5.714285714285715,-7.464228571428572 -3.428571428571429,0 z";
var parallelIcon = "m 23,10 0,12.5 -12.5,0 0,5 12.5,0 0,12.5 5,0 0,-12.5 12.5,0 0,-5 -12.5,0 0,-12.5 -5,0 z";
var inclusiveIcon = g("circle", {
  cx: 25,
  cy: 25,
  r: 13,
  style: "stroke-linecap: round; stroke-linejoin: round; stroke: rgb(34, 36, 42); stroke-width: 2.5px; fill: white;"
});
var serviceTaskIcon = "M882.527918 434.149934c-2.234901-5.303796-7.311523-8.853645-13.059434-9.138124l-61.390185-3.009544c-6.635117-20.973684-15.521508-41.175795-26.513864-60.282968l42.051745-47.743374c4.308119-4.889357 4.955872-12.004405 1.602498-17.59268-46.384423-77.30362-103.969956-101.422947-106.400309-102.410438-5.332449-2.170432-11.432377-1.090844-15.693424 2.77009L654.674467 240.664222c-17.004279-8.654101-35.092239-15.756869-53.995775-21.210068l-3.26537-66.490344c-0.280386-5.747911-3.833305-10.824533-9.134031-13.059434-1.683339-0.709151-30.193673-12.391215-76.866668-12.051477-46.672996-0.339738-75.18333 11.342326-76.866668 12.051477-5.300726 2.234901-8.853645 7.311523-9.134031 13.059434l-3.26537 66.490344c-18.903535 5.453199-36.991496 12.555967-53.995775 21.210068l-48.450479-43.922349c-4.261047-3.860934-10.360975-4.940522-15.693424-2.77009-2.430352 0.98749-60.015885 25.106818-106.400309 102.410438-3.353374 5.588275-2.705622 12.703323 1.602498 17.59268l42.051745 47.743374c-10.992355 19.107173-19.878746 39.309284-26.513864 60.282968l-61.390185 3.009544c-5.747911 0.284479-10.824533 3.834328-13.059434 9.138124-1.01512 2.415003-24.687262 60.190871-2.822278 147.651828 1.583055 6.324032 7.072069 10.893094 13.57518 11.308557 5.892197 0.37146 11.751648 0.523933 17.419741 0.667196 14.498202 0.372483 28.193109 0.723477 40.908712 4.63353 4.212952 1.294482 6.435573 8.270361 9.349949 18.763342 1.287319 4.640694 2.617617 9.43693 4.484128 14.010085 1.794879 4.393054 3.75758 8.570189 5.66093 12.607132 1.302669 2.765997 2.529613 5.380544 3.689019 8.018627 2.986007 6.803963 2.682086 9.773598 2.578732 10.349719-3.061732 3.672646-6.391571 7.238868-9.91379 11.015891-1.810229 1.943258-3.680832 3.949962-5.523807 5.980201l-22.560832 24.8909c-3.865028 4.261047-4.940522 10.365068-2.774183 15.693424 0.991584 2.426259 25.102724 60.011792 102.414531 106.400309 5.588275 3.353374 12.703323 2.701528 17.591657-1.603521l23.476691-20.682042c2.346441-2.061962 4.64888-4.336772 6.875594-6.534833 9.05319-8.93858 14.018272-12.95608 17.73185-11.576663 3.305279 1.222851 6.907317 3.166109 10.720156 5.228071 3.325745 1.794879 6.764054 3.650133 10.465352 5.288446 6.016017 2.662643 12.120039 4.688789 18.019399 6.65149 6.827499 2.266623 13.279445 4.409426 18.819624 7.275707 1.518586 0.782829 1.926886 0.994654 2.358721 7.830339 0.726547 11.496845 1.25048 23.276123 1.753947 34.672684 0.264013 5.900384 0.528026 11.803837 0.815575 17.700127 0.284479 5.743818 3.833305 10.82044 9.138124 13.05534 1.654686 0.698918 29.371958 12.063757 74.869175 12.063757 0.328481 0 3.65832 0 3.986801 0 45.497217 0 73.214489-11.364839 74.869175-12.063757 5.304819-2.234901 8.853645-7.311523 9.138124-13.05534 0.287549-5.89629 0.551562-11.799744 0.815575-17.700127 0.503467-11.396561 1.027399-23.175839 1.753947-34.672684 0.431835-6.835685 0.840134-7.04751 2.358721-7.830339 5.54018-2.866281 11.992125-5.009084 18.819624-7.275707 5.89936-1.962701 12.003382-3.988848 18.019399-6.65149 3.701299-1.638313 7.139607-3.493567 10.465352-5.288446 3.812839-2.061962 7.414877-4.00522 10.720156-5.228071 3.713578-1.379417 8.67866 2.638083 17.73185 11.576663 2.226714 2.198062 4.529153 4.472871 6.875594 6.534833l23.476691 20.682042c4.888334 4.305049 12.003382 4.956895 17.591657 1.603521 77.311807-46.388517 101.422947-103.97405 102.414531-106.400309 2.166339-5.328355 1.090844-11.432377-2.774183-15.693424l-22.560832-24.8909c-1.842974-2.030239-3.713578-4.036943-5.523807-5.980201-3.52222-3.777023-6.852058-7.343245-9.91379-11.015891-0.103354-0.576121-0.407276-3.545756 2.578732-10.349719 1.159406-2.638083 2.38635-5.252631 3.689019-8.018627 1.90335-4.036943 3.866051-8.214079 5.66093-12.607132 1.866511-4.573155 3.196809-9.369392 4.484128-14.010085 2.914376-10.492982 5.136997-17.46886 9.349949-18.763342 12.715603-3.910053 26.41051-4.261047 40.908712-4.63353 5.668093-0.143263 11.527544-0.295735 17.419741-0.667196 6.503111-0.415462 11.992125-4.984524 13.57518-11.308557C907.21518 494.340805 883.543038 436.564937 882.527918 434.149934zM643.49894 643.761929c-35.280528 35.280528-82.191954 54.711066-132.086317 54.711066s-96.806813-19.430538-132.086317-54.711066c-35.280528-35.279504-54.711066-82.191954-54.711066-132.086317 0-49.894364 19.430538-96.80272 54.711066-132.082224 35.283598-35.284621 82.191954-54.711066 132.086317-54.711066s96.80579 19.426445 132.086317 54.711066c35.279504 35.279504 54.711066 82.187861 54.711066 132.082224C698.210006 561.569976 678.782537 608.482425 643.49894 643.761929z";
var userTaskIcon = "M655.807326 287.35973m-223.989415 0a218.879 218.879 0 1 0 447.978829 0 218.879 218.879 0 1 0-447.978829 0ZM1039.955839 895.482975c-0.490184-212.177424-172.287821-384.030443-384.148513-384.030443-211.862739 0-383.660376 171.85302-384.15056 384.030443L1039.955839 895.482975z";
var scriptTaskIcon = "M6.402,0.5H20.902C20.902,0.5,15.069,3.333,15.069,6.083S19.486,12.083,19.486,15.25S15.319,20.333,15.319,20.333H0.235C0.235,20.333,5.235,17.665999999999997,5.235,15.332999999999998S0.6520000000000001,8.582999999999998,0.6520000000000001,6.082999999999998S6.402,0.5,6.402,0.5ZM3.5,4.5L13.5,4.5M3.8,8.5L13.8,8.5M6.3,12.5L16.3,12.5M6.5,16.5L16.5,16.5";
var manualTaskIcon = "M0.5,3.751L4.583,0.5009999999999999C4.583,0.5009999999999999,15.749,0.5839999999999999,16.666,0.5839999999999999S14.249,3.5009999999999994,15.166,3.5009999999999994S26.833,3.5009999999999994,27.75,3.5009999999999994C28.916,5.209,27.582,6.667999999999999,26.916,7.167999999999999S27.791,9.084999999999999,25.916,11.584999999999999C25.166,11.834999999999999,26.666,13.459999999999999,24.583000000000002,14.918C23.416,15.501,25.166,16.46,23.333000000000002,17.750999999999998C22.166,17.750999999999998,2.5000000000000036,17.833999999999996,2.5000000000000036,17.833999999999996L0.5000000000000036,16.500999999999998V3.751ZM13.5,7L27,7M13.5,11L26,11M14,14.5L25,14.5M8.2,3.1L15,3.1";
var style = {
  throw: "fill: rgb(34, 36, 42); stroke-linecap: round; stroke-linejoin: round; stroke: white; stroke-width: 1px;",
  catch: "fill: white; stroke-linecap: round; stroke-linejoin: round; stroke: rgb(34, 36, 42); stroke-width: 1px;",
  nonIntermediate: "stroke-width: 1.5; stroke-dash-array: 6",
  intermediate: "stroke-width: 1.5"
};
var parallelMarker = "m44,60 m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10";
var sequentialMarker = "m47,61 m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0";
var loopMarker = "m 50,73 c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 -6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902";

// node_modules/@logicflow/extension/es/bpmn-elements/presets/Gateway/gateway.js
var __extends13 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign11 = function() {
  __assign11 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign11.apply(this, arguments);
};
var gateway = {
  exclusive: 0,
  inclusive: 1,
  parallel: 2
};
var gatewayComposable = [
  [1, 1, 0],
  [0, 0, 1],
  [0, 1, 1]
];
function GatewayNodeFactory(type3, icon, props) {
  var view = (
    /** @class */
    function(_super) {
      __extends13(view2, _super);
      function view2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      view2.prototype.getShape = function() {
        var model2 = this.props.model;
        var _a = model2, x2 = _a.x, y = _a.y, width = _a.width, height = _a.height, points = _a.points;
        var style2 = model2.getNodeStyle();
        return g("g", {
          transform: "matrix(1 0 0 1 ".concat(x2 - width / 2, " ").concat(y - height / 2, ")")
        }, g(Polygon, __assign11(__assign11({}, style2), { x: x2, y, points })), typeof icon === "string" ? g("path", __assign11(__assign11({ d: icon }, style2), { fill: "rgb(34, 36, 42)", strokeWidth: 1 })) : icon);
      };
      return view2;
    }(PolygonNode)
  );
  var model = (
    /** @class */
    function(_super) {
      __extends13(model2, _super);
      function model2(data, graphModel) {
        var _this = this;
        if (!data.id) {
          data.id = "Gateway_".concat(genBpmnId());
        }
        if (!data.text) {
          data.text = "";
        }
        if (data.text && typeof data.text === "string") {
          data.text = {
            value: data.text,
            x: data.x,
            y: data.y + 40
          };
        }
        data.properties = __assign11(__assign11({}, props || {}), data.properties);
        _this = _super.call(this, data, graphModel) || this;
        _this.points = [
          [25, 0],
          [50, 25],
          [25, 50],
          [0, 25]
        ];
        groupRule.call(_this);
        return _this;
      }
      return model2;
    }(PolygonNodeModel)
  );
  return {
    type: type3,
    view,
    model
  };
}

// node_modules/@logicflow/extension/es/bpmn-elements/presets/Gateway/index.js
function registerGatewayNodes(lf) {
  var ExclusiveGateway2 = GatewayNodeFactory("bpmn:exclusiveGateway", exclusiveIcon);
  var ParallelGateway = GatewayNodeFactory("bpmn:parallelGateway", parallelIcon);
  var InclusiveGateway = GatewayNodeFactory("bpmn:inclusiveGateway", inclusiveIcon);
  lf.register(ExclusiveGateway2);
  lf.register(InclusiveGateway);
  lf.register(ParallelGateway);
}

// node_modules/@logicflow/extension/es/bpmn-elements/presets/Task/task.js
var __extends14 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign12 = function() {
  __assign12 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign12.apply(this, arguments);
};
var __read7 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray6 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var multiInstanceIcon = {
  parallel: parallelMarker,
  sequential: sequentialMarker,
  loop: loopMarker
};
function TaskNodeFactory(type3, icon, props) {
  var view = (
    /** @class */
    function(_super) {
      __extends14(view2, _super);
      function view2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      view2.prototype.getLabelShape = function() {
        var model2 = this.props.model;
        var x2 = model2.x, y = model2.y, width = model2.width, height = model2.height;
        var style2 = model2.getNodeStyle();
        var i = Array.isArray(icon) ? g.apply(void 0, __spreadArray6([
          "g",
          {
            transform: "matrix(1 0 0 1 ".concat(x2 - width / 2, " ").concat(y - height / 2, ")")
          }
        ], __read7(icon), false)) : g("path", {
          fill: style2.stroke,
          d: icon
        });
        return g("svg", {
          x: x2 - width / 2 + 5,
          y: y - height / 2 + 5,
          width: 25,
          height: 25,
          viewBox: "0 0 1274 1024"
        }, i);
      };
      view2.prototype.getShape = function() {
        var model2 = this.props.model;
        var x2 = model2.x, y = model2.y, width = model2.width, height = model2.height, radius = model2.radius, properties = model2.properties;
        var style2 = model2.getNodeStyle();
        return g("g", {}, [
          g("rect", __assign12(__assign12({}, style2), { x: x2 - width / 2, y: y - height / 2, rx: radius, ry: radius, width, height, opacity: 0.95 })),
          this.getLabelShape(),
          g("g", {
            transform: "matrix(1 0 0 1 ".concat(x2 - width / 2, " ").concat(y - height / 2, ")")
          }, g("path", {
            fill: "white",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            stroke: "rgb(34, 36, 42)",
            strokeWidth: "2",
            d: multiInstanceIcon[properties.multiInstanceType] || ""
            // TODO: 确认 properties.multiInstanceType 的类型
          }))
        ]);
      };
      return view2;
    }(RectNode)
  );
  var model = (
    /** @class */
    function(_super) {
      __extends14(model2, _super);
      function model2(data, graphModel) {
        var _this = this;
        var _a;
        if (!data.id) {
          data.id = "Activity_".concat(genBpmnId());
        }
        var properties = __assign12(__assign12({}, props || {}), data.properties);
        data.properties = properties;
        _this = _super.call(this, data, graphModel) || this;
        (_a = properties === null || properties === void 0 ? void 0 : properties.boundaryEvents) === null || _a === void 0 ? void 0 : _a.forEach(function(id) {
          _this.addBoundaryEvent(id);
        });
        _this.deleteProperty("boundaryEvents");
        groupRule.call(_this);
        return _this;
      }
      model2.prototype.initNodeData = function(data) {
        _super.prototype.initNodeData.call(this, data);
        this.isTaskNode = true;
        this.boundaryEvents = [];
      };
      model2.prototype.getNodeStyle = function() {
        var style2 = _super.prototype.getNodeStyle.call(this);
        var isBoundaryEventTouchingTask = this.properties.isBoundaryEventTouchingTask;
        if (isBoundaryEventTouchingTask) {
          style2.stroke = "#00acff";
          style2.strokeWidth = 2;
        }
        return style2;
      };
      model2.prototype.getOutlineStyle = function() {
        var style2 = _super.prototype.getOutlineStyle.call(this);
        style2.stroke = "transparent";
        !style2.hover && (style2.hover = {});
        style2.hover.stroke = "transparent";
        return style2;
      };
      model2.prototype.setTouching = function(flag) {
        this.setProperty("isBoundaryEventTouchingTask", flag);
      };
      model2.prototype.addBoundaryEvent = function(nodeId) {
        this.setTouching(false);
        if (this.boundaryEvents.find(function(item) {
          return item === nodeId;
        })) {
          return false;
        }
        var boundaryEvent2 = this.graphModel.getNodeModelById(nodeId);
        boundaryEvent2 === null || boundaryEvent2 === void 0 ? void 0 : boundaryEvent2.setProperties({
          attachedToRef: this.id
        });
        this.boundaryEvents.push(nodeId);
        return true;
      };
      model2.prototype.deleteBoundaryEvent = function(nodeId) {
        this.boundaryEvents = this.boundaryEvents.filter(function(item) {
          return item !== nodeId;
        });
      };
      return model2;
    }(RectNodeModel)
  );
  return {
    type: type3,
    view,
    model
  };
}

// node_modules/@logicflow/extension/es/NodeResize/control/Control.js
var __extends15 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign13 = function() {
  __assign13 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign13.apply(this, arguments);
};
var __read8 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var StepDrag2 = util_exports.StepDrag;
var Control = (
  /** @class */
  function(_super) {
    __extends15(Control3, _super);
    function Control3(props) {
      var _this = _super.call(this) || this;
      _this.updatePosition = function(_a) {
        var deltaX = _a.deltaX, deltaY = _a.deltaY;
        var _b = _this.nodeModel, x2 = _b.x, y = _b.y;
        _this.nodeModel.x = x2 + deltaX / 2;
        _this.nodeModel.y = y + deltaY / 2;
        _this.nodeModel.moveText(deltaX / 2, deltaY / 2);
      };
      _this.getResize = function(_a) {
        var index = _a.index, deltaX = _a.deltaX, deltaY = _a.deltaY, width = _a.width, height = _a.height, PCTResizeInfo = _a.PCTResizeInfo, _b = _a.pct, pct = _b === void 0 ? 1 : _b, _c = _a.freezeWidth, freezeWidth = _c === void 0 ? false : _c, _d = _a.freezeHeight, freezeHeight = _d === void 0 ? false : _d;
        var resize = {
          width,
          height,
          deltaX,
          deltaY
        };
        if (PCTResizeInfo) {
          var sensitivity = 4;
          var deltaScale = 0;
          var combineDelta = 0;
          switch (index) {
            case 0:
              combineDelta = (deltaX * -1 - deltaY) / sensitivity;
              break;
            case 1:
              combineDelta = (deltaX - deltaY) / sensitivity;
              break;
            case 2:
              combineDelta = (deltaX + deltaY) / sensitivity;
              break;
            case 3:
              combineDelta = (deltaX * -1 + deltaY) / sensitivity;
              break;
            default:
              break;
          }
          if (combineDelta !== 0) {
            deltaScale = Math.round(combineDelta / PCTResizeInfo.ResizeBasis.basisHeight * 1e5) / 1e3;
          }
          PCTResizeInfo.ResizePCT.widthPCT = Math.max(Math.min(PCTResizeInfo.ResizePCT.widthPCT + deltaScale, PCTResizeInfo.ScaleLimit.maxScaleLimit), PCTResizeInfo.ScaleLimit.minScaleLimit);
          PCTResizeInfo.ResizePCT.heightPCT = Math.max(Math.min(PCTResizeInfo.ResizePCT.heightPCT + deltaScale, PCTResizeInfo.ScaleLimit.maxScaleLimit), PCTResizeInfo.ScaleLimit.minScaleLimit);
          var spcWidth = Math.round(PCTResizeInfo.ResizePCT.widthPCT * PCTResizeInfo.ResizeBasis.basisWidth / 100);
          var spcHeight = Math.round(PCTResizeInfo.ResizePCT.heightPCT * PCTResizeInfo.ResizeBasis.basisHeight / 100);
          switch (index) {
            case 0:
              deltaX = width - spcWidth;
              deltaY = height - spcHeight;
              break;
            case 1:
              deltaX = spcWidth - width;
              deltaY = height - spcHeight;
              break;
            case 2:
              deltaX = spcWidth - width;
              deltaY = spcHeight - height;
              break;
            case 3:
              deltaX = width - spcWidth;
              deltaY = spcHeight - height;
              break;
            default:
              break;
          }
          resize.width = spcWidth;
          resize.height = spcHeight;
          resize.deltaX = deltaX / pct;
          resize.deltaY = deltaY / pct;
          return resize;
        }
        switch (index) {
          case 0:
            resize.width = freezeWidth ? width : width - deltaX * pct;
            resize.height = freezeHeight ? height : height - deltaY * pct;
            break;
          case 1:
            resize.width = freezeWidth ? width : width + deltaX * pct;
            resize.height = freezeHeight ? height : height - deltaY * pct;
            break;
          case 2:
            resize.width = freezeWidth ? width : width + deltaX * pct;
            resize.height = freezeHeight ? height : height + deltaY * pct;
            break;
          case 3:
            resize.width = freezeWidth ? width : width - deltaX * pct;
            resize.height = freezeHeight ? height : height + deltaY * pct;
            break;
          default:
            break;
        }
        return resize;
      };
      _this.updateEdgePointByAnchors = function() {
        var _a = _this.nodeModel, id = _a.id, anchors = _a.anchors;
        var edges = _this.getNodeEdges(id);
        edges.sourceEdges.forEach(function(item) {
          var anchorItem = anchors.find(function(anchor) {
            return anchor.id === item.sourceAnchorId;
          });
          if (anchorItem) {
            item.updateStartPoint({
              x: anchorItem.x,
              y: anchorItem.y
            });
          }
        });
        edges.targetEdges.forEach(function(item) {
          var anchorItem = anchors.find(function(anchor) {
            return anchor.id === item.targetAnchorId;
          });
          if (anchorItem) {
            item.updateEndPoint({
              x: anchorItem.x,
              y: anchorItem.y
            });
          }
        });
      };
      _this.updateRect = function(_a) {
        var deltaX = _a.deltaX, deltaY = _a.deltaY;
        var _b = _this.nodeModel, x2 = _b.x, y = _b.y, width = _b.width, height = _b.height, radius = _b.radius, PCTResizeInfo = _b.PCTResizeInfo;
        var _c = _this.nodeModel, minWidth = _c.minWidth, minHeight = _c.minHeight, maxWidth = _c.maxWidth, maxHeight = _c.maxHeight;
        var index = _this.index;
        var freezeWidth = minWidth === maxWidth;
        var freezeHeight = minHeight === maxHeight;
        var size = _this.getResize({
          index,
          deltaX,
          deltaY,
          width,
          height,
          PCTResizeInfo,
          pct: 1,
          freezeWidth,
          freezeHeight
        });
        if (size.width < minWidth || size.width > maxWidth || size.height < minHeight || size.height > maxHeight) {
          _this.dragHandler.cancelDrag();
          return;
        }
        _this.updatePosition({
          deltaX: freezeWidth ? 0 : size.deltaX,
          deltaY: freezeHeight ? 0 : size.deltaY
        });
        _this.nodeModel.width = size.width;
        _this.nodeModel.height = size.height;
        _this.nodeModel.setProperties({
          nodeSize: {
            width: size.width,
            height: size.height
          }
        });
        var beforeNode = {
          x: x2,
          y,
          width,
          height,
          radius
        };
        var afterNode = {
          x: _this.nodeModel.x,
          y: _this.nodeModel.y,
          width: _this.nodeModel.width,
          height: _this.nodeModel.height,
          radius
        };
        _this.updateEdgePointByAnchors();
        _this.eventEmit({
          deltaX,
          deltaY,
          beforeNode,
          afterNode
        });
      };
      _this.updateEllipse = function(_a) {
        var deltaX = _a.deltaX, deltaY = _a.deltaY;
        var _b = _this.nodeModel, rx = _b.rx, ry = _b.ry, x2 = _b.x, y = _b.y, PCTResizeInfo = _b.PCTResizeInfo;
        var index = _this.index;
        var _c = _this.nodeModel, minWidth = _c.minWidth, minHeight = _c.minHeight, maxWidth = _c.maxWidth, maxHeight = _c.maxHeight;
        var freezeWidth = minWidth === maxWidth;
        var freezeHeight = minHeight === maxHeight;
        var width = rx;
        var height = ry;
        var size = _this.getResize({
          index,
          deltaX,
          deltaY,
          width,
          height,
          PCTResizeInfo,
          pct: 1 / 2,
          freezeWidth,
          freezeHeight
        });
        if (size.width < minWidth / 2 || size.width > maxWidth / 2 || size.height < minHeight / 2 || size.height > maxHeight / 2) {
          _this.dragHandler.cancelDrag();
          return;
        }
        _this.updatePosition({
          deltaX: freezeWidth ? 0 : size.deltaX,
          deltaY: freezeHeight ? 0 : size.deltaY
        });
        _this.nodeModel.rx = size.width;
        _this.nodeModel.ry = size.height;
        _this.nodeModel.setProperties({
          nodeSize: {
            rx: size.width,
            ry: size.height
          }
        });
        var beforeNode = {
          x: x2,
          y
        };
        var afterNode = {
          rx: size.width,
          ry: size.height,
          x: _this.nodeModel.x,
          y: _this.nodeModel.y
        };
        _this.updateEdgePointByAnchors();
        _this.eventEmit({
          deltaX,
          deltaY,
          beforeNode: __assign13(__assign13({}, beforeNode), { rx, ry }),
          afterNode
        });
      };
      _this.updateDiamond = function(_a) {
        var deltaX = _a.deltaX, deltaY = _a.deltaY;
        var _b = _this.nodeModel, rx = _b.rx, ry = _b.ry, x2 = _b.x, y = _b.y, PCTResizeInfo = _b.PCTResizeInfo;
        var index = _this.index;
        var _c = _this.nodeModel, minWidth = _c.minWidth, minHeight = _c.minHeight, maxWidth = _c.maxWidth, maxHeight = _c.maxHeight;
        var freezeWidth = minWidth === maxWidth;
        var freezeHeight = minHeight === maxHeight;
        var width = rx;
        var height = ry;
        var size = _this.getResize({
          index,
          deltaX,
          deltaY,
          width,
          height,
          PCTResizeInfo,
          pct: 1 / 2,
          freezeWidth,
          freezeHeight
        });
        if (size.width < minWidth / 2 || size.width > maxWidth / 2 || size.height < minHeight / 2 || size.height > maxHeight / 2) {
          _this.dragHandler.cancelDrag();
          return;
        }
        _this.updatePosition({
          deltaX: freezeWidth ? 0 : size.deltaX,
          deltaY: freezeHeight ? 0 : size.deltaY
        });
        _this.nodeModel.rx = size.width;
        _this.nodeModel.ry = size.height;
        _this.nodeModel.setProperties({
          nodeSize: {
            rx: size.width,
            ry: size.height
          }
        });
        var beforeNode = {
          x: x2,
          y,
          rx,
          ry
        };
        var afterNode = {
          rx: size.width,
          ry: size.height,
          x: _this.nodeModel.x,
          y: _this.nodeModel.y
        };
        _this.updateEdgePointByAnchors();
        _this.eventEmit({
          deltaX,
          deltaY,
          beforeNode,
          afterNode
        });
      };
      _this.eventEmit = function(_a) {
        var deltaX = _a.deltaX, deltaY = _a.deltaY, beforeNode = _a.beforeNode, afterNode = _a.afterNode;
        var _b = _this.nodeModel, id = _b.id, modelType = _b.modelType, type3 = _b.type;
        var oldNodeSize = __assign13({ id, modelType, type: type3 }, beforeNode);
        var newNodeSize = __assign13({ id, modelType, type: type3 }, afterNode);
        _this.graphModel.eventCenter.emit("node:resize", {
          preData: oldNodeSize,
          data: newNodeSize,
          deltaX,
          deltaY,
          index: _this.index,
          model: _this.nodeModel
        });
      };
      _this.onDragging = function(_a) {
        var _b;
        var deltaX = _a.deltaX, deltaY = _a.deltaY;
        var transformModel = _this.graphModel.transformModel;
        var modelType = _this.nodeModel.modelType;
        _b = __read8(transformModel.fixDeltaXY(deltaX, deltaY), 2), deltaX = _b[0], deltaY = _b[1];
        if (modelType === ModelType.RECT_NODE || modelType === ModelType.HTML_NODE) {
          _this.updateRect({
            deltaX,
            deltaY
          });
        } else if (modelType === ModelType.ELLIPSE_NODE) {
          _this.updateEllipse({
            deltaX,
            deltaY
          });
        } else if (modelType === ModelType.DIAMOND_NODE) {
          _this.updateDiamond({
            deltaX,
            deltaY
          });
        }
      };
      _this.onDragEnd = function() {
        var _a = _this.graphModel.gridSize, gridSize = _a === void 0 ? 1 : _a;
        var x2 = gridSize * Math.round(_this.nodeModel.x / gridSize);
        var y = gridSize * Math.round(_this.nodeModel.y / gridSize);
        _this.nodeModel.moveTo(x2, y);
        _this.updateEdgePointByAnchors();
      };
      _this.index = props.index;
      _this.nodeModel = props.model;
      _this.graphModel = props.graphModel;
      _this.dragHandler = new StepDrag2({
        onDragging: _this.onDragging,
        onDragEnd: _this.onDragEnd,
        step: 1
      });
      return _this;
    }
    Control3.prototype.getNodeEdges = function(nodeId) {
      var graphModel = this.graphModel;
      var edges = graphModel.edges;
      var sourceEdges = [];
      var targetEdges = [];
      for (var i = 0; i < edges.length; i++) {
        var edgeModel = edges[i];
        if (edgeModel.sourceNodeId === nodeId) {
          sourceEdges.push(edgeModel);
        } else if (edges[i].targetNodeId === nodeId) {
          targetEdges.push(edgeModel);
        }
      }
      return {
        sourceEdges,
        targetEdges
      };
    };
    Control3.prototype.render = function() {
      var _a = this.props, x2 = _a.x, y = _a.y, index = _a.index, model = _a.model;
      var style2 = model.getControlPointStyle();
      return u("g", { className: "lf-resize-control-".concat(index), children: u(Rect, __assign13({ className: "lf-node-control", x: x2, y }, style2, { onMouseDown: this.dragHandler.handleMouseDown })) });
    };
    return Control3;
  }(x)
);
var Control_default = Control;

// node_modules/@logicflow/extension/es/NodeResize/control/ControlGroup.js
var __extends16 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign14 = function() {
  __assign14 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign14.apply(this, arguments);
};
var ControlGroup = (
  /** @class */
  function(_super) {
    __extends16(ControlGroup2, _super);
    function ControlGroup2() {
      var _this = _super.call(this) || this;
      _this.state = {};
      return _this;
    }
    ControlGroup2.prototype.getResizeControl = function() {
      var _a = this.props, model = _a.model, graphModel = _a.graphModel;
      var x2 = model.x, y = model.y, width = model.width, height = model.height;
      var box = {
        minX: x2 - width / 2,
        minY: y - height / 2,
        maxX: x2 + width / 2,
        maxY: y + height / 2
      };
      var minX = box.minX, minY = box.minY, maxX = box.maxX, maxY = box.maxY;
      var controlList = [
        // 左上角
        {
          x: minX,
          y: minY
        },
        // 右上角
        {
          x: maxX,
          y: minY
        },
        // 右下角
        {
          x: maxX,
          y: maxY
        },
        // 左下角
        {
          x: minX,
          y: maxY
        }
      ];
      return controlList.map(function(control, index) {
        return u(Control_default, __assign14({ index }, control, { model, graphModel }));
      });
    };
    ControlGroup2.prototype.getGroupSolid = function() {
      var model = this.props.model;
      var x2 = model.x, y = model.y, width = model.width, height = model.height;
      var style2 = model.getResizeOutlineStyle();
      return u(Rect, __assign14({}, style2, { x: x2, y, width, height }));
    };
    ControlGroup2.prototype.render = function() {
      return u("g", { className: "lf-resize-control", children: [this.getGroupSolid(), this.getResizeControl()] });
    };
    return ControlGroup2;
  }(x)
);
var ControlGroup_default = ControlGroup;

// node_modules/@logicflow/extension/es/NodeResize/node/EllipseResize.js
var __extends17 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var EllipseResizeModel = (
  /** @class */
  function(_super) {
    __extends17(EllipseResizeModel2, _super);
    function EllipseResizeModel2(data, graphModel) {
      var _this = _super.call(this, data, graphModel) || this;
      var nodeSize = data.properties.nodeSize;
      if (nodeSize) {
        _this.rx = nodeSize.rx;
        _this.ry = nodeSize.ry;
      }
      return _this;
    }
    EllipseResizeModel2.prototype.initNodeData = function(data) {
      _super.prototype.initNodeData.call(this, data);
      this.minWidth = 30;
      this.minHeight = 30;
      this.maxWidth = 2e3;
      this.maxHeight = 2e3;
    };
    EllipseResizeModel2.prototype.getOutlineStyle = function() {
      var style2 = _super.prototype.getOutlineStyle.call(this);
      var isSilentMode = this.graphModel.editConfigModel.isSilentMode;
      if (isSilentMode)
        return style2;
      style2.stroke = "none";
      if (style2.hover) {
        style2.hover.stroke = "none";
      }
      return style2;
    };
    EllipseResizeModel2.prototype.getResizeOutlineStyle = function() {
      return {
        fill: "none",
        stroke: "transparent",
        strokeWidth: 1,
        strokeDasharray: "3,3"
      };
    };
    EllipseResizeModel2.prototype.getControlPointStyle = function() {
      return {
        width: 7,
        height: 7,
        fill: "#FFFFFF",
        stroke: "#000000"
      };
    };
    EllipseResizeModel2.prototype.enableProportionResize = function(turnOn) {
      if (turnOn === void 0) {
        turnOn = true;
      }
      if (turnOn) {
        var ResizePCT = {
          widthPCT: 100,
          heightPCT: 100
        };
        var ResizeBasis = {
          basisWidth: this.rx,
          basisHeight: this.ry
        };
        var ScaleLimit = {
          maxScaleLimit: Math.min(this.maxWidth / (this.rx * 2) * 100, this.maxHeight / (this.ry * 2) * 100),
          minScaleLimit: Math.max(this.minWidth / (this.rx * 2) * 100, this.minHeight / (this.ry * 2) * 100)
        };
        this.PCTResizeInfo = {
          ResizePCT,
          ResizeBasis,
          ScaleLimit
        };
      } else {
        delete this.PCTResizeInfo;
      }
    };
    return EllipseResizeModel2;
  }(EllipseNodeModel)
);
var EllipseResizeView = (
  /** @class */
  function(_super) {
    __extends17(EllipseResizeView2, _super);
    function EllipseResizeView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    EllipseResizeView2.prototype.getControlGroup = function() {
      var _a = this.props, model = _a.model, graphModel = _a.graphModel;
      return u(ControlGroup_default, { model, graphModel });
    };
    EllipseResizeView2.prototype.getResizeShape = function() {
      return _super.prototype.getShape.call(this);
    };
    EllipseResizeView2.prototype.getShape = function() {
      var _a = this.props, model = _a.model, isSilentMode = _a.graphModel.editConfigModel.isSilentMode;
      return u("g", { children: [this.getResizeShape(), model.isSelected && !isSilentMode ? this.getControlGroup() : ""] });
    };
    return EllipseResizeView2;
  }(EllipseNode)
);
var EllipseResize = {
  type: "ellipse",
  view: EllipseResizeView,
  model: EllipseResizeModel
};
var EllipseResize_default = EllipseResize;

// node_modules/@logicflow/extension/es/NodeResize/node/DiamondResize.js
var __extends18 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign15 = function() {
  __assign15 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign15.apply(this, arguments);
};
var DiamondResizeModel = (
  /** @class */
  function(_super) {
    __extends18(DiamondResizeModel2, _super);
    function DiamondResizeModel2(data, graphModel) {
      var _this = _super.call(this, data, graphModel) || this;
      var nodeSize = data.properties.nodeSize;
      if (nodeSize) {
        _this.rx = nodeSize.rx;
        _this.ry = nodeSize.ry;
      }
      return _this;
    }
    DiamondResizeModel2.prototype.initNodeData = function(data) {
      _super.prototype.initNodeData.call(this, data);
      this.minWidth = 30;
      this.minHeight = 30;
      this.maxWidth = 2e3;
      this.maxHeight = 2e3;
      this.gridSize = 1;
    };
    DiamondResizeModel2.prototype.getOutlineStyle = function() {
      var style2 = _super.prototype.getOutlineStyle.call(this);
      var isSilentMode = this.graphModel.editConfigModel.isSilentMode;
      if (isSilentMode)
        return style2;
      style2.stroke = "none";
      if (style2.hover) {
        style2.hover.stroke = "none";
      }
      return style2;
    };
    DiamondResizeModel2.prototype.getResizeOutlineStyle = function() {
      return {
        fill: "none",
        stroke: "transparent",
        strokeWidth: 1,
        strokeDasharray: "3,3"
      };
    };
    DiamondResizeModel2.prototype.getControlPointStyle = function() {
      return {
        width: 7,
        height: 7,
        fill: "#FFFFFF",
        stroke: "#000000"
      };
    };
    DiamondResizeModel2.prototype.enableProportionResize = function(turnOn) {
      if (turnOn === void 0) {
        turnOn = true;
      }
      if (turnOn) {
        var ResizePCT = {
          widthPCT: 100,
          heightPCT: 100
        };
        var ResizeBasis = {
          basisWidth: this.rx,
          basisHeight: this.ry
        };
        var ScaleLimit = {
          maxScaleLimit: Math.min(this.maxWidth / (this.rx * 2) * 100, this.maxHeight / (this.ry * 2) * 100),
          minScaleLimit: Math.max(this.minWidth / (this.rx * 2) * 100, this.minHeight / (this.ry * 2) * 100)
        };
        this.PCTResizeInfo = {
          ResizePCT,
          ResizeBasis,
          ScaleLimit
        };
      } else {
        delete this.PCTResizeInfo;
      }
    };
    return DiamondResizeModel2;
  }(DiamondNodeModel)
);
var DiamondResizeView = (
  /** @class */
  function(_super) {
    __extends18(DiamondResizeView2, _super);
    function DiamondResizeView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DiamondResizeView2.prototype.getControlGroup = function() {
      var _a = this.props, model = _a.model, graphModel = _a.graphModel;
      return u(ControlGroup_default, { model, graphModel });
    };
    DiamondResizeView2.prototype.getResizeShape = function() {
      var model = this.props.model;
      var points = model.points;
      var style2 = model.getNodeStyle();
      return u("g", { children: u(Polygon, __assign15({}, style2, { points })) });
    };
    DiamondResizeView2.prototype.getShape = function() {
      var _a = this.props, isSelected = _a.model.isSelected, isSilentMode = _a.graphModel.editConfigModel.isSilentMode;
      return u("g", { children: [this.getResizeShape(), isSelected && !isSilentMode ? this.getControlGroup() : ""] });
    };
    return DiamondResizeView2;
  }(DiamondNode)
);
var DiamondResize = {
  type: "diamond",
  view: DiamondResizeView,
  model: DiamondResizeModel
};
var DiamondResize_default = DiamondResize;

// node_modules/@logicflow/extension/es/NodeResize/node/HtmlResize.js
var __extends19 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var HtmlResizeModel = (
  /** @class */
  function(_super) {
    __extends19(HtmlResizeModel2, _super);
    function HtmlResizeModel2(data, graphModel) {
      var _this = _super.call(this, data, graphModel) || this;
      var nodeSize = data.properties.nodeSize;
      if (nodeSize) {
        _this.width = nodeSize.width;
        _this.height = nodeSize.height;
      }
      return _this;
    }
    HtmlResizeModel2.prototype.initNodeData = function(data) {
      _super.prototype.initNodeData.call(this, data);
      this.minWidth = 30;
      this.minHeight = 30;
      this.maxWidth = 2e3;
      this.maxHeight = 2e3;
    };
    HtmlResizeModel2.prototype.getOutlineStyle = function() {
      var style2 = _super.prototype.getOutlineStyle.call(this);
      var isSilentMode = this.graphModel.editConfigModel.isSilentMode;
      if (isSilentMode)
        return style2;
      style2.stroke = "none";
      if (style2.hover) {
        style2.hover.stroke = "none";
      }
      return style2;
    };
    HtmlResizeModel2.prototype.getResizeOutlineStyle = function() {
      return {
        fill: "none",
        stroke: "transparent",
        strokeWidth: 1,
        strokeDasharray: "3,3"
      };
    };
    HtmlResizeModel2.prototype.getControlPointStyle = function() {
      return {
        width: 7,
        height: 7,
        fill: "#FFFFFF",
        stroke: "#000000"
      };
    };
    HtmlResizeModel2.prototype.enableProportionResize = function(turnOn) {
      if (turnOn === void 0) {
        turnOn = true;
      }
      if (turnOn) {
        var ResizePCT = {
          widthPCT: 100,
          heightPCT: 100
        };
        var ResizeBasis = {
          basisWidth: this.width,
          basisHeight: this.height
        };
        var ScaleLimit = {
          maxScaleLimit: Math.min(this.maxWidth / this.width * 100, this.maxHeight / this.height * 100),
          minScaleLimit: Math.max(this.minWidth / this.width * 100, this.minHeight / this.height * 100)
        };
        this.PCTResizeInfo = {
          ResizePCT,
          ResizeBasis,
          ScaleLimit
        };
      } else {
        delete this.PCTResizeInfo;
      }
    };
    return HtmlResizeModel2;
  }(HtmlNodeModel)
);
var HtmlResizeView = (
  /** @class */
  function(_super) {
    __extends19(HtmlResizeView2, _super);
    function HtmlResizeView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlResizeView2.prototype.getControlGroup = function() {
      var _a = this.props, model = _a.model, graphModel = _a.graphModel;
      return u(ControlGroup_default, { model, graphModel });
    };
    HtmlResizeView2.prototype.getResizeShape = function() {
      return _super.prototype.getShape.call(this);
    };
    HtmlResizeView2.prototype.getShape = function() {
      var _a = this.props, isSelected = _a.model.isSelected, isSilentMode = _a.graphModel.editConfigModel.isSilentMode;
      return u("g", { children: [this.getResizeShape(), isSelected && !isSilentMode ? this.getControlGroup() : ""] });
    };
    return HtmlResizeView2;
  }(HtmlNode)
);
var HtmlResize = {
  type: "html",
  view: HtmlResizeView,
  model: HtmlResizeModel
};
var HtmlResize_default = HtmlResize;

// node_modules/@logicflow/extension/es/NodeResize/node/RectResize.js
var __extends20 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var RectResizeModel = (
  /** @class */
  function(_super) {
    __extends20(RectResizeModel2, _super);
    function RectResizeModel2(data, graphModel) {
      var _this = _super.call(this, data, graphModel) || this;
      var nodeSize = data.properties.nodeSize;
      if (nodeSize) {
        _this.width = nodeSize.width;
        _this.height = nodeSize.height;
      }
      return _this;
    }
    RectResizeModel2.prototype.initNodeData = function(data) {
      _super.prototype.initNodeData.call(this, data);
      this.minWidth = 30;
      this.minHeight = 30;
      this.maxWidth = 2e3;
      this.maxHeight = 2e3;
    };
    RectResizeModel2.prototype.getOutlineStyle = function() {
      var style2 = _super.prototype.getOutlineStyle.call(this);
      var isSilentMode = this.graphModel.editConfigModel.isSilentMode;
      if (isSilentMode)
        return style2;
      style2.stroke = "none";
      if (style2.hover) {
        style2.hover.stroke = "none";
      }
      return style2;
    };
    RectResizeModel2.prototype.getResizeOutlineStyle = function() {
      return {
        fill: "none",
        stroke: "transparent",
        // 矩形默认不显示调整边框
        strokeWidth: 1,
        strokeDasharray: "3,3"
      };
    };
    RectResizeModel2.prototype.getControlPointStyle = function() {
      return {
        width: 7,
        height: 7,
        fill: "#FFFFFF",
        stroke: "#000000"
      };
    };
    RectResizeModel2.prototype.enableProportionResize = function(turnOn) {
      if (turnOn === void 0) {
        turnOn = true;
      }
      if (turnOn) {
        var ResizePCT = {
          widthPCT: 100,
          heightPCT: 100
        };
        var ResizeBasis = {
          basisWidth: this.width,
          basisHeight: this.height
        };
        var ScaleLimit = {
          maxScaleLimit: Math.min(this.maxWidth / this.width * 100, this.maxHeight / this.height * 100),
          minScaleLimit: Math.max(this.minWidth / this.width * 100, this.minHeight / this.height * 100)
        };
        this.PCTResizeInfo = {
          ResizePCT,
          ResizeBasis,
          ScaleLimit
        };
      } else {
        delete this.PCTResizeInfo;
      }
    };
    return RectResizeModel2;
  }(RectNodeModel)
);
var RectResizeView = (
  /** @class */
  function(_super) {
    __extends20(RectResizeView2, _super);
    function RectResizeView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    RectResizeView2.prototype.getControlGroup = function() {
      var _a = this.props, model = _a.model, graphModel = _a.graphModel;
      return u(ControlGroup_default, { model, graphModel });
    };
    RectResizeView2.prototype.getResizeShape = function() {
      return _super.prototype.getShape.call(this);
    };
    RectResizeView2.prototype.getShape = function() {
      var _a = this.props, isSelected = _a.model.isSelected, isSilentMode = _a.graphModel.editConfigModel.isSilentMode;
      return u("g", { children: [this.getResizeShape(), isSelected && !isSilentMode ? this.getControlGroup() : ""] });
    };
    return RectResizeView2;
  }(RectNode)
);
var RectResize = {
  type: "rect",
  view: RectResizeView,
  model: RectResizeModel
};
var RectResize_default = RectResize;

// node_modules/@logicflow/extension/es/NodeResize/index.js
var NodeResize = {
  pluginName: "nodeResize",
  // 拖动step
  step: 0,
  install: function(lf) {
    lf.register(EllipseResize_default);
    lf.register(DiamondResize_default);
    lf.register(HtmlResize_default);
    lf.register(RectResize_default);
  }
};

// node_modules/@logicflow/extension/es/materials/group/GroupNode.js
var __extends21 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign16 = function() {
  __assign16 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign16.apply(this, arguments);
};
var __read9 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray7 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var defaultWidth = 500;
var defaultHeight = 300;
var DEFAULT_BOTTOM_Z_INDEX = -1e4;
var GroupNodeModel = (
  /** @class */
  function(_super) {
    __extends21(GroupNodeModel2, _super);
    function GroupNodeModel2() {
      var _this = _super.apply(this, __spreadArray7([], __read9(arguments), false)) || this;
      _this.isGroup = true;
      _this.isFolded = false;
      _this.unfoldedWidth = defaultWidth;
      _this.unfoldedHeight = defaultHeight;
      _this.childrenLastFoldStatus = {};
      return _this;
    }
    GroupNodeModel2.prototype.initNodeData = function(data) {
      var _this = this;
      _super.prototype.initNodeData.call(this, data);
      var children = [];
      if (isArray_default(data.children)) {
        children = data.children;
      }
      this.children = new Set(children);
      this.width = defaultWidth;
      this.height = defaultHeight;
      this.foldedWidth = 80;
      this.foldedHeight = 60;
      this.zIndex = DEFAULT_BOTTOM_Z_INDEX;
      this.radius = 0;
      this.text.editable = false;
      this.text.draggable = false;
      this.isRestrict = false;
      this.resizable = false;
      this.autoToFront = false;
      this.foldable = false;
      if (this.properties.isFolded === void 0) {
        this.properties.isFolded = false;
      }
      this.isFolded = !!this.properties.isFolded;
      setTimeout(function() {
        _this.isFolded && _this.foldGroup(_this.isFolded);
      });
    };
    GroupNodeModel2.prototype.getResizeOutlineStyle = function() {
      var style2 = _super.prototype.getResizeOutlineStyle.call(this);
      style2.stroke = "none";
      return style2;
    };
    GroupNodeModel2.prototype.foldGroup = function(isFolded) {
      var _this = this;
      if (isFolded === this.isFolded) {
        return;
      }
      this.setProperty("isFolded", isFolded);
      this.isFolded = isFolded;
      if (isFolded) {
        this.x = this.x - this.width / 2 + this.foldedWidth / 2;
        this.y = this.y - this.height / 2 + this.foldedHeight / 2;
        this.unfoldedWidth = this.width;
        this.unfoldedHeight = this.height;
        this.width = this.foldedWidth;
        this.height = this.foldedHeight;
      } else {
        this.width = this.unfoldedWidth;
        this.height = this.unfoldedHeight;
        this.x = this.x + this.width / 2 - this.foldedWidth / 2;
        this.y = this.y + this.height / 2 - this.foldedHeight / 2;
      }
      var allEdges = __spreadArray7(__spreadArray7([], __read9(this.incoming.edges), false), __read9(this.outgoing.edges), false);
      this.children.forEach(function(elementId) {
        var nodeModel = _this.graphModel.getElement(elementId);
        if (nodeModel) {
          var foldStatus = nodeModel.isFolded;
          if (nodeModel.isGroup && !nodeModel.isFolded) {
            ;
            nodeModel.foldGroup(isFolded);
          }
          if (nodeModel.isGroup && !isFolded) {
            var lastFoldStatus = _this.childrenLastFoldStatus[elementId];
            if (lastFoldStatus !== void 0 && lastFoldStatus !== nodeModel.isFolded) {
              ;
              nodeModel.foldGroup(lastFoldStatus);
            }
          }
          _this.childrenLastFoldStatus[elementId] = !!foldStatus;
          nodeModel.visible = !isFolded;
          var incomingEdges = nodeModel.incoming.edges;
          var outgoingEdges = nodeModel.outgoing.edges;
          allEdges = __spreadArray7(__spreadArray7(__spreadArray7([], __read9(allEdges), false), __read9(incomingEdges), false), __read9(outgoingEdges), false);
        }
      });
      this.foldEdge(isFolded, allEdges);
    };
    GroupNodeModel2.prototype.getAnchorStyle = function(anchorInfo) {
      var style2 = _super.prototype.getAnchorStyle.call(this, anchorInfo);
      style2.stroke = "transparent";
      style2.fill = "transparent";
      style2.hover.fill = "transparent";
      style2.hover.stroke = "transparent";
      return style2;
    };
    GroupNodeModel2.prototype.foldEdge = function(isFolded, allEdges) {
      var _this = this;
      allEdges.forEach(function(edgeModel, index) {
        var id = edgeModel.id, sourceNodeId = edgeModel.sourceNodeId, targetNodeId = edgeModel.targetNodeId, startPoint = edgeModel.startPoint, endPoint = edgeModel.endPoint, type3 = edgeModel.type, text = edgeModel.text;
        var properties = edgeModel.getProperties();
        var data = {
          id: "".concat(id, "__").concat(index),
          sourceNodeId,
          targetNodeId,
          startPoint,
          endPoint,
          type: type3,
          properties,
          text: text === null || text === void 0 ? void 0 : text.value
        };
        if (edgeModel.virtual) {
          _this.graphModel.deleteEdgeById(edgeModel.id);
        }
        var targetNodeIdGroup = _this.graphModel.group.getNodeGroup(targetNodeId);
        if (!targetNodeIdGroup) {
          targetNodeIdGroup = _this.graphModel.getNodeModelById(targetNodeId);
        }
        var sourceNodeIdGroup = _this.graphModel.group.getNodeGroup(sourceNodeId);
        if (!sourceNodeIdGroup) {
          sourceNodeIdGroup = _this.graphModel.getNodeModelById(sourceNodeId);
        }
        if (isFolded && edgeModel.visible !== false) {
          if (_this.children.has(sourceNodeId) || _this.id === sourceNodeId) {
            data.startPoint = void 0;
            data.sourceNodeId = _this.id;
          } else {
            data.endPoint = void 0;
            data.targetNodeId = _this.id;
          }
          if (targetNodeIdGroup.id !== _this.id || sourceNodeIdGroup.id !== _this.id) {
            _this.createVirtualEdge(data);
          }
          edgeModel.visible = false;
        }
        if (!isFolded && edgeModel.visible === false) {
          if (targetNodeIdGroup && targetNodeIdGroup.isGroup && targetNodeIdGroup.isFolded) {
            data.targetNodeId = targetNodeIdGroup.id;
            data.endPoint = void 0;
            _this.createVirtualEdge(data);
          } else if (sourceNodeIdGroup && sourceNodeIdGroup.isGroup && sourceNodeIdGroup.isFolded) {
            data.sourceNodeId = sourceNodeIdGroup.id;
            data.startPoint = void 0;
            _this.createVirtualEdge(data);
          } else {
            edgeModel.visible = true;
          }
        }
      });
    };
    GroupNodeModel2.prototype.createVirtualEdge = function(edgeData) {
      edgeData.pointsList = void 0;
      var model = this.graphModel.addEdge(edgeData);
      model.virtual = true;
      model.text.editable = false;
      model.isFoldedEdge = true;
    };
    GroupNodeModel2.prototype.isInRange = function(_a) {
      var minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;
      return minX >= this.x - this.width / 2 && maxX <= this.x + this.width / 2 && minY >= this.y - this.height / 2 && maxY <= this.y + this.height / 2;
    };
    GroupNodeModel2.prototype.isAllowMoveTo = function(_a) {
      var minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;
      return {
        x: minX >= this.x - this.width / 2 && maxX <= this.x + this.width / 2,
        y: minY >= this.y - this.height / 2 && maxY <= this.y + this.height / 2
      };
    };
    GroupNodeModel2.prototype.setAllowAppendChild = function(isAllow) {
      this.setProperty("groupAddable", isAllow);
    };
    GroupNodeModel2.prototype.addChild = function(id) {
      this.children.add(id);
      this.graphModel.eventCenter.emit("group:add-node", { data: this.getData() });
    };
    GroupNodeModel2.prototype.removeChild = function(id) {
      this.children.delete(id);
      this.graphModel.eventCenter.emit("group:remove-node", {
        data: this.getData()
      });
    };
    GroupNodeModel2.prototype.getAddableOutlineStyle = function() {
      return {
        stroke: "#FEB663",
        strokeWidth: 2,
        strokeDasharray: "4 4",
        fill: "transparent"
      };
    };
    GroupNodeModel2.prototype.getData = function() {
      var _this = this;
      var data = _super.prototype.getData.call(this);
      data.children = [];
      console.log("this.children", this.children);
      this.children.forEach(function(childId) {
        var model = _this.graphModel.getNodeModelById(childId);
        if (model && !model.virtual) {
          ;
          data.children.push(childId);
        }
      });
      var properties = data.properties;
      properties === null || properties === void 0 ? true : delete properties.groupAddable;
      properties === null || properties === void 0 ? true : delete properties.isFolded;
      return data;
    };
    GroupNodeModel2.prototype.getHistoryData = function() {
      var data = _super.prototype.getData.call(this);
      data.children = __spreadArray7([], __read9(this.children), false);
      data.isGroup = true;
      var properties = data.properties;
      properties === null || properties === void 0 ? true : delete properties.groupAddable;
      if (properties === null || properties === void 0 ? void 0 : properties.isFolded) {
        data.x = data.x + this.unfoldedWidth / 2 - this.foldedWidth / 2;
        data.y = data.y + this.unfoldedHeight / 2 - this.foldedHeight / 2;
      }
      return data;
    };
    GroupNodeModel2.prototype.isAllowAppendIn = function(_nodeData) {
      console.info("_nodeData", _nodeData);
      return true;
    };
    GroupNodeModel2.prototype.toBack = function() {
      this.zIndex--;
    };
    return GroupNodeModel2;
  }(RectResizeModel)
);
var GroupNode = (
  /** @class */
  function(_super) {
    __extends21(GroupNode2, _super);
    function GroupNode2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    GroupNode2.prototype.getControlGroup = function() {
      var _a = this.props.model, resizable = _a.resizable, properties = _a.properties;
      return resizable && !properties.isFolded ? _super.prototype.getControlGroup.call(this) : null;
    };
    GroupNode2.prototype.getAddableShape = function() {
      var _a = this.props.model, width = _a.width, height = _a.height, x2 = _a.x, y = _a.y, radius = _a.radius, properties = _a.properties, getAddableOutlineStyle = _a.getAddableOutlineStyle;
      if (!properties.groupAddable)
        return null;
      var _b = this.props.model.getNodeStyle().strokeWidth, strokeWidth = _b === void 0 ? 0 : _b;
      var style2 = getAddableOutlineStyle();
      var newWidth = width + strokeWidth + 8;
      var newHeight = height + strokeWidth + 8;
      return g("rect", __assign16(__assign16({}, style2), { width: newWidth, height: newHeight, x: x2 - newWidth / 2, y: y - newHeight / 2, rx: radius, ry: radius }));
    };
    GroupNode2.prototype.getFoldIcon = function() {
      var model = this.props.model;
      var foldX = model.x - model.width / 2 + 5;
      var foldY = model.y - model.height / 2 + 5;
      if (!model.foldable)
        return null;
      var iconIcon = g("path", {
        fill: "none",
        stroke: "#818281",
        strokeWidth: 2,
        "pointer-events": "none",
        d: model.properties.isFolded ? "M ".concat(foldX + 3, ",").concat(foldY + 6, " ").concat(foldX + 11, ",").concat(foldY + 6, " M").concat(foldX + 7, ",").concat(foldY + 2, " ").concat(foldX + 7, ",").concat(foldY + 10) : "M ".concat(foldX + 3, ",").concat(foldY + 6, " ").concat(foldX + 11, ",").concat(foldY + 6, " ")
      });
      return g("g", {}, [
        g("rect", {
          height: 12,
          width: 14,
          rx: 2,
          ry: 2,
          strokeWidth: 1,
          fill: "#F4F5F6",
          stroke: "#CECECE",
          cursor: "pointer",
          x: model.x - model.width / 2 + 5,
          y: model.y - model.height / 2 + 5,
          onClick: function() {
            ;
            model.foldGroup(!model.properties.isFolded);
          }
        }),
        iconIcon
      ]);
    };
    GroupNode2.prototype.getResizeShape = function() {
      return g("g", {}, [
        this.getAddableShape(),
        _super.prototype.getResizeShape.call(this),
        this.getFoldIcon()
      ]);
    };
    return GroupNode2;
  }(RectResizeView)
);
var GroupNode_default = {
  type: "group",
  view: GroupNode,
  model: GroupNodeModel
};

// node_modules/@logicflow/extension/es/materials/group/index.js
var __assign17 = function() {
  __assign17 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign17.apply(this, arguments);
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __read10 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray8 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DEFAULT_TOP_Z_INDEX = -1e3;
var DEFAULT_BOTTOM_Z_INDEX2 = -1e4;
var Group = (
  /** @class */
  function() {
    function Group2(_a) {
      var lf = _a.lf;
      var _this = this;
      this.topGroupZIndex = DEFAULT_BOTTOM_Z_INDEX2;
      this.nodeGroupMap = /* @__PURE__ */ new Map();
      this.graphRendered = function(_a2) {
        var data = _a2.data;
        if (data && data.nodes) {
          data.nodes.forEach(function(node2) {
            if (node2.children) {
              ;
              node2.children.forEach(function(nodeId) {
                _this.nodeGroupMap.set(nodeId, node2.id);
              });
            }
          });
          _this.checkAndCorrectTopGroupZIndex(data.nodes);
        }
      };
      this.appendNodeToGroup = function(_a2) {
        var data = _a2.data;
        var preGroupId = _this.nodeGroupMap.get(data.id);
        if (preGroupId) {
          var preGroup = _this.lf.getNodeModelById(preGroupId);
          preGroup.removeChild(data.id);
          _this.nodeGroupMap.delete(data.id);
          preGroup.setAllowAppendChild(false);
        }
        var nodeModel = _this.lf.getNodeModelById(data.id);
        var bounds = nodeModel === null || nodeModel === void 0 ? void 0 : nodeModel.getBounds();
        if (bounds && nodeModel) {
          var group = _this.getGroup(bounds, data);
          if (nodeModel.isGroup) {
            ;
            data.children.forEach(function(nodeId) {
              _this.nodeGroupMap.set(nodeId, data.id);
            });
            _this.checkAndCorrectTopGroupZIndex([data]);
            _this.nodeSelected({
              data,
              isSelected: false,
              isMultiple: false
            });
          }
          if (!group)
            return;
          var isAllowAppendIn = group.isAllowAppendIn(data);
          if (!isAllowAppendIn) {
            _this.lf.emit("group:not-allowed", {
              group: group.getData(),
              node: data
            });
            return;
          }
          group.addChild(data.id);
          _this.nodeGroupMap.set(data.id, group.id);
          group.setAllowAppendChild(false);
        }
      };
      this.deleteGroupChild = function(_a2) {
        var data = _a2.data;
        if (data.children) {
          ;
          data.children.forEach(function(nodeId) {
            _this.nodeGroupMap.delete(nodeId);
            _this.lf.deleteNode(nodeId);
          });
        }
        var groupId = _this.nodeGroupMap.get(data.id);
        if (groupId) {
          var group = _this.lf.getNodeModelById(groupId);
          group.removeChild(data.id);
          _this.nodeGroupMap.delete(data.id);
        }
      };
      this.setActiveGroup = function(_a2) {
        var data = _a2.data;
        var nodeModel = _this.lf.getNodeModelById(data.id);
        var bounds = nodeModel === null || nodeModel === void 0 ? void 0 : nodeModel.getBounds();
        if (nodeModel && bounds) {
          var newGroup = _this.getGroup(bounds, data);
          if (_this.activeGroup) {
            _this.activeGroup.setAllowAppendChild(false);
          }
          if (!newGroup || nodeModel.isGroup && newGroup.id === data.id)
            return;
          var isAllowAppendIn = newGroup.isAllowAppendIn(data);
          if (!isAllowAppendIn) {
            return;
          }
          _this.activeGroup = newGroup;
          _this.activeGroup.setAllowAppendChild(true);
        }
      };
      this.findNodeAndChildMaxZIndex = function(nodeModel) {
        var maxZIndex = DEFAULT_BOTTOM_Z_INDEX2;
        if (nodeModel.isGroup) {
          maxZIndex = Math.max(maxZIndex, nodeModel.zIndex);
        }
        if (nodeModel.children) {
          ;
          nodeModel.children.forEach(function(nodeId) {
            if (typeof nodeId === "object") {
              nodeId = nodeId.id;
            }
            var child = _this.lf.getNodeModelById(nodeId);
            if (child === null || child === void 0 ? void 0 : child.isGroup) {
              var childMaxZIndex = _this.findNodeAndChildMaxZIndex(child);
              maxZIndex = Math.max(childMaxZIndex, maxZIndex);
            }
          });
        }
        return maxZIndex;
      };
      this.checkAndCorrectTopGroupZIndex = function(nodes) {
        var maxZIndex = DEFAULT_BOTTOM_Z_INDEX2;
        nodes.forEach(function(node2) {
          var nodeModel = _this.lf.getNodeModelById(node2.id);
          if (nodeModel) {
            var currentNodeMaxZIndex = _this.findNodeAndChildMaxZIndex(nodeModel);
            if (currentNodeMaxZIndex > maxZIndex) {
              maxZIndex = currentNodeMaxZIndex;
            }
          }
        });
        if (_this.topGroupZIndex >= maxZIndex) {
          return;
        }
        var allGroupNodes = _this.lf.graphModel.nodes.filter(function(node2) {
          return node2.isGroup;
        });
        var max = _this.topGroupZIndex;
        for (var i = 0; i < allGroupNodes.length; i++) {
          var groupNode = allGroupNodes[i];
          if (groupNode.zIndex > max) {
            max = groupNode.zIndex;
          }
        }
        _this.topGroupZIndex = max;
      };
      this.nodeSelected = function(_a2) {
        var data = _a2.data, isMultiple = _a2.isMultiple, isSelected = _a2.isSelected;
        var nodeModel = _this.lf.getNodeModelById(data.id);
        _this.toFrontGroup(nodeModel);
        if (_this.topGroupZIndex > DEFAULT_TOP_Z_INDEX) {
          _this.topGroupZIndex = DEFAULT_BOTTOM_Z_INDEX2;
          var allGroups = _this.lf.graphModel.nodes.filter(function(node2) {
            return node2.isGroup;
          }).sort(function(a, b2) {
            return a.zIndex - b2.zIndex;
          });
          var preZIndex = 0;
          for (var i = 0; i < allGroups.length; i++) {
            var group = allGroups[i];
            if (group.zIndex !== preZIndex) {
              _this.topGroupZIndex++;
              preZIndex = group.zIndex;
            }
            group.setZIndex(_this.topGroupZIndex);
          }
        }
        if (isMultiple && isSelected) {
          if (nodeModel === null || nodeModel === void 0 ? void 0 : nodeModel.isGroup) {
            ;
            nodeModel.children.forEach(function(child) {
              var childModel = _this.lf.graphModel.getElement(child);
              childModel === null || childModel === void 0 ? void 0 : childModel.setSelected(false);
            });
          } else {
            var groupId = _this.nodeGroupMap.get(data.id);
            if (groupId) {
              var groupModel = _this.lf.getNodeModelById(groupId);
              (groupModel === null || groupModel === void 0 ? void 0 : groupModel.isSelected) && (nodeModel === null || nodeModel === void 0 ? void 0 : nodeModel.setSelected(false));
            }
          }
        }
      };
      this.toFrontGroup = function(model) {
        if (!model || !model.isGroup) {
          return;
        }
        _this.topGroupZIndex++;
        model.setZIndex(_this.topGroupZIndex);
        if (model.children) {
          ;
          model.children.forEach(function(nodeId) {
            var node2 = _this.lf.getNodeModelById(nodeId);
            _this.toFrontGroup(node2);
          });
        }
      };
      lf.register(GroupNode_default);
      this.lf = lf;
      lf.graphModel.addNodeMoveRules(function(model, deltaX, deltaY) {
        if (model.isGroup) {
          var nodeIds = _this.getNodeAllChild(model);
          lf.graphModel.moveNodes(nodeIds, deltaX, deltaY, true);
          return true;
        }
        var groupModel = lf.getNodeModelById(_this.nodeGroupMap.get(model.id));
        if (groupModel && groupModel.isRestrict) {
          var _a2 = model.getBounds(), minX = _a2.minX, minY = _a2.minY, maxX = _a2.maxX, maxY = _a2.maxY;
          return groupModel.isAllowMoveTo({
            minX: minX + deltaX,
            minY: minY + deltaY,
            maxX: maxX + deltaX,
            maxY: maxY + deltaY
          });
        }
        return true;
      });
      lf.graphModel.group = this;
      lf.on("node:add,node:drop,node:dnd-add", this.appendNodeToGroup);
      lf.on("node:delete", this.deleteGroupChild);
      lf.on("node:dnd-drag,node:drag", this.setActiveGroup);
      lf.on("node:click", this.nodeSelected);
      lf.on("graph:rendered", this.graphRendered);
      lf.addElements = function(_a2, distance) {
        var selectedNodes = _a2.nodes, selectedEdges = _a2.edges;
        var nodeIdMap = {};
        var elements = {
          nodes: [],
          edges: []
        };
        var groupInnerEdges = [];
        forEach_default(selectedNodes, function(node2) {
          var preId = node2.id;
          var children = node2.children, rest = __rest(node2, ["children"]);
          var nodeModel = lf.addNode(rest);
          if (!nodeModel) {
            return {
              nodes: [],
              edges: []
            };
          }
          if (preId)
            nodeIdMap[preId] = nodeModel.id;
          elements.nodes.push(nodeModel);
          var edgesArray = _this.createAllChildNodes(nodeIdMap, children, nodeModel, distance).edgesArray;
          groupInnerEdges.push.apply(groupInnerEdges, __spreadArray8([], __read10(edgesArray), false));
        });
        groupInnerEdges.forEach(function(edge) {
          _this.createEdgeModel(edge, nodeIdMap, distance);
        });
        forEach_default(selectedEdges, function(edge) {
          var edgeModel = _this.createEdgeModel(edge, nodeIdMap, 0);
          elements.edges.push(edgeModel);
        });
        return elements;
      };
    }
    Group2.prototype.createAllChildNodes = function(nodeIdMap, children, current, distance) {
      var _this = this;
      var lf = this.lf;
      var edgesDataArray = [];
      var edgesNodeModelArray = [];
      var nodesArray = [];
      children === null || children === void 0 ? void 0 : children.forEach(function(childId) {
        var childNodeModel = lf.getNodeModelById(childId);
        if (childNodeModel) {
          var x2 = childNodeModel.x, y = childNodeModel.y, properties = childNodeModel.properties, type3 = childNodeModel.type, rotate = childNodeModel.rotate, children_1 = childNodeModel.children;
          var nodeConfig = {
            x: x2 + distance,
            y: y + distance,
            properties,
            type: type3,
            rotate
            // 如果不传递type，会自动触发NODE_ADD
            // 有概率触发appendToGroup
          };
          var eventType = EventType.NODE_GROUP_COPY || "node:group-copy-add";
          var newChildModel = lf.addNode(nodeConfig, eventType);
          current.addChild(newChildModel.id);
          nodeIdMap[childId] = newChildModel.id;
          nodesArray.push(newChildModel);
          childNodeModel.incoming.edges.forEach(function(edge) {
            edgesNodeModelArray.push(edge);
          });
          childNodeModel.outgoing.edges.forEach(function(edge) {
            edgesNodeModelArray.push(edge);
          });
          if (children_1 instanceof Set) {
            var _a = _this.createAllChildNodes(nodeIdMap, children_1, newChildModel, distance), childNodes = _a.nodesArray, childEdges = _a.edgesArray;
            nodesArray.push.apply(nodesArray, __spreadArray8([], __read10(childNodes), false));
            edgesDataArray.push.apply(edgesDataArray, __spreadArray8([], __read10(childEdges), false));
          }
        }
      });
      var filterEdgesArray = edgesNodeModelArray.filter(function(edge) {
        return nodeIdMap[edge.sourceNodeId] && nodeIdMap[edge.targetNodeId];
      });
      var filterEdgesDataArray = filterEdgesArray.map(function(item) {
        return item.getData();
      });
      return {
        nodesArray,
        edgesArray: edgesDataArray.concat(filterEdgesDataArray)
        // ??? what's this
      };
    };
    Group2.prototype.createEdgeModel = function(edge, nodeIdMap, distance) {
      var lf = this.lf;
      var sourceId = edge.sourceNodeId;
      var targetId = edge.targetNodeId;
      if (nodeIdMap[sourceId])
        sourceId = nodeIdMap[sourceId];
      if (nodeIdMap[targetId])
        targetId = nodeIdMap[targetId];
      var type3 = edge.type, startPoint = edge.startPoint, endPoint = edge.endPoint, pointsList = edge.pointsList, text = edge.text;
      var newStartPoint = {
        x: ((startPoint === null || startPoint === void 0 ? void 0 : startPoint.x) || 0) + distance,
        y: ((startPoint === null || startPoint === void 0 ? void 0 : startPoint.y) || 0) + distance
      };
      var newEndPoint = {
        x: ((endPoint === null || endPoint === void 0 ? void 0 : endPoint.x) || 0) + distance,
        y: ((endPoint === null || endPoint === void 0 ? void 0 : endPoint.y) || 0) + distance
      };
      var newPointsList = [];
      if (pointsList && pointsList.length > 0) {
        newPointsList = pointsList.map(function(point) {
          point.x += distance;
          point.y += distance;
          return point;
        });
      }
      var edgeConfig = {
        type: type3,
        startPoint: newStartPoint,
        endPoint: newEndPoint,
        sourceNodeId: sourceId,
        targetNodeId: targetId,
        pointsList: newPointsList
      };
      if (isObject_default(text) && !isEmpty_default(text)) {
        edgeConfig.text = __assign17(__assign17({}, text), { x: (text === null || text === void 0 ? void 0 : text.x) + distance, y: (text === null || text === void 0 ? void 0 : text.y) + distance });
      }
      return lf.graphModel.addEdge(edgeConfig);
    };
    Group2.prototype.getNodeAllChild = function(model) {
      var _this = this;
      var nodeIds = [];
      if (model.children) {
        ;
        model.children.forEach(function(nodeId) {
          nodeIds.push(nodeId);
          var nodeModel = _this.lf.getNodeModelById(nodeId);
          if (nodeModel === null || nodeModel === void 0 ? void 0 : nodeModel.isGroup) {
            nodeIds = nodeIds.concat(_this.getNodeAllChild(nodeModel));
          }
        });
      }
      return nodeIds;
    };
    Group2.prototype.getGroup = function(bounds, nodeData) {
      var nodes = this.lf.graphModel.nodes;
      var groups = nodes.filter(function(node2) {
        return node2.isGroup && node2.isInRange(bounds) && node2.id !== nodeData.id;
      });
      if (groups.length === 0)
        return;
      if (groups.length === 1)
        return groups[0];
      var topGroup = groups[groups.length - 1];
      for (var i = groups.length - 2; i >= 0; i--) {
        if (groups[i].zIndex > topGroup.zIndex) {
          topGroup = groups[i];
        }
      }
      return topGroup;
    };
    Group2.prototype.getNodeGroup = function(nodeId) {
      var groupId = this.nodeGroupMap.get(nodeId);
      if (groupId) {
        return this.lf.getNodeModelById(groupId);
      }
    };
    Group2.prototype.render = function() {
    };
    Group2.prototype.destroy = function() {
    };
    Group2.pluginName = "group";
    return Group2;
  }()
);

// node_modules/@logicflow/extension/es/bpmn-elements/presets/Task/subProcess.js
var __extends22 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign18 = function() {
  __assign18 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign18.apply(this, arguments);
};
function SubProcessFactory() {
  var view = (
    /** @class */
    function(_super) {
      __extends22(view2, _super);
      function view2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      view2.prototype.getFoldIcon = function() {
        var model2 = this.props.model;
        var _a = model2, x2 = _a.x, y = _a.y, width = _a.width, height = _a.height, properties = _a.properties, foldable = _a.foldable;
        var foldX = model2.x - model2.width / 2 + 5;
        var foldY = model2.y - model2.height / 2 + 5;
        if (!foldable)
          return null;
        var iconIcon = g("path", {
          fill: "none",
          stroke: "#818281",
          strokeWidth: 2,
          "pointer-events": "none",
          d: properties.isFolded ? "M ".concat(foldX + 3, ",").concat(foldY + 6, " ").concat(foldX + 11, ",").concat(foldY + 6, " M").concat(foldX + 7, ",").concat(foldY + 2, " ").concat(foldX + 7, ",").concat(foldY + 10) : "M ".concat(foldX + 3, ",").concat(foldY + 6, " ").concat(foldX + 11, ",").concat(foldY + 6, " ")
        });
        return g("g", {}, [
          g("rect", {
            height: 12,
            width: 14,
            rx: 2,
            ry: 2,
            strokeWidth: 1,
            fill: "#F4F5F6",
            stroke: "#CECECE",
            cursor: "pointer",
            x: x2 - width / 2 + 5,
            y: y - height / 2 + 5,
            onClick: function(e) {
              var _a2, _b;
              e.stopPropagation();
              (_b = (_a2 = model2).foldGroup) === null || _b === void 0 ? void 0 : _b.call(_a2, !properties.isFolded);
            }
          }),
          iconIcon
        ]);
      };
      view2.prototype.getResizeShape = function() {
        var model2 = this.props.model;
        var x2 = model2.x, y = model2.y, width = model2.width, height = model2.height;
        var style2 = model2.getNodeStyle();
        var foldRectAttrs = __assign18(__assign18({}, style2), { x: x2 - width / 2, y: y - height / 2, width, height, stroke: "black", strokeWidth: 2, strokeDasharray: "0 0" });
        return g("g", {}, [
          // this.getAddAbleShape(),
          g("rect", __assign18({}, foldRectAttrs)),
          this.getFoldIcon()
        ]);
      };
      return view2;
    }(GroupNode)
  );
  var model = (
    /** @class */
    function(_super) {
      __extends22(model2, _super);
      function model2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      model2.prototype.initNodeData = function(data) {
        _super.prototype.initNodeData.call(this, data);
        this.foldable = true;
        this.resizable = true;
        this.width = 400;
        this.height = 200;
        this.resetWidthHeight();
        this.isTaskNode = true;
        this.boundaryEvents = [];
      };
      model2.prototype.resetWidthHeight = function() {
        var _a, _b;
        var width = (_a = this.properties.iniProp) === null || _a === void 0 ? void 0 : _a.width;
        var height = (_b = this.properties.iniProp) === null || _b === void 0 ? void 0 : _b.height;
        width && (this.width = width);
        height && (this.height = height);
      };
      model2.prototype.getNodeStyle = function() {
        var style2 = _super.prototype.getNodeStyle.call(this);
        style2.stroke = "#989891";
        style2.strokeWidth = 1;
        style2.strokeDasharray = "3 3";
        if (this.isSelected) {
          style2.stroke = "rgb(124, 15, 255)";
        }
        var isBoundaryEventTouchingTask = this.properties.isBoundaryEventTouchingTask;
        if (isBoundaryEventTouchingTask) {
          style2.stroke = "#00acff";
          style2.strokeWidth = 2;
        }
        return style2;
      };
      model2.prototype.addChild = function(id) {
        var model3 = this.graphModel.getElement(id);
        model3 === null || model3 === void 0 ? void 0 : model3.setProperties({
          parent: this.id
        });
        _super.prototype.addChild.call(this, id);
      };
      model2.prototype.getAnchorStyle = function() {
        var style2 = _super.prototype.getAnchorStyle.call(this);
        style2.stroke = "#000";
        style2.fill = "#fff";
        if (!style2.hover) {
          style2.hover = {};
        }
        style2.hover.stroke = "transparent";
        return style2;
      };
      model2.prototype.getOutlineStyle = function() {
        var style2 = _super.prototype.getOutlineStyle.call(this);
        style2.stroke = "transparent";
        if (!style2.hover) {
          style2.hover = {};
        }
        style2.hover.stroke = "transparent";
        return style2;
      };
      model2.prototype.setTouching = function(flag) {
        this.setProperty("isBoundaryEventTouchingTask", flag);
      };
      model2.prototype.addBoundaryEvent = function(nodeId) {
        this.setTouching(false);
        if (this.boundaryEvents.find(function(item) {
          return item === nodeId;
        })) {
          return false;
        }
        var boundaryEvent2 = this.graphModel.getNodeModelById(nodeId);
        boundaryEvent2 === null || boundaryEvent2 === void 0 ? void 0 : boundaryEvent2.setProperties({
          attachedToRef: this.id
        });
        this.boundaryEvents.push(nodeId);
        return true;
      };
      model2.prototype.deleteBoundaryEvent = function(nodeId) {
        this.boundaryEvents = this.boundaryEvents.filter(function(item) {
          return item !== nodeId;
        });
      };
      return model2;
    }(GroupNodeModel)
  );
  return {
    type: "bpmn:subProcess",
    view,
    model
  };
}

// node_modules/@logicflow/extension/es/bpmn-elements/presets/Task/index.js
var __values = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function boundaryEvent(lf) {
  lf.on("node:drag,node:dnd-drag", checkAppendBoundaryEvent);
  lf.on("node:drop,node:dnd-add", appendBoundaryEvent);
  lf.graphModel.addNodeMoveRules(function(model, deltaX, deltaY) {
    if (model.isTaskNode) {
      var nodeIds = model.boundaryEvents;
      lf.graphModel.moveNodes(nodeIds, deltaX, deltaY, true);
      return true;
    }
    return true;
  });
  function appendBoundaryEvent(_a) {
    var e_1, _b;
    var data = _a.data;
    var type3 = data.type, id = data.id;
    if (type3 !== "bpmn:boundaryEvent") {
      return;
    }
    var nodes = lf.graphModel.nodes;
    try {
      for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {
        var node2 = nodes_1_1.value;
        if (node2.isTaskNode) {
          var nodeId = null;
          if ((nodeId = isBoundaryEventCloseToTask(node2, data)) !== null) {
            var eventModel = lf.graphModel.getNodeModelById(id);
            var nodeModel = lf.graphModel.getNodeModelById(nodeId);
            var attachedToRef = eventModel.properties.attachedToRef;
            if (attachedToRef && attachedToRef !== nodeId) {
              lf.graphModel.getNodeModelById(attachedToRef).deleteBoundaryEvent(id);
            }
            nodeModel.addBoundaryEvent(id);
            return;
          }
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (nodes_1_1 && !nodes_1_1.done && (_b = nodes_1.return)) _b.call(nodes_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  }
  function checkAppendBoundaryEvent(_a) {
    var e_2, _b;
    var data = _a.data;
    var type3 = data.type;
    if (type3 !== "bpmn:boundaryEvent") {
      return;
    }
    var nodes = lf.graphModel.nodes;
    try {
      for (var nodes_2 = __values(nodes), nodes_2_1 = nodes_2.next(); !nodes_2_1.done; nodes_2_1 = nodes_2.next()) {
        var node2 = nodes_2_1.value;
        if (node2.isTaskNode) {
          if (isBoundaryEventCloseToTask(node2, data)) {
            node2.setTouching(true);
          } else {
            node2.setTouching(false);
          }
        }
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (nodes_2_1 && !nodes_2_1.done && (_b = nodes_2.return)) _b.call(nodes_2);
      } finally {
        if (e_2) throw e_2.error;
      }
    }
  }
  function isBoundaryEventCloseToTask(task, event) {
    var offset = 5;
    var tx = task.x, ty = task.y, twidth = task.width, theight = task.height, id = task.id;
    var bbox = {
      minX: tx - twidth / 2,
      maxX: tx + twidth / 2,
      minY: ty - theight / 2,
      maxY: ty + theight / 2
    };
    var bx = event.x, by = event.y;
    var outerBBox = {
      minX: bbox.minX - offset,
      maxX: bbox.maxX + offset,
      minY: bbox.minY - offset,
      maxY: bbox.maxY + offset
    };
    var innerBBox = {
      minX: bbox.minX + offset,
      maxX: bbox.maxX - offset,
      minY: bbox.minY + offset,
      maxY: bbox.maxY - offset
    };
    if (bx > outerBBox.minX && bx < outerBBox.maxX && by > outerBBox.minY && by < outerBBox.maxY) {
      if (!(bx > innerBBox.minX && bx < innerBBox.maxX && by > innerBBox.minY && by < innerBBox.maxY)) {
        return id;
      }
    }
    return null;
  }
}
function registerTaskNodes(lf) {
  var ServiceTask2 = TaskNodeFactory("bpmn:serviceTask", serviceTaskIcon);
  var UserTask2 = TaskNodeFactory("bpmn:userTask", userTaskIcon);
  lf.register(ServiceTask2);
  lf.register(UserTask2);
  lf.register(SubProcessFactory());
  boundaryEvent(lf);
}

// node_modules/@logicflow/extension/es/bpmn-elements/presets/Flow/sequenceFlow.js
var __extends23 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign19 = function() {
  __assign19 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign19.apply(this, arguments);
};
function sequenceFlowFactory(props) {
  var model = (
    /** @class */
    function(_super) {
      __extends23(model2, _super);
      function model2(data, graphModel) {
        if (!data.id) {
          data.id = "Flow_".concat(genBpmnId());
        }
        var properties = __assign19(__assign19(__assign19({}, props || {}), data.properties), {
          // panels: ['condition'],
          isDefaultFlow: false
        });
        data.properties = properties;
        return _super.call(this, data, graphModel) || this;
      }
      model2.extendKey = "SequenceFlowModel";
      return model2;
    }(PolylineEdgeModel)
  );
  var view = (
    /** @class */
    function(_super) {
      __extends23(view2, _super);
      function view2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      view2.prototype.getStartArrow = function() {
        var model2 = this.props.model;
        var isDefaultFlow = model2.properties.isDefaultFlow;
        return isDefaultFlow ? g("path", {
          refX: 15,
          stroke: "#000000",
          strokeWidth: 2,
          d: "M 20 5 10 -5 z"
        }) : g("path", {
          d: ""
        });
      };
      view2.extendKey = "SequenceFlowEdge";
      return view2;
    }(PolylineEdge)
  );
  return {
    type: "bpmn:sequenceFlow",
    view,
    model
  };
}

// node_modules/@logicflow/extension/es/bpmn-elements/presets/Flow/index.js
var SequenceFlow2 = sequenceFlowFactory();
function registerFlows(lf) {
  lf.register(SequenceFlow2);
}

// node_modules/@logicflow/extension/es/bpmn-elements/index.js
var __read11 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var definitionConfig = [
  {
    nodes: ["startEvent", "intermediateCatchEvent", "boundaryEvent"],
    definition: [
      {
        type: "bpmn:timerEventDefinition",
        icon: timerIcon,
        properties: {
          definitionType: "bpmn:timerEventDefinition",
          timerValue: "",
          timerType: ""
        }
      }
    ]
  }
];
function useDefinition(definition) {
  function setDefinition(config) {
    function set(nodes, definitions) {
      nodes.forEach(function(name) {
        if (!(definition === null || definition === void 0 ? void 0 : definition[name])) {
          definition[name] = /* @__PURE__ */ new Map();
        }
        var map = definition === null || definition === void 0 ? void 0 : definition[name];
        definitions.forEach(function(define2) {
          map.set(define2.type, define2);
        });
      });
      return definition;
    }
    config.forEach(function(define2) {
      set(define2.nodes, define2.definition);
    });
  }
  return function() {
    return [definition, setDefinition];
  };
}
var BPMNElements = (
  /** @class */
  function() {
    function BPMNElements2(_a) {
      var lf = _a.lf;
      lf.definition = {};
      lf.useDefinition = useDefinition(lf.definition);
      var _b = __read11(lf.useDefinition(), 2), _definition = _b[0], setDefinition = _b[1];
      console.log("_definition", _definition);
      setDefinition(definitionConfig);
      registerEventNodes(lf);
      registerGatewayNodes(lf);
      registerFlows(lf);
      registerTaskNodes(lf);
      lf.setDefaultEdgeType("bpmn:sequenceFlow");
    }
    BPMNElements2.pluginName = "BpmnElementsPlugin";
    return BPMNElements2;
  }()
);

// node_modules/@logicflow/extension/es/bpmn-elements-adapter/constant.js
var StartEventConfig2 = {
  width: 40,
  height: 40
};
var EndEventConfig2 = {
  width: 40,
  height: 40
};
var BoundaryEventConfig = {
  width: 100,
  height: 80
};
var IntermediateEventConfig = {
  width: 100,
  height: 80
};
var ParallelGatewayConfig = {
  width: 100,
  height: 80
};
var InclusiveGatewayConfig = {
  width: 100,
  height: 80
};
var ExclusiveGatewayConfig2 = {
  width: 100,
  height: 80
};
var ServiceTaskConfig2 = {
  width: 100,
  height: 80
};
var UserTaskConfig2 = {
  width: 100,
  height: 80
};
var SubProcessConfig = {
  width: 100,
  height: 80
};

// node_modules/@logicflow/extension/es/bpmn-elements-adapter/xml2json.js
var XML2 = function() {
};
XML2.ObjTree = function() {
  return this;
};
XML2.ObjTree.VERSION = "0.23";
XML2.ObjTree.prototype.xmlDecl = '<?xml version="1.0" encoding="UTF-8" ?>\n';
XML2.ObjTree.prototype.attr_prefix = "-";
XML2.ObjTree.prototype.parseXML = function(xml) {
  var root;
  if (window.DOMParser) {
    var xmldom = new DOMParser();
    var dom = xmldom.parseFromString(xml, "application/xml");
    if (!dom)
      return;
    root = dom.documentElement;
  } else if (window.ActiveXObject) {
    xmldom = new ActiveXObject("Microsoft.XMLDOM");
    xmldom.async = false;
    xmldom.loadXML(xml);
    root = xmldom.documentElement;
  }
  if (!root)
    return;
  var data = this.parseDOM(root);
  return data;
};
XML2.ObjTree.prototype.parseHTTP = function(url, options, callback) {
  var myOpt = {};
  for (var key in options) {
    myOpt[key] = options[key];
  }
  if (!myOpt.method) {
    if (typeof myOpt.postBody === "undefined" && typeof myOpt.postbody === "undefined" && typeof myOpt.parameters === "undefined") {
      myOpt.method = "get";
    } else {
      myOpt.method = "post";
    }
  }
  if (callback) {
    myOpt.asynchronous = true;
    var __this_1 = this;
    var __func_1 = callback;
    var __save_1 = myOpt.onComplete;
    myOpt.onComplete = function(trans2) {
      var tree;
      if (trans2 && trans2.responseXML && trans2.responseXML.documentElement) {
        tree = __this_1.parseDOM(trans2.responseXML.documentElement);
      }
      __func_1(tree, trans2);
      if (__save_1)
        __save_1(trans2);
    };
  } else {
    myOpt.asynchronous = false;
  }
  var trans;
  if (typeof HTTP !== "undefined" && HTTP.Request) {
    myOpt.uri = url;
    var req = new HTTP.Request(myOpt);
    if (req)
      trans = req.transport;
  } else if (typeof Ajax !== "undefined" && Ajax.Request) {
    var req = new Ajax.Request(url, myOpt);
    if (req)
      trans = req.transport;
  }
  if (callback)
    return trans;
  if (trans && trans.responseXML && trans.responseXML.documentElement) {
    return this.parseDOM(trans.responseXML.documentElement);
  }
};
XML2.ObjTree.prototype.parseDOM = function(root) {
  if (!root)
    return;
  this.__force_array = {};
  if (this.force_array) {
    for (var i = 0; i < this.force_array.length; i++) {
      this.__force_array[this.force_array[i]] = 1;
    }
  }
  var json = this.parseElement(root);
  if (this.__force_array[root.nodeName]) {
    json = [json];
  }
  if (root.nodeType !== 11) {
    var tmp = {};
    tmp[root.nodeName] = json;
    json = tmp;
  }
  return json;
};
XML2.ObjTree.prototype.parseElement = function(elem) {
  if (elem.nodeType === 7) {
    return;
  }
  if (elem.nodeType === 3 || elem.nodeType === 4 || elem.nodeType === 8) {
    var bool = elem.nodeValue.match(/[^\x00-\x20]/);
    if (bool == null)
      return;
    return elem.nodeValue;
  }
  var retVal = null;
  var cnt = {};
  if (elem.attributes && elem.attributes.length) {
    retVal = {};
    for (var i = 0; i < elem.attributes.length; i++) {
      var key = elem.attributes[i].nodeName;
      if (typeof key !== "string")
        continue;
      var val = elem.attributes[i].nodeValue;
      try {
        val = JSON.parse(elem.attributes[i].nodeValue.replace(/'/g, '"'));
      } catch (error) {
        val = elem.attributes[i].nodeValue;
      }
      if (val === null || val === void 0)
        continue;
      key = this.attr_prefix + key;
      if (typeof cnt[key] === "undefined")
        cnt[key] = 0;
      cnt[key]++;
      this.addNode(retVal, key, cnt[key], val);
    }
  }
  if (elem.childNodes && elem.childNodes.length) {
    var textOnly = true;
    if (retVal)
      textOnly = false;
    for (var i = 0; i < elem.childNodes.length && textOnly; i++) {
      var nType = elem.childNodes[i].nodeType;
      if (nType === 3 || nType === 4 || nType === 8)
        continue;
      textOnly = false;
    }
    if (textOnly) {
      if (!retVal)
        retVal = "";
      for (var i = 0; i < elem.childNodes.length; i++) {
        retVal += elem.childNodes[i].nodeValue;
      }
    } else {
      if (!retVal)
        retVal = {};
      for (var i = 0; i < elem.childNodes.length; i++) {
        var key = elem.childNodes[i].nodeName;
        if (typeof key !== "string")
          continue;
        var val = this.parseElement(elem.childNodes[i]);
        if (!val)
          continue;
        if (typeof cnt[key] === "undefined")
          cnt[key] = 0;
        cnt[key]++;
        this.addNode(retVal, key, cnt[key], val);
      }
    }
  } else {
    retVal === null && (retVal = {});
  }
  return retVal;
};
XML2.ObjTree.prototype.addNode = function(hash, key, counts, val) {
  if (this.__force_array[key]) {
    if (counts === 1)
      hash[key] = [];
    hash[key][hash[key].length] = val;
  } else if (counts === 1) {
    hash[key] = val;
  } else if (counts === 2) {
    hash[key] = [hash[key], val];
  } else {
    hash[key][hash[key].length] = val;
  }
};
XML2.ObjTree.prototype.writeXML = function(tree) {
  var xml = this.hash_to_xml(null, tree);
  return this.xmlDecl + xml;
};
XML2.ObjTree.prototype.hash_to_xml = function(name, tree) {
  var elem = [];
  var attr = [];
  for (var key in tree) {
    if (!has_default(tree, key))
      continue;
    var val = tree[key];
    if (key.charAt(0) !== this.attr_prefix) {
      if (typeof val === "undefined" || val == null) {
        elem[elem.length] = "<".concat(key, " />");
      } else if (typeof val === "object" && val.constructor === Array) {
        elem[elem.length] = this.array_to_xml(key, val);
      } else if (typeof val === "object") {
        elem[elem.length] = this.hash_to_xml(key, val);
      } else {
        elem[elem.length] = this.scalar_to_xml(key, val);
      }
    } else {
      attr[attr.length] = " ".concat(key.substring(1), '="').concat(this.xml_escape(val), '"');
    }
  }
  var jattr = attr.join("");
  var jelem = elem.join("");
  if (typeof name === "undefined" || name == null) {
  } else if (elem.length > 0) {
    if (jelem.match(/\n/)) {
      jelem = "<".concat(name).concat(jattr, ">\n").concat(jelem, "</").concat(name, ">\n");
    } else {
      jelem = "<".concat(name).concat(jattr, ">").concat(jelem, "</").concat(name, ">\n");
    }
  } else {
    jelem = "<".concat(name).concat(jattr, " />\n");
  }
  return jelem;
};
XML2.ObjTree.prototype.array_to_xml = function(name, array) {
  var out = [];
  for (var i = 0; i < array.length; i++) {
    var val = array[i];
    if (typeof val === "undefined" || val == null) {
      out[out.length] = "<".concat(name, " />");
    } else if (typeof val === "object" && val.constructor === Array) {
      out[out.length] = this.array_to_xml(name, val);
    } else if (typeof val === "object") {
      out[out.length] = this.hash_to_xml(name, val);
    } else {
      out[out.length] = this.scalar_to_xml(name, val);
    }
  }
  return out.join("");
};
XML2.ObjTree.prototype.scalar_to_xml = function(name, text) {
  if (name === "#text") {
    return this.xml_escape(text);
  }
  return "<".concat(name, ">").concat(this.xml_escape(text), "</").concat(name, ">\n");
};
XML2.ObjTree.prototype.xml_escape = function(text) {
  return text.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">").replace(/"/g, '"');
};
var lfXml2Json2 = function(xmlData) {
  return new XML2.ObjTree().parseXML(xmlData);
};

// node_modules/@logicflow/extension/es/bpmn-elements-adapter/json2xml.js
function type2(obj) {
  return Object.prototype.toString.call(obj);
}
function addSpace2(depth) {
  return "  ".repeat(depth);
}
function handleAttributes2(obj) {
  if (type2(obj) === "[object Object]") {
    return Object.keys(obj).reduce(function(tmp, key) {
      var tmpKey = key;
      if (key.charAt(0) === "-") {
        tmpKey = key.substring(1);
      }
      tmp[tmpKey] = handleAttributes2(obj[key]);
      return tmp;
    }, {});
  }
  if (Array.isArray(obj)) {
    return obj.map(function(item) {
      return handleAttributes2(item);
    });
  }
  return obj;
}
function getAttributes2(obj) {
  var tmp = obj;
  try {
    if (typeof tmp !== "string") {
      tmp = JSON.parse(obj);
    }
  } catch (error) {
    tmp = JSON.stringify(handleAttributes2(obj)).replace(/"/g, "'");
  }
  return tmp;
}
var tn2 = "	\n";
function toXml2(obj, name, depth) {
  var frontSpace = addSpace2(depth);
  var str = "";
  var prefix = tn2 + frontSpace;
  if (name === "-json")
    return "";
  if (name === "#text") {
    return prefix + obj;
  }
  if (name === "#cdata-section") {
    return "".concat(prefix, "<![CDATA[").concat(obj, "]]>");
  }
  if (name === "#comment") {
    return "".concat(prefix, "<!--").concat(obj, "-->");
  }
  if ("".concat(name).charAt(0) === "-") {
    return " ".concat(name.substring(1), '="').concat(getAttributes2(obj), '"');
  }
  if (Array.isArray(obj)) {
    str += obj.map(function(item) {
      return toXml2(item, name, depth + 1);
    }).join("");
  } else if (type2(obj) === "[object Object]") {
    var keys = Object.keys(obj);
    var attributes_1 = "";
    var children_1 = obj["-json"] ? tn2 + addSpace2(depth + 1) + obj["-json"] : "";
    str += "".concat(depth === 0 ? "" : prefix, "<").concat(name);
    keys.forEach(function(k) {
      k.charAt(0) === "-" ? attributes_1 += toXml2(obj[k], k, depth + 1) : children_1 += toXml2(obj[k], k, depth + 1);
    });
    str += attributes_1 + (children_1 !== "" ? ">".concat(children_1).concat(prefix, "</").concat(name, ">") : " />");
  } else {
    str += "".concat(prefix, "<").concat(name, ">").concat(obj.toString(), "</").concat(name, ">");
  }
  return str;
}
function lfJson2Xml2(obj) {
  var xmlStr = "";
  for (var key in obj) {
    xmlStr += toXml2(obj[key], key, 0);
  }
  return xmlStr;
}

// node_modules/@logicflow/extension/es/bpmn-elements-adapter/index.js
var __extends24 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign20 = function() {
  __assign20 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign20.apply(this, arguments);
};
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __values2 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read12 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray9 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var BpmnElements2;
(function(BpmnElements3) {
  BpmnElements3["START"] = "bpmn:startEvent";
  BpmnElements3["END"] = "bpmn:endEvent";
  BpmnElements3["INTERMEDIATE_CATCH"] = "bpmn:intermediateCatchEvent";
  BpmnElements3["INTERMEDIATE_THROW"] = "bpmn:intermediateThrowEvent";
  BpmnElements3["BOUNDARY"] = "bpmn:boundaryEvent";
  BpmnElements3["PARALLEL_GATEWAY"] = "bpmn:parallelGateway";
  BpmnElements3["INCLUSIVE_GATEWAY"] = "bpmn:inclusiveGateway";
  BpmnElements3["EXCLUSIVE_GATEWAY"] = "bpmn:exclusiveGateway";
  BpmnElements3["USER"] = "bpmn:userTask";
  BpmnElements3["SYSTEM"] = "bpmn:serviceTask";
  BpmnElements3["FLOW"] = "bpmn:sequenceFlow";
  BpmnElements3["SUBPROCESS"] = "bpmn:subProcess";
})(BpmnElements2 || (BpmnElements2 = {}));
var defaultAttrsForInput = [
  "-name",
  "-id",
  "bpmn:incoming",
  "bpmn:outgoing",
  "-sourceRef",
  "-targetRef",
  "-children"
];
var defaultRetainedProperties = [
  "properties",
  "startPoint",
  "endPoint",
  "pointsList"
];
var defaultExcludeFields = {
  in: [],
  out: [
    "properties.panels",
    "properties.nodeSize",
    "properties.definitionId",
    "properties.timerValue",
    "properties.timerType",
    "properties.definitionType",
    "properties.parent",
    "properties.isBoundaryEventTouchingTask"
  ]
};
var mergeInNOutObject = function(target, source) {
  var sourceKeys = Object.keys(source || {});
  sourceKeys.forEach(function(key) {
    if (target[key]) {
      var _a = source[key], fnIn = _a.in, fnOut = _a.out;
      if (fnIn) {
        target[key].in = fnIn;
      }
      if (fnOut) {
        target[key].out = fnOut;
      }
    } else {
      target[key] = source[key];
    }
  });
  return target;
};
var defaultTransformer = {
  "bpmn:startEvent": {
    out: function(data) {
      var _a, _b;
      var properties = data.properties;
      return ((_b = (_a = defaultTransformer[properties.definitionType]) === null || _a === void 0 ? void 0 : _a.out) === null || _b === void 0 ? void 0 : _b.call(_a, data)) || {};
    }
  },
  // 'bpmn:endEvent': undefined,
  "bpmn:intermediateCatchEvent": {
    out: function(data) {
      var _a, _b;
      var properties = data.properties;
      return ((_b = (_a = defaultTransformer[properties.definitionType]) === null || _a === void 0 ? void 0 : _a.out) === null || _b === void 0 ? void 0 : _b.call(_a, data)) || {};
    }
  },
  "bpmn:intermediateThrowEvent": {
    out: function(data) {
      var _a, _b;
      var properties = data.properties;
      return ((_b = (_a = defaultTransformer[properties.definitionType]) === null || _a === void 0 ? void 0 : _a.out) === null || _b === void 0 ? void 0 : _b.call(_a, data)) || {};
    }
  },
  "bpmn:boundaryEvent": {
    out: function(data) {
      var _a, _b;
      var properties = data.properties;
      return ((_b = (_a = defaultTransformer[properties.definitionType]) === null || _a === void 0 ? void 0 : _a.out) === null || _b === void 0 ? void 0 : _b.call(_a, data)) || {};
    }
  },
  // 'bpmn:userTask': undefined,
  "bpmn:sequenceFlow": {
    out: function(data) {
      var _a = data.properties, expressionType = _a.expressionType, condition = _a.condition;
      if (condition) {
        if (expressionType === "cdata") {
          return {
            json: '<bpmn:conditionExpression xsi:type="bpmn2:tFormalExpression"><![CDATA[${'.concat(condition, "}]]></bpmn:conditionExpression>")
          };
        }
        return {
          json: '<bpmn:conditionExpression xsi:type="bpmn2:tFormalExpression">'.concat(condition, "</bpmn:conditionExpression>")
        };
      }
      return {
        json: ""
      };
    }
  },
  // 'bpmn:subProcess': undefined,
  // 'bpmn:participant': undefined,
  "bpmn:timerEventDefinition": {
    out: function(data) {
      var _a = data.properties, timerType = _a.timerType, timerValue = _a.timerValue, definitionId = _a.definitionId;
      var typeFunc = function() {
        return "<bpmn:".concat(timerType, ' xsi:type="bpmn:tFormalExpression">').concat(timerValue, "</bpmn:").concat(timerType, ">");
      };
      return {
        json: '<bpmn:timerEventDefinition id="'.concat(definitionId, '"').concat(timerType && timerValue ? ">".concat(typeFunc(), "</bpmn:timerEventDefinition>") : "/>")
      };
    },
    in: function(key, data) {
      var e_1, _a, _b;
      var _c;
      var definitionType = key;
      var definitionId = data["-id"];
      var timerType = "";
      var timerValue = "";
      try {
        for (var _d = __values2(Object.keys(data)), _e = _d.next(); !_e.done; _e = _d.next()) {
          var key_1 = _e.value;
          if (key_1.includes("bpmn:")) {
            ;
            _b = __read12(key_1.split(":"), 2), timerType = _b[1];
            timerValue = (_c = data[key_1]) === null || _c === void 0 ? void 0 : _c["#text"];
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return {
        "-definitionId": definitionId,
        "-definitionType": definitionType,
        "-timerType": timerType,
        "-timerValue": timerValue
      };
    }
  },
  "bpmn:conditionExpression": {
    in: function(_key, data) {
      var _a;
      var condition = "";
      var expressionType = "";
      if (data["#cdata-section"]) {
        expressionType = "cdata";
        condition = ((_a = /^\$\{(.*)\}$/g.exec(data["#cdata-section"])) === null || _a === void 0 ? void 0 : _a[1]) || "";
      } else if (data["#text"]) {
        expressionType = "normal";
        condition = data["#text"];
      }
      return {
        "-condition": condition,
        "-expressionType": expressionType
      };
    }
  }
};
function convertNormalToXml(other) {
  var _a = other !== null && other !== void 0 ? other : {}, retainedAttrsFields = _a.retainedAttrsFields, excludeFields = _a.excludeFields, transformer = _a.transformer;
  var retainedAttrsSet = new Set(__spreadArray9(__spreadArray9([], __read12(defaultRetainedProperties), false), __read12(retainedAttrsFields || []), false));
  var excludeFieldsSet = {
    in: new Set(__spreadArray9(__spreadArray9([], __read12(defaultExcludeFields.in), false), __read12((excludeFields === null || excludeFields === void 0 ? void 0 : excludeFields.in) || []), false)),
    out: new Set(__spreadArray9(__spreadArray9([], __read12(defaultExcludeFields.out), false), __read12((excludeFields === null || excludeFields === void 0 ? void 0 : excludeFields.out) || []), false))
  };
  defaultTransformer = mergeInNOutObject(defaultTransformer, transformer);
  return function(object) {
    var nodes = object.nodes;
    var edges = object.edges;
    function ToXmlJson(obj, path) {
      var e_2, _a2;
      if ((obj === null || obj === void 0 ? void 0 : obj.flag) === 1) {
        return;
      }
      var fn;
      if ((fn = defaultTransformer[obj.type]) && fn.out) {
        var output_1 = fn.out(obj);
        var keys = Object.keys(output_1);
        if (keys.length > 0) {
          keys.forEach(function(key2) {
            obj[key2] = output_1[key2];
          });
        }
      }
      if (obj === null || obj === void 0 ? void 0 : obj.children) {
        obj.children = obj.children.map(function(key2) {
          var target = nodes.find(function(item) {
            return item.id === key2;
          }) || edges.find(function(item) {
            return item.id === key2;
          });
          return target || {};
        });
      }
      var xmlJson = {};
      if (typeof obj === "string") {
        return obj;
      }
      if (Array.isArray(obj)) {
        return obj.map(function(item) {
          return ToXmlJson(item, "");
        }).filter(function(item) {
          return item != void 0;
        });
      }
      try {
        for (var _b = __values2(Object.entries(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read12(_c.value, 2), key = _d[0], value = _d[1];
          if ((value === null || value === void 0 ? void 0 : value["flag"]) === 1) {
            return;
          }
          var newPath = [path, key].filter(function(item) {
            return item;
          }).join(".");
          if (excludeFieldsSet.out.has(newPath)) {
            continue;
          } else if (typeof value !== "object") {
            if (key.indexOf("-") === 0 || ["#text", "#cdata-section", "#comment"].includes(key)) {
              xmlJson[key] = value;
            } else {
              xmlJson["-".concat(key)] = value;
            }
          } else if (retainedAttrsSet.has(newPath)) {
            xmlJson["-".concat(key)] = ToXmlJson(value, newPath);
          } else {
            xmlJson[key] = ToXmlJson(value, newPath);
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
      return xmlJson;
    }
    return ToXmlJson(object, "");
  };
}
function convertXmlToNormal(xmlJson) {
  var e_3, _a;
  var json = {};
  try {
    for (var _b = __values2(Object.entries(xmlJson)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var _d = __read12(_c.value, 2), key = _d[0], value = _d[1];
      if (key.indexOf("-") === 0) {
        json[key.substring(1)] = handleAttributes2(value);
      } else if (typeof value === "string") {
        json[key] = value;
      } else if (Object.prototype.toString.call(value) === "[object Object]") {
        json[key] = convertXmlToNormal(value);
      } else if (Array.isArray(value)) {
        json[key] = value.map(function(v) {
          return convertXmlToNormal(v);
        });
      } else {
        json[key] = value;
      }
    }
  } catch (e_3_1) {
    e_3 = { error: e_3_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
    } finally {
      if (e_3) throw e_3.error;
    }
  }
  return json;
}
function convertLf2ProcessData2(bpmnData, data, other) {
  var _a;
  var nodeIdMap = /* @__PURE__ */ new Map();
  var xmlJsonData = convertNormalToXml(other)(data);
  xmlJsonData.nodes.forEach(function(node2) {
    var nodeId = node2["-id"], nodeType = node2["-type"], text = node2.text, children = node2.children, otherProps = __rest2(node2, ["-id", "-type", "text", "children"]);
    var processNode = { "-id": nodeId };
    if (text === null || text === void 0 ? void 0 : text["-value"]) {
      processNode["-name"] = text["-value"];
    }
    if (otherProps["-json"]) {
      processNode["-json"] = otherProps["-json"];
    }
    if (otherProps["-properties"]) {
      Object.assign(processNode, otherProps["-properties"]);
    }
    if (children) {
      processNode.children = children;
    }
    if (!bpmnData[nodeType]) {
      bpmnData[nodeType] = [];
    }
    bpmnData[nodeType].push(processNode);
    nodeIdMap.set(nodeId, processNode);
  });
  var sequenceFlow = xmlJsonData.edges.map(function(edge) {
    var id = edge["-id"], sourceNodeId = edge["-sourceNodeId"], targetNodeId = edge["-targetNodeId"], text = edge.text, otherProps = __rest2(edge, ["-id", "-sourceNodeId", "-targetNodeId", "text"]);
    var targetNode = nodeIdMap.get(targetNodeId);
    if (!targetNode["bpmn:incoming"]) {
      targetNode["bpmn:incoming"] = [];
    }
    targetNode["bpmn:incoming"].push(id);
    var edgeConfig = {
      "-id": id,
      "-sourceRef": sourceNodeId,
      "-targetRef": targetNodeId
    };
    if (text === null || text === void 0 ? void 0 : text["-value"]) {
      edgeConfig["-name"] = text["-value"];
    }
    if (otherProps["-json"]) {
      edgeConfig["-json"] = otherProps["-json"];
    }
    if (otherProps["-properties"]) {
      Object.assign(edgeConfig, otherProps["-properties"]);
    }
    return edgeConfig;
  });
  data.edges.forEach(function(_a2) {
    var sourceNodeId = _a2.sourceNodeId, id = _a2.id;
    var sourceNode = nodeIdMap.get(sourceNodeId);
    if (!sourceNode["bpmn:outgoing"]) {
      sourceNode["bpmn:outgoing"] = [];
    }
    sourceNode["bpmn:outgoing"].push(id);
  });
  (_a = bpmnData["bpmn:subProcess"]) === null || _a === void 0 ? void 0 : _a.forEach(function(item) {
    var setMap = {
      "bpmn:incoming": /* @__PURE__ */ new Set(),
      "bpmn:outgoing": /* @__PURE__ */ new Set()
    };
    var edgesInSubProcess = [];
    item.children.forEach(function(child) {
      var _a2;
      var target = nodeIdMap.get(child["-id"]);
      ["bpmn:incoming", "bpmn:outgoing"].forEach(function(key) {
        target[key] && target[key].forEach(function(value) {
          setMap[key].add(value);
        });
      });
      var index = (_a2 = bpmnData[child["-type"]]) === null || _a2 === void 0 ? void 0 : _a2.findIndex(function(_item) {
        return _item["-id"] === child["-id"];
      });
      if (index >= 0) {
        bpmnData[child["-type"]].splice(index, 1);
      }
      nodeIdMap.delete(child["-id"]);
      if (!item[child["-type"]]) {
        item[child["-type"]] = [];
      }
      item[child["-type"]].push(target);
    });
    var incomingSet = setMap["bpmn:incoming"], outgoingSet = setMap["bpmn:outgoing"];
    outgoingSet.forEach(function(value) {
      incomingSet.has(value) && edgesInSubProcess.push(value);
    });
    var _loop_1 = function(i2) {
      var index = sequenceFlow.findIndex(function(item2) {
        return item2["-id"] === edgesInSubProcess[i2];
      });
      if (index >= 0) {
        if (!item["bpmn:sequenceFlow"]) {
          item["bpmn:sequenceFlow"] = [];
        }
        item["bpmn:sequenceFlow"].push(sequenceFlow[index]);
        sequenceFlow.splice(index, 1);
      } else {
        i2++;
      }
      out_i_1 = i2;
    };
    var out_i_1;
    for (var i = 0; i < edgesInSubProcess.length; ) {
      _loop_1(i);
      i = out_i_1;
    }
    delete item.children;
  });
  bpmnData[BpmnElements2.FLOW] = sequenceFlow;
  return bpmnData;
}
function convertLf2DiagramData2(bpmnDiagramData, data) {
  bpmnDiagramData["bpmndi:BPMNEdge"] = data.edges.map(function(edge) {
    var _a;
    var edgeId = edge.id;
    var pointsList = edge.pointsList.map(function(_a2) {
      var x2 = _a2.x, y = _a2.y;
      return {
        "-x": x2,
        "-y": y
      };
    });
    var diagramData = {
      "-id": "".concat(edgeId, "_di"),
      "-bpmnElement": edgeId,
      "di:waypoint": pointsList
    };
    if ((_a = edge.text) === null || _a === void 0 ? void 0 : _a.value) {
      diagramData["bpmndi:BPMNLabel"] = {
        "dc:Bounds": {
          "-x": edge.text.x - edge.text.value.length * 10 / 2,
          "-y": edge.text.y - 7,
          "-width": edge.text.value.length * 10,
          "-height": 14
        }
      };
    }
    return diagramData;
  });
  bpmnDiagramData["bpmndi:BPMNShape"] = data.nodes.map(function(node2) {
    var _a;
    var nodeId = node2.id;
    var width = 100;
    var height = 80;
    var x2 = node2.x, y = node2.y;
    var shapeConfig = BPMNBaseAdapter.shapeConfigMap.get(node2.type);
    if (shapeConfig) {
      width = shapeConfig.width;
      height = shapeConfig.height;
    }
    x2 -= width / 2;
    y -= height / 2;
    var diagramData = {
      "-id": "".concat(nodeId, "_di"),
      "-bpmnElement": nodeId,
      "dc:Bounds": {
        "-x": x2,
        "-y": y,
        "-width": width,
        "-height": height
      }
    };
    if ((_a = node2.text) === null || _a === void 0 ? void 0 : _a.value) {
      diagramData["bpmndi:BPMNLabel"] = {
        "dc:Bounds": {
          "-x": node2.text.x - node2.text.value.length * 10 / 2,
          "-y": node2.text.y - 7,
          "-width": node2.text.value.length * 10,
          "-height": 14
        }
      };
    }
    return diagramData;
  });
}
var ignoreType = ["bpmn:incoming", "bpmn:outgoing"];
function convertBpmn2LfData2(bpmnData, other) {
  var nodes = [];
  var edges = [];
  var eleMap = /* @__PURE__ */ new Map();
  var _a = other !== null && other !== void 0 ? other : {}, transformer = _a.transformer, excludeFields = _a.excludeFields;
  var excludeFieldsSet = {
    in: new Set(__spreadArray9(__spreadArray9([], __read12(defaultExcludeFields.in), false), __read12((excludeFields === null || excludeFields === void 0 ? void 0 : excludeFields.in) || []), false)),
    out: new Set(__spreadArray9(__spreadArray9([], __read12(defaultExcludeFields.out), false), __read12((excludeFields === null || excludeFields === void 0 ? void 0 : excludeFields.out) || []), false))
  };
  defaultTransformer = mergeInNOutObject(defaultTransformer, transformer);
  var definitions = bpmnData["bpmn:definitions"];
  if (definitions) {
    var process_1 = definitions["bpmn:process"];
    (function(data, callbacks) {
      callbacks.forEach(function(callback) {
        try {
          Object.keys(data).forEach(function(key) {
            try {
              callback(key);
            } catch (error) {
              console.error(error);
            }
          });
        } catch (error) {
          console.error(error);
        }
      });
    })(process_1, [
      function(key) {
        function subProcessProcessing(data2) {
          if (!data2["-children"]) {
            data2["-children"] = [];
          }
          Object.keys(data2).forEach(function(key2) {
            var _a2;
            if (key2.indexOf("bpmn:") === 0 && !ignoreType.includes(key2)) {
              if (!process_1[key2]) {
                process_1[key2] = [];
              }
              !Array.isArray(process_1[key2]) && (process_1[key2] = [process_1[key2]]);
              Array.isArray(data2[key2]) ? (_a2 = process_1[key2]).push.apply(_a2, __spreadArray9([], __read12(data2[key2]), false)) : process_1[key2].push(data2[key2]);
              if (Array.isArray(data2[key2])) {
                data2[key2].forEach(function(item) {
                  !key2.includes("Flow") && data2["-children"].push(item["-id"]);
                });
              } else {
                !key2.includes("Flow") && data2["-children"].push(data2[key2]["-id"]);
              }
              delete data2[key2];
            }
          });
        }
        if (key === "bpmn:subProcess") {
          var data = process_1[key];
          if (Array.isArray(data)) {
            data.forEach(function(item) {
              key === "bpmn:subProcess" && subProcessProcessing(item);
            });
          } else {
            subProcessProcessing(data);
          }
        }
      },
      function(key) {
        var fn = function(obj) {
          Object.keys(obj).forEach(function(key2) {
            var _a2, _b;
            if (key2.includes("bpmn:")) {
              var props_1 = {};
              if (defaultTransformer[key2] && defaultTransformer[key2].in) {
                props_1 = (_b = (_a2 = defaultTransformer[key2]).in) === null || _b === void 0 ? void 0 : _b.call(_a2, key2, lodash_default_default.cloneDeep(obj[key2]));
                delete obj[key2];
              } else {
                func(obj[key2]);
              }
              var keys = void 0;
              if ((keys = Reflect.ownKeys(props_1)).length > 0) {
                keys.forEach(function(key3) {
                  Reflect.set(obj, key3, props_1[key3]);
                });
              }
            }
          });
        };
        function func(data) {
          eleMap.set(data["-id"], data);
          if (Array.isArray(data)) {
            data.forEach(function(item) {
              func(item);
            });
          } else if (typeof data === "object") {
            fn(data);
          }
        }
        func(process_1[key]);
      },
      function(key) {
        if (key.indexOf("bpmn:") === 0) {
          var value = process_1[key];
          if (key === "bpmn:sequenceFlow") {
            var bpmnEdges = definitions["bpmndi:BPMNDiagram"]["bpmndi:BPMNPlane"]["bpmndi:BPMNEdge"];
            edges = getLfEdges2(value, bpmnEdges);
          } else {
            var shapes = definitions["bpmndi:BPMNDiagram"]["bpmndi:BPMNPlane"]["bpmndi:BPMNShape"];
            if (key === "bpmn:boundaryEvent") {
              var data = process_1[key];
              var fn_1 = function(item) {
                var attachedToRef = item["-attachedToRef"];
                var attachedToNode = eleMap.get(attachedToRef);
                if (!attachedToNode["-boundaryEvents"]) {
                  attachedToNode["-boundaryEvents"] = [];
                }
                attachedToNode["-boundaryEvents"].push(item["-id"]);
              };
              if (Array.isArray(data)) {
                data.forEach(function(item) {
                  fn_1(item);
                });
              } else {
                fn_1(data);
              }
            }
            nodes = nodes.concat(getLfNodes2(value, shapes, key));
          }
        }
      }
    ]);
  }
  var ignoreFields = function(obj, filterSet, path) {
    Object.keys(obj).forEach(function(key) {
      var tmpPath = path ? "".concat(path, ".").concat(key) : key;
      if (filterSet.has(tmpPath)) {
        delete obj[key];
      } else if (typeof obj[key] === "object") {
        ignoreFields(obj[key], filterSet, tmpPath);
      }
    });
  };
  nodes.forEach(function(node2) {
    var _a2, _b;
    if ((_a2 = other === null || other === void 0 ? void 0 : other.mapping) === null || _a2 === void 0 ? void 0 : _a2.in) {
      var mapping = (_b = other === null || other === void 0 ? void 0 : other.mapping) === null || _b === void 0 ? void 0 : _b.in;
      var type3 = node2.type;
      if (mapping[type3]) {
        node2.type = mapping[type3];
      }
    }
    ignoreFields(node2, excludeFieldsSet.in, "");
  });
  edges.forEach(function(edge) {
    var _a2, _b;
    if ((_a2 = other === null || other === void 0 ? void 0 : other.mapping) === null || _a2 === void 0 ? void 0 : _a2.in) {
      var mapping = (_b = other === null || other === void 0 ? void 0 : other.mapping) === null || _b === void 0 ? void 0 : _b.in;
      var type3 = edge.type;
      if (mapping[type3]) {
        edge.type = mapping[type3];
      }
    }
    ignoreFields(edge, excludeFieldsSet.in, "");
  });
  return {
    nodes,
    edges
  };
}
function getLfNodes2(value, shapes, key) {
  var nodes = [];
  if (Array.isArray(value)) {
    value.forEach(function(val) {
      var shapeValue2;
      if (Array.isArray(shapes)) {
        shapeValue2 = shapes.find(function(shape) {
          return shape["-bpmnElement"] === val["-id"];
        });
      } else {
        shapeValue2 = shapes;
      }
      var node3 = getNodeConfig2(shapeValue2, key, val);
      nodes.push(node3);
    });
  } else {
    var shapeValue = void 0;
    if (Array.isArray(shapes)) {
      shapeValue = shapes.find(function(shape) {
        return shape["-bpmnElement"] === value["-id"];
      });
    } else {
      shapeValue = shapes;
    }
    var node2 = getNodeConfig2(shapeValue, key, value);
    nodes.push(node2);
  }
  return nodes;
}
function getNodeConfig2(shapeValue, type3, processValue) {
  var x2 = Number(shapeValue["dc:Bounds"]["-x"]);
  var y = Number(shapeValue["dc:Bounds"]["-y"]);
  var children = processValue["-children"];
  var name = processValue["-name"];
  var shapeConfig = BPMNBaseAdapter.shapeConfigMap.get(type3);
  if (shapeConfig) {
    x2 += shapeConfig.width / 2;
    y += shapeConfig.height / 2;
  }
  var properties = {};
  Object.entries(processValue).forEach(function(_a) {
    var _b = __read12(_a, 2), key = _b[0], value = _b[1];
    if (!defaultAttrsForInput.includes(key)) {
      properties[key] = value;
    }
  });
  properties = convertXmlToNormal(properties);
  var text;
  if (name) {
    text = {
      x: x2,
      y,
      value: name
    };
    if (shapeValue["bpmndi:BPMNLabel"] && shapeValue["bpmndi:BPMNLabel"]["dc:Bounds"]) {
      var textBounds = shapeValue["bpmndi:BPMNLabel"]["dc:Bounds"];
      text.x = Number(textBounds["-x"]) + Number(textBounds["-width"]) / 2;
      text.y = Number(textBounds["-y"]) + Number(textBounds["-height"]) / 2;
    }
  }
  var nodeConfig = {
    id: shapeValue["-bpmnElement"],
    type: type3,
    x: x2,
    y,
    properties
  };
  children && (nodeConfig.children = children);
  if (text) {
    nodeConfig.text = text;
  }
  return nodeConfig;
}
function getLfEdges2(value, bpmnEdges) {
  var edges = [];
  if (Array.isArray(value)) {
    value.forEach(function(val) {
      var edgeValue2;
      if (Array.isArray(bpmnEdges)) {
        edgeValue2 = bpmnEdges.find(function(edge) {
          return edge["-bpmnElement"] === val["-id"];
        });
      } else {
        edgeValue2 = bpmnEdges;
      }
      edges.push(getEdgeConfig2(edgeValue2, val));
    });
  } else {
    var edgeValue = void 0;
    if (Array.isArray(bpmnEdges)) {
      edgeValue = bpmnEdges.find(function(edge) {
        return edge["-bpmnElement"] === value["-id"];
      });
    } else {
      edgeValue = bpmnEdges;
    }
    edges.push(getEdgeConfig2(edgeValue, value));
  }
  return edges;
}
function getEdgeConfig2(edgeValue, processValue) {
  var text;
  var textVal = processValue["-name"] ? "".concat(processValue["-name"]) : "";
  if (textVal) {
    var textBounds = edgeValue["bpmndi:BPMNLabel"]["dc:Bounds"];
    var textLength_1 = 0;
    textVal.split("\n").forEach(function(textSpan) {
      if (textLength_1 < textSpan.length) {
        textLength_1 = textSpan.length;
      }
    });
    text = {
      value: textVal,
      x: Number(textBounds["-x"]) + textLength_1 * 10 / 2,
      y: Number(textBounds["-y"]) + 7
    };
  }
  var properties = {};
  Object.entries(processValue).forEach(function(_a) {
    var _b = __read12(_a, 2), key = _b[0], value = _b[1];
    if (!defaultAttrsForInput.includes(key)) {
      properties[key] = value;
    }
  });
  properties = convertXmlToNormal(properties);
  var pointsList = edgeValue["di:waypoint"].map(function(point) {
    return {
      x: Number(point["-x"]),
      y: Number(point["-y"])
    };
  });
  var edge = {
    id: processValue["-id"],
    type: BpmnElements2.FLOW,
    pointsList,
    sourceNodeId: processValue["-sourceRef"],
    targetNodeId: processValue["-targetRef"],
    properties
  };
  if (text) {
    edge.text = text;
  }
  return edge;
}
var BPMNBaseAdapter = (
  /** @class */
  function() {
    function BPMNBaseAdapter2(_a) {
      var lf = _a.lf;
      var _this = this;
      this.adapterOut = function(data, other) {
        var _a2, _b;
        var bpmnProcessData = __assign20({}, _this.processAttributes);
        convertLf2ProcessData2(bpmnProcessData, data, other);
        var bpmnDiagramData = {
          "-id": "BPMNPlane_1",
          "-bpmnElement": bpmnProcessData["-id"]
        };
        convertLf2DiagramData2(bpmnDiagramData, data);
        var definitions = _this.definitionAttributes;
        definitions["bpmn:process"] = bpmnProcessData;
        definitions["bpmndi:BPMNDiagram"] = {
          "-id": "BPMNDiagram_1",
          "bpmndi:BPMNPlane": bpmnDiagramData
        };
        var bpmnData = {
          "bpmn:definitions": definitions
        };
        if ((_a2 = other === null || other === void 0 ? void 0 : other.mapping) === null || _a2 === void 0 ? void 0 : _a2.out) {
          var mapping_1 = (_b = other === null || other === void 0 ? void 0 : other.mapping) === null || _b === void 0 ? void 0 : _b.out;
          var nameMapping_1 = function(obj) {
            if (Array.isArray(obj)) {
              obj.forEach(function(item) {
                return nameMapping_1(item);
              });
            }
            if (typeof obj === "object") {
              Object.keys(obj).forEach(function(key) {
                var mappingName;
                if (mappingName = mapping_1[key]) {
                  obj[mappingName] = lodash_default_default.cloneDeep(obj[key]);
                  delete obj[key];
                  nameMapping_1(obj[mappingName]);
                } else {
                  nameMapping_1(obj[key]);
                }
              });
            }
          };
          nameMapping_1(bpmnData);
        }
        return bpmnData;
      };
      this.adapterIn = function(bpmnData, other) {
        if (bpmnData) {
          return convertBpmn2LfData2(bpmnData, other);
        }
      };
      lf.adapterIn = this.adapterIn;
      lf.adapterOut = this.adapterOut;
      this.processAttributes = {
        "-isExecutable": "true",
        "-id": "Process"
      };
      this.definitionAttributes = {
        "-id": "Definitions",
        "-xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
        "-xmlns:bpmn": "http://www.omg.org/spec/BPMN/20100524/MODEL",
        "-xmlns:bpmndi": "http://www.omg.org/spec/BPMN/20100524/DI",
        "-xmlns:dc": "http://www.omg.org/spec/DD/20100524/DC",
        "-xmlns:di": "http://www.omg.org/spec/DD/20100524/DI",
        "-targetNamespace": "http://logic-flow.org",
        "-exporter": "logicflow",
        "-exporterVersion": "1.2.10"
      };
    }
    BPMNBaseAdapter2.prototype.setCustomShape = function(key, val) {
      BPMNBaseAdapter2.shapeConfigMap.set(key, val);
    };
    BPMNBaseAdapter2.pluginName = "bpmn-adapter";
    BPMNBaseAdapter2.shapeConfigMap = /* @__PURE__ */ new Map();
    return BPMNBaseAdapter2;
  }()
);
BPMNBaseAdapter.shapeConfigMap.set(BpmnElements2.START, {
  width: StartEventConfig2.width,
  height: StartEventConfig2.height
});
BPMNBaseAdapter.shapeConfigMap.set(BpmnElements2.END, {
  width: EndEventConfig2.width,
  height: EndEventConfig2.height
});
BPMNBaseAdapter.shapeConfigMap.set(BpmnElements2.INTERMEDIATE_CATCH, {
  width: IntermediateEventConfig.width,
  height: IntermediateEventConfig.height
});
BPMNBaseAdapter.shapeConfigMap.set(BpmnElements2.INTERMEDIATE_THROW, {
  width: IntermediateEventConfig.width,
  height: IntermediateEventConfig.height
});
BPMNBaseAdapter.shapeConfigMap.set(BpmnElements2.BOUNDARY, {
  width: BoundaryEventConfig.width,
  height: BoundaryEventConfig.height
});
BPMNBaseAdapter.shapeConfigMap.set(BpmnElements2.PARALLEL_GATEWAY, {
  width: ParallelGatewayConfig.width,
  height: ParallelGatewayConfig.height
});
BPMNBaseAdapter.shapeConfigMap.set(BpmnElements2.INCLUSIVE_GATEWAY, {
  width: InclusiveGatewayConfig.width,
  height: InclusiveGatewayConfig.height
});
BPMNBaseAdapter.shapeConfigMap.set(BpmnElements2.EXCLUSIVE_GATEWAY, {
  width: ExclusiveGatewayConfig2.width,
  height: ExclusiveGatewayConfig2.height
});
BPMNBaseAdapter.shapeConfigMap.set(BpmnElements2.SYSTEM, {
  width: ServiceTaskConfig2.width,
  height: ServiceTaskConfig2.height
});
BPMNBaseAdapter.shapeConfigMap.set(BpmnElements2.USER, {
  width: UserTaskConfig2.width,
  height: UserTaskConfig2.height
});
BPMNBaseAdapter.shapeConfigMap.set(BpmnElements2.SUBPROCESS, {
  width: SubProcessConfig.width,
  height: SubProcessConfig.height
});
var BPMNAdapter = (
  /** @class */
  function(_super) {
    __extends24(BPMNAdapter2, _super);
    function BPMNAdapter2(data) {
      var _this = _super.call(this, data) || this;
      _this.adapterXmlIn = function(bpmnData) {
        var json = lfXml2Json2(bpmnData);
        return _this.adapterIn(json, _this.props);
      };
      _this.adapterXmlOut = function(data2) {
        var outData = _this.adapterOut(data2, _this.props);
        return lfJson2Xml2(outData);
      };
      var lf = data.lf, props = data.props;
      lf.adapterIn = _this.adapterXmlIn;
      lf.adapterOut = _this.adapterXmlOut;
      _this.props = props;
      return _this;
    }
    BPMNAdapter2.pluginName = "BPMNAdapter";
    return BPMNAdapter2;
  }(BPMNBaseAdapter)
);

// node_modules/@logicflow/extension/es/turbo-adapter/index.js
var __assign21 = function() {
  __assign21 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign21.apply(this, arguments);
};
var __read13 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var TurboType = {
  SEQUENCE_FLOW: 1,
  START_EVENT: 2,
  END_EVENT: 3,
  USER_TASK: 4,
  // SERVICE_TASK = 5, 暂不支持
  EXCLUSIVE_GATEWAY: 6
};
var TurboTypeMap = {
  1: "bpmn:sequenceFlow",
  2: "bpmn:startEvent",
  3: "bpmn:endEvent",
  4: "bpmn:userTask",
  6: "bpmn:exclusiveGateway"
};
function getTurboType(type3) {
  switch (type3) {
    case "bpmn:sequenceFlow":
      return TurboType.SEQUENCE_FLOW;
    case "bpmn:startEvent":
      return TurboType.START_EVENT;
    case "bpmn:endEvent":
      return TurboType.END_EVENT;
    case "bpmn:userTask":
      return TurboType.USER_TASK;
    case "bpmn:exclusiveGateway":
      return TurboType.EXCLUSIVE_GATEWAY;
    default:
      return type3;
  }
}
function convertNodeToTurboElement(node2) {
  var id = node2.id, type3 = node2.type, x2 = node2.x, y = node2.y, _a = node2.text, text = _a === void 0 ? "" : _a, properties = node2.properties;
  return {
    incoming: [],
    outgoing: [],
    dockers: [],
    type: getTurboType(type3),
    properties: __assign21(__assign21({}, properties), { name: text && text.value || "", x: x2, y, text }),
    key: id
  };
}
function convertEdgeToTurboElement(edge) {
  var id = edge.id, type3 = edge.type, sourceNodeId = edge.sourceNodeId, targetNodeId = edge.targetNodeId, startPoint = edge.startPoint, endPoint = edge.endPoint, pointsList = edge.pointsList, _a = edge.text, text = _a === void 0 ? "" : _a, properties = edge.properties;
  return {
    incoming: [sourceNodeId],
    outgoing: [targetNodeId],
    type: getTurboType(type3),
    dockers: [],
    properties: __assign21(__assign21({}, properties), { name: text && text.value || "", text, startPoint: JSON.stringify(startPoint), endPoint: JSON.stringify(endPoint), pointsList: JSON.stringify(pointsList) }),
    key: id
  };
}
function toTurboData(data) {
  var nodeMap = /* @__PURE__ */ new Map();
  var turboData = {
    // TODO: 定义类型
    flowElementList: []
  };
  data.nodes.forEach(function(node2) {
    var flowElement = convertNodeToTurboElement(node2);
    turboData.flowElementList.push(flowElement);
    nodeMap.set(node2.id, flowElement);
  });
  data.edges.forEach(function(edge) {
    var flowElement = convertEdgeToTurboElement(edge);
    var sourceElement = nodeMap.get(edge.sourceNodeId);
    sourceElement.outgoing.push(flowElement.key);
    var targetElement = nodeMap.get(edge.targetNodeId);
    targetElement.incoming.push(flowElement.key);
    turboData.flowElementList.push(flowElement);
  });
  return turboData;
}
function convertFlowElementToEdge(element) {
  var incoming = element.incoming, outgoing = element.outgoing, properties = element.properties, key = element.key, type3 = element.type;
  var text = properties.text, name = properties.name, startPoint = properties.startPoint, endPoint = properties.endPoint, pointsList = properties.pointsList;
  var edge = {
    id: key,
    type: TurboTypeMap[type3],
    sourceNodeId: incoming[0],
    targetNodeId: outgoing[0],
    text: text || name,
    properties: {}
  };
  if (startPoint) {
    edge.startPoint = JSON.parse(startPoint);
  }
  if (endPoint) {
    edge.endPoint = JSON.parse(endPoint);
  }
  if (pointsList) {
    edge.pointsList = JSON.parse(pointsList);
  }
  var excludeProperties = ["startPoint", "endPoint", "pointsList", "text"];
  Object.keys(element.properties).forEach(function(property) {
    if (excludeProperties.indexOf(property) === -1) {
      edge.properties[property] = element.properties[property];
    }
  });
  return edge;
}
function convertFlowElementToNode(element) {
  var properties = element.properties, key = element.key, type3 = element.type, bounds = element.bounds;
  var x2 = properties.x, y = properties.y;
  var text = properties.text;
  if (x2 === void 0) {
    var _a = __read13(bounds, 2), _b = _a[0], x1 = _b.x, y1 = _b.y, _c = _a[1], x22 = _c.x, y2 = _c.y;
    x2 = (x1 + x22) / 2;
    y = (y1 + y2) / 2;
  }
  var node2 = {
    id: key,
    type: TurboTypeMap[type3],
    x: x2,
    y,
    text,
    properties: {}
  };
  var excludeProperties = ["x", "y", "text"];
  Object.keys(element.properties).forEach(function(property) {
    if (excludeProperties.indexOf(property) === -1) {
      node2.properties[property] = element.properties[property];
    }
  });
  return node2;
}
function toLogicflowData(data) {
  var lfData = {
    // TODO: 定义类型
    nodes: [],
    edges: []
  };
  var list = data.flowElementList;
  list && list.length > 0 && list.forEach(function(element) {
    if (element.type === TurboType.SEQUENCE_FLOW) {
      var edge = convertFlowElementToEdge(element);
      lfData.edges.push(edge);
    } else {
      var node2 = convertFlowElementToNode(element);
      lfData.nodes.push(node2);
    }
  });
  return lfData;
}
var TurboAdapter = (
  /** @class */
  function() {
    function TurboAdapter2(_a) {
      var lf = _a.lf;
      lf.adapterIn = this.adapterIn;
      lf.adapterOut = this.adapterOut;
    }
    TurboAdapter2.prototype.adapterOut = function(logicflowData) {
      if (logicflowData) {
        return toTurboData(logicflowData);
      }
    };
    TurboAdapter2.prototype.adapterIn = function(turboData) {
      if (turboData) {
        return toLogicflowData(turboData);
      }
    };
    TurboAdapter2.pluginName = "turboAdapter";
    return TurboAdapter2;
  }()
);

// node_modules/@logicflow/extension/es/tools/label/utils.js
function calcPointAfterResize(origin, scaled, point) {
  var x1 = origin.x, y1 = origin.y, w1 = origin.width, h1 = origin.height;
  var x2 = scaled.x, y2 = scaled.y, w2 = scaled.width, h2 = scaled.height;
  var px1 = point.x, py1 = point.y;
  var relativeX = (px1 - x1) / w1;
  var relativeY = (py1 - y1) / h1;
  var px2 = x2 + relativeX * w2;
  var py2 = y2 + relativeY * h2;
  return { x: px2, y: py2 };
}
function rotatePointAroundCenter(target, center, radian) {
  var x1 = center.x, y1 = center.y;
  var x2 = target.x, y2 = target.y;
  var xPrime = x2 - x1;
  var yPrime = y2 - y1;
  var xDoublePrime = xPrime * Math.cos(radian) - yPrime * Math.sin(radian);
  var yDoublePrime = xPrime * Math.sin(radian) + yPrime * Math.cos(radian);
  var xNew = xDoublePrime + x1;
  var yNew = yDoublePrime + y1;
  return {
    x: xNew,
    y: yNew
  };
}

// node_modules/@logicflow/extension/es/dynamic-group/node.js
var __extends25 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign22 = function() {
  __assign22 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign22.apply(this, arguments);
};
var __read14 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray10 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DynamicGroupNode = (
  /** @class */
  function(_super) {
    __extends25(DynamicGroupNode2, _super);
    function DynamicGroupNode2() {
      var _this = _super.apply(this, __spreadArray10([], __read14(arguments), false)) || this;
      _this.childrenPositionMap = /* @__PURE__ */ new Map();
      _this.onNodeRotate = function(_a) {
        var model = _a.model;
        var _b = _this.props, curGroup = _b.model, graphModel = _b.graphModel;
        var transformWithContainer = curGroup.transformWithContainer, isRestrict = curGroup.isRestrict;
        var childrenPositionMap = _this.childrenPositionMap;
        if (!transformWithContainer || isRestrict) {
          return;
        }
        if (model.id === curGroup.id) {
          var center_1 = { x: curGroup.x, y: curGroup.y };
          forEach_default(Array.from(curGroup.children), function(childId) {
            var child = graphModel.getNodeModelById(childId);
            if (child) {
              var point = { x: child.x, y: child.y };
              if (childrenPositionMap.has(child.id)) {
                point = childrenPositionMap.get(child.id);
              } else {
                childrenPositionMap.set(child.id, point);
              }
              var theta = model.rotate * (180 / Math.PI);
              if (theta < 0)
                theta += 360;
              var radian = theta * (Math.PI / 180);
              var newPoint = rotatePointAroundCenter(point, center_1, radian);
              child.moveTo(newPoint.x, newPoint.y);
              child.rotate = model.rotate;
            }
          });
        }
      };
      _this.onNodeResize = function(_a) {
        var deltaX = _a.deltaX, deltaY = _a.deltaY, index = _a.index, model = _a.model, preData = _a.preData;
        var _b = _this.props, curGroup = _b.model, graphModel = _b.graphModel;
        var transformWithContainer = curGroup.transformWithContainer, isRestrict = curGroup.isRestrict;
        if (!transformWithContainer || isRestrict) {
          return;
        }
        if (model.id === curGroup.id) {
          var properties = preData.properties;
          var _c = properties || {}, groupWidth_1 = _c.width, groupHeight_1 = _c.height;
          forEach_default(Array.from(curGroup.children), function(childId) {
            var child = graphModel.getNodeModelById(childId);
            if (child) {
              var childDx = child.width / groupWidth_1 * deltaX;
              var childDy = child.height / groupHeight_1 * deltaY;
              handleResize({
                deltaX: childDx,
                deltaY: childDy,
                index,
                nodeModel: child,
                graphModel,
                cancelCallback: function() {
                }
              });
            }
          });
        }
      };
      _this.onNodeMouseMove = function() {
      };
      _this.graphRendered = function() {
        var model = _this.props.model;
        if (model.isCollapsed) {
          model.toggleCollapse(true);
        }
      };
      return _this;
    }
    DynamicGroupNode2.prototype.componentDidMount = function() {
      _super.prototype.componentDidMount.call(this);
      var eventCenter = this.props.graphModel.eventCenter;
      eventCenter.on("node:rotate", this.onNodeRotate);
      eventCenter.on("node:resize", this.onNodeResize);
      eventCenter.on("node:mousemove", this.onNodeMouseMove);
      eventCenter.on("graph:rendered", this.graphRendered);
    };
    DynamicGroupNode2.prototype.componentWillUnmount = function() {
      _super.prototype.componentWillUnmount.call(this);
      var eventCenter = this.props.graphModel.eventCenter;
      eventCenter.off("node:rotate", this.onNodeRotate);
      eventCenter.off("node:resize", this.onNodeResize);
      eventCenter.off("node:mousemove", this.onNodeMouseMove);
      eventCenter.off("graph:rendered", this.graphRendered);
    };
    DynamicGroupNode2.prototype.getNodesInGroup = function(groupModel, graphModel) {
      var _this = this;
      var nodeIds = [];
      if (groupModel.isGroup) {
        forEach_default(Array.from(groupModel.children), function(nodeId) {
          nodeIds.push(nodeId);
          var nodeModel = graphModel.getNodeModelById(nodeId);
          if (nodeModel === null || nodeModel === void 0 ? void 0 : nodeModel.isGroup) {
            nodeIds = nodeIds.concat(_this.getNodesInGroup(nodeModel, graphModel));
          }
        });
      }
      return nodeIds;
    };
    DynamicGroupNode2.prototype.getResizeControl = function() {
      var _a = this.props.model, resizable = _a.resizable, isCollapsed = _a.isCollapsed;
      var showResizeControl = resizable && !isCollapsed;
      return showResizeControl ? _super.prototype.getResizeControl.call(this) : null;
    };
    DynamicGroupNode2.prototype.getAppendAreaShape = function() {
      var model = this.props.model;
      var width = model.width, height = model.height, x2 = model.x, y = model.y, radius = model.radius, groupAddable = model.groupAddable;
      if (!groupAddable)
        return null;
      var _a = model.getNodeStyle().strokeWidth, strokeWidth = _a === void 0 ? 0 : _a;
      var style2 = model.getAddableOutlineStyle();
      var newWidth = width + strokeWidth + 8;
      var newHeight = height + strokeWidth + 8;
      return g("rect", __assign22(__assign22({}, style2), { width: newWidth, height: newHeight, x: x2 - newWidth / 2, y: y - newHeight / 2, rx: radius, ry: radius }));
    };
    DynamicGroupNode2.prototype.getCollapseIcon = function(sx, sy) {
      return "M ".concat(sx + 3, ",").concat(sy + 6, " ").concat(sx + 11, ",").concat(sy + 6, " M").concat(sx + 7, ",").concat(sy + 2, " ").concat(sx + 7, ",").concat(sy + 10);
    };
    DynamicGroupNode2.prototype.getExpandIcon = function(sx, sy) {
      return "M ".concat(sx + 3, ",").concat(sy + 6, " ").concat(sx + 11, ",").concat(sy + 6, " ");
    };
    DynamicGroupNode2.prototype.getOperateIcon = function() {
      var model = this.props.model;
      var x2 = model.x, y = model.y, width = model.width, height = model.height;
      var sx = x2 - width / 2 + 10;
      var sy = y - height / 2 + 10;
      if (!model.collapsible)
        return null;
      var iconPath = (model === null || model === void 0 ? void 0 : model.isCollapsed) ? this.getCollapseIcon(sx, sy) : this.getExpandIcon(sx, sy);
      var operateIcon = g("path", {
        fill: "none",
        stroke: "#818281",
        strokeWidth: 2,
        "pointer-events": "none",
        d: iconPath
      });
      return g("g", {}, [
        g("rect", {
          height: 12,
          width: 14,
          rx: 2,
          ry: 2,
          strokeWidth: 1,
          fill: "#f4f5f6",
          stroke: "#cecece",
          cursor: "pointer",
          x: sx,
          y: sy,
          onClick: function() {
            model.toggleCollapse(!model.isCollapsed);
          }
        }),
        operateIcon
      ]);
    };
    DynamicGroupNode2.prototype.getShape = function() {
      return g("g", {}, [
        this.getAppendAreaShape(),
        _super.prototype.getShape.call(this),
        this.getOperateIcon()
      ]);
    };
    return DynamicGroupNode2;
  }(RectNode)
);

// node_modules/@logicflow/extension/es/dynamic-group/model.js
var __extends26 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign23 = function() {
  __assign23 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign23.apply(this, arguments);
};
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __read15 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray11 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DEFAULT_GROUP_EXPAND_WIDTH = 400;
var DEFAULT_GROUP_EXPAND_HEIGHT = 230;
var DEFAULT_GROUP_COLLAPSE_WIDTH = 80;
var DEFAULT_GROUP_COLLAPSE_HEIGHT = 60;
var DEFAULT_BOTTOM_Z_INDEX3 = -1e4;
var DynamicGroupNodeModel = (
  /** @class */
  function(_super) {
    __extends26(DynamicGroupNodeModel2, _super);
    function DynamicGroupNodeModel2(data, graphModel) {
      var _this = _super.call(this, data, graphModel) || this;
      _this.isGroup = true;
      _this.isRestrict = false;
      _this.autoResize = false;
      _this.collapsible = true;
      _this.isCollapsed = false;
      _this.groupAddable = false;
      _this.transformWithContainer = false;
      _this.childrenLastCollapseStateDict = /* @__PURE__ */ new Map();
      _this.childrenLastCollapseStateDict = /* @__PURE__ */ new Map();
      _this.initNodeData(data);
      _this.setAttributes();
      return _this;
    }
    DynamicGroupNodeModel2.prototype.initNodeData = function(data) {
      var _a;
      _super.prototype.initNodeData.call(this, data);
      var _b = (_a = data.properties) !== null && _a !== void 0 ? _a : {}, children = _b.children, width = _b.width, height = _b.height, collapsedWidth = _b.collapsedWidth, collapsedHeight = _b.collapsedHeight, collapsible = _b.collapsible, isCollapsed = _b.isCollapsed, zIndex = _b.zIndex, isRestrict = _b.isRestrict, autoResize = _b.autoResize, autoToFront = _b.autoToFront, transformWithContainer = _b.transformWithContainer;
      this.children = children ? new Set(children) : /* @__PURE__ */ new Set();
      this.zIndex = zIndex !== null && zIndex !== void 0 ? zIndex : DEFAULT_BOTTOM_Z_INDEX3;
      this.isCollapsed = isCollapsed !== null && isCollapsed !== void 0 ? isCollapsed : false;
      var expandWidth = width !== null && width !== void 0 ? width : DEFAULT_GROUP_EXPAND_WIDTH;
      var expandHeight = height !== null && height !== void 0 ? height : DEFAULT_GROUP_EXPAND_HEIGHT;
      this.width = expandWidth;
      this.height = expandHeight;
      this.expandWidth = expandWidth;
      this.expandHeight = expandHeight;
      this.collapsedWidth = collapsedWidth !== null && collapsedWidth !== void 0 ? collapsedWidth : DEFAULT_GROUP_COLLAPSE_WIDTH;
      this.collapsedHeight = collapsedHeight !== null && collapsedHeight !== void 0 ? collapsedHeight : DEFAULT_GROUP_COLLAPSE_HEIGHT;
      this.isRestrict = isRestrict !== null && isRestrict !== void 0 ? isRestrict : false;
      this.transformWithContainer = transformWithContainer !== null && transformWithContainer !== void 0 ? transformWithContainer : false;
      this.autoResize = autoResize !== null && autoResize !== void 0 ? autoResize : false;
      this.collapsible = collapsible !== null && collapsible !== void 0 ? collapsible : true;
      this.autoToFront = autoToFront !== null && autoToFront !== void 0 ? autoToFront : false;
      this.text.editable = false;
      this.text.draggable = false;
    };
    DynamicGroupNodeModel2.prototype.setAttributes = function() {
      _super.prototype.setAttributes.call(this);
    };
    DynamicGroupNodeModel2.prototype.getData = function() {
      var _this = this;
      var data = _super.prototype.getData.call(this);
      var children = [];
      forEach_default(Array.from(this.children), function(childId) {
        var model = _this.graphModel.getNodeModelById(childId);
        if (model && !model.virtual) {
          children.push(childId);
        }
      });
      data.children = children;
      if (data.properties) {
        data.properties.children = children;
        data.properties.isCollapsed = this.isCollapsed;
      }
      return data;
    };
    DynamicGroupNodeModel2.prototype.getNodesInGroup = function(groupModel) {
      var nodeIds = [];
      if (groupModel.isGroup) {
        forEach_default(Array.from(groupModel.children), function(nodeId) {
          nodeIds.push(nodeId);
        });
      }
      return nodeIds;
    };
    DynamicGroupNodeModel2.prototype.getMoveDistance = function(deltaX, deltaY, isIgnoreRule) {
      if (isIgnoreRule === void 0) {
        isIgnoreRule = false;
      }
      var _a = __read15(_super.prototype.getMoveDistance.call(this, deltaX, deltaY, isIgnoreRule), 2), moveDeltaX = _a[0], moveDeltaY = _a[1];
      var nodeIds = this.getNodesInGroup(this);
      this.graphModel.moveNodes(nodeIds, deltaX, deltaY, isIgnoreRule);
      return [moveDeltaX, moveDeltaY];
    };
    DynamicGroupNodeModel2.prototype.getHistoryData = function() {
      var data = _super.prototype.getHistoryData.call(this);
      data.children = Array.from(this.children);
      data.isGroup = true;
      var _a = this, x2 = _a.x, y = _a.y, collapsedWidth = _a.collapsedWidth, collapsedHeight = _a.collapsedHeight, expandWidth = _a.expandWidth, expandHeight = _a.expandHeight, isCollapsed = _a.isCollapsed;
      if (isCollapsed) {
        data.x = x2 + expandWidth / 2 - collapsedWidth / 2;
        data.y = y + expandHeight / 2 - collapsedHeight / 2;
        if (data.text) {
          data.text.x = data.text.x + expandWidth / 2 - collapsedWidth / 2;
          data.text.y = data.text.y + expandHeight / 2 - collapsedHeight / 2;
        }
      }
      return data;
    };
    DynamicGroupNodeModel2.prototype.toggleCollapse = function(collapse) {
      var _this = this;
      var nextCollapseState = !!collapse;
      this.isCollapsed = nextCollapseState;
      if (nextCollapseState) {
        this.collapse();
      } else {
        this.expand();
      }
      var allRelatedEdges = __spreadArray11(__spreadArray11([], __read15(this.incoming.edges), false), __read15(this.outgoing.edges), false);
      var childrenArr = Array.from(this.children);
      forEach_default(childrenArr, function(elementId) {
        var _a, _b;
        var model = _this.graphModel.elementsModelMap.get(elementId);
        if (model) {
          var collapseStatus = model.isCollapsed;
          if (model.isGroup) {
            var groupModel = model;
            if (!groupModel.isCollapsed) {
              groupModel.toggleCollapse(collapse);
            }
            if (!collapse) {
              var lastCollapseStatus = (_a = _this.childrenLastCollapseStateDict) === null || _a === void 0 ? void 0 : _a.get(elementId);
              if (lastCollapseStatus !== void 0 && lastCollapseStatus !== model.isCollapsed) {
                groupModel.toggleCollapse(lastCollapseStatus);
              }
            }
          }
          (_b = _this.childrenLastCollapseStateDict) === null || _b === void 0 ? void 0 : _b.set(elementId, !!collapseStatus);
          model.visible = !collapse;
          if (model.BaseType === ElementType.NODE) {
            var incomingEdges = model.incoming.edges;
            var outgoingEdges = model.outgoing.edges;
            allRelatedEdges = __spreadArray11(__spreadArray11(__spreadArray11([], __read15(allRelatedEdges), false), __read15(incomingEdges), false), __read15(outgoingEdges), false);
          }
        }
      });
      this.collapseEdge(nextCollapseState, allRelatedEdges);
    };
    DynamicGroupNodeModel2.prototype.collapse = function() {
      var _a = this, x2 = _a.x, y = _a.y, text = _a.text, width = _a.width, height = _a.height, collapsedWidth = _a.collapsedWidth, collapsedHeight = _a.collapsedHeight;
      this.x = x2 - width / 2 + collapsedWidth / 2;
      this.y = y - height / 2 + collapsedHeight / 2;
      this.text.x = text.x - width / 2 + collapsedWidth / 2;
      this.text.y = text.y - height / 2 + collapsedHeight / 2;
      this.expandWidth = width;
      this.expandHeight = height;
      this.width = collapsedWidth;
      this.height = collapsedHeight;
    };
    DynamicGroupNodeModel2.prototype.expand = function() {
      var _a = this, x2 = _a.x, y = _a.y, text = _a.text, expandWidth = _a.expandWidth, expandHeight = _a.expandHeight, collapsedWidth = _a.collapsedWidth, collapsedHeight = _a.collapsedHeight;
      this.width = expandWidth;
      this.height = expandHeight;
      this.x = x2 + this.width / 2 - collapsedWidth / 2;
      this.y = y + this.height / 2 - collapsedHeight / 2;
      this.text.x = text.x + this.width / 2 - collapsedWidth / 2;
      this.text.y = text.y + this.height / 2 - collapsedHeight / 2;
    };
    DynamicGroupNodeModel2.prototype.createVirtualEdge = function(edgeConfig) {
      edgeConfig.pointsList = void 0;
      var virtualEdge = this.graphModel.addEdge(edgeConfig);
      virtualEdge.virtual = true;
      virtualEdge.text.editable = false;
      virtualEdge.isCollapsedEdge = true;
    };
    DynamicGroupNodeModel2.prototype.collapseEdge = function(collapse, edges) {
      var _this = this;
      var graphModel = this.graphModel;
      forEach_default(edges, function(edge, idx) {
        var _a;
        var edgeData = edge.getData();
        var targetNodeId = edgeData.targetNodeId, sourceNodeId = edgeData.sourceNodeId;
        var edgeConfig = __assign23(__assign23({}, edgeData), { id: "".concat(edgeData.id, "__").concat(idx), text: (_a = edgeData.text) === null || _a === void 0 ? void 0 : _a.value });
        if (edge.virtual) {
          graphModel.deleteEdgeById(edge.id);
        }
        var targetNodeGroup = graphModel.dynamicGroup.getGroupByNodeId(targetNodeId);
        if (!targetNodeGroup) {
          targetNodeGroup = graphModel.getNodeModelById(targetNodeId);
        }
        var sourceNodeGroup = graphModel.dynamicGroup.getGroupByNodeId(sourceNodeId);
        if (!sourceNodeGroup) {
          sourceNodeGroup = graphModel.getNodeModelById(sourceNodeId);
        }
        if (collapse && edge.visible) {
          if (_this.children.has(sourceNodeId) || _this.id === sourceNodeId) {
            edgeConfig.startPoint = void 0;
            edgeConfig.sourceNodeId = _this.id;
          } else {
            edgeConfig.endPoint = void 0;
            edgeConfig.targetNodeId = _this.id;
          }
          if (targetNodeGroup.id !== _this.id || sourceNodeGroup.id !== _this.id) {
            _this.createVirtualEdge(edgeConfig);
          }
          edge.visible = false;
        }
        if (!collapse && !edge.visible) {
          if (targetNodeGroup && targetNodeGroup.isGroup && targetNodeGroup.isCollapsed) {
            edgeConfig.targetNodeId = targetNodeGroup.id;
            edgeConfig.endPoint = void 0;
            _this.createVirtualEdge(edgeConfig);
          } else if (sourceNodeGroup && sourceNodeGroup.isGroup && sourceNodeGroup.isCollapsed) {
            edgeConfig.sourceNodeId = sourceNodeGroup.id;
            edgeConfig.startPoint = void 0;
            _this.createVirtualEdge(edgeConfig);
          } else {
            edge.visible = true;
          }
        }
      });
    };
    DynamicGroupNodeModel2.prototype.isAllowAppendIn = function(_nodeData) {
      return true;
    };
    DynamicGroupNodeModel2.prototype.setAllowAppendChild = function(isAllow) {
      this.groupAddable = isAllow;
    };
    DynamicGroupNodeModel2.prototype.addChild = function(id) {
      this.children.add(id);
      var groupData = this.getData();
      this.graphModel.eventCenter.emit("group:add-node", { data: groupData });
    };
    DynamicGroupNodeModel2.prototype.removeChild = function(id) {
      this.children.delete(id);
      var groupData = this.getData();
      this.graphModel.eventCenter.emit("group:remove-node", { data: groupData });
    };
    DynamicGroupNodeModel2.prototype.toBack = function() {
      this.zIndex--;
    };
    DynamicGroupNodeModel2.prototype.getResizeOutlineStyle = function() {
      var style2 = _super.prototype.getResizeOutlineStyle.call(this);
      style2.stroke = "none";
      return style2;
    };
    DynamicGroupNodeModel2.prototype.getAnchorStyle = function() {
      var style2 = _super.prototype.getAnchorStyle.call(this);
      style2.stroke = "transparent";
      style2.fill = "transparent";
      if (style2.hover) {
        style2.hover.fill = "transparent";
        style2.hover.stroke = "transparent";
      }
      return style2;
    };
    DynamicGroupNodeModel2.prototype.getAddableOutlineStyle = function() {
      return {
        stroke: "#feb663",
        strokeWidth: 2,
        strokeDasharray: "4 4",
        fill: "transparent"
      };
    };
    __decorate([
      observable
    ], DynamicGroupNodeModel2.prototype, "isCollapsed", void 0);
    __decorate([
      observable
    ], DynamicGroupNodeModel2.prototype, "groupAddable", void 0);
    __decorate([
      observable
    ], DynamicGroupNodeModel2.prototype, "transformWithContainer", void 0);
    return DynamicGroupNodeModel2;
  }(RectNodeModel)
);

// node_modules/@logicflow/extension/es/dynamic-group/utils.js
function isBoundsInGroup(bounds, group) {
  var minX = bounds.minX, minY = bounds.minY, maxX = bounds.maxX, maxY = bounds.maxY;
  var x2 = group.x, y = group.y, width = group.width, height = group.height;
  return minX >= x2 - width / 2 && maxX <= x2 + width / 2 && minY >= y - height / 2 && maxY <= y + height / 2;
}
function isAllowMoveTo(groupBounds, node2, deltaX, deltaY) {
  var minX = groupBounds.minX, minY = groupBounds.minY, maxX = groupBounds.maxX, maxY = groupBounds.maxY;
  var x2 = node2.x, y = node2.y, width = node2.width, height = node2.height;
  var allowMoveMinX = minX + width / 2;
  var allowMoveMinY = minY + height / 2;
  var allowMoveMaxX = maxX - width / 2;
  var allowMoveMaxY = maxY - height / 2;
  return {
    x: x2 + deltaX >= allowMoveMinX && x2 + deltaX <= allowMoveMaxX,
    y: y + deltaY >= allowMoveMinY && y + deltaY <= allowMoveMaxY
  };
}

// node_modules/@logicflow/extension/es/dynamic-group/index.js
var __assign24 = function() {
  __assign24 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign24.apply(this, arguments);
};
var __read16 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray12 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var dynamicGroup = {
  type: "dynamic-group",
  view: DynamicGroupNode,
  model: DynamicGroupNodeModel
};
var DEFAULT_TOP_Z_INDEX2 = -1e3;
var DEFAULT_BOTTOM_Z_INDEX4 = -1e4;
var DynamicGroup = (
  /** @class */
  function() {
    function DynamicGroup2(_a) {
      var lf = _a.lf, options = _a.options;
      var _this = this;
      this.topGroupZIndex = DEFAULT_BOTTOM_Z_INDEX4;
      this.nodeGroupMap = /* @__PURE__ */ new Map();
      this.addNodeToGroup = function(_a2) {
        var node2 = _a2.data;
        var preGroupId = _this.nodeGroupMap.get(node2.id);
        if (preGroupId) {
          var group = _this.lf.getNodeModelById(preGroupId);
          group.removeChild(node2.id);
          _this.nodeGroupMap.delete(node2.id);
          group.setAllowAppendChild(false);
        }
        var nodeModel = _this.lf.getNodeModelById(node2.id);
        var bounds = nodeModel === null || nodeModel === void 0 ? void 0 : nodeModel.getBounds();
        if (nodeModel && bounds) {
          if (nodeModel.isGroup) {
            var group_1 = nodeModel;
            forEach_default(Array.from(group_1.children), function(childId) {
              _this.nodeGroupMap.set(childId, node2.id);
            });
            _this.calibrateTopGroupZIndex([node2]);
            _this.onNodeSelect({
              data: node2,
              isSelected: false,
              isMultiple: false
            });
          }
          var group = _this.getGroupByBounds(bounds, node2);
          if (group) {
            var isAllowAppendIn = group.isAllowAppendIn(node2);
            console.log("isAllowAppendIn", isAllowAppendIn);
            if (isAllowAppendIn) {
              group.addChild(node2.id);
              _this.nodeGroupMap.set(node2.id, group.id);
              group.setAllowAppendChild(true);
            } else {
              _this.lf.emit("group:not-allowed", {
                group: group.getData(),
                node: node2
              });
            }
          }
        }
      };
      this.removeNodeFromGroup = function(_a2) {
        var node2 = _a2.data, model = _a2.model;
        if (model.isGroup && node2.children) {
          forEach_default(Array.from(node2.children), function(childId) {
            _this.nodeGroupMap.delete(childId);
            _this.lf.deleteNode(childId);
          });
        }
        var groupId = _this.nodeGroupMap.get(node2.id);
        if (groupId) {
          var group = _this.lf.getNodeModelById(groupId);
          group && group.removeChild(node2.id);
          _this.nodeGroupMap.delete(node2.id);
        }
      };
      this.setActiveGroup = function(_a2) {
        var node2 = _a2.data;
        var nodeModel = _this.lf.getNodeModelById(node2.id);
        var bounds = nodeModel === null || nodeModel === void 0 ? void 0 : nodeModel.getBounds();
        if (nodeModel && bounds) {
          var targetGroup = _this.getGroupByBounds(bounds, node2);
          if (_this.activeGroup) {
            _this.activeGroup.setAllowAppendChild(false);
          }
          if (!targetGroup || nodeModel.isGroup && targetGroup.id === node2.id) {
            return;
          }
          var isAllowAppendIn = targetGroup.isAllowAppendIn(node2);
          if (!isAllowAppendIn)
            return;
          _this.activeGroup = targetGroup;
          console.log("this.activeGroup", _this.activeGroup);
          _this.activeGroup.setAllowAppendChild(true);
        }
      };
      this.onNodeSelect = function(_a2) {
        var node2 = _a2.data, isMultiple = _a2.isMultiple, isSelected = _a2.isSelected;
        var nodeModel = _this.lf.getNodeModelById(node2.id);
        _this.sendNodeToFront(nodeModel);
        if (_this.topGroupZIndex > DEFAULT_TOP_Z_INDEX2) {
          var nodes = _this.lf.graphModel.nodes;
          _this.topGroupZIndex = DEFAULT_BOTTOM_Z_INDEX4;
          var groups = sortBy_default(filter_default(nodes, function(node3) {
            return !!node3.isGroup;
          }), "zIndex");
          var preZIndex_1 = 0;
          forEach_default(groups, function(group) {
            if (group.zIndex !== preZIndex_1) {
              _this.topGroupZIndex++;
              preZIndex_1 = group.zIndex;
            }
            group.setZIndex(_this.topGroupZIndex);
          });
        }
        if (isMultiple && isSelected) {
          if (nodeModel === null || nodeModel === void 0 ? void 0 : nodeModel.isGroup) {
            var children = nodeModel.children;
            forEach_default(Array.from(children), function(childId) {
              var childModel = _this.lf.getNodeModelById(childId);
              childModel === null || childModel === void 0 ? void 0 : childModel.setSelected(false);
            });
          } else {
            var groupId = _this.nodeGroupMap.get(node2.id);
            if (groupId) {
              var graphModel = _this.lf.getNodeModelById(groupId);
              (graphModel === null || graphModel === void 0 ? void 0 : graphModel.isSelected) && (nodeModel === null || nodeModel === void 0 ? void 0 : nodeModel.setSelected(false));
            }
          }
        }
      };
      this.onNodeMove = function(_a2) {
        var deltaX = _a2.deltaX, deltaY = _a2.deltaY, data = _a2.data;
        var id = data.id, x2 = data.x, y = data.y, properties = data.properties;
        if (!properties) {
          return;
        }
        var width = properties.width, height = properties.height;
        var groupId = _this.nodeGroupMap.get(id);
        if (!groupId) {
          return;
        }
        var groupModel = _this.lf.getNodeModelById(groupId);
        if (!groupModel || !groupModel.isRestrict || !groupModel.autoResize) {
          return;
        }
        var newX = x2 + deltaX / 2;
        var newY = y + deltaY / 2;
        var minX = newX - width / 2;
        var minY = newY - height / 2;
        var maxX = newX + width / 2;
        var maxY = newY + height / 2;
        var hasChange = false;
        var groupBounds = groupModel.getBounds();
        var newGroupBounds = Object.assign({}, groupBounds);
        if (minX < newGroupBounds.minX) {
          newGroupBounds.minX = minX;
          hasChange = true;
        }
        if (minY < newGroupBounds.minY) {
          newGroupBounds.minY = minY;
          hasChange = true;
        }
        if (maxX > newGroupBounds.maxX) {
          newGroupBounds.maxX = maxX;
          hasChange = true;
        }
        if (maxY > newGroupBounds.maxY) {
          newGroupBounds.maxY = maxY;
          hasChange = true;
        }
        if (!hasChange) {
          return;
        }
        var newGroupX = newGroupBounds.minX + (newGroupBounds.maxX - newGroupBounds.minX) / 2;
        var newGroupY = newGroupBounds.minY + (newGroupBounds.maxY - newGroupBounds.minY) / 2;
        var newGroupWidth = newGroupBounds.maxX - newGroupBounds.minX;
        var newGroupHeight = newGroupBounds.maxY - newGroupBounds.minY;
        groupModel.moveTo(newGroupX, newGroupY);
        groupModel.width = newGroupWidth;
        groupModel.height = newGroupHeight;
      };
      this.onGraphRendered = function(_a2) {
        var data = _a2.data;
        console.log("data", data);
        forEach_default(data.nodes, function(node2) {
          if (node2.children) {
            forEach_default(node2.children, function(childId) {
              _this.nodeGroupMap.set(childId, node2.id);
            });
          }
        });
        _this.calibrateTopGroupZIndex(data.nodes);
      };
      lf.register(dynamicGroup);
      this.lf = lf;
      assign_default(this, options);
      this.init();
    }
    DynamicGroup2.prototype.getGroupByNodeId = function(nodeId) {
      var groupId = this.nodeGroupMap.get(nodeId);
      if (groupId) {
        return this.lf.getNodeModelById(groupId);
      }
    };
    DynamicGroup2.prototype.getGroupByBounds = function(bounds, nodeData) {
      var nodes = this.lf.graphModel.nodes;
      var groups = filter_default(nodes, function(node2) {
        return !!node2.isGroup && isBoundsInGroup(bounds, node2) && node2.id !== nodeData.id;
      });
      var count = groups.length;
      if (count <= 1) {
        return groups[0];
      } else {
        var topZIndexGroup = groups[count - 1];
        for (var i = count - 2; i >= 0; i--) {
          if (groups[i].zIndex > topZIndexGroup.zIndex) {
            topZIndexGroup = groups[i];
          }
        }
        return topZIndexGroup;
      }
    };
    DynamicGroup2.prototype.sendNodeToFront = function(model) {
      var _this = this;
      if (!model || !model.isGroup)
        return;
      this.topGroupZIndex++;
      model.setZIndex(this.topGroupZIndex);
      if (model.children) {
        var children = model.children;
        forEach_default(Array.from(children), function(nodeId) {
          var node2 = _this.lf.getNodeModelById(nodeId);
          _this.sendNodeToFront(node2);
        });
      }
    };
    DynamicGroup2.prototype.getMaxZIndex = function(node2) {
      var _this = this;
      var maxZIndex = DEFAULT_BOTTOM_Z_INDEX4;
      if (node2.isGroup) {
        maxZIndex = Math.max(maxZIndex, node2.zIndex);
      }
      if (node2.children) {
        var children = node2.children;
        forEach_default(Array.from(children), function(childId) {
          var child = _this.lf.getNodeModelById(childId);
          if (child === null || child === void 0 ? void 0 : child.isGroup) {
            var childMaxZIndex = _this.getMaxZIndex(child);
            maxZIndex = Math.max(maxZIndex, childMaxZIndex);
          }
        });
      }
      return maxZIndex;
    };
    DynamicGroup2.prototype.calibrateTopGroupZIndex = function(nodes) {
      var _this = this;
      var maxZIndex = DEFAULT_BOTTOM_Z_INDEX4;
      forEach_default(nodes, function(node2) {
        var nodeModel = _this.lf.getNodeModelById(node2.id);
        if (nodeModel) {
          var currNodeMaxZIndex = _this.getMaxZIndex(nodeModel);
          if (currNodeMaxZIndex > maxZIndex) {
            maxZIndex = currNodeMaxZIndex;
          }
        }
      });
      if (this.topGroupZIndex >= maxZIndex) {
        return;
      }
      var allNodes = this.lf.graphModel.nodes;
      var allGroups = filter_default(allNodes, function(node2) {
        return !!node2.isGroup;
      });
      var max = this.topGroupZIndex;
      forEach_default(allGroups, function(group) {
        if (group.zIndex > max)
          max = group.zIndex;
      });
      this.topGroupZIndex = max;
    };
    DynamicGroup2.prototype.removeChildrenInGroupNodeData = function(nodeData) {
      var _a;
      var newNodeData = cloneDeep_default(nodeData);
      delete newNodeData.children;
      if ((_a = newNodeData.properties) === null || _a === void 0 ? void 0 : _a.children) {
        delete newNodeData.properties.children;
      }
      return newNodeData;
    };
    DynamicGroup2.prototype.initGroupChildNodes = function(nodeIdMap, children, curGroup, distance) {
      var _this = this;
      var allChildNodes = [];
      var edgesDataArr = [];
      var allRelatedEdges = [];
      forEach_default(Array.from(children), function(childId) {
        var childNode = _this.lf.getNodeModelById(childId);
        if (childNode) {
          var childNodeChildren = childNode.children;
          var childNodeData = childNode.getData();
          var eventType = EventType.NODE_GROUP_COPY || "node:group-copy-add";
          var newNodeConfig = transformNodeData(_this.removeChildrenInGroupNodeData(childNodeData), distance);
          var tempChildNode = _this.lf.addNode(newNodeConfig, eventType);
          curGroup.addChild(tempChildNode.id);
          nodeIdMap[childId] = tempChildNode.id;
          allChildNodes.push(tempChildNode);
          allRelatedEdges.push.apply(allRelatedEdges, __spreadArray12([], __read16(__spreadArray12(__spreadArray12([], __read16(tempChildNode.incoming.edges), false), __read16(tempChildNode.outgoing.edges), false)), false));
          if (childNodeChildren instanceof Set) {
            var _a = _this.initGroupChildNodes(nodeIdMap, childNodeChildren, tempChildNode, distance), childNodes = _a.childNodes, edgesData = _a.edgesData;
            allChildNodes.push.apply(allChildNodes, __spreadArray12([], __read16(childNodes), false));
            edgesDataArr.push.apply(edgesDataArr, __spreadArray12([], __read16(edgesData), false));
          }
        }
      });
      console.log("allRelatedEdges -->>", allRelatedEdges);
      var edgesInnerGroup = filter_default(allRelatedEdges, function(edge) {
        return has_default(nodeIdMap, edge.sourceNodeId) && has_default(nodeIdMap, edge.targetNodeId);
      });
      var edgesDataInnerGroup = map_default(edgesInnerGroup, function(edge) {
        return edge.getData();
      });
      return {
        childNodes: allChildNodes,
        edgesData: edgesDataArr.concat(edgesDataInnerGroup)
      };
    };
    DynamicGroup2.prototype.createEdge = function(edge, nodeIdMap, distance) {
      var _a, _b;
      var sourceNodeId = edge.sourceNodeId, targetNodeId = edge.targetNodeId;
      var sourceId = (_a = nodeIdMap[sourceNodeId]) !== null && _a !== void 0 ? _a : sourceNodeId;
      var targetId = (_b = nodeIdMap[targetNodeId]) !== null && _b !== void 0 ? _b : targetNodeId;
      var newEdgeConfig = cloneDeep_default(edge);
      if (edge.id && typeof edge.text === "object" && edge.text !== null) {
        newEdgeConfig = transformEdgeData(edge, distance);
      }
      return this.lf.graphModel.addEdge(__assign24(__assign24({}, newEdgeConfig), { sourceNodeId: sourceId, targetNodeId: targetId }));
    };
    DynamicGroup2.prototype.checkGroupBoundsWithChildren = function(groupModel, deltaX, deltaY, newWidth, newHeight) {
      if (groupModel.children) {
        var children = groupModel.children, x2 = groupModel.x, y = groupModel.y;
        var newX = x2 + deltaX / 2;
        var newY = y + deltaY / 2;
        var groupMinX = newX - newWidth / 2;
        var groupMinY = newY - newHeight / 2;
        var groupMaxX = newX + newWidth / 2;
        var groupMaxY = newY + newHeight / 2;
        var childrenArray = Array.from(children);
        for (var i = 0; i < childrenArray.length; i++) {
          var childId = childrenArray[i];
          var child = this.lf.getNodeModelById(childId);
          if (!child) {
            continue;
          }
          var childBounds = child.getBounds();
          var minX = childBounds.minX, minY = childBounds.minY, maxX = childBounds.maxX, maxY = childBounds.maxY;
          var canResize = groupMinX <= minX && groupMinY <= minY && groupMaxX >= maxX && groupMaxY >= maxY;
          if (!canResize) {
            return false;
          }
        }
      }
      return true;
    };
    DynamicGroup2.prototype.init = function() {
      var _this = this;
      var lf = this.lf;
      var graphModel = lf.graphModel;
      graphModel.addNodeMoveRules(function(model, deltaX, deltaY) {
        if (model.isGroup) {
          return true;
        }
        var groupId = _this.nodeGroupMap.get(model.id);
        var groupModel = _this.lf.getNodeModelById(groupId);
        if (groupModel && groupModel.isRestrict) {
          if (groupModel.autoResize) {
            return true;
          } else {
            var groupBounds = groupModel.getBounds();
            return isAllowMoveTo(groupBounds, model, deltaX, deltaY);
          }
        }
        return true;
      });
      graphModel.addNodeResizeRules(function(model, deltaX, deltaY, width, height) {
        if (model.isGroup && model.isRestrict) {
          return _this.checkGroupBoundsWithChildren(model, deltaX, deltaY, width, height);
        }
        return true;
      });
      graphModel.dynamicGroup = this;
      lf.on("node:add,node:drop,node:dnd-add", this.addNodeToGroup);
      lf.on("node:delete", this.removeNodeFromGroup);
      lf.on("node:drag,node:dnd-drag", this.setActiveGroup);
      lf.on("node:click", this.onNodeSelect);
      lf.on("node:mousemove", this.onNodeMove);
      lf.on("graph:rendered", this.onGraphRendered);
      lf.on("graph:updated", function(_a) {
        var data = _a.data;
        return console.log("data", data);
      });
      lf.on("group:add-node", function(_a) {
        var data = _a.data;
        return console.log("group:add-node", data);
      });
      lf.addElements = function(_a, distance) {
        var selectedNodes = _a.nodes, selectedEdges = _a.edges;
        if (distance === void 0) {
          distance = 40;
        }
        var nodeIdMap = {};
        var elements = {
          nodes: [],
          edges: []
        };
        var edgesInnerGroup = [];
        forEach_default(selectedNodes, function(node2) {
          var _a2, _b;
          var originId = node2.id;
          var children = (_b = (_a2 = node2.properties) === null || _a2 === void 0 ? void 0 : _a2.children) !== null && _b !== void 0 ? _b : node2.children;
          var model = lf.addNode(_this.removeChildrenInGroupNodeData(node2));
          if (originId)
            nodeIdMap[originId] = model.id;
          elements.nodes.push(model);
          if (model.isGroup) {
            var edgesData = _this.initGroupChildNodes(nodeIdMap, children, model, distance).edgesData;
            edgesInnerGroup.push.apply(edgesInnerGroup, __spreadArray12([], __read16(edgesData), false));
          }
        });
        forEach_default(edgesInnerGroup, function(edge) {
          _this.createEdge(edge, nodeIdMap, distance);
        });
        console.log("selectedEdges --->>>", selectedEdges);
        forEach_default(selectedEdges, function(edge) {
          elements.edges.push(_this.createEdge(edge, nodeIdMap, distance));
        });
        return elements;
      };
      this.render();
    };
    DynamicGroup2.prototype.render = function() {
    };
    DynamicGroup2.prototype.destroy = function() {
      this.lf.off("node:add,node:drop,node:dnd-add", this.addNodeToGroup);
      this.lf.off("node:delete", this.removeNodeFromGroup);
      this.lf.off("node:drag,node:dnd-drag", this.setActiveGroup);
      this.lf.off("node:click", this.onNodeSelect);
      this.lf.off("node:mousemove", this.onNodeMove);
      this.lf.off("graph:rendered", this.onGraphRendered);
    };
    DynamicGroup2.pluginName = "dynamicGroup";
    return DynamicGroup2;
  }()
);

// node_modules/@logicflow/extension/es/insert-node-in-polyline/edge.js
var SegmentDirection;
(function(SegmentDirection2) {
  SegmentDirection2["HORIZONTAL"] = "horizontal";
  SegmentDirection2["VERTICAL"] = "vertical";
})(SegmentDirection || (SegmentDirection = {}));
var isInSegment2 = function(point, start, end, deviation) {
  if (deviation === void 0) {
    deviation = 0;
  }
  var distance = distToSegment(point, start, end);
  return distance <= deviation;
};
function sqr(x2) {
  return x2 * x2;
}
function dist2(v, w) {
  return sqr(v.x - w.x) + sqr(v.y - w.y);
}
var distToSegmentSquared = function(p, v, w) {
  var l2 = dist2(v, w);
  if (l2 === 0)
    return dist2(p, v);
  var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
  t = Math.max(0, Math.min(1, t));
  return dist2(p, {
    x: v.x + t * (w.x - v.x),
    y: v.y + t * (w.y - v.y)
  });
};
var distToSegment = function(point, start, end) {
  return Math.sqrt(distToSegmentSquared(point, start, end));
};
var getNodeBBox = function(node2) {
  var x2 = node2.x, y = node2.y, width = node2.width, height = node2.height;
  var bBox = {
    minX: x2 - width / 2,
    minY: y - height / 2,
    maxX: x2 + width / 2,
    maxY: y + height / 2,
    x: x2,
    y,
    width,
    height,
    centerX: x2,
    centerY: y
  };
  return bBox;
};
var segmentDirection = function(start, end) {
  var direction;
  if (start.x === end.x) {
    direction = SegmentDirection.VERTICAL;
  } else if (start.y === end.y) {
    direction = SegmentDirection.HORIZONTAL;
  }
  return direction;
};
var crossPointInSegment = function(node2, start, end) {
  var bBox = getNodeBBox(node2);
  var direction = segmentDirection(start, end);
  var maxX = Math.max(start.x, end.x);
  var minX = Math.min(start.x, end.x);
  var maxY = Math.max(start.y, end.y);
  var minY = Math.min(start.y, end.y);
  var x2 = node2.x, y = node2.y, width = node2.width, height = node2.height;
  if (direction === SegmentDirection.HORIZONTAL) {
    if (maxX >= bBox.maxX && minX <= bBox.minX) {
      return {
        startCrossPoint: {
          x: start.x > end.x ? x2 + width / 2 : x2 - width / 2,
          y: start.y
        },
        endCrossPoint: {
          x: start.x > end.x ? x2 - width / 2 : x2 + width / 2,
          y: start.y
        }
      };
    }
  } else if (direction === SegmentDirection.VERTICAL) {
    if (maxY >= bBox.maxY && minY <= bBox.minY) {
      return {
        startCrossPoint: {
          x: start.x,
          y: start.y > end.y ? y + height / 2 : y - height / 2
        },
        endCrossPoint: {
          x: start.x,
          y: start.y > end.y ? y - height / 2 : y + height / 2
        }
      };
    }
  }
};
var isNodeInSegment = function(node2, polyline, deviation) {
  if (deviation === void 0) {
    deviation = 0;
  }
  var x2 = node2.x, y = node2.y;
  var pointsList = polyline.pointsList;
  for (var i = 0; i < pointsList.length - 1; i++) {
    if (isInSegment2({
      x: x2,
      y
    }, pointsList[i], pointsList[i + 1], deviation)) {
      var bBoxCross = crossPointInSegment(node2, pointsList[i], pointsList[i + 1]);
      if (bBoxCross) {
        return {
          crossIndex: i + 1,
          crossPoints: bBoxCross
        };
      }
    }
  }
  return {
    crossIndex: -1,
    crossPoints: {
      startCrossPoint: {
        x: 0,
        y: 0
      },
      endCrossPoint: {
        x: 0,
        y: 0
      }
    }
  };
};

// node_modules/@logicflow/extension/es/insert-node-in-polyline/index.js
var __read17 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray13 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var InsertNodeInPolyline = (
  /** @class */
  function() {
    function InsertNodeInPolyline2(_a) {
      var lf = _a.lf;
      this._lf = lf;
      this.deviation = 20;
      this.dndAdd = true;
      this.dropAdd = true;
      this.eventHandler();
    }
    InsertNodeInPolyline2.prototype.eventHandler = function() {
      var _this = this;
      if (this.dndAdd) {
        this._lf.on("node:dnd-add", function(_a) {
          var data = _a.data;
          _this.insetNode(data);
        });
      }
      if (this.dropAdd) {
        this._lf.on("node:drop", function(_a) {
          var data = _a.data;
          var edges = _this._lf.graphModel.edges;
          var id = data.id;
          var pureNode = true;
          for (var i = 0; i < edges.length; i++) {
            if (edges[i].sourceNodeId === id || edges[i].targetNodeId === id) {
              pureNode = false;
              break;
            }
          }
          if (pureNode) {
            _this.insetNode(data);
          }
        });
      }
    };
    InsertNodeInPolyline2.prototype.checkRuleBeforeInsetNode = function(sourceNodeId, targetNodeId, sourceAnchorId, targetAnchorId, nodeData) {
      var sourceNodeModel = this._lf.getNodeModelById(sourceNodeId);
      var targetNodeModel = this._lf.getNodeModelById(targetNodeId);
      var sourceAnchorInfo = sourceNodeModel.getAnchorInfo(sourceAnchorId);
      var targetAnchorInfo = targetNodeModel.getAnchorInfo(targetAnchorId);
      var sourceRuleResultData = sourceNodeModel.isAllowConnectedAsSource(nodeData, sourceAnchorInfo, targetAnchorInfo);
      var targetRuleResultData = targetNodeModel.isAllowConnectedAsTarget(nodeData, sourceAnchorInfo, targetAnchorInfo);
      var _a = formatAnchorConnectValidateData(sourceRuleResultData), isSourcePass = _a.isAllPass, sourceMsg = _a.msg;
      var _b = formatAnchorConnectValidateData(targetRuleResultData), isTargetPass = _b.isAllPass, targetMsg = _b.msg;
      return {
        isPass: isSourcePass && isTargetPass,
        sourceMsg,
        targetMsg
      };
    };
    InsertNodeInPolyline2.prototype.insetNode = function(nodeData) {
      var _this = this;
      var edges = this._lf.graphModel.edges;
      var nodeModel = this._lf.getNodeModelById(nodeData.id);
      var anchorArray = nodeModel === null || nodeModel === void 0 ? void 0 : nodeModel.getDefaultAnchor();
      var isNotAllowConnect = !anchorArray || anchorArray.length === 0;
      if (isNotAllowConnect) {
        this._lf.graphModel.eventCenter.emit(EventType.CONNECTION_NOT_ALLOWED, {
          data: nodeData,
          msg: "自定义类型节点不显示锚点，也不允许其他节点连接到此节点"
        });
        return;
      }
      if (!nodeModel)
        return;
      for (var i = 0; i < edges.length; i++) {
        var _a = isNodeInSegment(nodeModel, edges[i], this.deviation), crossIndex = _a.crossIndex, crossPoints = _a.crossPoints;
        if (crossIndex >= 0) {
          var _b = edges[i], sourceNodeId = _b.sourceNodeId, targetNodeId = _b.targetNodeId, id = _b.id, type3 = _b.type, pointsList = _b.pointsList, sourceAnchorId = _b.sourceAnchorId, targetAnchorId = _b.targetAnchorId;
          var startPoint = cloneDeep_default(pointsList[0]);
          var endPoint = cloneDeep_default(crossPoints.startCrossPoint);
          this._lf.deleteEdge(id);
          var checkResult = this.checkRuleBeforeInsetNode(sourceNodeId, targetNodeId, sourceAnchorId, targetAnchorId, nodeData);
          this._lf.addEdge({
            type: type3,
            sourceNodeId,
            targetNodeId: nodeData.id,
            startPoint,
            endPoint,
            pointsList: __spreadArray13(__spreadArray13([], __read17(pointsList.slice(0, crossIndex)), false), [
              crossPoints.startCrossPoint
            ], false)
          });
          this._lf.addEdge({
            type: type3,
            sourceNodeId: nodeData.id,
            targetNodeId,
            startPoint: cloneDeep_default(crossPoints.endCrossPoint),
            endPoint: cloneDeep_default(pointsList[pointsList.length - 1]),
            pointsList: __spreadArray13([
              crossPoints.endCrossPoint
            ], __read17(pointsList.slice(crossIndex)), false)
          });
          if (!checkResult.isPass) {
            this._lf.graphModel.eventCenter.emit(EventType.CONNECTION_NOT_ALLOWED, {
              data: nodeData,
              msg: checkResult.targetMsg || checkResult.sourceMsg
            });
            setTimeout(function() {
              _this._lf.undo();
            }, 200);
            break;
          } else {
            break;
          }
        }
      }
    };
    InsertNodeInPolyline2.pluginName = "insertNodeInPolyline";
    return InsertNodeInPolyline2;
  }()
);

// node_modules/@logicflow/extension/es/tools/label/Label.js
var import_classnames = __toESM(require_classnames());
var __extends27 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign25 = function() {
  __assign25 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign25.apply(this, arguments);
};
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __read18 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var Label = (
  /** @class */
  function(_super) {
    __extends27(Label3, _super);
    function Label3(props) {
      var _this = _super.call(this, props) || this;
      _this.textRef = b();
      _this.setHoverOn = function() {
        var element = _this.props.element;
        if (element.isDragging || _this.state.isHovered)
          return;
        _this.setState({ isHovered: true });
        element.setHovered(true);
      };
      _this.setHoverOff = function() {
        var element = _this.props.element;
        if (!_this.state.isHovered)
          return;
        _this.setState({ isHovered: false });
        element.setHovered(false);
      };
      _this.handleMouseDown = function(e) {
        var _a2;
        var _b = _this.props, label2 = _b.label, graphModel = _b.graphModel;
        var nodeTextDraggable = graphModel.editConfigModel.nodeTextDraggable;
        if (((_a2 = label2.draggable) !== null && _a2 !== void 0 ? _a2 : nodeTextDraggable) && !_this.state.isDragging && !_this.state.isEditing) {
          _this.stepDrag.handleMouseDown(e);
        }
      };
      _this.handleMouseUp = function(e) {
        if (_this.state.isDragging) {
          _this.stepDrag.handleMouseUp(e);
        }
      };
      _this.handleDragging = function(_a2) {
        var deltaX = _a2.deltaX, deltaY = _a2.deltaY;
        if (!_this.state.isDragging) {
          _this.setState({ isDragging: true });
        }
        var _b = _this.props, label2 = _b.label, graphModel = _b.graphModel;
        var transformModel = graphModel.transformModel;
        var _c = __read18(transformModel.fixDeltaXY(deltaX, deltaY), 2), curDeltaX = _c[0], curDeltaY = _c[1];
        _this.setElementModelLabelInfo({
          x: label2.x + curDeltaX,
          y: label2.y + curDeltaY
        });
        graphModel.eventCenter.emit("label:drag", {
          data: label2.getData(),
          model: label2
        });
      };
      _this.handleDragEnd = function() {
        _this.setState({ isDragging: false });
      };
      _this.handleClick = function(e) {
        var _a2 = _this.props, label2 = _a2.label, element = _a2.element, graphModel = _a2.graphModel;
        element.setSelected(!_this.state.isSelected);
        _this.setState({ isSelected: !_this.state.isSelected });
        _this.setElementModelLabelInfo({
          isSelected: true
        });
        graphModel.eventCenter.emit("label:click", {
          data: label2.getData(),
          e,
          model: element
        });
      };
      _this.handleDbClick = function(e) {
        var _a2 = _this.props, label2 = _a2.label, element = _a2.element, graphModel = _a2.graphModel;
        graphModel.eventCenter.emit("label:dblclick", {
          data: label2.getData(),
          e,
          model: element
        });
        if (!label2.editable) {
          element.setSelected(true);
          return;
        }
        element.setSelected();
        element.setElementState(ElementState.TEXT_EDIT);
        _this.setState({ isEditing: true });
        if (_this.textRef.current) {
          _this.textRef.current.contentEditable = "true";
          _this.textRef.current.focus();
          var range = document.createRange();
          var selection = window.getSelection();
          range.selectNodeContents(_this.textRef.current);
          range.collapse(false);
          selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
          selection === null || selection === void 0 ? void 0 : selection.addRange(range);
        }
      };
      _this.handleBlur = function(e) {
        var _a2 = _this.props, label2 = _a2.label, element = _a2.element, eventCenter2 = _a2.graphModel.eventCenter;
        eventCenter2.emit("label:blur", {
          e,
          model: element,
          data: label2.getData(),
          element: _this.textRef.current
        });
        _this.setState({
          isDragging: false,
          isHovered: false,
          isSelected: false
        });
      };
      _this.handleInput = function(e) {
        var _a2 = _this.props, label2 = _a2.label, graphModel = _a2.graphModel;
        graphModel.eventCenter.emit("label:input", {
          e,
          data: label2.getData()
        });
      };
      _this.reCalcLabelSize = function() {
      };
      var label = props.label, _a = props.graphModel, gridSize = _a.gridSize, eventCenter = _a.eventCenter;
      _this.stepDrag = new StepDrag({
        onDragging: _this.handleDragging,
        onDragEnd: _this.handleDragEnd,
        step: gridSize,
        eventType: "LABEL",
        model: label,
        eventCenter
      });
      _this.state = {
        isEditing: false,
        isHovered: false,
        isDragging: false,
        isSelected: false
      };
      return _this;
    }
    Label3.prototype.setElementModelLabelInfo = function(data) {
      var _a = this.props, label = _a.label, element = _a.element, graphModel = _a.graphModel;
      var _label = element.properties._label;
      var elementLabel = _label;
      var idx = findIndex_default(elementLabel, function(cur) {
        return cur.id === label.id;
      });
      var target = elementLabel[idx];
      elementLabel[idx] = __assign25(__assign25({}, target), data);
      var targetElem = graphModel.getElement(element.id);
      targetElem === null || targetElem === void 0 ? void 0 : targetElem.setProperty("_label", elementLabel);
    };
    Label3.prototype.componentDidMount = function() {
      var _this = this;
      var _a = this.props, label = _a.label, element = _a.element, graphModel = _a.graphModel;
      graphModel.eventCenter.on("blank:click,node:click,edge:click,label:click", function(_a2) {
        var _b, _c, _d, _e;
        var data = _a2.data;
        if ((data === null || data === void 0 ? void 0 : data.type) !== "label" || data.type === "label" && data.id !== label.id || _this.state.isSelected) {
          _this.setState({ isSelected: false });
        }
        if (((data === null || data === void 0 ? void 0 : data.type) !== "label" || data.type == "label" && data.id !== label.id) && _this.state.isEditing) {
          _this.setState({ isEditing: false });
          var value = (_c = (_b = _this.textRef.current) === null || _b === void 0 ? void 0 : _b.innerText) !== null && _c !== void 0 ? _c : "";
          var content = (_e = (_d = _this.textRef.current) === null || _d === void 0 ? void 0 : _d.innerHTML) !== null && _e !== void 0 ? _e : "";
          _this.setElementModelLabelInfo({
            value,
            content,
            isSelected: false
          });
          element.setElementState(ElementState.DEFAULT);
        }
        if (((data === null || data === void 0 ? void 0 : data.type) !== "label" || data.type == "label" && data.id !== label.id) && _this.textRef.current) {
          _this.textRef.current.contentEditable = "false";
        }
      });
    };
    Label3.prototype.componentDidUpdate = function() {
    };
    Label3.prototype.componentWillUnmount = function() {
      var graphModel = this.props.graphModel;
      graphModel.eventCenter.off("blank:click,node:click,edge:click");
    };
    Label3.prototype.render = function() {
      var _a;
      var _b = this.props, label = _b.label, element = _b.element, graphModel = _b.graphModel;
      var _c = this.state, isDragging = _c.isDragging, isHovered = _c.isHovered, isSelected = _c.isSelected, isEditing = _c.isEditing;
      var transformModel = graphModel.transformModel;
      var transform = transformModel.getTransformStyle().transform;
      var id = label.id, x2 = label.x, y = label.y, zIndex = label.zIndex, vertical = label.vertical, style2 = label.style, rotate = label.rotate, content = label.content, labelWidth = label.labelWidth, textOverflowMode = label.textOverflowMode;
      var maxLabelWidth = labelWidth !== null && labelWidth !== void 0 ? labelWidth : element.BaseType === "node" ? element.width - 20 : 80;
      var containerStyle = {
        left: "".concat(x2 - maxLabelWidth / 2, "px"),
        top: "".concat(y - 10, "px"),
        width: "".concat(maxLabelWidth, "px"),
        height: "20px",
        zIndex: zIndex !== null && zIndex !== void 0 ? zIndex : 1,
        transform: rotate ? "".concat(transform, " rotate(").concat(rotate, "deg)") : "".concat(transform, " rotate(").concat(vertical ? -0.25 : 0, "turn)")
      };
      return u("div", { id: "element-container-".concat(id), className: (0, import_classnames.default)("lf-label-editor-container"), style: containerStyle, onMouseDown: this.handleMouseDown, onMouseUp: this.handleMouseUp, onClick: this.handleClick, onDblClick: this.handleDbClick, onBlur: this.handleBlur, onMouseEnter: this.setHoverOn, onMouseOver: this.setHoverOn, onMouseLeave: this.setHoverOff, children: u("div", { ref: this.textRef, id: "editor-container-".concat(id), className: (0, import_classnames.default)("lf-label-editor", (_a = {
        "lf-label-editor-dragging": isDragging,
        "lf-label-editor-editing": isEditing,
        "lf-label-editor-hover": !isEditing && (isHovered || isSelected)
      }, _a["lf-label-editor-".concat(textOverflowMode)] = !isEditing, _a)), onInput: this.handleInput, style: __assign25({ maxWidth: "".concat(maxLabelWidth, "px"), boxSizing: "border-box", display: "inline-block", background: isEditing || element.BaseType === "edge" ? "#fff" : "transparent" }, style2), dangerouslySetInnerHTML: { __html: content } }) });
    };
    Label3 = __decorate2([
      observer
    ], Label3);
    return Label3;
  }(x)
);
var Label_default = Label;

// node_modules/@logicflow/extension/es/tools/label/LabelModel.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var createUuid2 = util_exports.createUuid;
var LabelModel = (
  /** @class */
  function() {
    function LabelModel2(config, element, graphModel) {
      var _a;
      this.type = "label";
      this.content = "";
      this.value = "";
      this.style = {};
      this.vertical = false;
      this.editable = true;
      this.draggable = true;
      this.textOverflowMode = "default";
      this.element = element;
      this.graphModel = graphModel;
      this.id = (_a = config.id) !== null && _a !== void 0 ? _a : createUuid2();
      this.initLabelData(config);
    }
    LabelModel2.prototype.initLabelData = function(config) {
      assign_default(this, config);
    };
    LabelModel2.prototype.getData = function() {
      return {
        id: this.id,
        x: this.x,
        y: this.y,
        type: "label",
        content: this.content,
        value: this.value,
        rotate: this.rotate,
        style: toJS(this.style),
        draggable: this.draggable,
        editable: this.editable,
        labelWidth: this.labelWidth,
        textOverflowMode: this.textOverflowMode,
        vertical: this.vertical
      };
    };
    __decorate3([
      observable
    ], LabelModel2.prototype, "x", void 0);
    __decorate3([
      observable
    ], LabelModel2.prototype, "y", void 0);
    __decorate3([
      observable
    ], LabelModel2.prototype, "content", void 0);
    __decorate3([
      observable
    ], LabelModel2.prototype, "value", void 0);
    __decorate3([
      observable
    ], LabelModel2.prototype, "rotate", void 0);
    __decorate3([
      observable
    ], LabelModel2.prototype, "style", void 0);
    __decorate3([
      observable
    ], LabelModel2.prototype, "zIndex", void 0);
    __decorate3([
      observable
    ], LabelModel2.prototype, "vertical", void 0);
    __decorate3([
      observable
    ], LabelModel2.prototype, "editable", void 0);
    __decorate3([
      observable
    ], LabelModel2.prototype, "draggable", void 0);
    __decorate3([
      observable
    ], LabelModel2.prototype, "labelWidth", void 0);
    __decorate3([
      observable
    ], LabelModel2.prototype, "textOverflowMode", void 0);
    return LabelModel2;
  }()
);
var LabelModel_default = LabelModel;

// node_modules/@logicflow/extension/es/tools/label/mediumEditor.js
var import_medium_editor = __toESM(require_medium_editor());

// node_modules/vanilla-picker/dist/vanilla-picker.mjs
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = /* @__PURE__ */ function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var slicedToArray = /* @__PURE__ */ function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
String.prototype.startsWith = String.prototype.startsWith || function(needle) {
  return this.indexOf(needle) === 0;
};
String.prototype.padStart = String.prototype.padStart || function(len, pad) {
  var str = this;
  while (str.length < len) {
    str = pad + str;
  }
  return str;
};
var colorNames = { cb: "0f8ff", tqw: "aebd7", q: "-ffff", qmrn: "7fffd4", zr: "0ffff", bg: "5f5dc", bsq: "e4c4", bck: "---", nch: "ebcd", b: "--ff", bvt: "8a2be2", brwn: "a52a2a", brw: "deb887", ctb: "5f9ea0", hrt: "7fff-", chcT: "d2691e", cr: "7f50", rnw: "6495ed", crns: "8dc", crms: "dc143c", cn: "-ffff", Db: "--8b", Dcn: "-8b8b", Dgnr: "b8860b", Dgr: "a9a9a9", Dgrn: "-64-", Dkhk: "bdb76b", Dmgn: "8b-8b", Dvgr: "556b2f", Drng: "8c-", Drch: "9932cc", Dr: "8b--", Dsmn: "e9967a", Dsgr: "8fbc8f", DsTb: "483d8b", DsTg: "2f4f4f", Dtrq: "-ced1", Dvt: "94-d3", ppnk: "1493", pskb: "-bfff", mgr: "696969", grb: "1e90ff", rbrc: "b22222", rwht: "af0", stg: "228b22", chs: "-ff", gnsb: "dcdcdc", st: "8f8ff", g: "d7-", gnr: "daa520", gr: "808080", grn: "-8-0", grnw: "adff2f", hnw: "0fff0", htpn: "69b4", nnr: "cd5c5c", ng: "4b-82", vr: "0", khk: "0e68c", vnr: "e6e6fa", nrb: "0f5", wngr: "7cfc-", mnch: "acd", Lb: "add8e6", Lcr: "08080", Lcn: "e0ffff", Lgnr: "afad2", Lgr: "d3d3d3", Lgrn: "90ee90", Lpnk: "b6c1", Lsmn: "a07a", Lsgr: "20b2aa", Lskb: "87cefa", LsTg: "778899", Lstb: "b0c4de", Lw: "e0", m: "-ff-", mgrn: "32cd32", nn: "af0e6", mgnt: "-ff", mrn: "8--0", mqm: "66cdaa", mmb: "--cd", mmrc: "ba55d3", mmpr: "9370db", msg: "3cb371", mmsT: "7b68ee", "": "-fa9a", mtr: "48d1cc", mmvt: "c71585", mnLb: "191970", ntc: "5fffa", mstr: "e4e1", mccs: "e4b5", vjw: "dead", nv: "--80", c: "df5e6", v: "808-0", vrb: "6b8e23", rng: "a5-", rngr: "45-", rch: "da70d6", pgnr: "eee8aa", pgrn: "98fb98", ptrq: "afeeee", pvtr: "db7093", ppwh: "efd5", pchp: "dab9", pr: "cd853f", pnk: "c0cb", pm: "dda0dd", pwrb: "b0e0e6", prp: "8-080", cc: "663399", r: "--", sbr: "bc8f8f", rb: "4169e1", sbrw: "8b4513", smn: "a8072", nbr: "4a460", sgrn: "2e8b57", ssh: "5ee", snn: "a0522d", svr: "c0c0c0", skb: "87ceeb", sTb: "6a5acd", sTgr: "708090", snw: "afa", n: "-ff7f", stb: "4682b4", tn: "d2b48c", t: "-8080", thst: "d8bfd8", tmT: "6347", trqs: "40e0d0", vt: "ee82ee", whT: "5deb3", wht: "", hts: "5f5f5", w: "-", wgrn: "9acd32" };
function printNum(num) {
  var decs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  var str = decs > 0 ? num.toFixed(decs).replace(/0+$/, "").replace(/\.$/, "") : num.toString();
  return str || "0";
}
var Color = function() {
  function Color2(r, g2, b2, a) {
    classCallCheck(this, Color2);
    var that = this;
    function parseString(input) {
      if (input.startsWith("hsl")) {
        var _input$match$map = input.match(/([\-\d\.e]+)/g).map(Number), _input$match$map2 = slicedToArray(_input$match$map, 4), h = _input$match$map2[0], s = _input$match$map2[1], l = _input$match$map2[2], _a = _input$match$map2[3];
        if (_a === void 0) {
          _a = 1;
        }
        h /= 360;
        s /= 100;
        l /= 100;
        that.hsla = [h, s, l, _a];
      } else if (input.startsWith("rgb")) {
        var _input$match$map3 = input.match(/([\-\d\.e]+)/g).map(Number), _input$match$map4 = slicedToArray(_input$match$map3, 4), _r = _input$match$map4[0], _g = _input$match$map4[1], _b = _input$match$map4[2], _a2 = _input$match$map4[3];
        if (_a2 === void 0) {
          _a2 = 1;
        }
        that.rgba = [_r, _g, _b, _a2];
      } else {
        if (input.startsWith("#")) {
          that.rgba = Color2.hexToRgb(input);
        } else {
          that.rgba = Color2.nameToRgb(input) || Color2.hexToRgb(input);
        }
      }
    }
    if (r === void 0) ;
    else if (Array.isArray(r)) {
      this.rgba = r;
    } else if (b2 === void 0) {
      var color = r && "" + r;
      if (color) {
        parseString(color.toLowerCase());
      }
    } else {
      this.rgba = [r, g2, b2, a === void 0 ? 1 : a];
    }
  }
  createClass(Color2, [{
    key: "printRGB",
    value: function printRGB(alpha) {
      var rgb = alpha ? this.rgba : this.rgba.slice(0, 3), vals = rgb.map(function(x2, i) {
        return printNum(x2, i === 3 ? 3 : 0);
      });
      return alpha ? "rgba(" + vals + ")" : "rgb(" + vals + ")";
    }
  }, {
    key: "printHSL",
    value: function printHSL(alpha) {
      var mults = [360, 100, 100, 1], suff = ["", "%", "%", ""];
      var hsl = alpha ? this.hsla : this.hsla.slice(0, 3), vals = hsl.map(function(x2, i) {
        return printNum(x2 * mults[i], i === 3 ? 3 : 1) + suff[i];
      });
      return alpha ? "hsla(" + vals + ")" : "hsl(" + vals + ")";
    }
  }, {
    key: "printHex",
    value: function printHex(alpha) {
      var hex = this.hex;
      return alpha ? hex : hex.substring(0, 7);
    }
  }, {
    key: "rgba",
    get: function get() {
      if (this._rgba) {
        return this._rgba;
      }
      if (!this._hsla) {
        throw new Error("No color is set");
      }
      return this._rgba = Color2.hslToRgb(this._hsla);
    },
    set: function set(rgb) {
      if (rgb.length === 3) {
        rgb[3] = 1;
      }
      this._rgba = rgb;
      this._hsla = null;
    }
  }, {
    key: "rgbString",
    get: function get() {
      return this.printRGB();
    }
  }, {
    key: "rgbaString",
    get: function get() {
      return this.printRGB(true);
    }
  }, {
    key: "hsla",
    get: function get() {
      if (this._hsla) {
        return this._hsla;
      }
      if (!this._rgba) {
        throw new Error("No color is set");
      }
      return this._hsla = Color2.rgbToHsl(this._rgba);
    },
    set: function set(hsl) {
      if (hsl.length === 3) {
        hsl[3] = 1;
      }
      this._hsla = hsl;
      this._rgba = null;
    }
  }, {
    key: "hslString",
    get: function get() {
      return this.printHSL();
    }
  }, {
    key: "hslaString",
    get: function get() {
      return this.printHSL(true);
    }
  }, {
    key: "hex",
    get: function get() {
      var rgb = this.rgba, hex = rgb.map(function(x2, i) {
        return i < 3 ? x2.toString(16) : Math.round(x2 * 255).toString(16);
      });
      return "#" + hex.map(function(x2) {
        return x2.padStart(2, "0");
      }).join("");
    },
    set: function set(hex) {
      this.rgba = Color2.hexToRgb(hex);
    }
  }], [{
    key: "hexToRgb",
    value: function hexToRgb(input) {
      var hex = (input.startsWith("#") ? input.slice(1) : input).replace(/^(\w{3})$/, "$1F").replace(/^(\w)(\w)(\w)(\w)$/, "$1$1$2$2$3$3$4$4").replace(/^(\w{6})$/, "$1FF");
      if (!hex.match(/^([0-9a-fA-F]{8})$/)) {
        throw new Error("Unknown hex color; " + input);
      }
      var rgba = hex.match(/^(\w\w)(\w\w)(\w\w)(\w\w)$/).slice(1).map(function(x2) {
        return parseInt(x2, 16);
      });
      rgba[3] = rgba[3] / 255;
      return rgba;
    }
  }, {
    key: "nameToRgb",
    value: function nameToRgb(input) {
      var hash = input.toLowerCase().replace("at", "T").replace(/[aeiouyldf]/g, "").replace("ght", "L").replace("rk", "D").slice(-5, 4), hex = colorNames[hash];
      return hex === void 0 ? hex : Color2.hexToRgb(hex.replace(/\-/g, "00").padStart(6, "f"));
    }
  }, {
    key: "rgbToHsl",
    value: function rgbToHsl(_ref) {
      var _ref2 = slicedToArray(_ref, 4), r = _ref2[0], g2 = _ref2[1], b2 = _ref2[2], a = _ref2[3];
      r /= 255;
      g2 /= 255;
      b2 /= 255;
      var max = Math.max(r, g2, b2), min = Math.min(r, g2, b2);
      var h = void 0, s = void 0, l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g2 - b2) / d + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h = (b2 - r) / d + 2;
            break;
          case b2:
            h = (r - g2) / d + 4;
            break;
        }
        h /= 6;
      }
      return [h, s, l, a];
    }
  }, {
    key: "hslToRgb",
    value: function hslToRgb(_ref3) {
      var _ref4 = slicedToArray(_ref3, 4), h = _ref4[0], s = _ref4[1], l = _ref4[2], a = _ref4[3];
      var r = void 0, g2 = void 0, b2 = void 0;
      if (s === 0) {
        r = g2 = b2 = l;
      } else {
        var hue2rgb = function hue2rgb2(p2, q2, t) {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;
          if (t < 1 / 2) return q2;
          if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
          return p2;
        };
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g2 = hue2rgb(p, q, h);
        b2 = hue2rgb(p, q, h - 1 / 3);
      }
      var rgba = [r * 255, g2 * 255, b2 * 255].map(Math.round);
      rgba[3] = a;
      return rgba;
    }
  }]);
  return Color2;
}();
var EventBucket = function() {
  function EventBucket2() {
    classCallCheck(this, EventBucket2);
    this._events = [];
  }
  createClass(EventBucket2, [{
    key: "add",
    value: function add(target, type3, handler) {
      target.addEventListener(type3, handler, false);
      this._events.push({
        target,
        type: type3,
        handler
      });
    }
  }, {
    key: "remove",
    value: function remove(target, type3, handler) {
      this._events = this._events.filter(function(e) {
        var isMatch = true;
        if (target && target !== e.target) {
          isMatch = false;
        }
        if (type3 && type3 !== e.type) {
          isMatch = false;
        }
        if (handler && handler !== e.handler) {
          isMatch = false;
        }
        if (isMatch) {
          EventBucket2._doRemove(e.target, e.type, e.handler);
        }
        return !isMatch;
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._events.forEach(function(e) {
        return EventBucket2._doRemove(e.target, e.type, e.handler);
      });
      this._events = [];
    }
  }], [{
    key: "_doRemove",
    value: function _doRemove(target, type3, handler) {
      target.removeEventListener(type3, handler, false);
    }
  }]);
  return EventBucket2;
}();
function parseHTML(htmlString) {
  var div = document.createElement("div");
  div.innerHTML = htmlString;
  return div.firstElementChild;
}
function dragTrack(eventBucket, area, callback) {
  var dragging = false;
  function clamp(val, min, max) {
    return Math.max(min, Math.min(val, max));
  }
  function onMove(e, info, starting) {
    if (starting) {
      dragging = true;
    }
    if (!dragging) {
      return;
    }
    e.preventDefault();
    var bounds = area.getBoundingClientRect(), w = bounds.width, h = bounds.height, x2 = info.clientX, y = info.clientY;
    var relX = clamp(x2 - bounds.left, 0, w), relY = clamp(y - bounds.top, 0, h);
    callback(relX / w, relY / h);
  }
  function onMouse(e, starting) {
    var button = e.buttons === void 0 ? e.which : e.buttons;
    if (button === 1) {
      onMove(e, e, starting);
    } else {
      dragging = false;
    }
  }
  function onTouch(e, starting) {
    if (e.touches.length === 1) {
      onMove(e, e.touches[0], starting);
    } else {
      dragging = false;
    }
  }
  eventBucket.add(area, "mousedown", function(e) {
    onMouse(e, true);
  });
  eventBucket.add(area, "touchstart", function(e) {
    onTouch(e, true);
  });
  eventBucket.add(window, "mousemove", onMouse);
  eventBucket.add(area, "touchmove", onTouch);
  eventBucket.add(window, "mouseup", function(e) {
    dragging = false;
  });
  eventBucket.add(area, "touchend", function(e) {
    dragging = false;
  });
  eventBucket.add(area, "touchcancel", function(e) {
    dragging = false;
  });
}
var BG_TRANSP = "linear-gradient(45deg, lightgrey 25%, transparent 25%, transparent 75%, lightgrey 75%) 0 0 / 2em 2em,\n                   linear-gradient(45deg, lightgrey 25%,       white 25%,       white 75%, lightgrey 75%) 1em 1em / 2em 2em";
var HUES = 360;
var EVENT_KEY = "keydown";
var EVENT_CLICK_OUTSIDE = "mousedown";
var EVENT_TAB_MOVE = "focusin";
function $(selector, context) {
  return (context || document).querySelector(selector);
}
function stopEvent(e) {
  e.preventDefault();
  e.stopPropagation();
}
function onKey(bucket, target, keys, handler, stop) {
  bucket.add(target, EVENT_KEY, function(e) {
    if (keys.indexOf(e.key) >= 0) {
      if (stop) {
        stopEvent(e);
      }
      handler(e);
    }
  });
}
var Picker = function() {
  function Picker2(options) {
    classCallCheck(this, Picker2);
    this.settings = {
      popup: "right",
      layout: "default",
      alpha: true,
      editor: true,
      editorFormat: "hex",
      cancelButton: false,
      defaultColor: "#0cf"
    };
    this._events = new EventBucket();
    this.onChange = null;
    this.onDone = null;
    this.onOpen = null;
    this.onClose = null;
    this.setOptions(options);
  }
  createClass(Picker2, [{
    key: "setOptions",
    value: function setOptions(options) {
      var _this = this;
      if (!options) {
        return;
      }
      var settings = this.settings;
      function transfer(source, target, skipKeys) {
        for (var key in source) {
          if (skipKeys && skipKeys.indexOf(key) >= 0) {
            continue;
          }
          target[key] = source[key];
        }
      }
      if (options instanceof HTMLElement) {
        settings.parent = options;
      } else {
        if (settings.parent && options.parent && settings.parent !== options.parent) {
          this._events.remove(settings.parent);
          this._popupInited = false;
        }
        transfer(options, settings);
        if (options.onChange) {
          this.onChange = options.onChange;
        }
        if (options.onDone) {
          this.onDone = options.onDone;
        }
        if (options.onOpen) {
          this.onOpen = options.onOpen;
        }
        if (options.onClose) {
          this.onClose = options.onClose;
        }
        var col = options.color || options.colour;
        if (col) {
          this._setColor(col);
        }
      }
      var parent = settings.parent;
      if (parent && settings.popup && !this._popupInited) {
        var openProxy = function openProxy2(e) {
          return _this.openHandler(e);
        };
        this._events.add(parent, "click", openProxy);
        onKey(this._events, parent, [" ", "Spacebar", "Enter"], openProxy);
        this._popupInited = true;
      } else if (options.parent && !settings.popup) {
        this.show();
      }
    }
  }, {
    key: "openHandler",
    value: function openHandler(e) {
      if (this.show()) {
        e && e.preventDefault();
        this.settings.parent.style.pointerEvents = "none";
        var toFocus = e && e.type === EVENT_KEY ? this._domEdit : this.domElement;
        setTimeout(function() {
          return toFocus.focus();
        }, 100);
        if (this.onOpen) {
          this.onOpen(this.colour);
        }
      }
    }
  }, {
    key: "closeHandler",
    value: function closeHandler(e) {
      var event = e && e.type;
      var doHide = false;
      if (!e) {
        doHide = true;
      } else if (event === EVENT_CLICK_OUTSIDE || event === EVENT_TAB_MOVE) {
        var knownTime = (this.__containedEvent || 0) + 100;
        if (e.timeStamp > knownTime) {
          doHide = true;
        }
      } else {
        stopEvent(e);
        doHide = true;
      }
      if (doHide && this.hide()) {
        this.settings.parent.style.pointerEvents = "";
        if (event !== EVENT_CLICK_OUTSIDE) {
          this.settings.parent.focus();
        }
        if (this.onClose) {
          this.onClose(this.colour);
        }
      }
    }
  }, {
    key: "movePopup",
    value: function movePopup(options, open) {
      this.closeHandler();
      this.setOptions(options);
      if (open) {
        this.openHandler();
      }
    }
  }, {
    key: "setColor",
    value: function setColor(color, silent) {
      this._setColor(color, { silent });
    }
  }, {
    key: "_setColor",
    value: function _setColor(color, flags) {
      if (typeof color === "string") {
        color = color.trim();
      }
      if (!color) {
        return;
      }
      flags = flags || {};
      var c = void 0;
      try {
        c = new Color(color);
      } catch (ex) {
        if (flags.failSilently) {
          return;
        }
        throw ex;
      }
      if (!this.settings.alpha) {
        var hsla = c.hsla;
        hsla[3] = 1;
        c.hsla = hsla;
      }
      this.colour = this.color = c;
      this._setHSLA(null, null, null, null, flags);
    }
  }, {
    key: "setColour",
    value: function setColour(colour, silent) {
      this.setColor(colour, silent);
    }
  }, {
    key: "show",
    value: function show() {
      var parent = this.settings.parent;
      if (!parent) {
        return false;
      }
      if (this.domElement) {
        var toggled = this._toggleDOM(true);
        this._setPosition();
        return toggled;
      }
      var html = this.settings.template || '<div class="picker_wrapper" tabindex="-1"><div class="picker_arrow"></div><div class="picker_hue picker_slider"><div class="picker_selector"></div></div><div class="picker_sl"><div class="picker_selector"></div></div><div class="picker_alpha picker_slider"><div class="picker_selector"></div></div><div class="picker_editor"><input aria-label="Type a color name or hex value"/></div><div class="picker_sample"></div><div class="picker_done"><button>Ok</button></div><div class="picker_cancel"><button>Cancel</button></div></div>';
      var wrapper = parseHTML(html);
      this.domElement = wrapper;
      this._domH = $(".picker_hue", wrapper);
      this._domSL = $(".picker_sl", wrapper);
      this._domA = $(".picker_alpha", wrapper);
      this._domEdit = $(".picker_editor input", wrapper);
      this._domSample = $(".picker_sample", wrapper);
      this._domOkay = $(".picker_done button", wrapper);
      this._domCancel = $(".picker_cancel button", wrapper);
      wrapper.classList.add("layout_" + this.settings.layout);
      if (!this.settings.alpha) {
        wrapper.classList.add("no_alpha");
      }
      if (!this.settings.editor) {
        wrapper.classList.add("no_editor");
      }
      if (!this.settings.cancelButton) {
        wrapper.classList.add("no_cancel");
      }
      this._ifPopup(function() {
        return wrapper.classList.add("popup");
      });
      this._setPosition();
      if (this.colour) {
        this._updateUI();
      } else {
        this._setColor(this.settings.defaultColor);
      }
      this._bindEvents();
      return true;
    }
  }, {
    key: "hide",
    value: function hide() {
      return this._toggleDOM(false);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._events.destroy();
      if (this.domElement) {
        this.settings.parent.removeChild(this.domElement);
      }
    }
  }, {
    key: "_bindEvents",
    value: function _bindEvents() {
      var _this2 = this;
      var that = this, dom = this.domElement, events = this._events;
      function addEvent(target, type3, handler) {
        events.add(target, type3, handler);
      }
      addEvent(dom, "click", function(e) {
        return e.preventDefault();
      });
      dragTrack(events, this._domH, function(x2, y) {
        return that._setHSLA(x2);
      });
      dragTrack(events, this._domSL, function(x2, y) {
        return that._setHSLA(null, x2, 1 - y);
      });
      if (this.settings.alpha) {
        dragTrack(events, this._domA, function(x2, y) {
          return that._setHSLA(null, null, null, 1 - y);
        });
      }
      var editInput = this._domEdit;
      {
        addEvent(editInput, "input", function(e) {
          that._setColor(this.value, { fromEditor: true, failSilently: true });
        });
        addEvent(editInput, "focus", function(e) {
          var input = this;
          if (input.selectionStart === input.selectionEnd) {
            input.select();
          }
        });
      }
      this._ifPopup(function() {
        var popupCloseProxy = function popupCloseProxy2(e) {
          return _this2.closeHandler(e);
        };
        addEvent(window, EVENT_CLICK_OUTSIDE, popupCloseProxy);
        addEvent(window, EVENT_TAB_MOVE, popupCloseProxy);
        onKey(events, dom, ["Esc", "Escape"], popupCloseProxy);
        var timeKeeper = function timeKeeper2(e) {
          _this2.__containedEvent = e.timeStamp;
        };
        addEvent(dom, EVENT_CLICK_OUTSIDE, timeKeeper);
        addEvent(dom, EVENT_TAB_MOVE, timeKeeper);
        addEvent(_this2._domCancel, "click", popupCloseProxy);
      });
      var onDoneProxy = function onDoneProxy2(e) {
        _this2._ifPopup(function() {
          return _this2.closeHandler(e);
        });
        if (_this2.onDone) {
          _this2.onDone(_this2.colour);
        }
      };
      addEvent(this._domOkay, "click", onDoneProxy);
      onKey(events, dom, ["Enter"], onDoneProxy);
    }
  }, {
    key: "_setPosition",
    value: function _setPosition() {
      var parent = this.settings.parent, elm = this.domElement;
      if (parent !== elm.parentNode) {
        parent.appendChild(elm);
      }
      this._ifPopup(function(popup) {
        if (getComputedStyle(parent).position === "static") {
          parent.style.position = "relative";
        }
        var cssClass = popup === true ? "popup_right" : "popup_" + popup;
        ["popup_top", "popup_bottom", "popup_left", "popup_right"].forEach(function(c) {
          if (c === cssClass) {
            elm.classList.add(c);
          } else {
            elm.classList.remove(c);
          }
        });
        elm.classList.add(cssClass);
      });
    }
  }, {
    key: "_setHSLA",
    value: function _setHSLA(h, s, l, a, flags) {
      flags = flags || {};
      var col = this.colour, hsla = col.hsla;
      [h, s, l, a].forEach(function(x2, i) {
        if (x2 || x2 === 0) {
          hsla[i] = x2;
        }
      });
      col.hsla = hsla;
      this._updateUI(flags);
      if (this.onChange && !flags.silent) {
        this.onChange(col);
      }
    }
  }, {
    key: "_updateUI",
    value: function _updateUI(flags) {
      if (!this.domElement) {
        return;
      }
      flags = flags || {};
      var col = this.colour, hsl = col.hsla, cssHue = "hsl(" + hsl[0] * HUES + ", 100%, 50%)", cssHSL = col.hslString, cssHSLA = col.hslaString;
      var uiH = this._domH, uiSL = this._domSL, uiA = this._domA, thumbH = $(".picker_selector", uiH), thumbSL = $(".picker_selector", uiSL), thumbA = $(".picker_selector", uiA);
      function posX(parent, child, relX) {
        child.style.left = relX * 100 + "%";
      }
      function posY(parent, child, relY) {
        child.style.top = relY * 100 + "%";
      }
      posX(uiH, thumbH, hsl[0]);
      this._domSL.style.backgroundColor = this._domH.style.color = cssHue;
      posX(uiSL, thumbSL, hsl[1]);
      posY(uiSL, thumbSL, 1 - hsl[2]);
      uiSL.style.color = cssHSL;
      posY(uiA, thumbA, 1 - hsl[3]);
      var opaque = cssHSL, transp = opaque.replace("hsl", "hsla").replace(")", ", 0)"), bg = "linear-gradient(" + [opaque, transp] + ")";
      this._domA.style.background = bg + ", " + BG_TRANSP;
      if (!flags.fromEditor) {
        var format = this.settings.editorFormat, alpha = this.settings.alpha;
        var value = void 0;
        switch (format) {
          case "rgb":
            value = col.printRGB(alpha);
            break;
          case "hsl":
            value = col.printHSL(alpha);
            break;
          default:
            value = col.printHex(alpha);
        }
        this._domEdit.value = value;
      }
      this._domSample.style.color = cssHSLA;
    }
  }, {
    key: "_ifPopup",
    value: function _ifPopup(actionIf, actionElse) {
      if (this.settings.parent && this.settings.popup) {
        actionIf && actionIf(this.settings.popup);
      } else {
        actionElse && actionElse();
      }
    }
  }, {
    key: "_toggleDOM",
    value: function _toggleDOM(toVisible) {
      var dom = this.domElement;
      if (!dom) {
        return false;
      }
      var displayStyle = toVisible ? "" : "none", toggle = dom.style.display !== displayStyle;
      if (toggle) {
        dom.style.display = displayStyle;
      }
      return toggle;
    }
  }]);
  return Picker2;
}();
{
  style2 = document.createElement("style");
  style2.textContent = '.picker_wrapper.no_alpha .picker_alpha{display:none}.picker_wrapper.no_editor .picker_editor{position:absolute;z-index:-1;opacity:0}.picker_wrapper.no_cancel .picker_cancel{display:none}.layout_default.picker_wrapper{display:flex;flex-flow:row wrap;justify-content:space-between;align-items:stretch;font-size:10px;width:25em;padding:.5em}.layout_default.picker_wrapper input,.layout_default.picker_wrapper button{font-size:1rem}.layout_default.picker_wrapper>*{margin:.5em}.layout_default.picker_wrapper::before{content:"";display:block;width:100%;height:0;order:1}.layout_default .picker_slider,.layout_default .picker_selector{padding:1em}.layout_default .picker_hue{width:100%}.layout_default .picker_sl{flex:1 1 auto}.layout_default .picker_sl::before{content:"";display:block;padding-bottom:100%}.layout_default .picker_editor{order:1;width:6.5rem}.layout_default .picker_editor input{width:100%;height:100%}.layout_default .picker_sample{order:1;flex:1 1 auto}.layout_default .picker_done,.layout_default .picker_cancel{order:1}.picker_wrapper{box-sizing:border-box;background:#f2f2f2;box-shadow:0 0 0 1px silver;cursor:default;font-family:sans-serif;color:#444;pointer-events:auto}.picker_wrapper:focus{outline:none}.picker_wrapper button,.picker_wrapper input{box-sizing:border-box;border:none;box-shadow:0 0 0 1px silver;outline:none}.picker_wrapper button:focus,.picker_wrapper button:active,.picker_wrapper input:focus,.picker_wrapper input:active{box-shadow:0 0 2px 1px #1e90ff}.picker_wrapper button{padding:.4em .6em;cursor:pointer;background-color:#f5f5f5;background-image:linear-gradient(0deg, gainsboro, transparent)}.picker_wrapper button:active{background-image:linear-gradient(0deg, transparent, gainsboro)}.picker_wrapper button:hover{background-color:#fff}.picker_selector{position:absolute;z-index:1;display:block;-webkit-transform:translate(-50%, -50%);transform:translate(-50%, -50%);border:2px solid #fff;border-radius:100%;box-shadow:0 0 3px 1px #67b9ff;background:currentColor;cursor:pointer}.picker_slider .picker_selector{border-radius:2px}.picker_hue{position:relative;background-image:linear-gradient(90deg, red, yellow, lime, cyan, blue, magenta, red);box-shadow:0 0 0 1px silver}.picker_sl{position:relative;box-shadow:0 0 0 1px silver;background-image:linear-gradient(180deg, white, rgba(255, 255, 255, 0) 50%),linear-gradient(0deg, black, rgba(0, 0, 0, 0) 50%),linear-gradient(90deg, #808080, rgba(128, 128, 128, 0))}.picker_alpha,.picker_sample{position:relative;background:linear-gradient(45deg, lightgrey 25%, transparent 25%, transparent 75%, lightgrey 75%) 0 0/2em 2em,linear-gradient(45deg, lightgrey 25%, white 25%, white 75%, lightgrey 75%) 1em 1em/2em 2em;box-shadow:0 0 0 1px silver}.picker_alpha .picker_selector,.picker_sample .picker_selector{background:none}.picker_editor input{font-family:monospace;padding:.2em .4em}.picker_sample::before{content:"";position:absolute;display:block;width:100%;height:100%;background:currentColor}.picker_arrow{position:absolute;z-index:-1}.picker_wrapper.popup{position:absolute;z-index:2;margin:1.5em}.picker_wrapper.popup,.picker_wrapper.popup .picker_arrow::before,.picker_wrapper.popup .picker_arrow::after{background:#f2f2f2;box-shadow:0 0 10px 1px rgba(0,0,0,.4)}.picker_wrapper.popup .picker_arrow{width:3em;height:3em;margin:0}.picker_wrapper.popup .picker_arrow::before,.picker_wrapper.popup .picker_arrow::after{content:"";display:block;position:absolute;top:0;left:0;z-index:-99}.picker_wrapper.popup .picker_arrow::before{width:100%;height:100%;-webkit-transform:skew(45deg);transform:skew(45deg);-webkit-transform-origin:0 100%;transform-origin:0 100%}.picker_wrapper.popup .picker_arrow::after{width:150%;height:150%;box-shadow:none}.popup.popup_top{bottom:100%;left:0}.popup.popup_top .picker_arrow{bottom:0;left:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.popup.popup_bottom{top:100%;left:0}.popup.popup_bottom .picker_arrow{top:0;left:0;-webkit-transform:rotate(90deg) scale(1, -1);transform:rotate(90deg) scale(1, -1)}.popup.popup_left{top:0;right:100%}.popup.popup_left .picker_arrow{top:0;right:0;-webkit-transform:scale(-1, 1);transform:scale(-1, 1)}.popup.popup_right{top:0;left:100%}.popup.popup_right .picker_arrow{top:0;left:0}';
  document.documentElement.firstElementChild.appendChild(style2);
  Picker.StyleElement = style2;
}
var style2;

// node_modules/@logicflow/extension/es/tools/label/mediumEditor.js
var import_rangy = __toESM(require_rangy_core());
var import_rangy_classapplier = __toESM(require_rangy_classapplier());
var defaultOptions = {
  toolbar: {
    allowMultiParagraphSelection: true,
    buttons: [
      "bold",
      "colorpicker",
      "italic",
      "underline",
      "strikethrough",
      "quote",
      "justifyLeft",
      "justifyCenter",
      "justifyRight",
      "justifyFull",
      "superscript",
      "subscript",
      "orderedlist",
      "unorderedlist",
      "pre",
      "removeFormat",
      "outdent",
      "indent",
      "h2",
      "h3"
    ],
    standardizeSelectionStart: false,
    updateOnEmptySelection: false
  },
  placeholder: {
    text: "请输入内容",
    hideOnClick: true
  },
  disableEditing: true
};
var ColorPickerButton = import_medium_editor.default.extensions.button.extend({
  name: "colorpicker",
  tagNames: ["mark"],
  contentDefault: "<b>Color</b>",
  aria: "Color Picker",
  action: "colorPicker",
  init: function() {
    var _this = this;
    import_rangy.default.init();
    import_medium_editor.default.extensions.button.prototype.init.call(this);
    this.colorPicker = new Picker({
      parent: this.button,
      color: "#000",
      onDone: function(res) {
        if (_this.coloredText && _this.coloredText.isAppliedToSelection()) {
          _this.coloredText.undoToSelection();
        }
        _this.coloredText = import_rangy.default.createClassApplier("colored", {
          elementTagName: "span",
          elementProperties: {
            style: {
              color: res.hex
            }
          },
          normalize: true
        });
        _this.coloredText.toggleSelection();
        _this.base.checkContentChanged();
        _this.setInactive();
      }
    });
  },
  getButton: function() {
    return this.button;
  },
  handleClick: function() {
    this.setActive();
    this.colorPicker.show();
  },
  isAlreadyApplied: function(node2) {
    return node2.nodeName.toLowerCase() === "mark";
  },
  isActive: function() {
    return this.button.classList.contains("medium-editor-button-active");
  },
  setInactive: function() {
    this.button.classList.remove("medium-editor-button-active");
  },
  setActive: function() {
    this.button.classList.add("medium-editor-button-active");
  }
});

// node_modules/@logicflow/extension/es/tools/label/LabelOverlay.js
var __extends28 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __read19 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray14 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var LabelOverlay = (
  /** @class */
  function(_super) {
    __extends28(LabelOverlay2, _super);
    function LabelOverlay2(props) {
      var _this = _super.call(this, props) || this;
      _this.labelMap = /* @__PURE__ */ new Map();
      var lf = props.lf, graphModel = props.graphModel;
      _this.lf = lf;
      _this.graphModel = graphModel;
      _this.state = { tick: 0 };
      return _this;
    }
    LabelOverlay2.prototype.componentDidMount = function() {
      var _this = this;
      var graphModel = this.props.graphModel;
      this.editor = new import_medium_editor.default(".lf-label-editor", merge_default(defaultOptions, {
        autoLink: true,
        extensions: {
          colorPicker: new ColorPickerButton()
        }
      }));
      graphModel.eventCenter.on("text:update,node:mousemove,node:resize,node:rotate,node:drag,label:drop,node:drop", function() {
      });
      graphModel.eventCenter.on("node:properties-change,node:properties-delete", function() {
        _this.setState({ tick: _this.state.tick + 1 });
      });
    };
    LabelOverlay2.prototype.componentDidUpdate = function() {
      var _a;
      if (this.editor && this.editor.elements.length > 0) {
        this.editor.addElements(".lf-label-editor");
      } else {
        (_a = this.editor) === null || _a === void 0 ? void 0 : _a.destroy();
        this.editor = new import_medium_editor.default(".lf-label-editor", merge_default(defaultOptions, {
          autoLink: true,
          extensions: {
            colorPicker: new ColorPickerButton()
          }
        }));
      }
    };
    LabelOverlay2.prototype.componentWillUnmount = function() {
      var _a;
      (_a = this.editor) === null || _a === void 0 ? void 0 : _a.destroy();
    };
    LabelOverlay2.prototype.getLabels = function() {
      var _this = this;
      var _a = this.props, extension = _a.lf.extension, graphModel = _a.graphModel;
      var elements = __spreadArray14(__spreadArray14([], __read19(graphModel.nodes), false), __read19(graphModel.edges), false);
      var curExtension = extension["label"];
      if (curExtension) {
        var labels_1 = [];
        forEach_default(elements, function(element) {
          var _a2, _b;
          var elementData = element.getData();
          var labelConfig = (_b = (_a2 = elementData.properties) === null || _a2 === void 0 ? void 0 : _a2._label) !== null && _b !== void 0 ? _b : [];
          forEach_default(labelConfig, function(config) {
            var labelMap = _this.labelMap;
            var label = new LabelModel_default(config, element, graphModel);
            labelMap.set(label.id, label);
            labels_1.push(u(Label_default, { label, element, graphModel }, label.id));
          });
        });
        return labels_1;
      }
      return null;
    };
    LabelOverlay2.prototype.render = function() {
      return u("foreignObject", { id: "lf-label-overlay", class: "lf-label-overlay", children: this.getLabels() });
    };
    LabelOverlay2.toolName = "label-edit-tool";
    LabelOverlay2 = __decorate4([
      observer
    ], LabelOverlay2);
    return LabelOverlay2;
  }(x)
);
var LabelOverlay_default = LabelOverlay;

// node_modules/@logicflow/extension/es/tools/label/index.js
var __assign26 = function() {
  __assign26 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign26.apply(this, arguments);
};
var Label2 = (
  /** @class */
  function() {
    function Label3(_a) {
      var lf = _a.lf, options = _a.options;
      var _b, _c, _d;
      this.labelInitPositionMap = /* @__PURE__ */ new Map();
      this.lf = lf;
      this.options = options !== null && options !== void 0 ? options : {};
      this.textOverflowMode = (_b = options.textOverflowMode) !== null && _b !== void 0 ? _b : "default";
      this.isMultiple = (_c = options.isMultiple) !== null && _c !== void 0 ? _c : true;
      this.labelWidth = options.labelWidth;
      this.maxCount = (_d = options.maxCount) !== null && _d !== void 0 ? _d : Infinity;
      lf.graphModel.editConfigModel.updateTextMode(TextMode.LABEL);
      this.addEventListeners();
      this.rewriteShortcut();
      lf.tool.registerTool(LabelOverlay_default.toolName, LabelOverlay_default);
      lf.tool.disableTool("text-edit-tool");
    }
    Label3.prototype.formatConfig = function(graphModel, element) {
      var _a = graphModel.editConfigModel, nodeTextEdit = _a.nodeTextEdit, edgeTextEdit = _a.edgeTextEdit, nodeTextDraggable = _a.nodeTextDraggable, edgeTextDraggable = _a.edgeTextDraggable;
      var _b = this, textOverflowMode = _b.textOverflowMode, isMultiple = _b.isMultiple, maxCount = _b.maxCount, labelWidth = _b.labelWidth;
      var text = element.text, zIndex = element.zIndex, _c = element.properties, _label = _c._label, _d = _c._labelOption, _labelOption = _d === void 0 ? {} : _d;
      var curLabelConfig = _label;
      var _e = _labelOption, curIsMultiple = _e.isMultiple, curMaxCount = _e.maxCount;
      var formatConfig = [];
      if (isArray_default(curLabelConfig)) {
        var size = curMaxCount !== null && curMaxCount !== void 0 ? curMaxCount : maxCount;
        if (isMultiple && curIsMultiple) {
          if (curLabelConfig.length > size) {
            formatConfig = curLabelConfig.slice(0, size);
          } else {
            formatConfig = curLabelConfig;
          }
        } else {
          formatConfig = [curLabelConfig[0]];
        }
      } else if (isObject_default(curLabelConfig)) {
        formatConfig = [curLabelConfig];
      } else if (typeof curLabelConfig === "string" || !curLabelConfig) {
        var config = __assign26(__assign26({}, text), { content: curLabelConfig || (text === null || text === void 0 ? void 0 : text.value), draggable: element.BaseType === "edge" ? edgeTextDraggable : nodeTextDraggable });
        formatConfig = config.value ? [config] : [];
      }
      if (element.BaseType === "edge") {
        formatConfig = map_default(formatConfig, function(config2) {
          return config2;
        });
      }
      return map_default(formatConfig, function(config2) {
        if (!config2.id) {
          config2.id = createUuid();
        }
        var value = config2.value, content = config2.content, vertical = config2.vertical, editable = config2.editable, draggable = config2.draggable, labelTextOverflowMode = config2.textOverflowMode;
        var textEdit = element.BaseType === "node" ? nodeTextEdit : edgeTextEdit;
        var textDraggable = element.BaseType === "node" ? nodeTextDraggable : edgeTextDraggable;
        return __assign26(__assign26({}, config2), { zIndex, labelWidth, content: content !== null && content !== void 0 ? content : value, vertical: vertical !== null && vertical !== void 0 ? vertical : false, editable: textEdit && editable, draggable: textDraggable && draggable, textOverflowMode: labelTextOverflowMode !== null && labelTextOverflowMode !== void 0 ? labelTextOverflowMode : textOverflowMode });
      });
    };
    Label3.prototype.setupLabels = function(graphModel) {
      var _this = this;
      var elements = graphModel.sortElements;
      forEach_default(elements, function(element) {
        _this.rewriteInnerMethods(element);
        var formatLabelConfig = _this.formatConfig(graphModel, element);
        element.setProperty("_label", formatLabelConfig);
      });
    };
    Label3.prototype.addLabel = function(element, position) {
      var _a, _b, _c;
      var _d = this, isMultiple = _d.isMultiple, maxCount = _d.maxCount;
      var _e = element.properties, _label = _e._label, _labelOption = _e._labelOption;
      var curLabelConfig = (_a = _label) !== null && _a !== void 0 ? _a : [];
      var curLabelOption = (_b = _labelOption) !== null && _b !== void 0 ? _b : {};
      var len = curLabelConfig.length;
      var newLabel = {
        id: createUuid(),
        x: position.x,
        y: position.y,
        content: "Label".concat(len + 1),
        value: "Label".concat(len + 1),
        style: {},
        draggable: true,
        editable: true,
        vertical: false
      };
      if (!isMultiple || isMultiple && curLabelOption.isMultiple === false || len >= ((_c = curLabelOption === null || curLabelOption === void 0 ? void 0 : curLabelOption.maxCount) !== null && _c !== void 0 ? _c : maxCount)) {
        return;
      }
      curLabelConfig.push(newLabel);
      element.setProperty("_label", curLabelConfig);
    };
    Label3.prototype.addEventListeners = function() {
      var _this = this;
      var graphModel = this.lf.graphModel;
      var eventCenter = graphModel.eventCenter, editConfigModel = graphModel.editConfigModel;
      eventCenter.on("graph:rendered", function(_a) {
        var graphModel2 = _a.graphModel;
        _this.setupLabels(graphModel2);
      });
      eventCenter.on("node:dbclick,edge:dbclick", function(_a) {
        var e = _a.e, data = _a.data;
        var target = graphModel.getElement(data.id);
        var _b = graphModel.getPointByClient({
          x: e.clientX,
          y: e.clientY
        }).canvasOverlayPosition, x1 = _b.x, y1 = _b.y;
        var point = {
          x: x1,
          y: y1
        };
        if (target && editConfigModel.textMode === TextMode.LABEL) {
          _this.addLabel(target, point);
        }
      });
      eventCenter.on("node:resize", function(_a) {
        var _b, _c;
        var preData = _a.preData, data = _a.data, model = _a.model;
        var _d = (_b = preData.properties) !== null && _b !== void 0 ? _b : {}, preWidth = _d.width, preHeight = _d.height, _e = _d._label, _label = _e === void 0 ? [] : _e;
        var _f = (_c = data.properties) !== null && _c !== void 0 ? _c : {}, curWidth = _f.width, curHeight = _f.height;
        if (preWidth && preHeight && curWidth && curHeight) {
          var origin_1 = {
            x: preData.x,
            y: preData.y,
            width: preWidth,
            height: preHeight
          };
          var scaled_1 = {
            x: data.x,
            y: data.y,
            width: curWidth,
            height: curHeight
          };
          var newLabelConfig = map_default(_label, function(label) {
            var x2 = label.x, y = label.y;
            var newPoint = calcPointAfterResize(origin_1, scaled_1, { x: x2, y });
            return __assign26(__assign26({}, label), newPoint);
          });
          model.setProperty("_label", newLabelConfig);
        }
      });
      eventCenter.on("node:rotate", function(_a) {
        var model = _a.model;
        var x2 = model.x, y = model.y, rotate = model.rotate, _b = model.properties._label, _label = _b === void 0 ? [] : _b;
        var center = { x: x2, y };
        var newLabelConfig = map_default(_label, function(label) {
          if (!label.id)
            return label;
          var point = { x: label.x, y: label.y };
          if (_this.labelInitPositionMap.has(label.id)) {
            point = _this.labelInitPositionMap.get(label.id);
          } else {
            _this.labelInitPositionMap.set(label.id, point);
          }
          var theta = rotate * (180 / Math.PI);
          if (theta < 0)
            theta += 360;
          var radian = theta * (Math.PI / 180);
          var newPoint = rotatePointAroundCenter(point, center, radian);
          return __assign26(__assign26(__assign26({}, label), newPoint), { rotate: theta });
        });
        model.setProperty("_label", newLabelConfig);
      });
      eventCenter.on("node:dnd-add,node:add,edge:add", function(_a) {
        var data = _a.data;
        var element = graphModel.getElement(data.id);
        if (element) {
          _this.rewriteInnerMethods(element);
          var formatedLabel = _this.formatConfig(graphModel, data);
          element.setProperty("_label", formatedLabel);
        }
      });
    };
    Label3.prototype.rewriteInnerMethods = function(element) {
      element.moveText = function(deltaX, deltaY) {
        if (!element.text)
          return;
        var _a = element.text, x2 = _a.x, y = _a.y, value = _a.value, draggable = _a.draggable, editable = _a.editable;
        element.text = {
          value,
          editable,
          draggable,
          x: x2 + deltaX,
          y: y + deltaY
        };
        var properties = cloneDeep_default(element.getProperties());
        if (isArray_default(properties._label)) {
          var nextLabel = map_default(properties._label, function(label) {
            return __assign26(__assign26({}, label), { x: label.x + deltaX, y: label.y + deltaY });
          });
          element === null || element === void 0 ? void 0 : element.setProperty("_label", nextLabel);
        }
      };
    };
    Label3.prototype.rewriteShortcut = function() {
      var _this = this;
      var _a = this.lf, keyboard = _a.keyboard, graphModel = _a.graphModel;
      var keyboardOptions = keyboard.options.keyboard;
      keyboard.off(["backspace"]);
      keyboard.on(["backspace"], function() {
        if (!(keyboardOptions === null || keyboardOptions === void 0 ? void 0 : keyboardOptions.enabled))
          return true;
        if (graphModel.textEditElement)
          return true;
        var elements = graphModel.getSelectElements(true);
        _this.lf.clearSelectElements();
        var editConfigModel = _this.lf.graphModel.editConfigModel;
        elements.edges.forEach(function(edge) {
          var properties = edge.properties;
          if (properties && !isEmpty_default(properties._label) && editConfigModel.textMode === TextMode.LABEL) {
            var newLabelList = properties._label.filter(function(label) {
              return !label.isSelected;
            });
            if (!isEqual_default(newLabelList.length, properties._label.length)) {
              var edgeModel = graphModel.getEdgeModelById(edge.id);
              edgeModel === null || edgeModel === void 0 ? void 0 : edgeModel.setProperty("_label", newLabelList);
              return;
            }
          }
          edge.id && _this.lf.deleteEdge(edge.id);
        });
        elements.nodes.forEach(function(node2) {
          var properties = node2.properties;
          if (properties && !isEmpty_default(properties._label) && editConfigModel.textMode === TextMode.LABEL) {
            var newLabelList = properties._label.filter(function(label) {
              return !label.isSelected;
            });
            if (!isEqual_default(newLabelList.length, properties._label.length)) {
              var nodeModel = graphModel.getNodeModelById(node2.id);
              nodeModel === null || nodeModel === void 0 ? void 0 : nodeModel.setProperty("_label", newLabelList);
              return;
            }
          }
          node2.id && _this.lf.deleteNode(node2.id);
        });
        return false;
      });
    };
    Label3.prototype.updateTextMode = function(textMode) {
      var editConfigModel = this.lf.graphModel.editConfigModel;
      if (textMode === editConfigModel.textMode)
        return;
      editConfigModel.updateTextMode(textMode);
      if (textMode === TextMode.LABEL) {
        this.lf.tool.enableTool(LabelOverlay_default.toolName);
        this.lf.tool.disableTool("text-edit-tool");
      } else if (textMode === TextMode.TEXT) {
        this.lf.tool.enableTool("text-edit-tool");
        this.lf.tool.disableTool(LabelOverlay_default.toolName);
      }
    };
    Label3.prototype.render = function() {
    };
    Label3.prototype.destroy = function() {
    };
    Label3.pluginName = "label";
    return Label3;
  }()
);

// node_modules/@logicflow/extension/es/tools/snapshot/utils.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __read20 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray15 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var imageCache = {};
function isTextPlainBase64(str) {
  return str.startsWith("data:text/plain");
}
function convertImageToBase64(url) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      if (imageCache[url]) {
        return [2, imageCache[url]];
      }
      return [2, new Promise(function(resolve, reject) {
        try {
          fetch(url).then(function(response) {
            return response.blob();
          }).then(function(blob) {
            var reader = new FileReader();
            reader.onloadend = function() {
              resolve(imageCache[url] = reader.result);
            };
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          }).catch(function() {
            resolve(imageCache[url] = url);
          });
        } catch (error) {
          return imageCache[url] = url;
        }
      })];
    });
  });
}
function updateImageSrcOrHrefWithBase64Image(node2, attrName) {
  return __awaiter(this, void 0, void 0, function() {
    var url, base64Image, error_1;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          _a.trys.push([0, 2, , 3]);
          url = node2.getAttribute(attrName) || "";
          if (url.startsWith("data:")) {
            return [
              2
              /*return*/
            ];
          }
          return [4, convertImageToBase64(url)];
        case 1:
          base64Image = _a.sent();
          if (isTextPlainBase64(base64Image)) {
            return [
              2
              /*return*/
            ];
          }
          node2.setAttribute(attrName, base64Image);
          return [3, 3];
        case 2:
          error_1 = _a.sent();
          console.error(error_1);
          return [3, 3];
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function updateBackgroundImageWithBase64Image(node2, url) {
  return __awaiter(this, void 0, void 0, function() {
    var base64Image, error_2;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          _a.trys.push([0, 2, , 3]);
          if (url.startsWith("data:")) {
            return [
              2
              /*return*/
            ];
          }
          return [4, convertImageToBase64(url)];
        case 1:
          base64Image = _a.sent();
          if (isTextPlainBase64(base64Image)) {
            return [
              2
              /*return*/
            ];
          }
          node2.style.backgroundImage = "url(".concat(base64Image, ")");
          return [3, 3];
        case 2:
          error_2 = _a.sent();
          console.error(error_2);
          return [3, 3];
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function updateImageSource(node2) {
  return __awaiter(this, void 0, void 0, function() {
    var nodes, nodePtr, promises, _a, background, backgroundImage, backgroundUrlMatch, imageUrl, backgroundImageUrlMatch, imageUrl;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          nodes = [node2];
          promises = [];
          while (nodes.length) {
            nodePtr = nodes.shift();
            if (nodePtr.children.length) {
              nodes.push.apply(nodes, __spreadArray15([], __read20(nodePtr.children), false));
            }
            if (nodePtr instanceof HTMLElement) {
              _a = nodePtr.style, background = _a.background, backgroundImage = _a.backgroundImage;
              backgroundUrlMatch = background.match(/url\(["']?(.*?)["']?\)/);
              if (backgroundUrlMatch && backgroundUrlMatch[1]) {
                imageUrl = backgroundUrlMatch[1];
                promises.push(updateBackgroundImageWithBase64Image(nodePtr, imageUrl));
              }
              backgroundImageUrlMatch = backgroundImage.match(/url\(["']?(.*?)["']?\)/);
              if (backgroundImageUrlMatch && backgroundImageUrlMatch[1]) {
                imageUrl = backgroundImageUrlMatch[1];
                promises.push(updateBackgroundImageWithBase64Image(nodePtr, imageUrl));
              }
            }
            if (nodePtr instanceof HTMLImageElement) {
              promises.push(updateImageSrcOrHrefWithBase64Image(nodePtr, "src"));
            } else if (nodePtr instanceof SVGImageElement) {
              promises.push(updateImageSrcOrHrefWithBase64Image(nodePtr, "href"));
            }
          }
          return [4, Promise.all(promises)];
        case 1:
          _b.sent();
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function copyCanvas(originCanvas, targetWidth, targetHeight) {
  var newCanvas = document.createElement("canvas");
  newCanvas.width = targetWidth;
  newCanvas.height = targetHeight;
  var newCtx = newCanvas.getContext("2d");
  if (newCtx) {
    newCtx.drawImage(originCanvas, 0, 0, originCanvas.width, originCanvas.height, 0, 0, targetWidth, targetHeight);
  }
  return newCanvas;
}

// node_modules/@logicflow/extension/es/tools/snapshot/index.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator2 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var Snapshot = (
  /** @class */
  function() {
    function Snapshot2(_a) {
      var lf = _a.lf;
      var _this = this;
      this.lf = lf;
      this.customCssRules = "";
      this.useGlobalRules = true;
      lf.getSnapshot = function(fileName, toImageOptions) {
        return __awaiter2(_this, void 0, void 0, function() {
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [
                  4,
                  this.getSnapshot(fileName, toImageOptions)
                  /* 获取Blob对象 */
                ];
              case 1:
                return [
                  2,
                  _a2.sent()
                  /* 获取Blob对象 */
                ];
            }
          });
        });
      };
      lf.getSnapshotBlob = function(backgroundColor, fileType) {
        return __awaiter2(_this, void 0, void 0, function() {
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [
                  4,
                  this.getSnapshotBlob(backgroundColor, fileType)
                  /* 获取Base64对象 */
                ];
              case 1:
                return [
                  2,
                  _a2.sent()
                  /* 获取Base64对象 */
                ];
            }
          });
        });
      };
      lf.getSnapshotBase64 = function(backgroundColor, fileType) {
        return __awaiter2(_this, void 0, void 0, function() {
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.getSnapshotBase64(backgroundColor, fileType)];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
    }
    Snapshot2.prototype.getSvgRootElement = function(lf) {
      var svgRootElement = lf.container.querySelector(".lf-canvas-overlay");
      return svgRootElement;
    };
    Snapshot2.prototype.triggerDownload = function(imgUrl) {
      var evt = new MouseEvent("click", {
        view: document.defaultView,
        bubbles: false,
        cancelable: true
      });
      var a = document.createElement("a");
      a.setAttribute("download", this.fileName);
      a.setAttribute("href", imgUrl);
      a.setAttribute("target", "_blank");
      a.dispatchEvent(evt);
    };
    Snapshot2.prototype.removeAnchor = function(element) {
      var childNodes = element.childNodes;
      var childLength = element.childNodes && element.childNodes.length;
      for (var i = 0; i < childLength; i++) {
        var child = childNodes[i];
        var classList = child.classList && Array.from(child.classList) || [];
        if (classList.indexOf("lf-anchor") > -1) {
          element.removeChild(element.childNodes[i]);
          childLength--;
          i--;
        }
      }
    };
    Snapshot2.prototype.removeRotateControl = function(element) {
      var childNodes = element.childNodes;
      var childLength = element.childNodes && element.childNodes.length;
      for (var i = 0; i < childLength; i++) {
        var child = childNodes[i];
        var classList = child.classList && Array.from(child.classList) || [];
        if (classList.indexOf("lf-rotate-control") > -1) {
          element.removeChild(element.childNodes[i]);
          childLength--;
          i--;
        }
      }
    };
    Snapshot2.prototype.getSnapshot = function(fileName, toImageOptions) {
      return __awaiter2(this, void 0, void 0, function() {
        var curPartial, _a, partial, editConfig;
        var _this = this;
        return __generator2(this, function(_b) {
          switch (_b.label) {
            case 0:
              curPartial = this.lf.graphModel.getPartial();
              _a = (toImageOptions !== null && toImageOptions !== void 0 ? toImageOptions : {}).partial, partial = _a === void 0 ? curPartial : _a;
              editConfig = this.lf.getEditConfig();
              this.lf.updateEditConfig({
                isSilentMode: true,
                stopScrollGraph: true,
                stopMoveGraph: true
              });
              if (!(curPartial !== partial)) return [3, 1];
              this.lf.graphModel.setPartial(partial);
              this.lf.graphModel.eventCenter.once("graph:updated", function() {
                return __awaiter2(_this, void 0, void 0, function() {
                  return __generator2(this, function(_a2) {
                    switch (_a2.label) {
                      case 0:
                        return [
                          4,
                          this.snapshot(fileName, toImageOptions)
                          // 恢复原来渲染模式
                        ];
                      case 1:
                        _a2.sent();
                        this.lf.graphModel.setPartial(curPartial);
                        return [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              });
              return [3, 3];
            case 1:
              return [4, this.snapshot(fileName, toImageOptions)];
            case 2:
              _b.sent();
              _b.label = 3;
            case 3:
              this.lf.updateEditConfig(editConfig);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Snapshot2.prototype.snapshot = function(fileName, toImageOptions) {
      return __awaiter2(this, void 0, void 0, function() {
        var _a, _b, fileType, quality, svg, copy, svgString, blob, url;
        var _this = this;
        return __generator2(this, function(_c) {
          switch (_c.label) {
            case 0:
              _a = toImageOptions !== null && toImageOptions !== void 0 ? toImageOptions : {}, _b = _a.fileType, fileType = _b === void 0 ? "png" : _b, quality = _a.quality;
              this.fileName = "".concat(fileName !== null && fileName !== void 0 ? fileName : "logic-flow.".concat(Date.now()), ".").concat(fileType);
              svg = this.getSvgRootElement(this.lf);
              return [4, updateImageSource(svg)];
            case 1:
              _c.sent();
              if (fileType === "svg") {
                copy = this.cloneSvg(svg);
                svgString = new XMLSerializer().serializeToString(copy);
                blob = new Blob([svgString], {
                  type: "image/svg+xml;charset=utf-8"
                });
                url = URL.createObjectURL(blob);
                this.triggerDownload(url);
              } else {
                this.getCanvasData(svg, toImageOptions !== null && toImageOptions !== void 0 ? toImageOptions : {}).then(function(canvas) {
                  var imgUrl = canvas.toDataURL("image/".concat(fileType), quality).replace("image/".concat(fileType), "image/octet-stream");
                  _this.triggerDownload(imgUrl);
                });
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Snapshot2.prototype.getSnapshotBase64 = function(backgroundColor, fileType) {
      return __awaiter2(this, void 0, void 0, function() {
        var svg;
        var _this = this;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              svg = this.getSvgRootElement(this.lf);
              return [4, updateImageSource(svg)];
            case 1:
              _a.sent();
              return [2, new Promise(function(resolve) {
                _this.getCanvasData(svg, { backgroundColor }).then(function(canvas) {
                  var base64 = canvas.toDataURL("image/".concat(fileType !== null && fileType !== void 0 ? fileType : "png"));
                  resolve({
                    data: base64,
                    width: canvas.width,
                    height: canvas.height
                  });
                });
              })];
          }
        });
      });
    };
    Snapshot2.prototype.getSnapshotBlob = function(backgroundColor, fileType) {
      return __awaiter2(this, void 0, void 0, function() {
        var svg;
        var _this = this;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              svg = this.getSvgRootElement(this.lf);
              return [4, updateImageSource(svg)];
            case 1:
              _a.sent();
              return [2, new Promise(function(resolve) {
                _this.getCanvasData(svg, { backgroundColor }).then(function(canvas) {
                  canvas.toBlob(function(blob) {
                    resolve({
                      data: blob,
                      width: canvas.width,
                      height: canvas.height
                    });
                  }, "image/".concat(fileType !== null && fileType !== void 0 ? fileType : "png"));
                });
              })];
          }
        });
      });
    };
    Snapshot2.prototype.getClassRules = function() {
      var rules = "";
      if (this.useGlobalRules) {
        var styleSheets = document.styleSheets;
        for (var i = 0; i < styleSheets.length; i++) {
          var sheet = styleSheets[i];
          try {
            for (var j = 0; j < sheet.cssRules.length; j++) {
              rules += sheet.cssRules[j].cssText;
            }
          } catch (error) {
            console.log("CSS scripts from different sources have been filtered out");
          }
        }
      }
      if (this.customCssRules) {
        rules += this.customCssRules;
      }
      return rules;
    };
    Snapshot2.prototype.getCanvasData = function(svg, toImageOptions) {
      return __awaiter2(this, void 0, void 0, function() {
        var width, height, backgroundColor, _a, padding, copy, dpr, base, bbox, layoutCanvas, layout, offsetX, offsetY, graphModel, transformModel, SCALE_X, SCALE_Y, TRANSLATE_X, TRANSLATE_Y, bboxWidth, bboxHeight, canvas, ctx, img, style2, foreignObject;
        return __generator2(this, function(_b) {
          width = toImageOptions.width, height = toImageOptions.height, backgroundColor = toImageOptions.backgroundColor, _a = toImageOptions.padding, padding = _a === void 0 ? 40 : _a;
          copy = this.cloneSvg(svg, false);
          dpr = window.devicePixelRatio || 1;
          if (dpr < 1) {
            dpr = 1;
          }
          base = this.lf.graphModel.rootEl.querySelector(".lf-base");
          bbox = base.getBoundingClientRect();
          layoutCanvas = this.lf.container.querySelector(".lf-canvas-overlay");
          layout = layoutCanvas.getBoundingClientRect();
          offsetX = bbox.x - layout.x;
          offsetY = bbox.y - layout.y;
          graphModel = this.lf.graphModel;
          transformModel = graphModel.transformModel;
          SCALE_X = transformModel.SCALE_X, SCALE_Y = transformModel.SCALE_Y, TRANSLATE_X = transformModel.TRANSLATE_X, TRANSLATE_Y = transformModel.TRANSLATE_Y;
          copy.lastChild.style.transform = "matrix(1, 0, 0, 1, ".concat((-offsetX + TRANSLATE_X) * (1 / SCALE_X), ", ").concat((-offsetY + TRANSLATE_Y) * (1 / SCALE_Y), ")");
          bboxWidth = Math.ceil(bbox.width / SCALE_X);
          bboxHeight = Math.ceil(bbox.height / SCALE_Y);
          canvas = document.createElement("canvas");
          canvas.style.width = "".concat(bboxWidth, "px");
          canvas.style.height = "".concat(bboxHeight, "px");
          canvas.width = bboxWidth * dpr + padding * 2;
          canvas.height = bboxHeight * dpr + padding * 2;
          ctx = canvas.getContext("2d");
          if (ctx) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.scale(dpr, dpr);
            if (backgroundColor) {
              ctx.fillStyle = backgroundColor;
              ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
          }
          img = new Image();
          style2 = document.createElement("style");
          style2.innerHTML = this.getClassRules();
          foreignObject = document.createElement("foreignObject");
          foreignObject.appendChild(style2);
          copy.appendChild(foreignObject);
          return [2, new Promise(function(resolve) {
            img.onload = function() {
              var isFirefox = navigator.userAgent.indexOf("Firefox") > -1;
              try {
                if (isFirefox) {
                  createImageBitmap(img, {
                    resizeWidth: width && height ? copyCanvas(canvas, width, height).width : canvas.width,
                    resizeHeight: width && height ? copyCanvas(canvas, width, height).height : canvas.height
                  }).then(function(imageBitmap) {
                    ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(imageBitmap, padding / dpr, padding / dpr);
                    resolve(width && height ? copyCanvas(canvas, width, height) : canvas);
                  });
                } else {
                  ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(img, padding / dpr, padding / dpr);
                  resolve(width && height ? copyCanvas(canvas, width, height) : canvas);
                }
              } catch (e) {
                ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(img, padding / dpr, padding / dpr);
                resolve(width && height ? copyCanvas(canvas, width, height) : canvas);
              }
            };
            var svg2Img = "data:image/svg+xml;charset=utf-8,".concat(new XMLSerializer().serializeToString(copy));
            var imgSrc = svg2Img.replace(/\n/g, "").replace(/\t/g, "").replace(/#/g, "%23");
            img.src = imgSrc;
          })];
        });
      });
    };
    Snapshot2.prototype.cloneSvg = function(svg, addStyle) {
      var _this = this;
      var _a;
      if (addStyle === void 0) {
        addStyle = true;
      }
      var copy = svg.cloneNode(true);
      var graph = copy.lastChild;
      var childLength = (_a = graph === null || graph === void 0 ? void 0 : graph.childNodes) === null || _a === void 0 ? void 0 : _a.length;
      if (childLength) {
        for (var i = 0; i < childLength; i++) {
          var lfLayer = graph === null || graph === void 0 ? void 0 : graph.childNodes[i];
          var layerClassList = lfLayer.classList && Array.from(lfLayer.classList);
          if (layerClassList && layerClassList.indexOf("lf-base") < 0) {
            graph === null || graph === void 0 ? void 0 : graph.removeChild(graph.childNodes[i]);
            childLength--;
            i--;
          } else {
            var lfBase = graph === null || graph === void 0 ? void 0 : graph.childNodes[i];
            lfBase && lfBase.childNodes.forEach(function(item) {
              var element = item;
              _this.removeAnchor(element.firstChild);
              _this.removeRotateControl(element.firstChild);
            });
          }
        }
      }
      if (addStyle) {
        var style2 = document.createElement("style");
        style2.innerHTML = this.getClassRules();
        var foreignObject = document.createElement("foreignObject");
        foreignObject.appendChild(style2);
        copy.appendChild(foreignObject);
      }
      return copy;
    };
    Snapshot2.pluginName = "snapshot";
    return Snapshot2;
  }()
);

// node_modules/@logicflow/extension/es/tools/flow-path/index.js
var __read21 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray16 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var FlowPath = (
  /** @class */
  function() {
    function FlowPath2(_a) {
      var lf = _a.lf;
      var _this = this;
      this.lf = lf;
      this.paths = [];
      lf.getPathes = function() {
        if (!_this.startNodeType) {
          throw new Error("需要预先指定开始节点类型");
        }
        return _this.getPathes();
      };
      lf.setRawPaths = function(paths) {
        _this.setPathes(paths);
      };
      lf.getRawPathes = function() {
        return _this.paths;
      };
      lf.setStartNodeType = function(type3) {
        _this.startNodeType = type3;
      };
    }
    FlowPath2.prototype.setPathes = function(paths) {
      this.paths = paths.map(function(_a) {
        var routeId = _a.routeId, name = _a.name, elements = _a.elements, type3 = _a.type;
        return {
          routeId,
          name,
          elements,
          type: type3,
          similarElement: null,
          weight: 0
        };
      });
    };
    FlowPath2.prototype.getPathes = function() {
      var _this = this;
      var graphData = this.lf.getGraphRawData();
      var nodesMap = /* @__PURE__ */ new Map();
      var startNodeIds = [];
      graphData.nodes.forEach(function(node2) {
        nodesMap.set(node2.id, {
          id: node2.id,
          data: node2,
          nextNodes: []
        });
        if (node2.type === _this.startNodeType) {
          startNodeIds.push(node2.id);
        }
      });
      graphData.edges.forEach(function(edge) {
        var node2 = nodesMap.get(edge.sourceNodeId);
        node2 === null || node2 === void 0 ? void 0 : node2.nextNodes.push(edge.targetNodeId);
      });
      var pathElements = [];
      startNodeIds.forEach(function(id) {
        var node2 = nodesMap.get(id);
        if (node2) {
          pathElements = pathElements.concat(_this.findPathElements(node2, nodesMap, []));
        }
      });
      return this.getNewPathes(pathElements);
    };
    FlowPath2.prototype.findPathElements = function(node2, nodesMap, elements) {
      if (elements === void 0) {
        elements = [];
      }
      var newPaths = __spreadArray16([], __read21(elements), false);
      newPaths.push(node2.id);
      if (node2.nextNodes.length === 0) {
        return [newPaths];
      }
      var subPath = [];
      for (var i = 0; i < node2.nextNodes.length; i++) {
        var n = nodesMap.get(node2.nextNodes[i]);
        var p = void 0;
        if (n) {
          var idx = newPaths.indexOf(n.id);
          if (idx !== -1) {
            p = [__spreadArray16(__spreadArray16([], __read21(newPaths.slice(idx)), false), [n.id], false)];
          } else {
            p = this.findPathElements(n, nodesMap, __spreadArray16([], __read21(newPaths), false));
          }
          subPath = subPath.concat(p);
        }
      }
      return subPath;
    };
    FlowPath2.prototype.getNewPathes = function(pathElements) {
      var _this = this;
      var paths = [];
      var LoopSet = /* @__PURE__ */ new Set();
      pathElements.forEach(function(elements) {
        var routeId = _this.getNewId("path");
        var name = _this.getNewId("路径");
        var isLoop = _this.isLoopPath(elements);
        var elementStr = elements.join(",");
        if (!LoopSet.has(elementStr)) {
          LoopSet.add(elementStr);
          paths.push({
            routeId,
            name,
            elements,
            type: isLoop,
            weight: 0,
            similarElement: ""
          });
        }
      });
      var oldPaths = JSON.parse(JSON.stringify(this.paths));
      paths.forEach(function(newPath) {
        for (var i = 0; i < oldPaths.length; i++) {
          var oldPath = oldPaths[i];
          var weight = _this.similar2Path(__spreadArray16([], __read21(newPath.elements), false), __spreadArray16([], __read21(oldPath.elements), false));
          if (weight > newPath.weight && oldPath.weight <= weight) {
            newPath.weight = weight;
            newPath.similarElement = oldPath;
            if (weight === oldPath.weight && oldPath.similarElement) {
              oldPath.similarElement.similarElement = null;
              oldPath.similarElement.weight = 0;
              oldPath.similarElement = null;
              oldPath.weight = 0;
            } else {
              oldPath.similarElement = newPath;
              oldPath.weight = weight;
            }
          }
        }
      });
      paths.forEach(function(newPath) {
        if (newPath.similarElement && newPath.similarElement.similarElement === newPath) {
          newPath.routeId = newPath.similarElement.routeId;
          newPath.name = newPath.similarElement.name;
        }
        delete newPath.similarElement;
        delete newPath.weight;
      });
      this.setPathes(paths);
      return paths;
    };
    FlowPath2.prototype.similar2Path = function(x2, y) {
      var z = 0;
      var s = x2.length + y.length;
      x2.sort();
      y.sort();
      var a = x2.shift();
      var b2 = y.shift();
      while (a !== void 0 && b2 !== void 0) {
        if (a === b2) {
          z++;
          a = x2.shift();
          b2 = y.shift();
        } else if (a < b2) {
          a = x2.shift();
        } else if (a > b2) {
          b2 = y.shift();
        }
      }
      return z / s * 200;
    };
    FlowPath2.prototype.getNewId = function(prefix) {
      return "".concat(prefix, "_").concat(getBpmnId());
    };
    FlowPath2.prototype.isLoopPath = function(elements) {
      var length = elements.length;
      return elements.indexOf(elements[length - 1]) !== length - 1 ? 1 : 0;
    };
    FlowPath2.pluginName = "flowPath";
    return FlowPath2;
  }()
);

// node_modules/@logicflow/extension/es/tools/auto-layout/index.js
var __assign27 = function() {
  __assign27 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign27.apply(this, arguments);
};
var POSITION_TYPE = {
  LEFT_TOP: -1,
  LEFT: 0,
  LEFT_BOTTOM: 1
};
var AutoLayout = (
  /** @class */
  function() {
    function AutoLayout2(_a) {
      var lf = _a.lf;
      var _this = this;
      this.levelHeight = [];
      this.newNodeMap = /* @__PURE__ */ new Map();
      this.lf = lf;
      this.trunk = [];
      lf.layout = function(startNodeType) {
        var data = _this.lf.getGraphRawData();
        _this.lf.setStartNodeType(startNodeType);
        var path = _this.lf.getPathes();
        _this.levelHeight = [];
        _this.newNodeMap = /* @__PURE__ */ new Map();
        return _this.layout(data, path);
      };
    }
    AutoLayout2.prototype.layout = function(data, path) {
      var _this = this;
      var trunk = [];
      path.forEach(function(p) {
        var elements = p.elements;
        if (elements.length > trunk.length) {
          trunk = elements;
        } else if (elements.length === trunk.length) {
          if (JSON.stringify(elements) === JSON.stringify(_this.trunk)) {
            trunk = _this.trunk;
          }
        }
      });
      this.trunk = trunk;
      var nodeMap = this.formatData(data);
      var newGraphData = {
        nodes: [],
        edges: []
      };
      for (var i = trunk.length - 1; i >= 0; i--) {
        this.setNodePosition(trunk[i], nodeMap, newGraphData, i, 1);
      }
      this.lf.graphModel.graphDataToModel(newGraphData);
    };
    AutoLayout2.prototype.setNodePosition = function(nodeId, nodeMap, newGraphData, xLevel, yLevel) {
      var _this = this;
      var n = nodeMap[nodeId];
      var text = n.text, type3 = n.type, next = n.next, properties = n.properties;
      var x2 = xLevel * 160 + 40;
      var y = yLevel * 120;
      var nodeData = {
        id: nodeId,
        x: x2,
        text,
        y,
        type: type3,
        properties
      };
      if (text && typeof text === "object") {
        nodeData.text = __assign27(__assign27({}, text), { x: x2 + text.x, y: y + text.y });
      }
      this.newNodeMap.set(nodeData.id, {
        x: nodeData.x,
        y: nodeData.y,
        type: type3
      });
      newGraphData.nodes.push(nodeData);
      n.isFixed = true;
      this.addLevelHeight(xLevel, 1);
      if (next && next.length > 0) {
        next.forEach(function(nextInfo) {
          var n1 = nodeMap[nextInfo.nodeId];
          if (!n1.isFixed) {
            var nextYLevel = _this.getLevelHeight(xLevel + 1);
            _this.addLevelHeight(xLevel, 1);
            _this.setNodePosition(nextInfo.nodeId, nodeMap, newGraphData, xLevel + 1, nextYLevel + 1);
          } else {
          }
          newGraphData.edges.push(__assign27({ id: nextInfo.edgeId, type: nextInfo.edgeType, sourceNodeId: nodeId, targetNodeId: nextInfo.nodeId, properties: nextInfo.properties, text: nextInfo.text }, _this.getEdgeDataPoints(nodeId, nextInfo.nodeId)));
        });
      }
      return nodeData;
    };
    AutoLayout2.prototype.getEdgeDataPoints = function(sourceNodeId, targetNodeId) {
      var source = this.newNodeMap.get(sourceNodeId);
      var target = this.newNodeMap.get(targetNodeId);
      var _a = this.getShape(sourceNodeId), width = _a.width, height = _a.height;
      var _b = this.getShape(targetNodeId), targetWidth = _b.width, targetHeight = _b.height;
      var positionType = this.getRelativePosition(source, target);
      var startPoint = {
        x: source.x,
        y: source.y
      };
      var endPoint = {
        x: target.x,
        y: target.y
      };
      switch (positionType) {
        case POSITION_TYPE.LEFT:
          startPoint.x = source.x + width / 2;
          endPoint.x = target.x - targetWidth / 2;
          break;
        case POSITION_TYPE.LEFT_TOP:
          startPoint.y = source.y + height / 2;
          endPoint.x = target.x - targetWidth / 2;
          break;
        case POSITION_TYPE.LEFT_BOTTOM:
          startPoint.x = source.x + width / 2;
          endPoint.y = target.y + targetHeight / 2;
          break;
        default:
          break;
      }
      return {
        startPoint,
        endPoint
      };
    };
    AutoLayout2.prototype.getRelativePosition = function(source, target) {
      var y = source.y;
      var y1 = target.y;
      var positionType;
      if (y < y1) {
        positionType = -1;
      } else if (y === y1) {
        positionType = 0;
      } else {
        positionType = 1;
      }
      return positionType;
    };
    AutoLayout2.prototype.getShape = function(nodeId) {
      var _a, _b;
      var nodeModel = this.lf.getNodeModelById(nodeId);
      return {
        height: (_a = nodeModel === null || nodeModel === void 0 ? void 0 : nodeModel.height) !== null && _a !== void 0 ? _a : 0,
        width: (_b = nodeModel === null || nodeModel === void 0 ? void 0 : nodeModel.width) !== null && _b !== void 0 ? _b : 0
      };
    };
    AutoLayout2.prototype.formatData = function(data) {
      var nodeMap = data.nodes.reduce(function(nMap, node2) {
        var type3 = node2.type, properties = node2.properties, text = node2.text, x2 = node2.x, y = node2.y;
        if (text && typeof text === "object") {
          text.x = text.x - x2;
          text.y = text.y - y;
        }
        nMap[node2.id] = {
          type: type3,
          properties,
          text,
          prev: [],
          next: []
        };
        return nMap;
      }, {});
      data.edges.forEach(function(edge) {
        var sourceNodeId = edge.sourceNodeId, targetNodeId = edge.targetNodeId, id = edge.id, properties = edge.properties, text = edge.text;
        var newText = text;
        if (typeof text === "object") {
          newText = text.value;
        }
        nodeMap[sourceNodeId].next.push({
          edgeId: id,
          nodeId: targetNodeId,
          edgeType: edge.type,
          properties,
          text: newText
        });
        nodeMap[targetNodeId].prev.push({
          edgeId: id,
          nodeId: sourceNodeId,
          properties,
          text: newText
        });
      });
      return nodeMap;
    };
    AutoLayout2.prototype.addLevelHeight = function(level, height, isNegative) {
      if (height === void 0) {
        height = 1;
      }
      if (isNegative === void 0) {
        isNegative = false;
      }
      var l = this.levelHeight[level];
      if (!l) {
        l = {
          positiveHeight: 0,
          negativeHeight: 0
        };
        this.levelHeight[level] = l;
      }
      isNegative ? l.negativeHeight -= height : l.positiveHeight += height;
    };
    AutoLayout2.prototype.getLevelHeight = function(level, isNegative) {
      if (isNegative === void 0) {
        isNegative = false;
      }
      var val = this.levelHeight[level];
      if (!val) {
        return 0;
      }
      return isNegative ? val.negativeHeight : val.positiveHeight;
    };
    AutoLayout2.pluginName = "AutoLayout";
    return AutoLayout2;
  }()
);

// node_modules/@logicflow/extension/es/tools/proximity-connect/index.js
var __assign28 = function() {
  __assign28 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign28.apply(this, arguments);
};
var ProximityConnect = (
  /** @class */
  function() {
    function ProximityConnect2(_a) {
      var lf = _a.lf, options = _a.options;
      this.enable = true;
      this.currentDistance = Infinity;
      this.thresholdDistance = 100;
      this.reverseDirection = false;
      this.virtualEdgeStyle = {
        strokeDasharray: "10,10",
        stroke: "#acacac"
      };
      this.lf = lf;
      assign_default(this, options);
    }
    ProximityConnect2.prototype.render = function() {
      this.addEventListeners();
    };
    ProximityConnect2.prototype.addEventListeners = function() {
      var _this = this;
      this.lf.graphModel.eventCenter.on("node:dragstart", function(_a) {
        var data = _a.data;
        if (!_this.enable)
          return;
        var graphModel = _this.lf.graphModel;
        var id = data.id;
        _this.currentNode = graphModel.getNodeModelById(id);
      });
      this.lf.graphModel.eventCenter.on("node:drag", function() {
        _this.handleNodeDrag();
      });
      this.lf.graphModel.eventCenter.on("anchor:dragstart", function(_a) {
        var data = _a.data, nodeModel = _a.nodeModel;
        if (!_this.enable)
          return;
        _this.currentNode = nodeModel;
        _this.currentAnchor = data;
      });
      this.lf.graphModel.eventCenter.on("anchor:drag", function(_a) {
        var _b = _a.e, clientX = _b.clientX, clientY = _b.clientY;
        if (!_this.enable)
          return;
        _this.handleAnchorDrag(clientX, clientY);
      });
      this.lf.graphModel.eventCenter.on("node:drop,anchor:dragend", function() {
        if (!_this.enable)
          return;
        _this.handleDrop();
      });
    };
    ProximityConnect2.prototype.handleNodeDrag = function() {
      var nodes = this.lf.graphModel.nodes;
      if (!isNil_default(this.virtualEdge)) {
        var _a = this.virtualEdge, startPoint = _a.startPoint, endPoint = _a.endPoint, id = _a.id;
        var curDistance = twoPointDistance(startPoint, endPoint);
        if (curDistance > this.thresholdDistance) {
          this.lf.deleteEdge(id);
          this.virtualEdge = void 0;
        }
      }
      if (this.currentNode) {
        this.findClosestAnchorOfNode(this.currentNode, nodes);
      }
      if (this.currentDistance < this.thresholdDistance) {
        this.addVirtualEdge();
      }
    };
    ProximityConnect2.prototype.handleDrop = function() {
      this.addActualEdge();
      this.resetData();
    };
    ProximityConnect2.prototype.handleAnchorDrag = function(clientX, clientY) {
      var graphModel = this.lf.graphModel;
      var _a = graphModel.getPointByClient({
        x: clientX,
        y: clientY
      }).canvasOverlayPosition, x2 = _a.x, y = _a.y;
      if (isNil_default(x2) || isNil_default(y))
        return;
      var currentPoint = { x: x2, y };
      var nodes = graphModel.nodes;
      if (!isNil_default(this.virtualEdge)) {
        var _b = this.virtualEdge, endPoint = _b.endPoint, id = _b.id;
        var curDistance = twoPointDistance(currentPoint, endPoint);
        if (curDistance > this.thresholdDistance) {
          this.lf.deleteEdge(id);
          this.virtualEdge = void 0;
        }
      }
      this.findClosestAnchorOfAnchor(currentPoint, nodes);
      if (this.currentDistance < this.thresholdDistance) {
        this.addVirtualEdge();
      }
    };
    ProximityConnect2.prototype.findClosestAnchorOfNode = function(draggingNode, allNodes) {
      var _this = this;
      if (isNil_default(draggingNode) || isEmpty_default(draggingNode))
        return;
      var _a = draggingNode.anchors, draggingAnchors = _a === void 0 ? [] : _a, id = draggingNode.id;
      var distance;
      var preConnectAnchor;
      var closestAnchor;
      var closestNode;
      allNodes.forEach(function(node2) {
        if (isEqual_default(node2.id, id))
          return;
        var _a2 = node2.anchors, anchors = _a2 === void 0 ? [] : _a2;
        anchors.forEach(function(anchor) {
          draggingAnchors.forEach(function(draggingAnchor) {
            var anchorAllowConnect = _this.anchorAllowConnect(node2, anchor, draggingAnchor);
            if (!anchorAllowConnect)
              return;
            var curDistance = twoPointDistance(draggingAnchor, anchor);
            if (!distance || curDistance < distance) {
              distance = curDistance;
              preConnectAnchor = draggingAnchor;
              closestAnchor = anchor;
              closestNode = node2;
            }
          });
        });
      });
      this.currentDistance = distance;
      this.currentAnchor = preConnectAnchor;
      this.closestAnchor = closestAnchor;
      this.closestNode = closestNode;
    };
    ProximityConnect2.prototype.findClosestAnchorOfAnchor = function(draggingPoint, allNodes) {
      var _this = this;
      if (isNil_default(draggingPoint))
        return;
      var distance;
      var closestAnchor;
      var closestNode;
      var _a = this, currentNode = _a.currentNode, currentAnchor = _a.currentAnchor;
      allNodes.forEach(function(node2) {
        if (!currentNode)
          return;
        var _a2 = node2.anchors, anchors = _a2 === void 0 ? [] : _a2;
        anchors.forEach(function(anchor) {
          var _a3;
          if (isEqual_default((_a3 = _this.currentAnchor) === null || _a3 === void 0 ? void 0 : _a3.id, anchor.id))
            return;
          var anchorAllowConnect = _this.anchorAllowConnect(node2, anchor, currentAnchor);
          if (!anchorAllowConnect)
            return;
          var curDistance = twoPointDistance(draggingPoint, anchor);
          if (!distance || curDistance < distance) {
            distance = curDistance;
            closestAnchor = anchor;
            closestNode = node2;
          }
        });
      });
      this.currentDistance = distance;
      this.closestAnchor = closestAnchor;
      this.closestNode = closestNode;
    };
    ProximityConnect2.prototype.anchorAllowConnect = function(node2, anchor, draggingAnchor) {
      var currentNode = this.currentNode;
      if (!currentNode)
        return;
      var sourceValidResult = (this.reverseDirection ? node2.isAllowConnectedAsSource(currentNode, anchor, draggingAnchor) : currentNode.isAllowConnectedAsSource(node2, draggingAnchor, anchor)).isAllPass;
      var targetValidResult = (this.reverseDirection ? currentNode.isAllowConnectedAsTarget(node2, anchor, draggingAnchor) : node2.isAllowConnectedAsTarget(currentNode, draggingAnchor, anchor)).isAllPass;
      return sourceValidResult && targetValidResult;
    };
    ProximityConnect2.prototype.sameEdgeIsExist = function(edge) {
      if (isNil_default(this.closestNode) || isNil_default(this.currentNode) || isNil_default(this.closestAnchor) || isNil_default(this.currentAnchor))
        return false;
      if (isNil_default(edge))
        return false;
      var _a = this, closestNodeId = _a.closestNode.id, currentNodeId = _a.currentNode.id, closestAnchorId = _a.closestAnchor.id, currentAnchorId = _a.currentAnchor.id, reverseDirection = _a.reverseDirection;
      var sourceNodeId = edge.sourceNodeId, targetNodeId = edge.targetNodeId, sourceAnchorId = edge.sourceAnchorId, targetAnchorId = edge.targetAnchorId;
      var isExist = reverseDirection ? isEqual_default(closestNodeId, sourceNodeId) && isEqual_default(currentNodeId, targetNodeId) && isEqual_default(closestAnchorId, sourceAnchorId) && isEqual_default(currentAnchorId, targetAnchorId) : isEqual_default(currentNodeId, sourceNodeId) && isEqual_default(closestNodeId, targetNodeId) && isEqual_default(currentAnchorId, sourceAnchorId) && isEqual_default(closestAnchorId, targetAnchorId);
      return isExist;
    };
    ProximityConnect2.prototype.addVirtualEdge = function() {
      var _this = this;
      var edges = this.lf.graphModel.edges;
      var actualEdgeIsExist = reduce_default(edges, function(result, edge) {
        if (edge.virtual)
          return result;
        return result || _this.sameEdgeIsExist(edge);
      }, false);
      if (actualEdgeIsExist)
        return;
      if (!isNil_default(this.virtualEdge)) {
        var edgeId = this.virtualEdge.id;
        if (this.sameEdgeIsExist(this.virtualEdge))
          return;
        this.lf.deleteEdge(edgeId);
      }
      var _a = this, reverseDirection = _a.reverseDirection, currentNode = _a.currentNode, closestNode = _a.closestNode, currentAnchor = _a.currentAnchor, closestAnchor = _a.closestAnchor;
      if (isEmpty_default(currentNode) || isEmpty_default(closestNode))
        return;
      var properties = {
        style: this.virtualEdgeStyle
      };
      this.virtualEdge = this.lf.addEdge(reverseDirection ? {
        sourceNodeId: closestNode === null || closestNode === void 0 ? void 0 : closestNode.id,
        targetNodeId: currentNode === null || currentNode === void 0 ? void 0 : currentNode.id,
        sourceAnchorId: closestAnchor === null || closestAnchor === void 0 ? void 0 : closestAnchor.id,
        targetAnchorId: currentAnchor === null || currentAnchor === void 0 ? void 0 : currentAnchor.id,
        properties
      } : {
        sourceNodeId: currentNode === null || currentNode === void 0 ? void 0 : currentNode.id,
        targetNodeId: closestNode === null || closestNode === void 0 ? void 0 : closestNode.id,
        sourceAnchorId: currentAnchor === null || currentAnchor === void 0 ? void 0 : currentAnchor.id,
        targetAnchorId: closestAnchor === null || closestAnchor === void 0 ? void 0 : closestAnchor.id,
        properties
      });
      this.virtualEdge.virtual = true;
    };
    ProximityConnect2.prototype.addActualEdge = function() {
      if (isNil_default(this.virtualEdge))
        return;
      var _a = this.virtualEdge, type3 = _a.type, sourceNodeId = _a.sourceNodeId, targetNodeId = _a.targetNodeId, sourceAnchorId = _a.sourceAnchorId, targetAnchorId = _a.targetAnchorId, startPoint = _a.startPoint, endPoint = _a.endPoint, pointsList = _a.pointsList;
      this.lf.addEdge({
        type: type3,
        sourceNodeId,
        targetNodeId,
        sourceAnchorId,
        targetAnchorId,
        startPoint,
        endPoint,
        pointsList
      });
      this.lf.deleteEdge(this.virtualEdge.id);
    };
    ProximityConnect2.prototype.setVirtualEdgeStyle = function(value) {
      this.virtualEdgeStyle = __assign28(__assign28({}, this.virtualEdgeStyle), value);
    };
    ProximityConnect2.prototype.setThresholdDistance = function(distance) {
      console.log("distance", distance);
      if (!isFinite_default(distance))
        return;
      this.thresholdDistance = distance;
    };
    ProximityConnect2.prototype.setReverseDirection = function(value) {
      this.reverseDirection = value;
    };
    ProximityConnect2.prototype.setEnable = function(enable) {
      this.enable = enable;
      if (!enable) {
        this.resetData();
      }
    };
    ProximityConnect2.prototype.resetData = function() {
      this.closestNode = void 0;
      this.currentDistance = Infinity;
      this.currentNode = void 0;
      this.currentAnchor = void 0;
      this.closestAnchor = void 0;
      this.virtualEdge = void 0;
    };
    ProximityConnect2.pluginName = "proximityConnect";
    return ProximityConnect2;
  }()
);

// node_modules/@logicflow/extension/es/components/control/index.js
var __read22 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray17 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Control2 = (
  /** @class */
  function() {
    function Control3(_a) {
      var lf = _a.lf;
      var _this = this;
      this.controlItems = [
        {
          key: "zoom-out",
          iconClass: "lf-control-zoomOut",
          title: "缩小流程图",
          text: "缩小",
          onClick: function() {
            _this.lf.zoom(false);
          }
        },
        {
          key: "zoom-in",
          iconClass: "lf-control-zoomIn",
          title: "放大流程图",
          text: "放大",
          onClick: function() {
            _this.lf.zoom(true);
          }
        },
        {
          key: "reset",
          iconClass: "lf-control-fit",
          title: "恢复流程原有尺寸",
          text: "适应",
          onClick: function() {
            _this.lf.resetZoom();
          }
        },
        {
          key: "undo",
          iconClass: "lf-control-undo",
          title: "回到上一步",
          text: "上一步",
          onClick: function() {
            _this.lf.undo();
          }
        },
        {
          key: "redo",
          iconClass: "lf-control-redo",
          title: "移到下一步",
          text: "下一步",
          onClick: function() {
            _this.lf.redo();
          }
        }
      ];
      this.lf = lf;
    }
    Control3.prototype.render = function(_, domContainer) {
      this.destroy();
      var toolEl = this.getControlTool();
      this.toolEl = toolEl;
      domContainer.appendChild(toolEl);
      this.domContainer = domContainer;
    };
    Control3.prototype.destroy = function() {
      if (this.domContainer && this.toolEl && this.domContainer.contains(this.toolEl)) {
        this.domContainer.removeChild(this.toolEl);
      }
    };
    Control3.prototype.addItem = function(item) {
      this.controlItems.push(item);
    };
    Control3.prototype.removeItem = function(key) {
      var index = this.controlItems.findIndex(function(item) {
        return item.key === key;
      });
      return index == -1 ? null : this.controlItems.splice(index, 1)[0];
    };
    Control3.prototype.getControlTool = function() {
      var _this = this;
      var NORMAL = "lf-control-item";
      var DISABLED = "lf-control-item disabled";
      var controlTool = document.createElement("div");
      var controlElements = [];
      controlTool.className = "lf-control";
      this.controlItems.forEach(function(item) {
        var itemContainer = document.createElement("div");
        var icon = document.createElement("i");
        var text = document.createElement("span");
        itemContainer.className = DISABLED;
        item.onClick && (itemContainer.onclick = item.onClick.bind(null, _this.lf));
        item.onMouseEnter && (itemContainer.onmouseenter = item.onMouseEnter.bind(null, _this.lf));
        item.onMouseLeave && (itemContainer.onmouseleave = item.onMouseLeave.bind(null, _this.lf));
        icon.className = item.iconClass;
        text.className = "lf-control-text";
        text.title = item.title;
        text.innerText = item.text;
        itemContainer.append(icon, text);
        switch (item.text) {
          case "上一步":
            _this.lf.on("history:change", function(_a) {
              var undoAble = _a.data.undoAble;
              itemContainer.className = undoAble ? NORMAL : DISABLED;
            });
            break;
          case "下一步":
            _this.lf.on("history:change", function(_a) {
              var redoAble = _a.data.redoAble;
              itemContainer.className = redoAble ? NORMAL : DISABLED;
            });
            break;
          default:
            itemContainer.className = NORMAL;
            break;
        }
        controlElements.push(itemContainer);
      });
      controlTool.append.apply(controlTool, __spreadArray17([], __read22(controlElements), false));
      return controlTool;
    };
    Control3.pluginName = "control";
    return Control3;
  }()
);

// node_modules/@logicflow/extension/es/components/menu/index.js
var __read23 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray18 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DefaultNodeMenuKey = "lf:defaultNodeMenu";
var DefaultEdgeMenuKey = "lf:defaultEdgeMenu";
var DefaultGraphMenuKey = "lf:defaultGraphMenu";
var DefaultSelectionMenuKey = "lf:defaultSelectionMenu";
var Menu = (
  /** @class */
  function() {
    function Menu2(_a) {
      var lf = _a.lf;
      var _this = this;
      this.__currentData = null;
      this.lf = lf;
      var isSilentMode = lf.options.isSilentMode;
      if (!isSilentMode) {
        this.__menuDOM = document.createElement("ul");
        this.menuTypeMap = /* @__PURE__ */ new Map();
        this.init();
        this.lf.setMenuConfig = function(config) {
          _this.setMenuConfig(config);
        };
        this.lf.addMenuConfig = function(config) {
          _this.addMenuConfig(config);
        };
        this.lf.setMenuByType = function(config) {
          _this.setMenuByType(config);
        };
      }
    }
    Menu2.prototype.init = function() {
      var _this = this;
      var _a, _b, _c, _d;
      var defaultNodeMenu = [
        {
          text: "删除",
          callback: function(node2) {
            _this.lf.deleteNode(node2.id);
          }
        },
        {
          text: "编辑文本",
          callback: function(node2) {
            _this.lf.graphModel.editText(node2.id);
          }
        },
        {
          text: "复制",
          callback: function(node2) {
            _this.lf.cloneNode(node2.id);
          }
        }
      ];
      (_a = this.menuTypeMap) === null || _a === void 0 ? void 0 : _a.set(DefaultNodeMenuKey, defaultNodeMenu);
      var defaultEdgeMenu = [
        {
          text: "删除",
          callback: function(edge) {
            _this.lf.deleteEdge(edge.id);
          }
        },
        {
          text: "编辑文本",
          callback: function(edge) {
            _this.lf.graphModel.editText(edge.id);
          }
        }
      ];
      (_b = this.menuTypeMap) === null || _b === void 0 ? void 0 : _b.set(DefaultEdgeMenuKey, defaultEdgeMenu);
      (_c = this.menuTypeMap) === null || _c === void 0 ? void 0 : _c.set(DefaultGraphMenuKey, []);
      var DefaultSelectionMenu = [
        {
          text: "删除",
          callback: function(elements) {
            _this.lf.clearSelectElements();
            elements.edges.forEach(function(edge) {
              return _this.lf.deleteEdge(edge.id);
            });
            elements.nodes.forEach(function(node2) {
              return _this.lf.deleteNode(node2.id);
            });
          }
        }
      ];
      (_d = this.menuTypeMap) === null || _d === void 0 ? void 0 : _d.set(DefaultSelectionMenuKey, DefaultSelectionMenu);
    };
    Menu2.prototype.render = function(lf, container) {
      var _this = this;
      if (lf.options.isSilentMode)
        return;
      this.__container = container;
      this.__currentData = null;
      if (this.__menuDOM) {
        this.__menuDOM.className = "lf-menu";
        container.appendChild(this.__menuDOM);
        this.__menuDOM.addEventListener("click", function(event) {
          event.stopPropagation();
          var target = event.target;
          while (Array.from(target.classList).indexOf("lf-menu-item") === -1 && Array.from(target.classList).indexOf("lf-menu") === -1) {
            target = target === null || target === void 0 ? void 0 : target.parentElement;
          }
          if (Array.from(target.classList).indexOf("lf-menu-item") > -1) {
            ;
            target.onclickCallback(_this.__currentData);
            if (_this.__menuDOM) {
              _this.__menuDOM.style.display = "none";
            }
            _this.__currentData = null;
          } else {
            console.warn("点击区域不在菜单项内，请检查代码！");
          }
        }, true);
      }
      this.lf.on("node:contextmenu", function(_a) {
        var _b, _c;
        var data = _a.data, position = _a.position, e = _a.e;
        var _d = position.domOverlayPosition, x2 = _d.x, y = _d.y;
        var id = data.id;
        var model = _this.lf.graphModel.getNodeModelById(id);
        if (!model)
          return;
        var menuList = [];
        var typeMenus = (_b = _this.menuTypeMap) === null || _b === void 0 ? void 0 : _b.get(model.type);
        if (model && model.menu && Array.isArray(model.menu)) {
          menuList = model.menu;
        } else if (typeMenus) {
          menuList = typeMenus;
        } else {
          menuList = (_c = _this.menuTypeMap) === null || _c === void 0 ? void 0 : _c.get(DefaultNodeMenuKey);
        }
        _this.__currentData = data;
        _this.showMenu(x2, y, menuList, {
          width: model.width,
          height: model.height,
          clientX: e.clientX,
          clientY: e.clientY
        });
      });
      this.lf.on("edge:contextmenu", function(_a) {
        var _b, _c, _d;
        var data = _a.data, position = _a.position, e = _a.e;
        var _e = position.domOverlayPosition, x2 = _e.x, y = _e.y;
        var id = data.id;
        var model = _this.lf.graphModel.getEdgeModelById(id);
        if (!model)
          return;
        var menuList = [];
        var typeMenus = (_b = _this.menuTypeMap) === null || _b === void 0 ? void 0 : _b.get(model.type);
        if (model && model.menu && Array.isArray(model.menu)) {
          menuList = model.menu;
        } else if (typeMenus) {
          menuList = typeMenus;
        } else {
          menuList = (_d = (_c = _this.menuTypeMap) === null || _c === void 0 ? void 0 : _c.get(DefaultEdgeMenuKey)) !== null && _d !== void 0 ? _d : [];
        }
        _this.__currentData = data;
        _this.showMenu(x2, y, menuList, {
          width: model.width,
          height: model.height,
          clientX: e.clientX,
          clientY: e.clientY
        });
      });
      this.lf.on("blank:contextmenu", function(_a) {
        var _b, _c;
        var position = _a.position;
        var menuList = (_c = (_b = _this.menuTypeMap) === null || _b === void 0 ? void 0 : _b.get(DefaultGraphMenuKey)) !== null && _c !== void 0 ? _c : [];
        var _d = position.domOverlayPosition, x2 = _d.x, y = _d.y;
        _this.showMenu(x2, y, menuList);
      });
      this.lf.on("selection:contextmenu", function(_a) {
        var _b;
        var data = _a.data, position = _a.position;
        var menuList = (_b = _this.menuTypeMap) === null || _b === void 0 ? void 0 : _b.get(DefaultSelectionMenuKey);
        var _c = position.domOverlayPosition, x2 = _c.x, y = _c.y;
        _this.__currentData = data;
        _this.showMenu(x2, y, menuList);
      });
      this.lf.on("node:mousedown", function() {
        _this.__menuDOM.style.display = "none";
      });
      this.lf.on("edge:click", function() {
        _this.__menuDOM.style.display = "none";
      });
      this.lf.on("blank:click", function() {
        _this.__menuDOM.style.display = "none";
      });
    };
    Menu2.prototype.destroy = function() {
      var _a;
      if (this.__menuDOM) {
        (_a = this === null || this === void 0 ? void 0 : this.__container) === null || _a === void 0 ? void 0 : _a.removeChild(this.__menuDOM);
        this.__menuDOM = void 0;
      }
    };
    Menu2.prototype.showMenu = function(x2, y, menuList, options) {
      if (!menuList || !menuList.length)
        return;
      var menu = this.__menuDOM;
      if (menu) {
        menu.innerHTML = "";
        menu.append.apply(menu, __spreadArray18([], __read23(this.__getMenuDom(menuList)), false));
        if (!menu.children.length)
          return;
        menu.style.display = "block";
        if (!options) {
          menu.style.top = "".concat(y, "px");
          menu.style.left = "".concat(x2, "px");
          return;
        }
        var width = options.width, height = options.height, clientX = options.clientX, clientY = options.clientY;
        var graphModel = this.lf.graphModel;
        var menuWidth = menu.offsetWidth;
        var menuIsRightShow = true;
        var windowMaxX = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        var rightDistance = windowMaxX - clientX;
        var graphRect = graphModel.rootEl.getBoundingClientRect();
        var graphMaxX = graphRect.left + graphRect.width;
        if (graphMaxX < windowMaxX) {
          rightDistance = graphMaxX - clientX;
        }
        if (rightDistance < menuWidth) {
          menuIsRightShow = false;
        }
        if (menuIsRightShow) {
          menu.style.left = "".concat(x2, "px");
        } else {
          menu.style.left = "".concat(x2 - width, "px");
        }
        var menuHeight = menu.offsetHeight;
        var menuIsBottomShow = true;
        var windowMaxY = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
        var bottomDistance = windowMaxY - clientY;
        var graphMaxY = graphRect.top + graphRect.height;
        if (graphMaxY < windowMaxY) {
          bottomDistance = graphMaxY - clientY;
        }
        if (bottomDistance < menuHeight) {
          menuIsBottomShow = false;
        }
        if (menuIsBottomShow) {
          menu.style.top = "".concat(y, "px");
        } else {
          menu.style.top = "".concat(y - height, "px");
        }
      }
    };
    Menu2.prototype.setMenuByType = function(_a) {
      var _b;
      var type3 = _a.type, menu = _a.menu;
      if (!type3 || !menu) {
        return;
      }
      (_b = this.menuTypeMap) === null || _b === void 0 ? void 0 : _b.set(type3, menu);
    };
    Menu2.prototype.__getMenuDom = function(list) {
      var menuList = [];
      list && list.length > 0 && list.forEach(function(item) {
        var element = document.createElement("li");
        if (item.className) {
          element.className = "lf-menu-item ".concat(item.className);
        } else {
          element.className = "lf-menu-item";
        }
        if (item.icon === true) {
          var icon = document.createElement("span");
          icon.className = "lf-menu-item-icon";
          element.appendChild(icon);
        }
        var text = document.createElement("span");
        text.className = "lf-menu-item-text";
        if (item.text) {
          text.innerText = item.text;
        }
        element.appendChild(text);
        element.onclickCallback = item.callback;
        menuList.push(element);
      });
      return menuList;
    };
    Menu2.prototype.setMenuConfig = function(config) {
      var _a, _b, _c;
      if (!config) {
        return;
      }
      config.nodeMenu !== void 0 && ((_a = this.menuTypeMap) === null || _a === void 0 ? void 0 : _a.set(DefaultNodeMenuKey, config.nodeMenu ? config.nodeMenu : []));
      config.edgeMenu !== void 0 && ((_b = this.menuTypeMap) === null || _b === void 0 ? void 0 : _b.set(DefaultEdgeMenuKey, config.edgeMenu ? config.edgeMenu : []));
      config.graphMenu !== void 0 && ((_c = this.menuTypeMap) === null || _c === void 0 ? void 0 : _c.set(DefaultGraphMenuKey, config.graphMenu ? config.graphMenu : []));
    };
    Menu2.prototype.addMenuConfig = function(config) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      if (!config) {
        return;
      }
      if (Array.isArray(config.nodeMenu)) {
        var menuList = (_b = (_a = this.menuTypeMap) === null || _a === void 0 ? void 0 : _a.get(DefaultNodeMenuKey)) !== null && _b !== void 0 ? _b : [];
        (_c = this.menuTypeMap) === null || _c === void 0 ? void 0 : _c.set(DefaultNodeMenuKey, menuList.concat(config.nodeMenu));
      }
      if (Array.isArray(config.edgeMenu)) {
        var menuList = (_e = (_d = this.menuTypeMap) === null || _d === void 0 ? void 0 : _d.get(DefaultEdgeMenuKey)) !== null && _e !== void 0 ? _e : [];
        (_f = this.menuTypeMap) === null || _f === void 0 ? void 0 : _f.set(DefaultEdgeMenuKey, menuList.concat(config.edgeMenu));
      }
      if (Array.isArray(config.graphMenu)) {
        var menuList = (_h = (_g = this.menuTypeMap) === null || _g === void 0 ? void 0 : _g.get(DefaultGraphMenuKey)) !== null && _h !== void 0 ? _h : [];
        (_j = this.menuTypeMap) === null || _j === void 0 ? void 0 : _j.set(DefaultGraphMenuKey, menuList.concat(config.graphMenu));
      }
    };
    Menu2.prototype.changeMenuItem = function(type3, config) {
      if (type3 === "add") {
        this.addMenuConfig(config);
      } else if (type3 === "reset") {
        this.setMenuConfig(config);
      } else {
        throw new Error("The first parameter of changeMenuConfig should be 'add' or 'reset'");
      }
    };
    Menu2.pluginName = "menu";
    return Menu2;
  }()
);

// node_modules/@logicflow/extension/es/components/context-menu/index.js
var __read24 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray19 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var COMMON_TYPE_KEY = "menu-common";
var NEXT_X_DISTANCE = 200;
var NEXT_Y_DISTANCE = 100;
var ContextMenu = (
  /** @class */
  function() {
    function ContextMenu2(_a) {
      var lf = _a.lf;
      var _this = this;
      this.menuTypeMap = /* @__PURE__ */ new Map();
      this.listenDelete = function() {
        _this.hideContextMenu();
      };
      this.lf = lf;
      this.__menuDOM = document.createElement("div");
      this.__menuDOM.className = "lf-inner-context";
      this.menuTypeMap.set(COMMON_TYPE_KEY, []);
      this.lf.setContextMenuByType = function(type3, menus) {
        _this.setContextMenuByType(type3, menus);
      };
      this.lf.setContextMenuItems = function(menus) {
        _this.setContextMenuItems(menus);
      };
      this.lf.showContextMenu = function(data) {
        _this.showContextMenu(data);
      };
      this.lf.hideContextMenu = function() {
        _this.hideContextMenu();
      };
    }
    ContextMenu2.prototype.render = function(lf, container) {
      var _this = this;
      this.container = container;
      lf.on("node:click", function(_a) {
        var data = _a.data;
        _this._activeData = data;
        _this.createContextMenu();
      });
      lf.on("edge:click", function(_a) {
        var data = _a.data;
        _this._activeData = data;
        _this.createContextMenu();
      });
      lf.on("blank:click", function() {
        _this.hideContextMenu();
      });
    };
    ContextMenu2.prototype.setContextMenuByType = function(type3, menus) {
      this.menuTypeMap.set(type3, menus);
    };
    ContextMenu2.prototype.hideContextMenu = function() {
      this.__menuDOM.innerHTML = "";
      this.__menuDOM.style.display = "none";
      if (this.isShow) {
        this.container.removeChild(this.__menuDOM);
      }
      this.lf.off("node:delete,edge:delete,node:drag,graph:transform", this.listenDelete);
      this.isShow = false;
    };
    ContextMenu2.prototype.showContextMenu = function(data) {
      if (!data || !data.id) {
        console.warn("请检查传入的参数");
        return;
      }
      this._activeData = data;
      this.createContextMenu();
    };
    ContextMenu2.prototype.setContextMenuItems = function(menus) {
      this.menuTypeMap.set(COMMON_TYPE_KEY, menus);
    };
    ContextMenu2.prototype.getContextMenuPosition = function() {
      var data = this._activeData;
      var Model = this.lf.graphModel.getElement(data.id);
      if (Model) {
        var x_1;
        var y_1;
        if (Model.BaseType === "edge") {
          x_1 = Number.MIN_SAFE_INTEGER;
          y_1 = Number.MAX_SAFE_INTEGER;
          var edgeData = Model.getData();
          x_1 = Math.max(edgeData.startPoint.x, x_1);
          y_1 = Math.min(edgeData.startPoint.y, y_1);
          x_1 = Math.max(edgeData.endPoint.x, x_1);
          y_1 = Math.min(edgeData.endPoint.y, y_1);
          if (edgeData.pointsList) {
            edgeData.pointsList.forEach(function(point) {
              x_1 = Math.max(point.x, x_1);
              y_1 = Math.min(point.y, y_1);
            });
          }
        }
        if (Model.BaseType === "node") {
          x_1 = data.x + Model.width / 2;
          y_1 = data.y - Model.height / 2;
        }
        return this.lf.graphModel.transformModel.CanvasPointToHtmlPoint([x_1, y_1]);
      }
    };
    ContextMenu2.prototype.createContextMenu = function() {
      var _this = this;
      var isSilentMode = this.lf.options.isSilentMode;
      if (isSilentMode) {
        return;
      }
      var items = __spreadArray19(__spreadArray19([], __read24(this.menuTypeMap.get(this._activeData.type) || []), false), __read24(this.menuTypeMap.get(COMMON_TYPE_KEY) || []), false);
      var menus = document.createDocumentFragment();
      items.forEach(function(item) {
        var menuItem = document.createElement("div");
        menuItem.className = "lf-context-item";
        var img = document.createElement("img");
        img.src = item.icon;
        img.className = "lf-context-img";
        if (item.className) {
          menuItem.className = "".concat(menuItem.className, " ").concat(item.className);
        }
        img.addEventListener("click", function() {
          _this.hideContextMenu();
          if (item.callback) {
            item.callback(_this._activeData);
          } else {
            _this.addNode({
              sourceId: _this._activeData.id,
              x: _this._activeData.x,
              y: _this._activeData.y,
              properties: item.properties,
              type: item.type
            });
          }
        });
        menuItem.appendChild(img);
        menus.appendChild(menuItem);
      });
      this.__menuDOM.innerHTML = "";
      this.__menuDOM.appendChild(menus);
      this.showMenu();
    };
    ContextMenu2.prototype.addNode = function(node2, y) {
      var isDeep = y !== void 0;
      if (y === void 0) {
        y = node2.y;
      }
      var nodeModel = this.lf.getNodeModelById(node2.sourceId);
      if (nodeModel) {
        var leftTopX = node2.x - nodeModel.width + NEXT_X_DISTANCE;
        var leftTopY = y - node2.y / 2 - 20;
        var rightBottomX = node2.x + nodeModel.width + NEXT_X_DISTANCE;
        var rightBottomY = y + node2.y / 2 + 20;
        var existElements = this.lf.getAreaElement([leftTopX, leftTopY], [rightBottomX, rightBottomY]);
        if (existElements.length) {
          y = y + NEXT_Y_DISTANCE;
          this.addNode(node2, y);
          return;
        }
        if (node2.type) {
          var newNode = this.lf.addNode({
            type: node2.type,
            x: node2.x + 200,
            y,
            properties: node2.properties
          });
          var startPoint = void 0;
          var endPoint = void 0;
          if (isDeep) {
            startPoint = {
              x: node2.x,
              y: node2.y + nodeModel.height / 2
            };
            endPoint = {
              x: newNode.x - newNode.width / 2,
              y: newNode.y
            };
          }
          this.lf.addEdge({
            sourceNodeId: node2.sourceId,
            targetNodeId: newNode.id,
            startPoint,
            endPoint
          });
        }
      }
    };
    ContextMenu2.prototype.showMenu = function() {
      var menuPosition = this.getContextMenuPosition();
      if (menuPosition) {
        var _a = __read24(menuPosition, 2), x2 = _a[0], y = _a[1];
        this.__menuDOM.style.display = "flex";
        this.__menuDOM.style.top = "".concat(y, "px");
        this.__menuDOM.style.left = "".concat(x2 + 10, "px");
        this.container.appendChild(this.__menuDOM);
        !this.isShow && this.lf.on("node:delete,edge:delete,node:drag,graph:transform", this.listenDelete);
        this.isShow = true;
      }
    };
    ContextMenu2.pluginName = "contextMenu";
    return ContextMenu2;
  }()
);

// node_modules/@logicflow/extension/es/components/dnd-panel/index.js
var DndPanel = (
  /** @class */
  function() {
    function DndPanel2(_a) {
      var lf = _a.lf;
      var _this = this;
      this.lf = lf;
      this.lf.setPatternItems = function(shapeList) {
        _this.setPatternItems(shapeList);
      };
    }
    DndPanel2.prototype.render = function(_lf, domContainer) {
      var _this = this;
      this.destroy();
      if (!this.shapeList || this.shapeList.length === 0) {
        this.domContainer = domContainer;
        return;
      }
      this.panelEl = document.createElement("div");
      this.panelEl.className = "lf-dndpanel";
      this.shapeList.forEach(function(shapeItem) {
        var _a;
        (_a = _this.panelEl) === null || _a === void 0 ? void 0 : _a.appendChild(_this.createDndItem(shapeItem));
      });
      domContainer.appendChild(this.panelEl);
      this.domContainer = domContainer;
    };
    DndPanel2.prototype.destroy = function() {
      if (this.domContainer && this.panelEl && this.domContainer.contains(this.panelEl)) {
        this.domContainer.removeChild(this.panelEl);
      }
    };
    DndPanel2.prototype.setPatternItems = function(shapeList) {
      this.shapeList = shapeList;
      if (this.domContainer) {
        this.render(this.lf, this.domContainer);
      }
    };
    DndPanel2.prototype.createDndItem = function(shapeItem) {
      var _this = this;
      var el = document.createElement("div");
      el.className = shapeItem.className ? "lf-dnd-item ".concat(shapeItem.className) : "lf-dnd-item";
      var shape = document.createElement("div");
      shape.className = "lf-dnd-shape";
      if (shapeItem.icon) {
        shape.style.backgroundImage = "url(".concat(shapeItem.icon, ")");
      }
      el.appendChild(shape);
      if (shapeItem.label) {
        var text = document.createElement("div");
        text.innerText = shapeItem.label;
        text.className = "lf-dnd-text";
        el.appendChild(text);
      }
      if (shapeItem.disabled) {
        el.classList.add("disabled");
        el.onmousedown = function() {
          if (shapeItem.callback) {
            shapeItem.callback(_this.lf, _this.domContainer);
          }
        };
        return el;
      }
      el.onmousedown = function() {
        if (shapeItem.type) {
          _this.lf.dnd.startDrag({
            type: shapeItem.type,
            properties: shapeItem.properties,
            text: shapeItem.text
          });
        }
        if (shapeItem.callback) {
          shapeItem.callback(_this.lf, _this.domContainer);
        }
      };
      el.ondblclick = function(e) {
        _this.lf.graphModel.eventCenter.emit("dnd:panel-dbclick", {
          e,
          data: shapeItem
        });
      };
      el.onclick = function(e) {
        _this.lf.graphModel.eventCenter.emit("dnd:panel-click", {
          e,
          data: shapeItem
        });
      };
      el.oncontextmenu = function(e) {
        _this.lf.graphModel.eventCenter.emit("dnd:panel-contextmenu", {
          e,
          data: shapeItem
        });
      };
      return el;
    };
    DndPanel2.pluginName = "dndPanel";
    return DndPanel2;
  }()
);

// node_modules/@logicflow/extension/es/components/mini-map/index.js
var __values3 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var MiniMap = (
  /** @class */
  function() {
    function MiniMap2(_a) {
      var lf = _a.lf, LogicFlow = _a.LogicFlow, options = _a.options;
      var _this = this;
      this.width = 200;
      this.height = 150;
      this.scale = 1;
      this.translateX = 0;
      this.translateY = 0;
      this.showEdge = false;
      this.viewPortTop = 0;
      this.viewPortLeft = 0;
      this.viewPortWidth = 150;
      this.viewPortHeight = 75;
      this.isShow = false;
      this.isShowHeader = false;
      this.isShowCloseIcon = false;
      this.headerTitle = "导航";
      this.disabledPlugins = ["miniMap", "control", "selectionSelect"];
      this.onGraphResize = function() {
        _this.updateViewPortBounds();
        if (_this.isShow) {
          _this.updateViewPort();
        }
      };
      this.render = function(_, container) {
        _this.container = container;
        _this.lf.on("history:change", function() {
          if (_this.isShow) {
            _this.setView();
          }
        });
        _this.lf.on("graph:transform", function() {
          if (_this.isShow) {
            _this.setView(false);
          }
        });
      };
      this.show = function(left, top) {
        if (!_this.isShow) {
          _this.createMiniMap(left, top);
          _this.setView();
        }
        _this.isShow = true;
      };
      this.hide = function() {
        if (_this.isShow) {
          _this.removeMiniMap();
          _this.lf.emit("miniMap:close", {});
        }
        _this.isShow = false;
      };
      this.updatePosition = function(position) {
        if (typeof position === "object") {
          if (position.left !== void 0 || position.right !== void 0) {
            _this.leftPosition = position.left;
            _this.rightPosition = position.right;
          }
          if (position.top !== void 0 || position.bottom !== void 0) {
            _this.topPosition = position.top;
            _this.bottomPosition = position.bottom;
          }
        } else {
          switch (position) {
            case "left-top":
              _this.leftPosition = 0;
              _this.rightPosition = void 0;
              _this.topPosition = 0;
              _this.bottomPosition = void 0;
              break;
            case "right-top":
              _this.leftPosition = void 0;
              _this.rightPosition = 0;
              _this.topPosition = 0;
              _this.bottomPosition = void 0;
              break;
            case "left-bottom":
              _this.leftPosition = 0;
              _this.rightPosition = void 0;
              _this.topPosition = void 0;
              _this.bottomPosition = 0;
              break;
            case "right-bottom":
              _this.leftPosition = void 0;
              _this.rightPosition = 0;
              _this.topPosition = void 0;
              _this.bottomPosition = 0;
              break;
          }
        }
        _this.updateMiniMapPosition();
      };
      this.reset = function() {
        _this.lf.resetTranslate();
        _this.lf.resetZoom();
      };
      this.setShowEdge = function(showEdge) {
        if (_this.showEdge !== showEdge) {
          _this.showEdge = showEdge;
          _this.setView();
        }
      };
      this.startDrag = function(e) {
        document.addEventListener("mousemove", _this.drag);
        document.addEventListener("mouseup", _this.drop);
        var x2 = e.x, y = e.y;
        _this.startPosition = { x: x2, y };
      };
      this.drag = function(e) {
        var x2 = e.x, y = e.y;
        var translateX = (x2 - _this.startPosition.x) / _this.scale;
        var translateY = (y - _this.startPosition.y) / _this.scale;
        var centerX = _this.viewPortLeft + translateX + _this.viewPortWidth / _this.scale / 2;
        var centerY = _this.viewPortTop + translateY + _this.viewPortHeight / _this.scale / 2;
        _this.startPosition = { x: x2, y };
        _this.lf.focusOn({
          coordinate: {
            x: centerX,
            y: centerY
          }
        });
      };
      this.drop = function() {
        document.removeEventListener("mousemove", _this.drag);
        document.removeEventListener("mouseup", _this.drop);
      };
      this.mapClick = function(e) {
        var offsetX = e.offsetX, offsetY = e.offsetY;
        var centerX = _this.translateX + offsetX / _this.scale;
        var centerY = _this.translateY + offsetY / _this.scale;
        _this.lf.focusOn({
          coordinate: {
            x: centerX,
            y: centerY
          }
        });
      };
      this.lf = lf;
      this.LFCtor = LogicFlow;
      if (options) {
        this.setOption(options);
      }
      this.viewPortWidth = lf.graphModel.width;
      this.viewPortHeight = lf.graphModel.height;
      var boundsInit = {
        left: 0,
        right: this.viewPortWidth,
        top: 0,
        bottom: this.viewPortHeight
      };
      this.bounds = boundsInit;
      this.elementAreaBounds = boundsInit;
      this.viewPortBounds = boundsInit;
      this.initMiniMap();
      lf.on("graph:resize", this.onGraphResize);
    }
    MiniMap2.prototype.setOption = function(options) {
      var _a = options.width, width = _a === void 0 ? 150 : _a, _b = options.height, height = _b === void 0 ? 220 : _b, _c = options.showEdge, showEdge = _c === void 0 ? false : _c, _d = options.isShowHeader, isShowHeader = _d === void 0 ? false : _d, _e = options.isShowCloseIcon, isShowCloseIcon = _e === void 0 ? false : _e, leftPosition = options.leftPosition, topPosition = options.topPosition, _f = options.rightPosition, rightPosition = _f === void 0 ? 0 : _f, _g = options.bottomPosition, bottomPosition = _g === void 0 ? 0 : _g, _h = options.headerTitle, headerTitle = _h === void 0 ? "导航" : _h;
      this.width = width;
      this.height = height;
      this.showEdge = showEdge;
      this.isShowHeader = isShowHeader;
      this.isShowCloseIcon = isShowCloseIcon;
      this.leftPosition = leftPosition;
      this.rightPosition = leftPosition !== void 0 ? void 0 : rightPosition;
      this.topPosition = topPosition;
      this.bottomPosition = topPosition !== void 0 ? void 0 : bottomPosition;
      this.headerTitle = headerTitle;
    };
    MiniMap2.prototype.initMiniMap = function() {
      var miniMapWrap = document.createElement("div");
      miniMapWrap.className = "lf-mini-map-graph";
      miniMapWrap.style.width = "".concat(this.width, "px");
      miniMapWrap.style.height = "".concat(this.height, "px");
      this.lfMap = new this.LFCtor({
        container: miniMapWrap,
        grid: false,
        isSilentMode: true,
        stopZoomGraph: true,
        stopScrollGraph: true,
        // 禁用画布移动会导致 transformModel.translate 无效，所以这里不禁用
        stopMoveGraph: false,
        history: false,
        snapline: false,
        disabledPlugins: this.disabledPlugins
      });
      this.miniMapWrap = miniMapWrap;
      this.createViewPort();
      miniMapWrap.addEventListener("click", this.mapClick);
    };
    MiniMap2.prototype.createMiniMap = function(left, top) {
      var _a;
      var miniMapContainer = document.createElement("div");
      this.miniMapContainer = miniMapContainer;
      miniMapContainer.appendChild(this.miniMapWrap);
      miniMapContainer.style.position = "absolute";
      if (left !== void 0 || top !== void 0) {
        this.leftPosition = left || 0;
        this.topPosition = top || 0;
        this.rightPosition = void 0;
        this.bottomPosition = void 0;
      }
      this.updateMiniMapPosition();
      miniMapContainer.className = "lf-mini-map";
      if (!this.isShowCloseIcon) {
        miniMapContainer.classList.add("lf-mini-map-no-close-icon");
      }
      if (!this.isShowHeader) {
        miniMapContainer.classList.add("lf-mini-map-no-header");
      }
      (_a = this.container) === null || _a === void 0 ? void 0 : _a.appendChild(miniMapContainer);
      this.miniMapWrap.appendChild(this.viewport);
      var header = document.createElement("div");
      header.className = "lf-mini-map-header";
      header.innerText = this.headerTitle;
      miniMapContainer.appendChild(header);
      var close = document.createElement("span");
      close.className = "lf-mini-map-close";
      close.addEventListener("click", this.hide);
      miniMapContainer.appendChild(close);
    };
    MiniMap2.prototype.updateMiniMapPosition = function() {
      if (this.miniMapContainer) {
        var style2 = this.miniMapContainer.style;
        if (this.rightPosition !== void 0) {
          style2.right = "".concat(this.rightPosition, "px");
          style2.left = "";
        } else {
          style2.left = "".concat(this.leftPosition, "px");
          style2.right = "";
        }
        if (this.bottomPosition !== void 0) {
          style2.bottom = "".concat(this.bottomPosition, "px");
          style2.top = "";
        } else {
          style2.top = "".concat(this.topPosition, "px");
          style2.bottom = "";
        }
      }
    };
    MiniMap2.prototype.removeMiniMap = function() {
      var _a;
      if (this.miniMapContainer) {
        (_a = this.container) === null || _a === void 0 ? void 0 : _a.removeChild(this.miniMapContainer);
      }
    };
    MiniMap2.prototype.updateBounds = function(data) {
      if (data) {
        this.updateElementAreaBounds(data);
      }
      this.updateViewPortBounds();
      this.bounds = {
        left: Math.min(this.elementAreaBounds.left, this.viewPortBounds.left),
        right: Math.max(this.elementAreaBounds.right, this.viewPortBounds.right),
        top: Math.min(this.elementAreaBounds.top, this.viewPortBounds.top),
        bottom: Math.max(this.elementAreaBounds.bottom, this.viewPortBounds.bottom)
      };
    };
    MiniMap2.prototype.updateElementAreaBounds = function(data) {
      var elementAreaBounds = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      var nodes = data.nodes;
      if (nodes && nodes.length > 0) {
        nodes.forEach(function(node2) {
          var _a, _b;
          var x2 = node2.x, y = node2.y;
          var width = (_a = node2.width) !== null && _a !== void 0 ? _a : 200;
          var height = (_b = node2.height) !== null && _b !== void 0 ? _b : 200;
          var nodeLeft = x2 - width / 2;
          var nodeRight = x2 + width / 2;
          var nodeTop = y - height / 2;
          var nodeBottom = y + height / 2;
          elementAreaBounds.left = Math.min(nodeLeft, elementAreaBounds.left);
          elementAreaBounds.right = Math.max(nodeRight, elementAreaBounds.right);
          elementAreaBounds.top = Math.min(nodeTop, elementAreaBounds.top);
          elementAreaBounds.bottom = Math.max(nodeBottom, elementAreaBounds.bottom);
        });
      }
      this.elementAreaBounds = elementAreaBounds;
    };
    MiniMap2.prototype.updateViewPortBounds = function() {
      var _a = this.lf.getTransform(), TRANSLATE_X = _a.TRANSLATE_X, TRANSLATE_Y = _a.TRANSLATE_Y, SCALE_X = _a.SCALE_X, SCALE_Y = _a.SCALE_Y;
      var _b = this.lf.graphModel, width = _b.width, height = _b.height;
      this.viewPortBounds = {
        left: -TRANSLATE_X / SCALE_X,
        right: (-TRANSLATE_X + width) / SCALE_X,
        top: -TRANSLATE_Y / SCALE_Y,
        bottom: (-TRANSLATE_Y + height) / SCALE_Y
      };
    };
    MiniMap2.prototype.resetData = function(data) {
      var nodes = data.nodes, edges = data.edges;
      nodes.forEach(function(node2) {
        node2.text = void 0;
      });
      if (this.showEdge) {
        edges.forEach(function(edge) {
          edge.text = void 0;
        });
      }
      return {
        nodes,
        // 是否渲染边
        edges: this.showEdge ? edges : []
      };
    };
    MiniMap2.prototype.setView = function(reRender) {
      var e_1, _a;
      if (reRender === void 0) {
        reRender = true;
      }
      if (reRender) {
        var graphData = this.lf.getGraphRawData();
        var data = this.resetData(graphData);
        var viewMap = this.lf.viewMap;
        var modelMap = this.lf.graphModel.modelMap;
        var minimapViewMap = this.lfMap.viewMap;
        try {
          for (var _b = __values3(viewMap.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            if (!minimapViewMap.has(key)) {
              this.lfMap.register({
                type: key,
                view: viewMap.get(key),
                model: modelMap.get(key)
              });
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        this.lfMap.render(data);
        this.updateBounds(data);
      } else {
        this.updateBounds();
      }
      var _d = this.bounds, left = _d.left, top = _d.top, right = _d.right, bottom = _d.bottom;
      var realWidth = right - left;
      var realHeight = bottom - top;
      var realWidthScale = this.width / realWidth;
      var realHeightScale = this.height / realHeight;
      var scale = Math.min(realWidthScale, realHeightScale);
      this.scale = scale;
      var translateX = left - (this.width / scale - realWidth) / 2;
      var translateY = top - (this.height / scale - realHeight) / 2;
      this.lfMap.graphModel.transformModel.translate(-translateX + this.translateX, -translateY + this.translateY);
      this.translateX = translateX;
      this.translateY = translateY;
      if (this.miniMapWrap.firstChild) {
        var innerStyle = this.miniMapWrap.firstChild.style;
        innerStyle.pointerEvents = "none";
        innerStyle.transform = "matrix(".concat(scale, ", 0, 0, ").concat(scale, ", 0, 0)");
        innerStyle.transformOrigin = "left top";
        innerStyle.height = "".concat(this.height / scale, "px");
        innerStyle.width = "".concat(this.width / scale, "px");
        this.updateViewPort();
      }
    };
    MiniMap2.prototype.updateViewPort = function() {
      var viewStyle = this.viewport.style;
      var _a = this.lf.getTransform(), TRANSLATE_X = _a.TRANSLATE_X, TRANSLATE_Y = _a.TRANSLATE_Y, SCALE_X = _a.SCALE_X, SCALE_Y = _a.SCALE_Y;
      var _b = this.lf.graphModel, width = _b.width, height = _b.height;
      this.viewPortLeft = -TRANSLATE_X / SCALE_X;
      this.viewPortTop = -TRANSLATE_Y / SCALE_Y;
      this.viewPortWidth = width / SCALE_X * this.scale;
      this.viewPortHeight = height / SCALE_Y * this.scale;
      viewStyle.width = "".concat(this.viewPortWidth, "px");
      viewStyle.height = "".concat(this.viewPortHeight, "px");
      viewStyle.left = "".concat((this.viewPortLeft - this.translateX) * this.scale, "px");
      viewStyle.top = "".concat((this.viewPortTop - this.translateY) * this.scale, "px");
    };
    MiniMap2.prototype.createViewPort = function() {
      var div = document.createElement("div");
      div.className = "lf-minimap-viewport";
      div.addEventListener("mousedown", this.startDrag);
      div.addEventListener("click", function(e) {
        e.stopPropagation();
      });
      this.viewport = div;
    };
    MiniMap2.prototype.destroy = function() {
      this.lf.off("graph:resize", this.onGraphResize);
    };
    MiniMap2.pluginName = "miniMap";
    return MiniMap2;
  }()
);

// node_modules/@logicflow/extension/es/components/selection-select/index.js
var SelectionSelect = (
  /** @class */
  function() {
    function SelectionSelect2(_a) {
      var lf = _a.lf;
      var _this = this;
      this.disabled = true;
      this.isDefaultStopMoveGraph = false;
      this.isWholeNode = true;
      this.isWholeEdge = true;
      this.draw = function(ev) {
        var _a2 = _this.lf.getPointByClient(ev.clientX, ev.clientY).domOverlayPosition, x1 = _a2.x, y1 = _a2.y;
        _this.endPoint = {
          x: x1,
          y: y1
        };
        if (_this.startPoint) {
          var _b = _this.startPoint, x2 = _b.x, y = _b.y;
          var left = x2;
          var top_1 = y;
          var width = x1 - x2;
          var height = y1 - y;
          if (x1 < x2) {
            left = x1;
            width = x2 - x1;
          }
          if (y1 < y) {
            top_1 = y1;
            height = y - y1;
          }
          if (_this.wrapper) {
            _this.wrapper.style.left = "".concat(left, "px");
            _this.wrapper.style.top = "".concat(top_1, "px");
            _this.wrapper.style.width = "".concat(width, "px");
            _this.wrapper.style.height = "".concat(height, "px");
          }
        }
      };
      this.drawOff = function() {
        var _a2;
        document.removeEventListener("mousemove", _this.draw);
        document.removeEventListener("mouseup", _this.drawOff);
        if (_this.wrapper) {
          _this.wrapper.oncontextmenu = null;
          (_a2 = _this.container) === null || _a2 === void 0 ? void 0 : _a2.removeChild(_this.wrapper);
        }
        if (_this.startPoint && _this.endPoint) {
          var _b = _this.startPoint, x2 = _b.x, y = _b.y;
          var _c = _this.endPoint, x1 = _c.x, y1 = _c.y;
          var lt = [Math.min(x2, x1), Math.min(y, y1)];
          var rb = [Math.max(x2, x1), Math.max(y, y1)];
          _this.lf.emit("selection:selected-area", {
            topLeft: lt,
            bottomRight: rb
          });
          if (Math.abs(x1 - x2) < 10 && Math.abs(y1 - y) < 10) {
            return;
          }
          var elements = _this.lf.graphModel.getAreaElement(lt, rb, _this.isWholeEdge, _this.isWholeNode, true);
          var _d = _this.lf.graphModel, dynamicGroup_1 = _d.dynamicGroup, group_1 = _d.group;
          var nonGroupedElements_1 = [];
          elements.forEach(function(element) {
            if (group_1 && group_1.getNodeGroup(element.id)) {
              return;
            }
            if (dynamicGroup_1 && dynamicGroup_1.getGroupByNodeId(element.id)) {
              return;
            }
            _this.lf.selectElementById(element.id, true);
            nonGroupedElements_1.push(element);
          });
          _this.lf.emit("selection:selected", {
            elements: nonGroupedElements_1,
            leftTopPoint: lt,
            rightBottomPoint: rb
          });
        }
      };
      this.lf = lf;
      var stopMoveGraph = lf.getEditConfig().stopMoveGraph;
      this.isDefaultStopMoveGraph = stopMoveGraph;
      lf.openSelectionSelect = function() {
        _this.openSelectionSelect();
      };
      lf.closeSelectionSelect = function() {
        _this.closeSelectionSelect();
      };
    }
    SelectionSelect2.prototype.render = function(lf, domContainer) {
      var _this = this;
      this.container = domContainer;
      lf.on("blank:mousedown", function(_a) {
        var e = _a.e;
        var config = lf.getEditConfig();
        if (!config.stopMoveGraph || _this.disabled) {
          return;
        }
        var isRightClick = e.button === 2;
        if (isRightClick) {
          return;
        }
        var _b = lf.getPointByClient(e.clientX, e.clientY).domOverlayPosition, x2 = _b.x, y = _b.y;
        _this.startPoint = {
          x: x2,
          y
        };
        _this.endPoint = {
          x: x2,
          y
        };
        var wrapper = document.createElement("div");
        wrapper.className = "lf-selection-select";
        wrapper.oncontextmenu = function prevent(ev) {
          ev.preventDefault();
        };
        wrapper.style.top = "".concat(_this.startPoint.y, "px");
        wrapper.style.left = "".concat(_this.startPoint.x, "px");
        domContainer.appendChild(wrapper);
        _this.wrapper = wrapper;
        document.addEventListener("mousemove", _this.draw);
        document.addEventListener("mouseup", _this.drawOff);
      });
    };
    SelectionSelect2.prototype.setSelectionSense = function(isWholeEdge, isWholeNode) {
      if (isWholeEdge === void 0) {
        isWholeEdge = true;
      }
      if (isWholeNode === void 0) {
        isWholeNode = true;
      }
      this.isWholeEdge = isWholeEdge;
      this.isWholeNode = isWholeNode;
    };
    SelectionSelect2.prototype.openSelectionSelect = function() {
      var stopMoveGraph = this.lf.getEditConfig().stopMoveGraph;
      if (!stopMoveGraph) {
        this.isDefaultStopMoveGraph = false;
        this.lf.updateEditConfig({
          stopMoveGraph: true
        });
      }
      this.open();
    };
    SelectionSelect2.prototype.closeSelectionSelect = function() {
      if (!this.isDefaultStopMoveGraph) {
        this.lf.updateEditConfig({
          stopMoveGraph: false
        });
      }
      this.close();
    };
    SelectionSelect2.prototype.open = function() {
      this.disabled = false;
    };
    SelectionSelect2.prototype.close = function() {
      this.disabled = true;
    };
    SelectionSelect2.pluginName = "selectionSelect";
    return SelectionSelect2;
  }()
);

// node_modules/@logicflow/extension/es/components/highlight/index.js
var __assign29 = function() {
  __assign29 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign29.apply(this, arguments);
};
var __read25 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray20 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var getPath = function(id, lf) {
  var el = lf.getModelById(id);
  return getNodePath((el === null || el === void 0 ? void 0 : el.BaseType) === "node" ? el : el === null || el === void 0 ? void 0 : el.targetNode, lf);
};
var getNodePath = function(node2, lf) {
  var incomingPaths = [];
  var outgoingPaths = [];
  var getIncomingPaths = function(curNode, path, prevNode) {
    if (!curNode)
      return;
    if (prevNode) {
      path.unshift.apply(path, __spreadArray20([], __read25(lf.getEdgeModels({
        sourceNodeId: curNode.id,
        targetNodeId: prevNode === null || prevNode === void 0 ? void 0 : prevNode.id
      }).map(function(item) {
        return item.id;
      })), false));
    }
    if (path.includes(curNode.id)) {
      incomingPaths.push(path);
      return;
    }
    path.unshift(curNode.id);
    if (!curNode.incoming.nodes.length) {
      incomingPaths.push(path);
      return;
    }
    curNode.incoming.nodes.forEach(function(nextNode) {
      getIncomingPaths(nextNode, path.slice(), curNode);
    });
  };
  var getOutgoingPaths = function(curNode, path, prevNode) {
    if (!curNode)
      return;
    if (prevNode) {
      path.push.apply(path, __spreadArray20([], __read25(lf.getEdgeModels({
        sourceNodeId: prevNode === null || prevNode === void 0 ? void 0 : prevNode.id,
        targetNodeId: curNode.id
      }).map(function(item) {
        return item.id;
      })), false));
    }
    if (path.includes(curNode.id)) {
      outgoingPaths.push(path);
      return;
    }
    path.push(curNode.id);
    if (!curNode.outgoing.nodes.length) {
      outgoingPaths.push(path);
      return;
    }
    curNode.outgoing.nodes.forEach(function(nextNode) {
      getOutgoingPaths(nextNode, path.slice(), curNode);
    });
  };
  getIncomingPaths(node2, []);
  getOutgoingPaths(node2, []);
  return __spreadArray20([], __read25(new Set(__spreadArray20(__spreadArray20([], __read25(incomingPaths.flat()), false), __read25(outgoingPaths.flat()), false))), false);
};
var Highlight = (
  /** @class */
  function() {
    function Highlight2(_a) {
      var lf = _a.lf, options = _a.options;
      this.mode = "path";
      this.enable = true;
      this.tempStyles = {};
      var _b = options.mode, mode = _b === void 0 ? "path" : _b, _c = options.enable, enable = _c === void 0 ? true : _c;
      this.lf = lf;
      this.mode = mode;
      this.enable = enable;
    }
    Highlight2.prototype.setMode = function(mode) {
      this.mode = mode;
    };
    Highlight2.prototype.setEnable = function(enable) {
      this.enable = enable;
    };
    Highlight2.prototype.highlightSingle = function(id) {
      var model = this.lf.getModelById(id);
      if ((model === null || model === void 0 ? void 0 : model.BaseType) === "node") {
        model.updateStyles(this.tempStyles[id]);
      } else if ((model === null || model === void 0 ? void 0 : model.BaseType) === "edge") {
        model.updateStyles(this.tempStyles[id]);
        model.sourceNode.updateStyles(this.tempStyles[model.sourceNode.id]);
        model.targetNode.updateStyles(this.tempStyles[model.targetNode.id]);
      }
    };
    Highlight2.prototype.highlightNeighbours = function(id) {
      var _this = this;
      var model = this.lf.getModelById(id);
      if ((model === null || model === void 0 ? void 0 : model.BaseType) === "node") {
        model.updateStyles(this.tempStyles[id]);
        var _a = model.incoming, incomingNodes = _a.nodes, incomingEdges = _a.edges;
        var _b = model.outgoing, outgoingNodes = _b.nodes, outgoingEdges = _b.edges;
        concat_default(incomingNodes, outgoingNodes).forEach(function(node2) {
          node2.updateStyles(_this.tempStyles[node2.id]);
        });
        concat_default(incomingEdges, outgoingEdges).forEach(function(edge) {
          edge.updateStyles(_this.tempStyles[edge.id]);
        });
      } else if ((model === null || model === void 0 ? void 0 : model.BaseType) === "edge") {
        model.updateStyles(this.tempStyles[id]);
        model.sourceNode.updateStyles(this.tempStyles[model.sourceNode.id]);
        model.targetNode.updateStyles(this.tempStyles[model.targetNode.id]);
      }
    };
    Highlight2.prototype.highlightPath = function(id) {
      var _this = this;
      var path = getPath(id, this.lf);
      path.forEach(function(_id) {
        var _a;
        (_a = _this.lf.getModelById(_id)) === null || _a === void 0 ? void 0 : _a.updateStyles(_this.tempStyles[_id]);
      });
    };
    Highlight2.prototype.highlight = function(id, mode) {
      var _this = this;
      if (mode === void 0) {
        mode = this.mode;
      }
      if (!this.enable)
        return;
      if (Object.keys(this.tempStyles).length) {
        this.restoreHighlight();
      }
      Object.values(this.lf.graphModel.modelsMap).forEach(function(item) {
        var oStyle = item.BaseType === "node" ? item.getNodeStyle() : item.getEdgeStyle();
        _this.tempStyles[item.id] = __assign29({}, oStyle);
        item.setStyles({ opacity: 0.1 });
      });
      var modeTrigger = {
        single: this.highlightSingle.bind(this),
        neighbour: this.highlightNeighbours.bind(this),
        path: this.highlightPath.bind(this)
      };
      modeTrigger[mode](id);
    };
    Highlight2.prototype.restoreHighlight = function() {
      var _this = this;
      if (!Object.keys(this.tempStyles).length)
        return;
      Object.values(this.lf.graphModel.modelsMap).forEach(function(item) {
        var _a;
        var oStyle = (_a = _this.tempStyles[item.id]) !== null && _a !== void 0 ? _a : {};
        item.updateStyles(__assign29({}, oStyle));
      });
      this.tempStyles = {};
    };
    Highlight2.prototype.render = function() {
      console.log("cccccccc");
      var _this = this;
      this.lf.on("node:click", function(_a) {
        var data = _a.data;
        return _this.highlight(data.id);
      });
      this.lf.on("edge:click", function(_a) {
        var data = _a.data;
        return _this.highlight(data.id);
      });
      this.lf.on("blank:click", this.restoreHighlight.bind(this));
      this.lf.on("history:change", this.restoreHighlight.bind(this));
    };
    Highlight2.prototype.destroy = function() {
    };
    Highlight2.pluginName = "highlight";
    return Highlight2;
  }()
);

// node_modules/@logicflow/extension/es/materials/curved-edge/index.js
var __extends29 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign30 = function() {
  __assign30 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign30.apply(this, arguments);
};
var __read26 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var directionMap = {
  tr: "tl",
  lb: "tl",
  tl: "tr",
  rb: "tr",
  br: "bl",
  lt: "bl",
  bl: "br",
  rt: "br"
};
function pointFilter(points) {
  var all = points;
  var i = 1;
  while (i < all.length - 1) {
    var _a = __read26(all[i - 1], 2), x2 = _a[0], y = _a[1];
    var _b = __read26(all[i], 2), x1 = _b[0], y1 = _b[1];
    var _c = __read26(all[i + 1], 2), x22 = _c[0], y2 = _c[1];
    if (x2 === x1 && x1 === x22 || y === y1 && y1 === y2) {
      all.splice(i, 1);
    } else {
      i++;
    }
  }
  return all;
}
function getMidPoints(cur, key, orientation, radius) {
  var mid1 = [cur[0], cur[1]];
  var mid2 = [cur[0], cur[1]];
  switch (orientation) {
    case "tl": {
      if (key === "tr") {
        mid1[1] += radius;
        mid2[0] += radius;
      } else if (key === "lb") {
        mid1[0] += radius;
        mid2[1] += radius;
      }
      return [mid1, mid2];
    }
    case "tr": {
      if (key === "tl") {
        mid1[1] += radius;
        mid2[0] -= radius;
      } else if (key === "rb") {
        mid1[0] -= radius;
        mid2[1] += radius;
      }
      return [mid1, mid2];
    }
    case "bl": {
      if (key === "br") {
        mid1[1] -= radius;
        mid2[0] += radius;
      } else if (key === "lt") {
        mid1[0] += radius;
        mid2[1] -= radius;
      }
      return [mid1, mid2];
    }
    case "br": {
      if (key === "bl") {
        mid1[1] -= radius;
        mid2[0] -= radius;
      } else if (key === "rt") {
        mid1[0] -= radius;
        mid2[1] -= radius;
      }
      return [mid1, mid2];
    }
    default:
      return [];
  }
}
function getPartialPath(prev, cur, next, radius) {
  var _a;
  var dir1 = "";
  var dir2 = "";
  if (prev[0] === cur[0]) {
    dir1 = prev[1] > cur[1] ? "t" : "b";
  } else if (prev[1] === cur[1]) {
    dir1 = prev[0] > cur[0] ? "l" : "r";
  }
  if (cur[0] === next[0]) {
    dir2 = cur[1] > next[1] ? "t" : "b";
  } else if (cur[1] === next[1]) {
    dir2 = cur[0] > next[0] ? "l" : "r";
  }
  var r = Math.min(Math.hypot(cur[0] - prev[0], cur[1] - prev[1]) / 2, Math.hypot(next[0] - cur[0], next[1] - cur[1]) / 2, radius) || 1 / 5 * radius;
  var key = "".concat(dir1).concat(dir2);
  var orientation = directionMap[key] || "-";
  var path = "L ".concat(prev[0], " ").concat(prev[1]);
  if (orientation === "-") {
    path += "L ".concat(cur[0], " ").concat(cur[1], " L ").concat(next[0], " ").concat(next[1]);
  } else {
    var _b = __read26(getMidPoints(cur, key, orientation, r), 2), mid1 = _b[0], mid2 = _b[1];
    if (mid1 && mid2) {
      path += "L ".concat(mid1[0], " ").concat(mid1[1], " Q ").concat(cur[0], " ").concat(cur[1], " ").concat(mid2[0], " ").concat(mid2[1]);
      _a = __read26(mid2, 2), cur[0] = _a[0], cur[1] = _a[1];
    }
  }
  return path;
}
function getCurvedEdgePath(points, radius) {
  var i = 0;
  var d = "";
  if (points.length === 2) {
    d += "M".concat(points[i][0], " ").concat(points[i++][1], " L ").concat(points[i][0], " ").concat(points[i][1]);
  } else {
    d += "M".concat(points[i][0], " ").concat(points[i++][1]);
    for (; i + 1 < points.length; ) {
      var prev = points[i - 1];
      var cur = points[i];
      var next = points[i++ + 1];
      d += getPartialPath(prev, cur, next, radius);
    }
    d += "L ".concat(points[i][0], " ").concat(points[i][1]);
  }
  return d;
}
var CurvedEdge = (
  /** @class */
  function(_super) {
    __extends29(CurvedEdge2, _super);
    function CurvedEdge2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CurvedEdge2.prototype.getEdge = function() {
      var model = this.props.model;
      var pointsStr = model.points, isAnimation = model.isAnimation, arrowConfig = model.arrowConfig, _a = model.radius, radius = _a === void 0 ? 5 : _a;
      var style2 = model.getEdgeStyle();
      var animationStyle = model.getEdgeAnimationStyle();
      var points = pointFilter(pointsStr.split(" ").map(function(p) {
        return p.split(",").map(function(a) {
          return +a;
        });
      }));
      var d = getCurvedEdgePath(points, radius);
      var attrs = __assign30(__assign30(__assign30({ style: isAnimation ? animationStyle : {} }, style2), arrowConfig), { fill: "none" });
      return g("path", __assign30({ d }, attrs));
    };
    return CurvedEdge2;
  }(PolylineEdge)
);
var CurvedEdgeModel = (
  /** @class */
  function(_super) {
    __extends29(CurvedEdgeModel2, _super);
    function CurvedEdgeModel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return CurvedEdgeModel2;
  }(PolylineEdgeModel)
);

// node_modules/@logicflow/extension/es/materials/node-selection/index.js
var __extends30 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign31 = function() {
  __assign31 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign31.apply(this, arguments);
};
var __read27 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray21 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NodeSelectionView = (
  /** @class */
  function(_super) {
    __extends30(NodeSelectionView2, _super);
    function NodeSelectionView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NodeSelectionView2.prototype.getLabelShape = function() {
      var _a = this.props.model, id = _a.id, x2 = _a.x, y = _a.y, width = _a.width, height = _a.height, properties = _a.properties;
      var style2 = this.props.model.getNodeStyle();
      return g("svg", {
        x: x2 - width / 2,
        y: y - height / 2,
        width: 50,
        height: 24,
        style: "z-index: 0; background: none; overflow: auto;"
      }, [
        properties.labelText ? g("text", {
          x: 0,
          y: -5,
          fontSize: "16px",
          fill: style2.stroke
        }, properties.labelText) : "",
        properties.disabledDelete ? "" : g("text", {
          x: properties.labelText ? 50 : 0,
          y: -5,
          fontSize: "24px",
          cursor: "pointer",
          fill: style2.stroke,
          onclick: this.handleCustomDeleteIconClick.bind(this, id)
        }, "x")
      ]);
    };
    NodeSelectionView2.prototype.getShape = function() {
      var _a = this.props.model, x2 = _a.x, y = _a.y, width = _a.width, height = _a.height, id = _a.id;
      var style2 = this.props.model.getNodeStyle();
      return g("g", {}, [
        g("rect", __assign31(__assign31({}, style2), { x: x2 - width / 2, y: y - height / 2, width, height, id })),
        this.getLabelShape()
      ]);
    };
    NodeSelectionView2.prototype.toFront = function() {
    };
    NodeSelectionView2.prototype.handleCustomDeleteIconClick = function(id) {
      var graphModel = this.props.graphModel;
      graphModel.deleteNode(id);
    };
    return NodeSelectionView2;
  }(PolygonNode)
);
var NodeSelectionModel = (
  /** @class */
  function(_super) {
    __extends30(NodeSelectionModel2, _super);
    function NodeSelectionModel2() {
      var _this = _super.apply(this, __spreadArray21([], __read27(arguments), false)) || this;
      _this.d = 10;
      _this.isResize = false;
      return _this;
    }
    NodeSelectionModel2.prototype.initNodeData = function(data) {
      data.text = {
        value: "",
        x: data.x,
        y: data.y,
        draggable: false,
        editable: false
      };
      _super.prototype.initNodeData.call(this, data);
      this.zIndex = 0;
      this.draggable = true;
    };
    NodeSelectionModel2.prototype.setAttributes = function() {
      var _this = this;
      var _a;
      this.points = [];
      if (((_a = this.properties) === null || _a === void 0 ? void 0 : _a.node_selection_ids).length > 1) {
        setTimeout(function() {
          var _a2;
          _this.updatePointsByNodes(((_a2 = _this.properties) === null || _a2 === void 0 ? void 0 : _a2.node_selection_ids) || []);
        });
      }
    };
    NodeSelectionModel2.prototype.getNodeStyle = function() {
      var style2 = _super.prototype.getNodeStyle.call(this);
      style2.stroke = this.properties.strokeColor || "#008000";
      style2.strokeDasharray = "10 5";
      return style2;
    };
    NodeSelectionModel2.prototype.getDefaultAnchor = function() {
      return [];
    };
    NodeSelectionModel2.prototype.updatePoints = function(points) {
      this.points = points;
    };
    NodeSelectionModel2.prototype.updateCoordinate = function(_a) {
      var x2 = _a.x, y = _a.y;
      this.x = x2;
      this.y = y;
    };
    NodeSelectionModel2.prototype.updatePointsByNodes = function(nodesIds) {
      var _this = this;
      var points = [];
      var minX = Infinity;
      var minY = Infinity;
      var maxX = -Infinity;
      var maxY = -Infinity;
      nodesIds.forEach(function(id) {
        var model = _this.graphModel.getNodeModelById(id);
        if (!model)
          return;
        var width = model.width, height = model.height, x2 = model.x, y = model.y;
        minX = Math.min(minX, x2 - width / 2 - _this.d);
        minY = Math.min(minY, y - height / 2 - _this.d);
        maxX = Math.max(maxX, x2 + width / 2 + _this.d);
        maxY = Math.max(maxY, y + height / 2 + _this.d);
      });
      points.push([minX, minY], [maxX, minY], [maxX, maxY], [minX, maxY]);
      if ([minX, minY, maxX, maxY].some(function(n) {
        return Math.abs(n) === Infinity;
      }))
        return;
      this.updatePoints(points);
      this.updateCoordinate({
        x: (maxX + minX) / 2,
        y: (maxY + minY) / 2
      });
    };
    NodeSelectionModel2.prototype.resize = function(resizeInfo) {
      var _a;
      this.isResize = true;
      var width = resizeInfo.width, height = resizeInfo.height;
      var scale = {
        x: width / this.width,
        y: height / this.height
      };
      var childIds = (this.properties.node_selection_ids || []).slice();
      var childModels = [];
      var usedGroupId = /* @__PURE__ */ new Set();
      while (childIds.length) {
        var id = childIds.shift();
        var node2 = (_a = this.graphModel.nodesMap[id]) === null || _a === void 0 ? void 0 : _a.model;
        if (!node2) {
          continue;
        }
        if (!isNodeSelectionModel(node2)) {
          childModels.push(node2);
          continue;
        }
        if (usedGroupId.has(node2.id)) {
          continue;
        }
        usedGroupId.add(node2.id);
        childIds.push.apply(childIds, __spreadArray21([], __read27(node2.properties.node_selection_ids || []), false));
      }
      var begin = {
        x: this.x - this.width / 2,
        y: this.y - this.height / 2
      };
      var res = _super.prototype.resize.call(this, resizeInfo);
      var end = {
        x: this.x - this.width / 2,
        y: this.y - this.height / 2
      };
      childModels.forEach(function(node3) {
        node3.width = node3.width * scale.x;
        node3.height = node3.height * scale.y;
        var deltaX = (node3.x - begin.x) * scale.x + end.x - node3.x;
        var deltaY = (node3.y - begin.y) * scale.y + end.y - node3.y;
        node3.move(deltaX, deltaY, true);
      });
      this.isResize = false;
      return res;
    };
    return NodeSelectionModel2;
  }(PolygonNodeModel)
);
var NODE_SELECTION_TYPE = "node-selection";
var NodeSelection = (
  /** @class */
  function() {
    function NodeSelection2(_a) {
      var lf = _a.lf;
      this.selectNodes = [];
      this.d = 10;
      this.lf = lf;
      lf.register({
        type: NODE_SELECTION_TYPE,
        view: NodeSelectionView,
        model: NodeSelectionModel
      });
    }
    Object.defineProperty(NodeSelection2.prototype, "selectNodesIds", {
      /**
       * 获取所选node的id数组
       */
      get: function() {
        return this.selectNodes.map(function(node2) {
          return node2.id;
        });
      },
      enumerable: false,
      configurable: true
    });
    NodeSelection2.prototype.addNodeSelection = function() {
      var node2 = this.lf.addNode({
        type: "node-selection",
        text: "",
        properties: {
          node_selection_ids: this.selectNodesIds
        },
        x: 0,
        y: 0
      });
      node2.updatePointsByNodes(this.selectNodesIds);
    };
    NodeSelection2.prototype.updateNodeSelection = function() {
      var _a;
      var nodeSelection = this.getNodeSelection();
      if (!nodeSelection)
        return;
      this.lf.setProperties(nodeSelection.id, {
        node_selection_ids: this.selectNodesIds
      });
      (_a = this.lf.getNodeModelById(nodeSelection.id)) === null || _a === void 0 ? void 0 : _a.updatePointsByNodes(this.selectNodesIds);
    };
    NodeSelection2.prototype.getNodeSelection = function() {
      var _this = this;
      var ids4 = this.selectNodesIds;
      var rawData = this.lf.getGraphRawData();
      var oldIds = ids4.filter(function(id) {
        return id !== _this.currentClickNode.id;
      });
      return rawData.nodes.find(function(node2) {
        if (node2.type === "node-selection") {
          var nodeSelectionIds_1 = get_default(node2, "properties.node_selection_ids", []);
          return oldIds.every(function(id) {
            return nodeSelectionIds_1.includes(id);
          });
        }
        return false;
      });
    };
    NodeSelection2.prototype.onNodeChange = function(lf, model) {
      var connectedSelections = lf.graphModel.nodes.filter(function(node2) {
        if (!isNodeSelectionModel(node2)) {
          return false;
        }
        var childIds = node2.properties.node_selection_ids || [];
        return childIds.includes(model.id);
      });
      Promise.resolve().then(function() {
        connectedSelections.forEach(function(node2) {
          node2.updatePointsByNodes(node2.properties.node_selection_ids || []);
        });
      });
    };
    NodeSelection2.prototype.render = function(lf) {
      var _this = this;
      this.lf = lf;
      lf.on("node:click", function(val) {
        var _a;
        if (!val.e.shiftKey || val.data.type === NODE_SELECTION_TYPE)
          return;
        _this.currentClickNode = val.data;
        var hasExists = false;
        if (_this.selectNodesIds.includes(val.data.id)) {
          (_a = _this.lf.getNodeModelById(val.data.id)) === null || _a === void 0 ? void 0 : _a.setSelected(false);
          hasExists = true;
        }
        var nodes = lf.getSelectElements(true).nodes;
        _this.selectNodes = nodes;
        if (_this.selectNodes.length === 1) {
          if (!hasExists) {
            _this.addNodeSelection();
          } else {
            _this.updateNodeSelection();
          }
        } else if (_this.selectNodes.length > 1) {
          _this.updateNodeSelection();
        }
      });
      lf.graphModel.addNodeMoveRules(function(model, deltaX, deltaY) {
        _this.onNodeChange(lf, model);
        if (isNodeSelectionModel(model) && !model.isResize) {
          var nodeIds = model.properties.node_selection_ids || [];
          lf.graphModel.moveNodes(nodeIds, deltaX, deltaY, true);
          return true;
        }
        return true;
      });
      lf.graphModel.addNodeResizeRules(function(model) {
        if (!isNodeSelectionModel(model)) {
          _this.onNodeChange(lf, model);
        }
        return true;
      });
    };
    NodeSelection2.pluginName = "node-selection";
    return NodeSelection2;
  }()
);
var isNodeSelectionModel = function(node2) {
  return !!(node2 && node2.type === NODE_SELECTION_TYPE);
};

// node_modules/@logicflow/extension/es/rect-label-node/RectLabelNodeView.js
var __extends31 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign32 = function() {
  __assign32 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign32.apply(this, arguments);
};
var RectLabelNodeView = (
  /** @class */
  function(_super) {
    __extends31(RectLabelNodeView2, _super);
    function RectLabelNodeView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    RectLabelNodeView2.prototype.getLabelShape = function() {
      var _a = this.props.model, x2 = _a.x, y = _a.y, width = _a.width, height = _a.height, properties = _a.properties;
      return g("text", {
        x: x2 - width / 2 + 5,
        y: y - height / 2 + 16,
        fontSize: 12,
        fill: "blue"
      }, properties.moreText);
    };
    RectLabelNodeView2.prototype.getShape = function() {
      var _a = this.props.model, x2 = _a.x, y = _a.y, width = _a.width, height = _a.height;
      var style2 = this.props.model.getNodeStyle();
      return g("g", {}, [
        g("rect", __assign32(__assign32({}, style2), { fill: "#FFFFFF", x: x2 - width / 2, y: y - height / 2 })),
        this.getLabelShape()
      ]);
    };
    return RectLabelNodeView2;
  }(RectNode)
);

// node_modules/@logicflow/extension/es/rect-label-node/index.js
var RectLabelNode = {
  pluginName: "rectLabelNode",
  install: function(lf) {
    lf.register({
      type: "rect-label",
      model: RectNodeModel,
      view: RectLabelNodeView
    });
  }
};
export {
  AutoLayout,
  BPMNAdapter,
  BPMNBaseAdapter,
  BPMNElements,
  BoundaryEventFactory,
  BpmnAdapter,
  BpmnElement,
  BpmnXmlAdapter,
  ContextMenu,
  Control2 as Control,
  CurvedEdge,
  CurvedEdgeModel,
  DiamondResize,
  DiamondResizeModel,
  DiamondResizeView,
  DndPanel,
  DynamicGroup,
  DynamicGroupNode,
  DynamicGroupNodeModel,
  EllipseResize,
  EllipseResizeModel,
  EllipseResizeView,
  EndEventFactory,
  EndEventModel,
  EndEventView,
  ExclusiveGatewayModel,
  ExclusiveGatewayView,
  FlowPath,
  GatewayNodeFactory,
  Group,
  GroupNode,
  GroupNodeModel,
  Highlight,
  HtmlResize,
  HtmlResizeModel,
  HtmlResizeView,
  InsertNodeInPolyline,
  IntermediateCatchEventFactory,
  IntermediateThrowEventFactory,
  Label2 as Label,
  Menu,
  MiniMap,
  NodeResize,
  NodeSelection,
  ProximityConnect,
  RectLabelNode,
  RectResize,
  RectResizeModel,
  RectResizeView,
  SelectionSelect,
  SequenceFlowModel,
  SequenceFlowView,
  ServiceTaskModel,
  ServiceTaskView,
  Snapshot,
  StartEventFactory,
  StartEventModel,
  StartEventView,
  SubProcessFactory,
  TaskNodeFactory,
  UserTaskModel,
  UserTaskView,
  utils_exports as bpmnUtils,
  convertNormalToXml,
  convertXmlToNormal,
  dynamicGroup,
  gateway,
  gatewayComposable,
  getCurvedEdgePath,
  handleAttributes,
  icons_exports as icons,
  lfJson2Xml,
  lfXml2Json,
  multiInstanceIcon,
  sequenceFlowFactory,
  toLogicflowData,
  toNormalJson,
  toTurboData,
  toXmlJson,
  useDefinition
};
/*! Bundled license information:

medium-editor/dist/js/medium-editor.js:
  (*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js *)
  (*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js *)

vanilla-picker/dist/vanilla-picker.mjs:
  (*!
   * vanilla-picker v2.12.3
   * https://vanilla-picker.js.org
   *
   * Copyright 2017-2024 Andreas Borgen (https://github.com/Sphinxxxx), Adam Brooks (https://github.com/dissimulate)
   * Released under the ISC license.
   *)
*/
//# sourceMappingURL=@logicflow_extension.js.map
