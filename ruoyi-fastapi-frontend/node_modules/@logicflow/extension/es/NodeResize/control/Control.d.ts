import { h, Component, GraphModel, BaseNodeModel, BaseEdgeModel, LogicFlowUtil } from '@logicflow/core';
type VectorData = Record<'deltaX' | 'deltaY', number>;
interface IControlProps {
    index: number;
    x: number;
    y: number;
    model: BaseNodeModel;
    graphModel: GraphModel;
    style?: CSSStyleDeclaration;
}
interface IControlState {
    startX: number;
    startY: number;
    endX: number;
    endY: number;
    dragging: boolean;
}
declare class Control extends Component<IControlProps, IControlState> {
    index: number;
    nodeModel: BaseNodeModel;
    graphModel: GraphModel;
    dragHandler: LogicFlowUtil.StepDrag;
    constructor(props: IControlProps);
    getNodeEdges(nodeId: string): {
        sourceEdges: BaseEdgeModel<import("@logicflow/core").LogicFlow.PropertiesType>[];
        targetEdges: BaseEdgeModel<import("@logicflow/core").LogicFlow.PropertiesType>[];
    };
    updatePosition: ({ deltaX, deltaY }: VectorData) => void;
    getResize: ({ index, deltaX, deltaY, width, height, PCTResizeInfo, pct, freezeWidth, freezeHeight, }: any) => {
        width: any;
        height: any;
        deltaX: any;
        deltaY: any;
    };
    updateEdgePointByAnchors: () => void;
    updateRect: ({ deltaX, deltaY }: VectorData) => void;
    updateEllipse: ({ deltaX, deltaY }: VectorData) => void;
    updateDiamond: ({ deltaX, deltaY }: VectorData) => void;
    eventEmit: ({ deltaX, deltaY, beforeNode, afterNode }: any) => void;
    onDragging: ({ deltaX, deltaY }: VectorData) => void;
    /**
     * 由于将拖拽放大缩小改成丝滑模式，这个时候需要在拖拽结束的时候，将节点的位置更新到grid上.
     */
    onDragEnd: () => void;
    render(): h.JSX.Element;
}
export default Control;
