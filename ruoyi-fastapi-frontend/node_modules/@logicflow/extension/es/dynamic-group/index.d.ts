import LogicFlow, { BaseEdgeModel, BaseNodeModel, CallbackArgs, Model } from '@logicflow/core';
import { DynamicGroupNode } from './node';
import { DynamicGroupNodeModel } from './model';
import EdgeConfig = LogicFlow.EdgeConfig;
import EdgeData = LogicFlow.EdgeData;
import NodeData = LogicFlow.NodeData;
import BoxBoundsPoint = Model.BoxBoundsPoint;
import ElementsInfoInGroup = DynamicGroup.ElementsInfoInGroup;
export * from './node';
export * from './model';
export declare const dynamicGroup: {
    type: string;
    view: typeof DynamicGroupNode;
    model: typeof DynamicGroupNodeModel;
};
export declare class DynamicGroup {
    static pluginName: string;
    private lf;
    topGroupZIndex: number;
    activeGroup?: DynamicGroupNodeModel;
    nodeGroupMap: Map<string, string>;
    constructor({ lf, options }: LogicFlow.IExtensionProps);
    /**
     * 获取节点所属的分组
     * @param nodeId
     */
    getGroupByNodeId(nodeId: string): BaseNodeModel<LogicFlow.PropertiesType> | undefined;
    /**
     * 获取自定位置及其所属分组
     * 当分组重合时，优先返回最上层的分组
     * @param bounds
     * @param nodeData
     */
    getGroupByBounds(bounds: BoxBoundsPoint, nodeData: NodeData): DynamicGroupNodeModel | undefined;
    /**
     * 提高元素的层级，如果是 group，同时提高其子元素的层级
     * @param model
     */
    sendNodeToFront(model?: BaseNodeModel): void;
    /**
     * 递归计算某个分组内最高的 zIndex 值
     * TODO: 这块儿有点疑问❓如果 node 不是 group，这块儿返回的 maxZIndex 是最小值，但 node 的 zIndex 不一定是这个值
     * @param node
     */
    getMaxZIndex(node: BaseNodeModel): number;
    /**
     * 校准当前 topGroupZIndex 的值
     * @param nodes
     */
    calibrateTopGroupZIndex(nodes: NodeData[]): void;
    addNodeToGroup: ({ data: node }: CallbackArgs<'node:add'>) => void;
    removeNodeFromGroup: ({ data: node, model, }: CallbackArgs<'node:delete'>) => void;
    setActiveGroup: ({ data: node }: CallbackArgs<'node:drag'>) => void;
    /**
     * 1. 分组节点默认在普通节点下面
     * 2. 分组节点被选中后，会将分组节点以及其内部的其它分组节点放到其余分组节点的上面
     * 3. 分组节点取消选中后，不会将分组节点重置为原来的高度
     * 4. 由于 LogicFlow 核心目标是支持用户手动绘制流程图，所以暂时不支持一张流程图超过 1000 个分组节点的情况
     * @param node
     * @param isMultiple
     * @param isSelected
     */
    onNodeSelect: ({ data: node, isMultiple, isSelected, }: Omit<CallbackArgs<'node:click'>, 'e' | 'position'>) => void;
    onNodeMove: ({ deltaX, deltaY, data, }: Omit<CallbackArgs<'node:mousemove'>, 'e' | 'position'>) => void;
    onGraphRendered: ({ data }: CallbackArgs<'graph:rendered'>) => void;
    removeChildrenInGroupNodeData<T extends LogicFlow.NodeData | LogicFlow.NodeConfig>(nodeData: T): T;
    /**
     * 创建一个 Group 类型节点内部所有子节点的副本
     * 并且在遍历所有 nodes 的过程中，顺便拿到所有 edges (只在 Group 范围的 edges)
     */
    initGroupChildNodes(nodeIdMap: Record<string, string>, children: Set<string>, curGroup: DynamicGroupNodeModel, distance: number): ElementsInfoInGroup;
    /**
     * 根据参数 edge 选择是新建边还是基于已有边，复制一条边出来
     * @param edge
     * @param nodeIdMap
     * @param distance
     */
    createEdge(edge: EdgeConfig | EdgeData, nodeIdMap: Record<string, string>, distance: number): BaseEdgeModel<LogicFlow.PropertiesType>;
    /**
     * 检测group:resize后的bounds是否会小于children的bounds
     * 限制group进行resize时不能小于内部的占地面积
     * @param groupModel
     * @param deltaX
     * @param deltaY
     * @param newWidth
     * @param newHeight
     */
    checkGroupBoundsWithChildren(groupModel: DynamicGroupNodeModel, deltaX: number, deltaY: number, newWidth: number, newHeight: number): boolean;
    /**
     * Group 插件的初始化方法
     * TODO：1. 待讨论，可能之前插件分类是有意义的 components, material, tools
     * 区别是：1. 有些插件就是自定义节点，可能会有初始化方法 init，但不必要有 render （比如 Group）
     * 2. 有些插件是渲染一些部件（比如 MiniMap、Control、Menu 等）必须要有 render
     * 3. 工具类的，init 、 render
     * 该如何分类呢？并如何完善插件的类型
     *
     * TODO: 2. 插件的 destroy 方法该做些什么，是否应该加 destroy 方法
     * TODO: 3. 是否应该定义一个 Extension 的基类，所有插件基于这个基类来开发，这样在初始化的时候就可以确认执行什么方法
     */
    init(): void;
    render(): void;
    destroy(): void;
}
export declare namespace DynamicGroup {
    type ElementsInfoInGroup = {
        childNodes: BaseNodeModel[];
        edgesData: EdgeData[];
    };
    type DynamicGroupOptions = Partial<{
        isCollapsed: boolean;
    }>;
}
export default DynamicGroup;
