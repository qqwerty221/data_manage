"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InsertNodeInPolyline = void 0;
var core_1 = require("@logicflow/core");
var lodash_es_1 = require("lodash-es");
var edge_1 = require("./edge");
var InsertNodeInPolyline = /** @class */ (function () {
    function InsertNodeInPolyline(_a) {
        var lf = _a.lf;
        this._lf = lf;
        // fix https://github.com/didi/LogicFlow/issues/754
        this.deviation = 20;
        this.dndAdd = true;
        this.dropAdd = true;
        this.eventHandler();
    }
    InsertNodeInPolyline.prototype.eventHandler = function () {
        var _this = this;
        // 监听事件
        if (this.dndAdd) {
            this._lf.on('node:dnd-add', function (_a) {
                var data = _a.data;
                _this.insetNode(data);
            });
        }
        if (this.dropAdd) {
            this._lf.on('node:drop', function (_a) {
                var data = _a.data;
                var edges = _this._lf.graphModel.edges;
                var id = data.id;
                // 只有游离节点才能插入到连线上
                var pureNode = true;
                for (var i = 0; i < edges.length; i++) {
                    if (edges[i].sourceNodeId === id || edges[i].targetNodeId === id) {
                        pureNode = false;
                        break;
                    }
                }
                if (pureNode) {
                    _this.insetNode(data);
                }
            });
        }
    };
    /**
     * 插入节点前校验规则
     * @param sourceNodeId
     * @param targetNodeId
     * @param sourceAnchorId
     * @param targetAnchorId
     * @param nodeData
     */
    // fix: https://github.com/didi/LogicFlow/issues/1078
    InsertNodeInPolyline.prototype.checkRuleBeforeInsetNode = function (sourceNodeId, targetNodeId, sourceAnchorId, targetAnchorId, nodeData) {
        var sourceNodeModel = this._lf.getNodeModelById(sourceNodeId);
        var targetNodeModel = this._lf.getNodeModelById(targetNodeId);
        var sourceAnchorInfo = sourceNodeModel.getAnchorInfo(sourceAnchorId);
        var targetAnchorInfo = targetNodeModel.getAnchorInfo(targetAnchorId);
        // TODO: nodeData 与 isAllowConnectedAsSource 方法需要的类型 BaseNodeModel 不一致，少了 target 属性等，需要验证是否可用。
        var sourceRuleResultData = sourceNodeModel.isAllowConnectedAsSource(nodeData, sourceAnchorInfo, targetAnchorInfo);
        var targetRuleResultData = targetNodeModel.isAllowConnectedAsTarget(nodeData, sourceAnchorInfo, targetAnchorInfo);
        var _a = (0, core_1.formatAnchorConnectValidateData)(sourceRuleResultData), isSourcePass = _a.isAllPass, sourceMsg = _a.msg;
        var _b = (0, core_1.formatAnchorConnectValidateData)(targetRuleResultData), isTargetPass = _b.isAllPass, targetMsg = _b.msg;
        return {
            isPass: isSourcePass && isTargetPass,
            sourceMsg: sourceMsg,
            targetMsg: targetMsg,
        };
    };
    InsertNodeInPolyline.prototype.insetNode = function (nodeData) {
        var _this = this;
        var edges = this._lf.graphModel.edges;
        var nodeModel = this._lf.getNodeModelById(nodeData.id);
        // fix: https://github.com/didi/LogicFlow/issues/1077
        // 参照https://github.com/didi/LogicFlow/issues/454=>当getDefaultAnchor(){return []}表示：不显示锚点，也不允许其他节点连接到此节点
        // 当getDefaultAnchor=[]，直接阻止下面进行edges的截断插入node相关逻辑
        var anchorArray = nodeModel === null || nodeModel === void 0 ? void 0 : nodeModel.getDefaultAnchor();
        var isNotAllowConnect = !anchorArray || anchorArray.length === 0;
        if (isNotAllowConnect) {
            this._lf.graphModel.eventCenter.emit(core_1.EventType.CONNECTION_NOT_ALLOWED, {
                data: nodeData,
                msg: '自定义类型节点不显示锚点，也不允许其他节点连接到此节点',
            });
            return;
        }
        if (!nodeModel)
            return;
        for (var i = 0; i < edges.length; i++) {
            var _a = (0, edge_1.isNodeInSegment)(nodeModel, edges[i], this.deviation), crossIndex = _a.crossIndex, crossPoints = _a.crossPoints;
            if (crossIndex >= 0) {
                var _b = edges[i], sourceNodeId = _b.sourceNodeId, targetNodeId = _b.targetNodeId, id = _b.id, type = _b.type, pointsList = _b.pointsList, sourceAnchorId = _b.sourceAnchorId, targetAnchorId = _b.targetAnchorId;
                // fix https://github.com/didi/LogicFlow/issues/996
                var startPoint = (0, lodash_es_1.cloneDeep)(pointsList[0]);
                var endPoint = (0, lodash_es_1.cloneDeep)(crossPoints.startCrossPoint);
                this._lf.deleteEdge(id);
                var checkResult = this.checkRuleBeforeInsetNode(sourceNodeId, targetNodeId, sourceAnchorId, targetAnchorId, nodeData);
                this._lf.addEdge({
                    type: type,
                    sourceNodeId: sourceNodeId,
                    targetNodeId: nodeData.id,
                    startPoint: startPoint,
                    endPoint: endPoint,
                    pointsList: __spreadArray(__spreadArray([], __read(pointsList.slice(0, crossIndex)), false), [
                        crossPoints.startCrossPoint,
                    ], false),
                });
                this._lf.addEdge({
                    type: type,
                    sourceNodeId: nodeData.id,
                    targetNodeId: targetNodeId,
                    startPoint: (0, lodash_es_1.cloneDeep)(crossPoints.endCrossPoint),
                    endPoint: (0, lodash_es_1.cloneDeep)(pointsList[pointsList.length - 1]),
                    pointsList: __spreadArray([
                        crossPoints.endCrossPoint
                    ], __read(pointsList.slice(crossIndex)), false),
                });
                if (!checkResult.isPass) {
                    this._lf.graphModel.eventCenter.emit(core_1.EventType.CONNECTION_NOT_ALLOWED, {
                        data: nodeData,
                        msg: checkResult.targetMsg || checkResult.sourceMsg,
                    });
                    // FIXME:在关闭了历史记录的情况下，撤销操作会不生效。
                    setTimeout(function () {
                        _this._lf.undo();
                    }, 200);
                    break;
                }
                else {
                    break;
                }
            }
        }
    };
    InsertNodeInPolyline.pluginName = 'insertNodeInPolyline';
    return InsertNodeInPolyline;
}());
exports.InsertNodeInPolyline = InsertNodeInPolyline;
exports.default = InsertNodeInPolyline;
