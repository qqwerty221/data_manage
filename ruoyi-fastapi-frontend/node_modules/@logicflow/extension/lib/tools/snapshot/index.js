"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Snapshot = void 0;
var utils_1 = require("./utils");
/**
 * 快照插件，生成视图
 */
var Snapshot = /** @class */ (function () {
    function Snapshot(_a) {
        var lf = _a.lf;
        var _this = this;
        this.lf = lf;
        this.customCssRules = '';
        this.useGlobalRules = true;
        // TODO: 设置fileType为gif但是下载下来的还是png
        // TODO: 完善静默模式不允许添加、操作元素能力
        /* 导出画布快照 */
        lf.getSnapshot = function (fileName, toImageOptions) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, this.getSnapshot(fileName, toImageOptions)
                    /* 获取Blob对象 */
                ];
                case 1: return [2 /*return*/, _a.sent()
                    /* 获取Blob对象 */
                ];
            }
        }); }); };
        /* 获取Blob对象 */
        lf.getSnapshotBlob = function (backgroundColor, fileType) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, this.getSnapshotBlob(backgroundColor, fileType)
                    /* 获取Base64对象 */
                ];
                case 1: return [2 /*return*/, _a.sent()
                    /* 获取Base64对象 */
                ];
            }
        }); }); };
        /* 获取Base64对象 */
        lf.getSnapshotBase64 = function (backgroundColor, fileType) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, this.getSnapshotBase64(backgroundColor, fileType)];
                case 1: return [2 /*return*/, _a.sent()];
            }
        }); }); };
    }
    /**
     * 获取svgRoot对象dom: 画布元素（不包含grid背景）
     * @param lf
     * @returns
     */
    Snapshot.prototype.getSvgRootElement = function (lf) {
        var svgRootElement = lf.container.querySelector('.lf-canvas-overlay');
        return svgRootElement;
    };
    /**
     * 通过 imgUrl 下载图片
     * @param imgUrl
     */
    Snapshot.prototype.triggerDownload = function (imgUrl) {
        var evt = new MouseEvent('click', {
            view: document.defaultView,
            bubbles: false,
            cancelable: true,
        });
        var a = document.createElement('a');
        a.setAttribute('download', this.fileName);
        a.setAttribute('href', imgUrl);
        a.setAttribute('target', '_blank');
        a.dispatchEvent(evt);
    };
    /**
     * 删除锚点
     * @param element
     */
    Snapshot.prototype.removeAnchor = function (element) {
        var childNodes = element.childNodes;
        var childLength = element.childNodes && element.childNodes.length;
        for (var i = 0; i < childLength; i++) {
            var child = childNodes[i];
            var classList = (child.classList && Array.from(child.classList)) || [];
            if (classList.indexOf('lf-anchor') > -1) {
                element.removeChild(element.childNodes[i]);
                childLength--;
                i--;
            }
        }
    };
    /**
     * 删除旋转按钮
     * @param element
     */
    Snapshot.prototype.removeRotateControl = function (element) {
        var childNodes = element.childNodes;
        var childLength = element.childNodes && element.childNodes.length;
        for (var i = 0; i < childLength; i++) {
            var child = childNodes[i];
            var classList = (child.classList && Array.from(child.classList)) || [];
            if (classList.indexOf('lf-rotate-control') > -1) {
                element.removeChild(element.childNodes[i]);
                childLength--;
                i--;
            }
        }
    };
    /**
     * 导出画布：导出前的处理画布工作，局部渲染模式处理、静默模式处理
     * @param fileName
     * @param toImageOptions
     */
    Snapshot.prototype.getSnapshot = function (fileName, toImageOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var curPartial, _a, partial, editConfig;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        curPartial = this.lf.graphModel.getPartial();
                        _a = (toImageOptions !== null && toImageOptions !== void 0 ? toImageOptions : {}).partial, partial = _a === void 0 ? curPartial : _a;
                        editConfig = this.lf.getEditConfig();
                        // 开启静默模式：如果元素多的话 避免用户交互 感知卡顿
                        this.lf.updateEditConfig({
                            isSilentMode: true,
                            stopScrollGraph: true,
                            stopMoveGraph: true,
                        });
                        if (!(curPartial !== partial)) return [3 /*break*/, 1];
                        this.lf.graphModel.setPartial(partial);
                        this.lf.graphModel.eventCenter.once('graph:updated', function () { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this.snapshot(fileName, toImageOptions)
                                        // 恢复原来渲染模式
                                    ];
                                    case 1:
                                        _a.sent();
                                        // 恢复原来渲染模式
                                        this.lf.graphModel.setPartial(curPartial);
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.snapshot(fileName, toImageOptions)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        // 恢复原来配置
                        this.lf.updateEditConfig(editConfig);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * 下载图片
     * @param fileName
     * @param toImageOptions
     */
    Snapshot.prototype.snapshot = function (fileName, toImageOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, fileType, quality, svg, copy, svgString, blob, url;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = toImageOptions !== null && toImageOptions !== void 0 ? toImageOptions : {}, _b = _a.fileType, fileType = _b === void 0 ? 'png' : _b, quality = _a.quality;
                        this.fileName = "".concat(fileName !== null && fileName !== void 0 ? fileName : "logic-flow.".concat(Date.now()), ".").concat(fileType);
                        svg = this.getSvgRootElement(this.lf);
                        return [4 /*yield*/, (0, utils_1.updateImageSource)(svg)];
                    case 1:
                        _c.sent();
                        if (fileType === 'svg') {
                            copy = this.cloneSvg(svg);
                            svgString = new XMLSerializer().serializeToString(copy);
                            blob = new Blob([svgString], {
                                type: 'image/svg+xml;charset=utf-8',
                            });
                            url = URL.createObjectURL(blob);
                            this.triggerDownload(url);
                        }
                        else {
                            this.getCanvasData(svg, toImageOptions !== null && toImageOptions !== void 0 ? toImageOptions : {}).then(function (canvas) {
                                // canvas元素 => base64 url   image/octet-stream: 确保所有浏览器都能正常下载
                                var imgUrl = canvas
                                    .toDataURL("image/".concat(fileType), quality)
                                    .replace("image/".concat(fileType), 'image/octet-stream');
                                _this.triggerDownload(imgUrl);
                            });
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * 获取base64对象
     * @param backgroundColor
     * @param fileType
     * @returns
     */
    Snapshot.prototype.getSnapshotBase64 = function (backgroundColor, fileType) {
        return __awaiter(this, void 0, void 0, function () {
            var svg;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        svg = this.getSvgRootElement(this.lf);
                        return [4 /*yield*/, (0, utils_1.updateImageSource)(svg)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, new Promise(function (resolve) {
                                _this.getCanvasData(svg, { backgroundColor: backgroundColor }).then(function (canvas) {
                                    var base64 = canvas.toDataURL("image/".concat(fileType !== null && fileType !== void 0 ? fileType : 'png'));
                                    // 输出图片数据以及图片宽高
                                    resolve({
                                        data: base64,
                                        width: canvas.width,
                                        height: canvas.height,
                                    });
                                });
                            })];
                }
            });
        });
    };
    /**
     * 获取Blob对象
     * @param backgroundColor
     * @param fileType
     * @returns
     */
    Snapshot.prototype.getSnapshotBlob = function (backgroundColor, fileType) {
        return __awaiter(this, void 0, void 0, function () {
            var svg;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        svg = this.getSvgRootElement(this.lf);
                        return [4 /*yield*/, (0, utils_1.updateImageSource)(svg)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, new Promise(function (resolve) {
                                _this.getCanvasData(svg, { backgroundColor: backgroundColor }).then(function (canvas) {
                                    canvas.toBlob(function (blob) {
                                        // 输出图片数据以及图片宽高
                                        resolve({
                                            data: blob,
                                            width: canvas.width,
                                            height: canvas.height,
                                        });
                                    }, "image/".concat(fileType !== null && fileType !== void 0 ? fileType : 'png'));
                                });
                            })];
                }
            });
        });
    };
    /**
     * 获取脚本 css 样式
     * @returns
     */
    Snapshot.prototype.getClassRules = function () {
        var rules = '';
        if (this.useGlobalRules) {
            var styleSheets = document.styleSheets;
            for (var i = 0; i < styleSheets.length; i++) {
                var sheet = styleSheets[i];
                // 这里是为了过滤掉不同源 css 脚本，防止报错终止导出
                try {
                    for (var j = 0; j < sheet.cssRules.length; j++) {
                        rules += sheet.cssRules[j].cssText;
                    }
                }
                catch (error) {
                    console.log('CSS scripts from different sources have been filtered out');
                }
            }
        }
        if (this.customCssRules) {
            rules += this.customCssRules;
        }
        return rules;
    };
    /**
     * 将 svg 转化为 canvas
     * @param svg - svg 元素
     * @param toImageOptions - 图像选项
     * @returns Promise<canvas> - 返回 canvas 对象
     */
    Snapshot.prototype.getCanvasData = function (svg, toImageOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var width, height, backgroundColor, _a, padding, copy, dpr, base, bbox, layoutCanvas, layout, offsetX, offsetY, graphModel, transformModel, SCALE_X, SCALE_Y, TRANSLATE_X, TRANSLATE_Y, bboxWidth, bboxHeight, canvas, ctx, img, style, foreignObject;
            return __generator(this, function (_b) {
                width = toImageOptions.width, height = toImageOptions.height, backgroundColor = toImageOptions.backgroundColor, _a = toImageOptions.padding, padding = _a === void 0 ? 40 : _a;
                copy = this.cloneSvg(svg, false);
                dpr = window.devicePixelRatio || 1;
                if (dpr < 1) {
                    // https://github.com/didi/LogicFlow/issues/1222
                    // canvas.width = bboxWidth * dpr配合ctx.scale(dpr, dpr)是为了解决绘制模糊
                    // 比如dpr=2，先让canvas.width放大到等同于屏幕的物理像素宽高，然后自适应缩放适配canvas.style.width
                    // 由于所有元素都缩放了一半，因此需要ctx.scale(dpr, dpr)放大2倍整体绘制的内容
                    // 当用户缩放浏览器时，window.devicePixelRatio会随着变小
                    // 当window.devicePixelRatio变小到一定程度，会导致canvas.width<canvas.style.width
                    // 由于导出图片的svg的大小是canvas.style.width+canvas.style.height
                    // 因此会导致导出的svg图片无法完整绘制到canvas（因为canvas.width小于svg的宽）
                    // 从而导致canvas导出图片是缺失的svg
                    // 而dpr>=1就能保证canvas.width>=canvas.style.width
                    // 当dpr小于1的时候，我们强制转化为1，并不会产生绘制模糊等问题
                    dpr = 1;
                }
                base = this.lf.graphModel.rootEl.querySelector('.lf-base');
                bbox = base.getBoundingClientRect();
                layoutCanvas = this.lf.container.querySelector('.lf-canvas-overlay');
                layout = layoutCanvas.getBoundingClientRect();
                offsetX = bbox.x - layout.x;
                offsetY = bbox.y - layout.y;
                graphModel = this.lf.graphModel;
                transformModel = graphModel.transformModel;
                SCALE_X = transformModel.SCALE_X, SCALE_Y = transformModel.SCALE_Y, TRANSLATE_X = transformModel.TRANSLATE_X, TRANSLATE_Y = transformModel.TRANSLATE_Y;
                copy.lastChild.style.transform = "matrix(1, 0, 0, 1, ".concat((-offsetX + TRANSLATE_X) * (1 / SCALE_X), ", ").concat((-offsetY + TRANSLATE_Y) * (1 / SCALE_Y), ")");
                bboxWidth = Math.ceil(bbox.width / SCALE_X);
                bboxHeight = Math.ceil(bbox.height / SCALE_Y);
                canvas = document.createElement('canvas');
                canvas.style.width = "".concat(bboxWidth, "px");
                canvas.style.height = "".concat(bboxHeight, "px");
                // 宽高值 默认加padding 40，保证图形不会紧贴着下载图片
                canvas.width = bboxWidth * dpr + padding * 2;
                canvas.height = bboxHeight * dpr + padding * 2;
                ctx = canvas.getContext('2d');
                if (ctx) {
                    // 清空canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.scale(dpr, dpr);
                    // 如果有背景色，设置流程图导出的背景色
                    if (backgroundColor) {
                        ctx.fillStyle = backgroundColor;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                    else {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }
                }
                img = new Image();
                style = document.createElement('style');
                style.innerHTML = this.getClassRules();
                foreignObject = document.createElement('foreignObject');
                foreignObject.appendChild(style);
                copy.appendChild(foreignObject);
                return [2 /*return*/, new Promise(function (resolve) {
                        img.onload = function () {
                            var isFirefox = navigator.userAgent.indexOf('Firefox') > -1;
                            try {
                                if (isFirefox) {
                                    createImageBitmap(img, {
                                        resizeWidth: width && height
                                            ? (0, utils_1.copyCanvas)(canvas, width, height).width
                                            : canvas.width,
                                        resizeHeight: width && height
                                            ? (0, utils_1.copyCanvas)(canvas, width, height).height
                                            : canvas.height,
                                    }).then(function (imageBitmap) {
                                        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(imageBitmap, padding / dpr, padding / dpr);
                                        resolve(width && height ? (0, utils_1.copyCanvas)(canvas, width, height) : canvas);
                                    });
                                }
                                else {
                                    ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(img, padding / dpr, padding / dpr);
                                    resolve(width && height ? (0, utils_1.copyCanvas)(canvas, width, height) : canvas);
                                }
                            }
                            catch (e) {
                                ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(img, padding / dpr, padding / dpr);
                                resolve(width && height ? (0, utils_1.copyCanvas)(canvas, width, height) : canvas);
                            }
                        };
                        /*
                        因为svg中存在dom存放在foreignObject元素中
                        svg dom => Base64编码字符串 挂载到img上
                        fixme: XMLSerializer的中的css background url不会下载图片
                        */
                        var svg2Img = "data:image/svg+xml;charset=utf-8,".concat(new XMLSerializer().serializeToString(copy));
                        var imgSrc = svg2Img
                            .replace(/\n/g, '')
                            .replace(/\t/g, '')
                            .replace(/#/g, '%23');
                        img.src = imgSrc;
                    })];
            });
        });
    };
    /**
     * 克隆并处理画布节点
     * @param svg
     * @returns
     */
    Snapshot.prototype.cloneSvg = function (svg, addStyle) {
        var _this = this;
        var _a;
        if (addStyle === void 0) { addStyle = true; }
        var copy = svg.cloneNode(true);
        var graph = copy.lastChild;
        var childLength = (_a = graph === null || graph === void 0 ? void 0 : graph.childNodes) === null || _a === void 0 ? void 0 : _a.length;
        if (childLength) {
            for (var i = 0; i < childLength; i++) {
                var lfLayer = graph === null || graph === void 0 ? void 0 : graph.childNodes[i];
                // 只保留包含节点和边的基础图层进行下载，其他图层删除
                var layerClassList = lfLayer.classList && Array.from(lfLayer.classList);
                if (layerClassList && layerClassList.indexOf('lf-base') < 0) {
                    graph === null || graph === void 0 ? void 0 : graph.removeChild(graph.childNodes[i]);
                    childLength--;
                    i--;
                }
                else {
                    // 删除锚点
                    var lfBase = graph === null || graph === void 0 ? void 0 : graph.childNodes[i];
                    lfBase &&
                        lfBase.childNodes.forEach(function (item) {
                            var element = item;
                            _this.removeAnchor(element.firstChild);
                            _this.removeRotateControl(element.firstChild);
                        });
                }
            }
        }
        // 设置css样式
        if (addStyle) {
            var style = document.createElement('style');
            style.innerHTML = this.getClassRules();
            var foreignObject = document.createElement('foreignObject');
            foreignObject.appendChild(style);
            copy.appendChild(foreignObject);
        }
        return copy;
    };
    Snapshot.pluginName = 'snapshot';
    return Snapshot;
}());
exports.Snapshot = Snapshot;
exports.default = Snapshot;
